{"version":3,"file":"input-face-api-webcam.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/input-face-api-webcam.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Host, h, Element, Prop, Event, EventEmitter, Method, State, Watch } from '@stencil/core';\nimport { DetectionImg, faceapiService } from '../../utils/facepi.service';\nimport { CameraDirection, createCanvas, createVideo, initWebcamToVideo, renderToCanvas } from '../../utils/camera.service';\nimport { Detection, FaceLandmarkerResult } from '@mediapipe/tasks-vision';\nimport { pxTimer } from 'src/utils/utils';\nimport { LabeledDescriptorsArray } from './TrainedModel';\nimport { getBestMatch } from './distance.worker';\n\nexport interface iFaceDetected {\n  blob: Blob;\n  result: Detection;\n}\n\nexport interface FaceDetectionError {\n  type: 'CAMERA_ACCESS_DENIED' | 'NO_CAMERA' | 'FACE_API_ERROR' | 'INITIALIZATION_ERROR' | 'UNKNOWN_ERROR';\n  message: string;\n  originalError?: Error;\n}\n\ntype CameraState = 'inactive' | 'loading' | 'ready' | 'detecting' | 'error';\n\n@Component({\n  tag: 'input-face-api-webcam',\n  styleUrl: 'input-face-api-webcam.css',\n  shadow: true,\n})\nexport class InputFaceApiWebcam {\n  //webcam stream\n  video: HTMLVideoElement;\n\n  //canvas to draw webcam\n  canvas: HTMLCanvasElement;\n\n  @Element() el: HTMLElement;\n\n  @State() detectionResult: DetectionImg;\n  @State() loaded: boolean = false;\n  @State() cameraState: CameraState = 'inactive';\n  @State() currentError: FaceDetectionError | null = null;\n  @State() detectedFacesCount: number = 0;\n  @State() isRecognizing: boolean = false;\n\n  @Watch('detectionResult')\n  detectionResultChangedHandler(newValue: DetectionImg, oldValue: DetectionImg) {\n    if (newValue?.blobImg) {\n      this.detectedFacesCount = newValue.detection ? 1 : 0;\n      this.faceDetected.emit(newValue);\n\n      // Auto capture photo if enabled and face confidence is above threshold\n      if (this.autoCapture && newValue.detection &&\n          newValue.detection.categories?.[0]?.score >= this.captureThreshold) {\n        this.capturePhoto();\n      }\n    } else {\n      if (oldValue) {\n        this.detectedFacesCount = 0;\n        this.faceStopDetection.emit();\n      }\n    }\n  }\n\n  // Enhanced Properties\n  /**\n   * Enable or disable face detection\n   */\n  @Prop({ reflect: true, mutable: true }) enableDetection: boolean = true;\n\n  /**\n   * Show control buttons for starting/stopping detection\n   */\n  @Prop() showControls: boolean = true;\n\n  /**\n   * Auto-start detection when component loads\n   */\n  @Prop() autoStart: boolean = true;\n\n  /**\n   * Show bounding boxes around detected faces\n   */\n  @Prop() showBoundingBoxes: boolean = true;\n\n  /**\n   * Show face landmarks on detected faces\n   */\n  @Prop() showLandmarks: boolean = false;\n\n  /**\n   * Text for the start detection button\n   */\n  @Prop() startButtonText: string = 'Start Detection';\n\n  /**\n   * Text for the stop detection button\n   */\n  @Prop() stopButtonText: string = 'Stop Detection';\n\n  /**\n   * Text for the flip camera button\n   */\n  @Prop() flipButtonText: string = 'Flip Camera';\n\n  /**\n   * Trained models to use for recognition and best match\n   */\n  @Prop({ reflect: false }) trainedModel?: LabeledDescriptorsArray;\n\n\n  /**\n   * Width of the video element\n   */\n  @Prop({ reflect: true, mutable: true }) width?: number = 460;\n\n  /**\n   * Height of the video element\n   */\n  @Prop({ reflect: true, mutable: true }) height?: number = 460;\n\n  /**\n   * Score threshold to detect a face\n   */\n  @Prop({ reflect: true, mutable: true }) scoreThreshold?: number = 0.65;\n\n  /**\n   * Detection timer interval in milliseconds\n   */\n  @Prop({ reflect: true, mutable: true }) detectionTimer?: number = 1500;\n\n  /**\n   * Facing mode options following https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode#value\n   */\n  @Prop({ mutable: true, reflect: true }) facingMode?: CameraDirection = CameraDirection.Front;\n\n  /**\n   * Enable automatic photo capture when face is detected\n   */\n  @Prop() autoCapture: boolean = true;\n\n  /**\n   * Minimum confidence score for face detection to trigger photo capture\n   */\n  @Prop() captureThreshold: number = 0.8;\n\n  /**\n   * Delay between automatic photo captures in milliseconds\n   */\n  @Prop() captureDelay: number = 3000;\n\n\n  // Enhanced Methods\n  /**\n   * Stop face detection\n   */\n  @Method()\n  async stopDetection(): Promise<void> {\n    this.enableDetection = false;\n    this.cameraState = 'ready';\n    this.detectionStopped.emit();\n  }\n\n  /**\n   * Start face detection\n   */\n  @Method()\n  async startDetection(): Promise<void> {\n    if (this.cameraState === 'ready' || this.cameraState === 'inactive') {\n      this.enableDetection = true;\n      this.cameraState = 'detecting';\n      this.detectionStarted.emit();\n    }\n  }\n\n  /**\n   * Toggle camera between front and back\n   */\n  @Method()\n  async toggleCamera(): Promise<void> {\n    try {\n      this.cameraState = 'loading';\n      this.facingMode = this.facingMode === CameraDirection.Front ? CameraDirection.Rear : CameraDirection.Front;\n\n      // Stop current video stream\n      if (this.video.srcObject) {\n        const stream = this.video.srcObject as MediaStream;\n        stream.getTracks().forEach(track => track.stop());\n      }\n\n      // Reinitialize with new facing mode\n      await initWebcamToVideo(this.video, this.facingMode);\n      this.facingModeChanged.emit(this.facingMode);\n      this.cameraState = this.enableDetection ? 'detecting' : 'ready';\n    } catch (error) {\n      this.handleError('CAMERA_ACCESS_DENIED', 'Failed to toggle camera', error);\n    }\n  }\n\n  /**\n   * Initialize camera and face detection\n   */\n  @Method()\n  async initializeCamera(): Promise<void> {\n    try {\n      this.cameraState = 'loading';\n      this.currentError = null;\n\n      await this.componentWillLoad();\n\n      if (this.autoStart && this.enableDetection) {\n        this.cameraState = 'detecting';\n      } else {\n        this.cameraState = 'ready';\n      }\n    } catch (error) {\n      this.handleError('INITIALIZATION_ERROR', 'Failed to initialize camera', error);\n    }\n  }\n\n\n  /**\n   * Giving a blob image, get the face landmarks\n   * @returns face landmarks\n   */\n  @Method()\n  async getBlobImageDescriptors(blob: Blob): Promise<FaceLandmarkerResult> {\n    return await faceapiService.getFaceLandmarksFromBlob( blob )\n  }\n\n  /**\n   * Giving current face in video canvas, get the face landmarks\n   * @returns face landmarks\n   */\n  @Method()\n  async getFaceLandMarks(): Promise<FaceLandmarkerResult> {\n    if ( this.detectionResult && this.detectionResult.blobImg ) {\n      return await faceapiService.getFaceLandmarksFromBlob( this.detectionResult.blobImg )\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Predicts best face match, uses worker to calculate distance between the given blob and the trained model\n   * passed in trainedModel prop\n   * @param blob\n   * @returns\n   */\n  @Method()\n  async predictBestMatch(blob?: Blob): Promise<any> {\n    console.info(\"tyrained model es\", this.trainedModel);\n    if ( !this.trainedModel ) {\n      return null;\n    }\n\n    let lm;\n    if ( !blob ) {\n      lm = await faceapiService.getFaceLandmarksFromBlob( blob )\n    } else {\n      lm = await this.getFaceLandMarks()\n    }\n    // for each trained model of this.trainedModels get minimum distance\n    const best = await getBestMatch( this.trainedModel, lm.faceLandmarks[0] )\n    return best;\n\n  }\n\n  /**\n   * Diagnostic method to check detection status\n   */\n  @Method()\n  async getDiagnosticInfo(): Promise<any> {\n    return {\n      // Component state\n      cameraState: this.cameraState,\n      enableDetection: this.enableDetection,\n      loaded: this.loaded,\n      detectedFacesCount: this.detectedFacesCount,\n\n      // Video element status\n      videoElement: {\n        readyState: this.video?.readyState,\n        videoWidth: this.video?.videoWidth,\n        videoHeight: this.video?.videoHeight,\n        currentTime: this.video?.currentTime,\n        paused: this.video?.paused\n      },\n\n      // Service status\n      faceApiService: {\n        isReady: faceapiService.isReady(),\n        config: faceapiService.getConfig(),\n        performanceStats: faceapiService.getPerformanceStats()\n      },\n\n      // Last detection result\n      lastDetection: this.detectionResult ? {\n        hasDetection: !!this.detectionResult.detection,\n        confidence: this.detectionResult.confidence,\n        timestamp: this.detectionResult.timestamp\n      } : null\n    };\n  }\n\n  /**\n   * Event emitted when a face is detected in video stream\n   */\n  @Event({\n    eventName: 'faceDetected',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceDetected: EventEmitter<DetectionImg>;\n\n  /**\n   * Event emitted when face detection was stopped\n   */\n  @Event({\n    eventName: 'faceStopDetection',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceStopDetection: EventEmitter<void>;\n\n  /**\n   * Event emitted when detection starts\n   */\n  @Event({\n    eventName: 'detectionStarted',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) detectionStarted: EventEmitter<void>;\n\n  /**\n   * Event emitted when detection stops\n   */\n  @Event({\n    eventName: 'detectionStopped',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) detectionStopped: EventEmitter<void>;\n\n  /**\n   * Event emitted when camera starts successfully\n   */\n  @Event({\n    eventName: 'cameraStarted',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraStarted: EventEmitter<MediaStream>;\n\n  /**\n   * Event emitted when camera stops\n   */\n  @Event({\n    eventName: 'cameraStopped',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraStopped: EventEmitter<void>;\n\n  /**\n   * Event emitted when camera encounters an error\n   */\n  @Event({\n    eventName: 'cameraError',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraError: EventEmitter<FaceDetectionError>;\n\n  /**\n   * Event emitted when facing mode changes\n   */\n  @Event({\n    eventName: 'facingModeChanged',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) facingModeChanged: EventEmitter<CameraDirection>;\n\n  /**\n   * Event emitted when a photo is automatically captured\n   */\n  @Event({\n    eventName: 'photoCapture',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) photoCapture: EventEmitter<Blob>;\n\n\n  // Private properties\n  private lastVideoTime = -1;\n  private photoTaken = false;\n\n  // Helper Methods\n  private handleError(type: FaceDetectionError['type'], message: string, originalError?: Error): void {\n    const error: FaceDetectionError = {\n      type,\n      message,\n      originalError\n    };\n    this.currentError = error;\n    this.cameraState = 'error';\n    this.cameraError.emit(error);\n    console.error('Face API Webcam Error:', error);\n  }\n\n  private async capturePhoto(): Promise<void> {\n    try {\n      if (this.photoTaken) return; // Prevent multiple captures\n\n      this.photoTaken = true;\n\n      // Create a temporary canvas to capture the current frame\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = this.canvas.width;\n      tempCanvas.height = this.canvas.height;\n      const tempCtx = tempCanvas.getContext('2d');\n\n      // Draw current frame to temporary canvas\n      tempCtx.drawImage(this.canvas, 0, 0);\n\n      // Convert to blob\n      tempCanvas.toBlob((blob) => {\n        if (blob) {\n          console.log('Photo captured automatically:', blob);\n          this.photoCapture.emit(blob);\n        }\n      }, 'image/jpeg', 0.9);\n\n      // Reset photo flag after delay\n      setTimeout(() => {\n        this.photoTaken = false;\n      }, this.captureDelay);\n\n    } catch (error) {\n      console.error('Error capturing photo:', error);\n      this.photoTaken = false;\n    }\n  }\n\n  async componentWillLoad() {\n    try {\n      this.cameraState = 'loading';\n      this.currentError = null;\n\n      this.video = createVideo()\n      this.canvas = createCanvas(this.el)\n      this.canvas.width = this.width\n      this.canvas.height = this.height\n      this.el.appendChild(this.canvas)\n\n      await faceapiService.initialize()\n      console.info(\"el faceapi es\", faceapiService);\n\n      const stream = await initWebcamToVideo(this.video, this.facingMode)\n      this.cameraStarted.emit(stream as MediaStream);\n\n      // Wait for video to be ready before starting render loop\n      await this.waitForVideoReady();\n\n      renderToCanvas( this.canvas, this.video)\n\n      this.loaded = true;\n\n      if (this.autoStart && this.enableDetection) {\n        this.cameraState = 'detecting';\n        this.detectionStarted.emit();\n      } else {\n        this.cameraState = 'ready';\n      }\n\n      // Start render loop only after video is ready\n      requestAnimationFrame(() => {\n        this.webcamRender()\n      })\n\n    } catch (error) {\n      this.handleError('INITIALIZATION_ERROR', 'Failed to initialize camera and face detection', error);\n    }\n  }\n\n\n  async webcamRender () {\n    const startTimeMs = performance.now();\n\n    // Verify video is ready for detection\n    if (!this.isVideoElementReady()) {\n      console.warn('⚠️ Video element not ready in webcamRender:', {\n        readyState: this.video?.readyState,\n        videoWidth: this.video?.videoWidth,\n        videoHeight: this.video?.videoHeight,\n        currentTime: this.video?.currentTime\n      });\n\n      await pxTimer(this.detectionTimer);\n      requestAnimationFrame(() => {\n        this.webcamRender();\n      });\n      return;\n    }\n\n    // Detect faces using detectForVideo\n    if ( this.video.currentTime !== this.lastVideoTime ) {\n      this.lastVideoTime = this.video.currentTime;\n\n      if ( this.enableDetection ) {\n        try {\n          // get context of canvas and create paning and zoooming to center\n          this.detectionResult = await faceapiService.detectFaceOptimized( this.video, startTimeMs )\n\n          // Add debugging\n          if (this.detectionResult) {\n            console.log('✅ Face detected in component:', {\n              confidence: this.detectionResult.confidence,\n              timestamp: this.detectionResult.timestamp\n            });\n          } else {\n            console.log('❌ No face detected in component');\n          }\n        } catch (error) {\n          console.error('❌ Error in webcamRender detection:', error);\n        }\n      }\n    }\n\n    await pxTimer(this.detectionTimer)\n\n    requestAnimationFrame(() => {\n      this.webcamRender()\n    })\n  }\n\n  // Helper method to check if video element is ready\n  private isVideoElementReady(): boolean {\n    return (\n      this.video &&\n      this.video.readyState >= 2 && // HAVE_CURRENT_DATA or higher\n      this.video.videoWidth > 0 &&\n      this.video.videoHeight > 0 &&\n      !this.video.paused &&\n      !this.video.ended &&\n      this.video.currentTime > 0\n    );\n  }\n\n  // Wait for video to be properly loaded and ready for processing\n  private async waitForVideoReady(maxWaitMs: number = 5000): Promise<void> {\n    const startTime = Date.now();\n    const checkInterval = 50; // Check every 50ms\n\n    return new Promise((resolve, reject) => {\n      const checkVideo = () => {\n        if (this.isVideoElementReady()) {\n          console.log('✅ Video element is ready for processing:', {\n            readyState: this.video.readyState,\n            videoWidth: this.video.videoWidth,\n            videoHeight: this.video.videoHeight,\n            currentTime: this.video.currentTime\n          });\n          resolve();\n          return;\n        }\n\n        const elapsed = Date.now() - startTime;\n        if (elapsed >= maxWaitMs) {\n          const error = new Error(`Video not ready after ${maxWaitMs}ms`);\n          console.error('❌ Video readiness timeout:', {\n            elapsed,\n            readyState: this.video?.readyState,\n            videoWidth: this.video?.videoWidth,\n            videoHeight: this.video?.videoHeight,\n            currentTime: this.video?.currentTime\n          });\n          reject(error);\n          return;\n        }\n\n        console.log('⏳ Waiting for video to be ready...', {\n          elapsed: elapsed + 'ms',\n          readyState: this.video?.readyState,\n          videoWidth: this.video?.videoWidth,\n          videoHeight: this.video?.videoHeight,\n          currentTime: this.video?.currentTime\n        });\n\n        setTimeout(checkVideo, checkInterval);\n      };\n\n      checkVideo();\n    });\n  }\n\n\ndrawWebcamnToCanvas(ctx) {\n  let imgWidth = this.video.videoWidth;\n  let imgHeight = this.video.videoHeight;\n\n  var imgSize = Math.min(imgWidth, imgHeight);\n    // The following two lines yield a central based cropping.\n    // They can both be amended to be 0, if you wish it to be\n    // a left based cropped image.\n  var left = (imgWidth - imgSize) / 2;\n  var top = (imgHeight - imgSize) / 2;\n\n  // ctx clear all\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n  ctx.drawImage(this.video, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n}\n\n\n  render() {\n    const hostStyle = {\n      height: this.height+\"px\",\n      width: this.width+\"px\",\n    }\n\n    const renderCameraState = () => {\n      if (this.cameraState === 'inactive') {\n        return (\n          <div class=\"camera-state\">\n            <div class=\"state-icon inactive-icon\">📷</div>\n            <h3>Camera Inactive</h3>\n            <p>Click start to begin face detection</p>\n          </div>\n        );\n      }\n\n      if (this.cameraState === 'loading') {\n        return (\n          <div class=\"camera-state\">\n            <div class=\"loading-spinner\"></div>\n            <h3>Starting Camera</h3>\n            <p>Please allow camera access when prompted</p>\n          </div>\n        );\n      }\n\n      if (this.cameraState === 'error') {\n        return (\n          <div class=\"camera-state\">\n            <div class=\"state-icon error-icon\">⚠️</div>\n            <h3>Camera Error</h3>\n            <p>{this.currentError?.message || 'Unable to access camera'}</p>\n          </div>\n        );\n      }\n\n      return null;\n    };\n\n    const renderIndicators = () => {\n      if (this.cameraState !== 'detecting' && this.cameraState !== 'ready') return null;\n\n      return [\n        // Auto-capture indicator\n        this.autoCapture && (\n          <div class=\"auto-capture-indicator\">\n            AUTO CAPTURE\n          </div>\n        ),\n\n        // Face detection indicator\n        this.cameraState === 'detecting' && (\n          <div class={`face-indicator ${this.detectedFacesCount > 0 ? 'detected' : 'not-detected'}`}>\n            {this.detectedFacesCount > 0 ? `${this.detectedFacesCount} Face${this.detectedFacesCount !== 1 ? 's' : ''} Detected` : 'No Face Detected'}\n          </div>\n        ),\n\n        // Error message\n        this.currentError && (\n          <div class=\"error-message\">\n            {this.currentError.message}\n          </div>\n        )\n      ];\n    };\n\n    const renderControls = () => {\n      if (!this.showControls) return null;\n\n      const isLoading = this.cameraState === 'loading';\n\n      return (\n        <div class=\"camera-controls\">\n          {this.cameraState === 'inactive' || this.cameraState === 'ready' ? (\n            <button\n              class=\"control-button start-button\"\n              onClick={() => this.startDetection()}\n              disabled={isLoading}\n              title={this.startButtonText}\n            >\n              ▶️\n            </button>\n          ) : this.cameraState === 'detecting' ? (\n            <button\n              class=\"control-button stop-button\"\n              onClick={() => this.stopDetection()}\n              title={this.stopButtonText}\n            >\n              ⏹️\n            </button>\n          ) : null}\n\n          {(this.cameraState === 'ready' || this.cameraState === 'detecting') && (\n            <button\n              class=\"control-button flip-button\"\n              onClick={() => this.toggleCamera()}\n              disabled={isLoading}\n              title={this.flipButtonText}\n            >\n              🔄\n            </button>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <Host style={hostStyle}>\n        <slot name='before'></slot>\n\n        {/* Camera state overlay */}\n        {renderCameraState()}\n\n        {/* Status indicators */}\n        {renderIndicators()}\n\n        {/* Control buttons */}\n        {renderControls()}\n\n        <slot></slot>\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"]}