{"version":3,"file":"input-face-api-webcam.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/input-face-api-webcam.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Host, h, Element, Prop, Event,EventEmitter, Method, State } from '@stencil/core';\nimport { FaceapiService } from '../../utils/facepi.service';\nimport { createCanvas, createVideo, initWebcamToVideo } from '../../utils/camera.service';\nimport { FaceDetection } from 'face-api.js';\n\n@Component({\n  tag: 'input-face-api-webcam',\n  styleUrl: 'input-face-api-webcam.css',\n  shadow: true,\n})\nexport class InputFaceApiWebcam {\n\n  // canvas to store photo\n  photoCanvas: HTMLCanvasElement\n\n  //webcam stream\n  video: HTMLVideoElement\n\n  //canvas to draw webcam\n  canvas: HTMLCanvasElement\n\n  //faceapi service\n  faceapiService: FaceapiService\n\n    \n  @Element() el: HTMLElement;\n\n  @State() isDetecting = true;\n\n\n  @Prop({reflect: true, mutable: true}) photoPicMinValue?: number = 300\n  @Prop({reflect: true, mutable: true}) width?: number = 460\n  @Prop({reflect: true, mutable: true}) height?: number = 460\n\n  @Method()\n  async stopDetection(): Promise<void> {\n    this.isDetecting = false;\n  }\n\n  @Method()\n  async startDetection(): Promise<void> {\n    this.isDetecting = true;\n  }\n\n\n\n  @Event({\n    eventName: 'faceDetected',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceDetected: EventEmitter<Blob>;\n\n  @Event({\n    eventName: 'faceMinValueError',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceMinValueError: EventEmitter<FaceDetection>;\n\n\n  async componentWillLoad() {\n    this.video = createVideo()\n    //this.el.appendChild(this.video)\n\n    this.canvas = createCanvas(this.el)\n    this.el.appendChild(this.canvas)\n\n\n    this.photoCanvas = createCanvas(this.el)\n\n  }\n\n  async componentDidRender() {\n\n    this.canvas.width = parseInt( this.el.getAttribute(\"width\") );\n    this.canvas.height = parseInt( this.el.getAttribute(\"height\") );\n\n    this.photoCanvas.width = parseInt( this.el.getAttribute(\"width\") );\n    this.photoCanvas.height = parseInt( this.el.getAttribute(\"height\") );\n\n    \n    initWebcamToVideo(this.video)\n   \n      this.faceapiService = new FaceapiService()\n\n      this.webcamRender();\n    \n  }\n\n  async disconnectedCallback() {\n  }\n\n  /**\n   * \n   * @param result \n   * @returns true si proceso y detecto imagen\n   */\n  __processReturn(result): boolean {\n\n    let h = result.box.height *1.5\n    let w = result.box.width *1.5\n\n    // hacer caudrada la imagen\n    if ( h > w ) {\n        w = h\n    } else {\n        h = w\n    }\n\n    console.info(\"result\", result);\n    \n    //centrar la imagen\n    const x = result.box.x - (w - result.box.width) / 2\n    const y = result.box.y - (h - result.box.height) / 2\n\n    // eliminar la imagen del canvas\n    this.photoCanvas.getContext('2d').clearRect(0, 0, this.photoCanvas.width, this.photoCanvas.height)\n    \n    // zom video into canvas\n    this.photoCanvas.getContext('2d').drawImage(this.canvas, x, y, w, h, 0, 0, this.canvas.width, this.canvas.height)\n\n\n      \n    // this faceDetected emit blob from this.canvas\n    this.photoCanvas.toBlob((blob) => {\n      this.faceDetected.emit(blob)\n    }, 'image/jpeg', 1)\n\n    return true;\n\n  }\n\n  drawCanvasNoFace() {\n    this.canvas.getContext('2d').drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height)\n  }\n\n  async webcamRender () {\n    \n    requestAnimationFrame(() => {\n      this.webcamRender() \n    });\n    \n    if ( this.isDetecting ) {\n      \n      const result = await this.faceapiService.detectFace( this.canvas )\n     \n      if (result ) {\n        if ( !this.__processReturn(result) ) {\n          this.faceMinValueError.emit(result)\n          this.drawCanvasNoFace();\n        }\n      }\n\n      this.drawCanvasNoFace()\n      \n    }\n};\n\n\n  render() {\n    return (\n      <Host style={{height: this.height+\"px\", width: this.width+\"px\"}}>\n\n        <slot name='before'></slot>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"]}