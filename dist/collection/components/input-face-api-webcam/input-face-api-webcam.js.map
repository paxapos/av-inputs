{"version":3,"file":"input-face-api-webcam.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/input-face-api-webcam.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Host, h, Element, Prop, Event,EventEmitter, Method, State } from '@stencil/core';\nimport { FaceapiService } from '../../utils/facepi.service';\nimport { createCanvas, createVideo, initWebcamToVideo } from '../../utils/camera.service';\nimport { FaceDetection } from 'face-api.js';\n\n@Component({\n  tag: 'input-face-api-webcam',\n  styleUrl: 'input-face-api-webcam.css',\n  shadow: true,\n})\nexport class InputFaceApiWebcam {\n  faceFound: Blob = null;\n\n  // canvas to store photo\n  photoCanvas: HTMLCanvasElement\n\n  //webcam stream\n  video: HTMLVideoElement\n\n  //canvas to draw webcam\n  canvas: HTMLCanvasElement\n\n  //faceapi service\n  faceapiService: FaceapiService\n\n  // timer to detect face bassed on detectionTimer\n  pictureTimer: any = null\n\n  // last result\n  result: FaceDetection = null\n\n    \n  @Element() el: HTMLElement;\n\n  @State() isDetecting = true;\n\n\n  @Prop({reflect: true, mutable: true}) width?: number = 460\n  @Prop({reflect: true, mutable: true}) height?: number = 460\n\n  @Prop({reflect: true, mutable: true}) detectionTimer?: number = 1000\n\n  @Method()\n  async stopDetection(): Promise<void> {\n    this.isDetecting = false;\n  }\n\n  @Method()\n  async startDetection(): Promise<void> {\n    this.isDetecting = true;\n  }\n\n\n\n  @Event({\n    eventName: 'faceDetected',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceDetected: EventEmitter<Blob>;\n\n\n  @Event({\n    eventName: 'faceStopDetection',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceStopDetection: EventEmitter<void>;\n\n\n  async componentWillLoad() {\n   \n    this.video = createVideo()\n    //this.el.appendChild(this.video)\n\n    this.canvas = createCanvas(this.el)\n    this.canvas.width = this.width\n    this.canvas.height = this.height\n\n    this.el.appendChild(this.canvas)\n\n\n    this.photoCanvas = createCanvas(this.el)\n    this.photoCanvas.width = this.width\n    this.photoCanvas.height = this.height\n\n    //this.el.appendChild(this.photoCanvas)\n    this.faceapiService = new FaceapiService()\n\n\n  }\n\n  async componentDidRender() {\n\n    initWebcamToVideo(this.video)\n   \n\n    this.webcamRender();\n    \n  }\n\n  async disconnectedCallback() {\n  }\n\n  /**\n   * \n   * @param result \n   * @returns true si proceso y detecto imagen\n   */\n  getPicZoom(result): Promise<Blob> {\n\n    if ( this.pictureTimer ) {\n      return null\n    }\n\n    this.pictureTimer = setTimeout(() => {\n      this.pictureTimer = null\n    }, this.detectionTimer)\n      \n\n      return new Promise((resolve, reject) => {\n        let h = result.box.height * 1.5\n        let w = result.box.width *1.5\n    \n        // hacer caudrada la imagen\n        if ( h > w ) {\n            w = h\n        } else {\n            h = w\n        }\n        \n        //centrar la imagen\n        \n        // center in x\n        let x = result.box.x - (w - result.box.width) / 2\n        const xlimit =  result.box.x + w\n        if ( xlimit >= this.canvas.width ) {\n          \n          // out of right\n          x = xlimit - result.box.x\n        } else {\n        }\n        \n        \n        let y;\n        const ylimit = result.box.y + h\n        if ( ylimit > this.canvas.height ) {\n          // out of bottom\n          y = ylimit - result.box.y\n        } else {\n          // center in y\n          y = result.box.y - (h - result.box.height) / 2\n        }\n        \n        \n        // eliminar la imagen del canvas\n        this.photoCanvas.getContext('2d').clearRect(0, 0, this.photoCanvas.width, this.photoCanvas.height)\n        \n        \n        // zom video into canvas\n        this.photoCanvas.getContext('2d').drawImage(this.canvas, x, y, w, h, 0, 0, this.photoCanvas.width, this.photoCanvas.height)\n    \n    \n        try {\n          \n          // this faceDetected emit blob from this.canvas\n          this.photoCanvas.toBlob((blob) => {\n            this.faceDetected.emit(blob)\n            resolve(blob)\n          }, 'image/jpeg', 1)\n      \n        } catch (error) {\n          reject(error)\n        }\n\n      })\n\n  }\n\n\n\n\n  handleStopDetection() {\n    if ( this.faceFound ) {\n      console.info(\"STOOPPPP detectiopnm\")\n      this.faceStopDetection.emit()\n    }\n    this.faceFound = null\n  }\n \n  async webcamRender () {\n    \n\n    \n   // this.canvas.getContext('2d').drawImage(this.video, 0, 0, this.width, this.height)\n\n    if ( this.isDetecting ) {\n\n      let imgWidth = this.video.videoWidth;\n      let imgHeight = this.video.videoHeight;\n\n      var imgSize = Math.min(imgWidth, imgHeight);\n        // The following two lines yield a central based cropping.\n        // They can both be amended to be 0, if you wish it to be\n        // a left based cropped image.\n      var left = (imgWidth - imgSize) / 2;\n      var top = (imgHeight - imgSize) / 2;\n    \n      const context = this.canvas.getContext('2d')\n      \n      const result = await this.faceapiService.detectFace( this.canvas )\n      context.drawImage(this.video, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n      if (result ) {\n        try {\n          let x =  result.box.x\n          let y =  result.box.y\n          let w =  result.box.width\n          let h =  result.box.height\n\n          if ( this.result) {\n            if ( result.box.x < this.result.box.x  ) {\n              x = result.box.x - 1\n            } else {\n              x = result.box.x + 1\n            }\n\n            if ( result.box.y < this.result.box.y  ) {\n              y = result.box.y - 1\n            } else {\n              y = result.box.y + 1\n            }\n\n            if ( result.box.width < this.result.box.width  ) {\n              w = result.box.width - 1\n            } else {\n              w = result.box.width + 1\n            }\n\n            if ( result.box.height < this.result.box.height  ) {\n              h = result.box.height - 1\n            } else {\n              h = result.box.height + 1\n            }\n          }\n          \n          // draw border arround face\n          context.strokeStyle = '#4efd54'\n          context.lineWidth = 2\n          context.strokeRect(x, y, w, h)\n\n\n          this.getPicZoom(result)\n\n        } catch (e) {\n          this.handleStopDetection()\n        }\n      } else {\n        this.handleStopDetection()\n      }\n      this.result = result\n\n    }\n\n    requestAnimationFrame(() => {\n   //   setTimeout(() => {\n          this.webcamRender() \n     //   }, 1000) ;\n    });\n};\n\n\n  render() {\n    return (\n      <Host style={{height: this.height+\"px\", width: this.width+\"px\"}}>\n        <slot name='before'></slot>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"]}