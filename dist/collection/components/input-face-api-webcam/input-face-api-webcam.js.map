{"version":3,"file":"input-face-api-webcam.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/input-face-api-webcam.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Host, h, Element, Prop, Event,EventEmitter, Method, State } from '@stencil/core';\nimport { FaceapiService } from '../../utils/facepi.service';\nimport { CameraDirection, createCanvas, createVideo, initWebcamToVideo } from '../../utils/camera.service';\nimport { FaceDetection } from 'face-api.js';\n\n\nexport interface iFaceDetected{\n  blob: Blob\n  result: FaceDetection\n}\n\n@Component({\n  tag: 'input-face-api-webcam',\n  styleUrl: 'input-face-api-webcam.css',\n  shadow: true,\n})\nexport class InputFaceApiWebcam {\n  \n  //webcam stream\n  video: HTMLVideoElement\n\n  //canvas to draw webcam\n  canvas: HTMLCanvasElement\n\n  //faceapi service\n  faceapiService: FaceapiService\n\n  // timer to detect face bassed on detectionTimer\n  resultTimer: NodeJS.Timeout\n\n  // last result\n  result: FaceDetection = null\n\n  curCords = {x: 0, y: 0}\n  toCords = {x: 0, y: 0}\n\n    \n  @Element() el: HTMLElement;\n\n  @State() isDetecting = true;\n\n\n  @Prop({reflect: true, mutable: true}) width?: number = 460\n  @Prop({reflect: true, mutable: true}) height?: number = 460\n\n  /** Minimun input size of face */\n  @Prop({reflect: true, mutable: true}) inputSize?: number = 192\n\n  @Prop({reflect: true, mutable: true}) scoreThreshold?: number = 0.7\n\n  @Prop({reflect: true, mutable: true}) detectionTimer?: number = 1500\n\n  @Prop({ mutable: true, reflect: true }) facingMode?: CameraDirection = CameraDirection.Front\n\n\n  @Method()\n  async stopDetection(): Promise<void> {\n    this.isDetecting = false;\n  }\n\n  @Method()\n  async startDetection(): Promise<void> {\n    this.isDetecting = true;\n  }\n\n\n  @Event({\n    eventName: 'faceDetected',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceDetected: EventEmitter<iFaceDetected>;\n\n\n  @Event({\n    eventName: 'faceStopDetection',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) faceStopDetection: EventEmitter<void>;\n\n\n  async componentWillLoad() {\n   \n    this.video = createVideo()\n\n    this.canvas = createCanvas(this.el)\n    this.canvas.width = this.width\n    this.canvas.height = this.height\n\n    this.el.appendChild(this.canvas)\n\n\n    this.faceapiService = new FaceapiService()\n\n\n  }\n\n  async componentDidRender() {\n    initWebcamToVideo(this.video, this.facingMode)\n   \n    this.webcamRender();\n    \n  }\n\n\n\n  /**\n   * \n   * @param result \n   * @returns true si proceso y detecto imagen\n   */\n  emitBlob(result): Promise<Blob> {\n\n    return new Promise((resolve, reject) => {\n      try {\n        // this faceDetected emit blob from this.canvas\n        this.canvas.toBlob((blob) => {\n          const iface = {blob, result}\n          this.faceDetected.emit(iface)\n          resolve(blob)\n        }, 'image/jpeg', 1)\n    \n      } catch (error) {\n        reject(error)\n      }\n\n    })\n\n  }\n\n\n \n  async webcamRender () {\n    \n\n    let ctx = this.canvas.getContext('2d');\n    this.drawWebcamnToCanvas(ctx);\n    \n    // get context of canvas and create paning and zoooming to center\n    if ( this.isDetecting && !this.resultTimer) {\n        \n      const result = await this.faceapiService.detectFace( this.canvas, this.inputSize, this.scoreThreshold )\n      \n      if ( result ) {\n        this.toCords = {x: Math.ceil(result.box.x), y: Math.ceil(result.box.y)}\n\n        try {\n          // saca una foto del canvas y genera el BLOB para emitir\n          await this.emitBlob(result)\n        } catch (e) {\n          console.error(e)\n        }\n      } else {\n\n        this.faceStopDetection.emit()\n\n        ctx.translate(0, 0);\n        ctx.scale(1, 1);\n        this.toCords = {x: 0, y: 0}\n  \n      }\n      this.result = result\n        \n      this.resultTimer = setTimeout(async () => {\n        clearTimeout(this.resultTimer)\n        this.resultTimer = null\n\n      }, Math.abs(this.detectionTimer))\n    }\n\n    \n    requestAnimationFrame(() => {\n      this.webcamRender() \n    })\n};\n\n\ndrawWebcamnToCanvas(ctx) {\n  let imgWidth = this.video.videoWidth;\n  let imgHeight = this.video.videoHeight;\n\n  var imgSize = Math.min(imgWidth, imgHeight);\n    // The following two lines yield a central based cropping.\n    // They can both be amended to be 0, if you wish it to be\n    // a left based cropped image.\n  var left = (imgWidth - imgSize) / 2;\n  var top = (imgHeight - imgSize) / 2;\n\n  // ctx clear all\n  ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n  ctx.drawImage(this.video, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n}\n\n\n  render() {\n    return (\n      <Host style={{height: this.height+\"px\", width: this.width+\"px\"}}>\n        <slot name='before'></slot>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"]}