{"version":3,"file":"distance.worker.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/distance.worker.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAI1C,MAAM,CAAC,KAAK,UAAU,UAAU,CAAC,EAAwB,EAAE,EAAwB;EAC/E,UAAU;EACV,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,IAAI,EAAC,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;EAEpC,OAAO,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;EACzC,OAAO,CAAC,CAAA;EACR;;;;;;;;;IASE;AACN,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,WAAW,CAAC,EAAwB,EAAE,EAAwB;EAChF,IAAK,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM;IAAG,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAA;EAErF,IAAI,CAAC,GAAG,CAAC,CAAC;EACV,IAAI,GAAG,GAAG,CAAC,CAAC;EACZ,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE;IAClB,gCAAgC;IAChC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3G,CAAC,EAAE,CAAC;GACP;EAED,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAE1B,CAAC;AAGD;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAAC,kBAA2C,EAAE,EAAwB,EAAG,SAAiB,GAAG;EAC3H,IAAI,SAAS,GAAuB,IAAI,CAAC;EACzC,IAAI,YAAY,GAAG,QAAQ,CAAC;EAE5B,KAAK,MAAM,UAAU,IAAI,kBAAkB,EAAE;IACzC,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC,UAAU,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;IAE/D,IAAK,QAAQ,GAAG,MAAM,EAAG;MACrB,SAAS;KACZ;IAED,IAAK,QAAQ,GAAG,YAAY,EAAG;MAC3B,YAAY,GAAG,QAAQ,CAAC;MACxB,SAAS,GAAG,UAAU,CAAC;KAC1B;GACJ;EAED,OAAO,SAAS,CAAC;AAGrB,CAAC","sourcesContent":["import { NormalizedLandmark } from \"@mediapipe/tasks-vision\";\nimport { LabeledDescriptors, LabeledDescriptorsArray } from \"./TrainedModel\";\nimport { tensor } from \"@tensorflow/tfjs\";\n\n\n\nexport async function tsDistance(v1: NormalizedLandmark[], v2: NormalizedLandmark[]) {\n    // Vectors\n    const t = tensor([1212,12]).print();\n    \n    console.info(\"el tensor es: \", t, v1, v2)\n    return t\n    /*\n    a = tf.placeholder(tf.float32, shape=[600, 52])\n    b = tf.placeholder(tf.float32, shape=[16000, 52])\n    # Cosine similarity\n    similarity = tf.reduce_sum(a[:, tf.newaxis] * b, axis=-1)\n    # Only necessary if vectors are not normalized\n    similarity /= tf.norm(a[:, tf.newaxis], axis=-1) * tf.norm(b, axis=-1)\n    # If you prefer the distance measure\n    distance = 1 - similarity\n    */\n}\n\nexport async function getDistance(v1: NormalizedLandmark[], v2: NormalizedLandmark[]) {\n    if ( v1.length !== v2.length ) throw new Error(\"v1 and v2 must have the same length\")\n\n    let i = 0;\n    let sum = 0;\n    while (i < v1.length) {\n        // calculate euclidean distantce\n        sum += Math.pow( v1[i].x - v2[i].x, 2) + Math.pow( v1[i].y - v2[i].y, 2) + Math.pow( v1[i].z - v2[i].z, 2);\n        i++;\n    }\n\n    return Math.sqrt(sum);\n\n}\n\n\n/**\n * \n * retorna el descriptor que mas se parece al descriptor de entrada usando getDistance\n * \n * @param trainedModel \n * @param lm \n */\nexport async function getBestMatch(labeledDescriptors: LabeledDescriptorsArray, lm: NormalizedLandmark[],  umbral: number = 1.5): Promise<LabeledDescriptors> {\n    let bestMatch: LabeledDescriptors = null;\n    let bestDistance = Infinity;\n\n    for (const descriptor of labeledDescriptors) {\n        const distance = await getDistance(descriptor.descriptors, lm);\n\n        if ( distance > umbral ) {\n            continue;\n        }\n\n        if ( distance < bestDistance ) {\n            bestDistance = distance;\n            bestMatch = descriptor;\n        }\n    }\n\n    return bestMatch;\n    \n\n}"]}