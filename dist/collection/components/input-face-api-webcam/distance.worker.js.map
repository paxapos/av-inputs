{"version":3,"file":"distance.worker.js","sourceRoot":"","sources":["../../../src/components/input-face-api-webcam/distance.worker.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAI1C,MAAM,CAAC,KAAK,UAAU,UAAU,CAAC,EAAwB,EAAE,EAAwB;IAC/E,UAAU;IACV,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,IAAI,EAAC,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;IAEpC,OAAO,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;IACzC,OAAO,CAAC,CAAA;IACR;;;;;;;;;MASE;AACN,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,WAAW,CAAC,EAAwB,EAAE,EAAwB;IAChF,IAAK,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM;QAAG,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAA;IAErF,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC;QACnB,gCAAgC;QAChC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3G,CAAC,EAAE,CAAC;IACR,CAAC;IAED,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAE1B,CAAC;AAGD;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,YAAY,CAAC,kBAA2C,EAAE,EAAwB,EAAG,SAAiB,GAAG;IAC3H,IAAI,SAAS,GAAuB,IAAI,CAAC;IACzC,IAAI,YAAY,GAAG,QAAQ,CAAC;IAE5B,KAAK,MAAM,UAAU,IAAI,kBAAkB,EAAE,CAAC;QAC1C,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC,UAAU,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;QAE/D,IAAK,QAAQ,GAAG,MAAM,EAAG,CAAC;YACtB,SAAS;QACb,CAAC;QAED,IAAK,QAAQ,GAAG,YAAY,EAAG,CAAC;YAC5B,YAAY,GAAG,QAAQ,CAAC;YACxB,SAAS,GAAG,UAAU,CAAC;QAC3B,CAAC;IACL,CAAC;IAED,OAAO,SAAS,CAAC;AAGrB,CAAC","sourcesContent":["import { NormalizedLandmark } from \"@mediapipe/tasks-vision\";\nimport { LabeledDescriptors, LabeledDescriptorsArray } from \"./TrainedModel\";\nimport { tensor } from \"@tensorflow/tfjs\";\n\n\n\nexport async function tsDistance(v1: NormalizedLandmark[], v2: NormalizedLandmark[]) {\n    // Vectors\n    const t = tensor([1212,12]).print();\n    \n    console.info(\"el tensor es: \", t, v1, v2)\n    return t\n    /*\n    a = tf.placeholder(tf.float32, shape=[600, 52])\n    b = tf.placeholder(tf.float32, shape=[16000, 52])\n    # Cosine similarity\n    similarity = tf.reduce_sum(a[:, tf.newaxis] * b, axis=-1)\n    # Only necessary if vectors are not normalized\n    similarity /= tf.norm(a[:, tf.newaxis], axis=-1) * tf.norm(b, axis=-1)\n    # If you prefer the distance measure\n    distance = 1 - similarity\n    */\n}\n\nexport async function getDistance(v1: NormalizedLandmark[], v2: NormalizedLandmark[]) {\n    if ( v1.length !== v2.length ) throw new Error(\"v1 and v2 must have the same length\")\n\n    let i = 0;\n    let sum = 0;\n    while (i < v1.length) {\n        // calculate euclidean distantce\n        sum += Math.pow( v1[i].x - v2[i].x, 2) + Math.pow( v1[i].y - v2[i].y, 2) + Math.pow( v1[i].z - v2[i].z, 2);\n        i++;\n    }\n\n    return Math.sqrt(sum);\n\n}\n\n\n/**\n * \n * retorna el descriptor que mas se parece al descriptor de entrada usando getDistance\n * \n * @param trainedModel \n * @param lm \n */\nexport async function getBestMatch(labeledDescriptors: LabeledDescriptorsArray, lm: NormalizedLandmark[],  umbral: number = 1.5): Promise<LabeledDescriptors> {\n    let bestMatch: LabeledDescriptors = null;\n    let bestDistance = Infinity;\n\n    for (const descriptor of labeledDescriptors) {\n        const distance = await getDistance(descriptor.descriptors, lm);\n\n        if ( distance > umbral ) {\n            continue;\n        }\n\n        if ( distance < bestDistance ) {\n            bestDistance = distance;\n            bestMatch = descriptor;\n        }\n    }\n\n    return bestMatch;\n    \n\n}"]}