{"version":3,"names":["CameraDirection","createVideo","video","document","createElement","autoplay","style","display","createCanvas","parentElement","canvas","width","parseInt","getAttribute","height","videoToCanvas","box","Promise","resolve","reject","originX","originY","upscaledW","upscaledH","finalW","finalH","ctx","getContext","xMove","yMove","drawImage","error","videoToBlob","compression","then","toBlob","blob","renderToCanvas","drawImageCb","imgWidth","videoWidth","imgHeight","videoHeight","imgSize","Math","min","left","top","call","this","requestAnimationFrame","async","takePicture","filename","abs","round","random","file","File","type","initWebcamToVideo","direction","Front","navigator","mediaDevices","getUserMedia","facingMode","audio","stream","srcObject","catch","err0r"],"sources":["src/utils/camera.service.ts"],"sourcesContent":["import { BoundingBox } from \"@mediapipe/tasks-vision\";\n\nexport enum CameraDirection {\n    Rear = \"REAR\",\n    Front = \"FRONT\"\n}\n\n/**\n * Crea un HTMLVideoElement en el parentElement dado, siempre y cuando no exista\n * @param parentElement \n */\nexport  function createVideo(): HTMLVideoElement {\n        \n    // no existe, lo creo\n    const video = document.createElement(\"video\")\n    video.autoplay = true;\n    video.style.display = \"none\"\n\n    return video\n}\n\n\n/**\n * Crea un HTMLCanvasElement en el parentElement dado, siempre y cuando no exista\n * @param parentElement \n */\nexport  function createCanvas( parentElement: HTMLElement ): HTMLCanvasElement {\n        \n    // no existe, lo creo\n    const canvas = document.createElement(\"canvas\")\n    canvas.width = parseInt( parentElement.getAttribute(\"width\") );\n    canvas.height = parseInt( parentElement.getAttribute(\"height\") );\n    return canvas\n}\n\nexport function videoToCanvas(video: HTMLVideoElement,box: BoundingBox): Promise<HTMLCanvasElement> {\n    return new Promise((resolve, reject) => {\n        try {\n            const canvas = document.createElement(\"canvas\")\n            const { originX, originY, width, height } = box\n\n            const upscaledW = width * 1.3\n            const upscaledH = height * 2\n\n\n            const finalW = upscaledW > upscaledH ? upscaledW : upscaledH\n            const finalH = upscaledW > upscaledH ? upscaledW : upscaledH\n\n            canvas.width = finalW;\n            canvas.height = finalH;\n\n            const ctx = canvas.getContext('2d');\n\n            const xMove = ((finalW - width)/2)\n            const yMove = ((finalH - height)/2)\n            ctx.drawImage(video, originX - xMove, originY - yMove, finalW, finalH, 0, 0, canvas.width, canvas.height);\n\n            resolve(canvas);\n        } catch (error) {\n            reject(error);\n        }\n      });\n}\n\n\nexport function videoToBlob(video: HTMLVideoElement, box?: BoundingBox, compression: number = 0.85): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n        try {\n            \n            videoToCanvas(video, box).then( canvas => {\n                canvas.toBlob( (blob) => {\n                    resolve(blob);\n                }, \"image/jpeg\", compression)\n            })\n        } catch (error) {\n            reject(error);\n        }\n      });\n    \n\n}\n\nexport function renderToCanvas( canvas, video, drawImageCb?: Function|null ): number {\n\n    let ctx = canvas.getContext('2d');\n\n    let imgWidth = video.videoWidth;\n    let imgHeight = video.videoHeight;\n\n    var imgSize = Math.min(imgWidth, imgHeight);\n    // The following two lines yield a central based cropping.\n    // They can both be amended to be 0, if you wish it to be\n    // a left based cropped image.\n    var left = (imgWidth - imgSize) / 2;\n    var top = (imgHeight - imgSize) / 2;\n\n\n    if ( drawImageCb ) {\n        drawImageCb.call(this, ctx, video, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height)\n    } else {\n        ctx.drawImage(video, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height);\n    }\n\n\n    return requestAnimationFrame(() => renderToCanvas( canvas, video, drawImageCb) );\n\n}\n\n\nexport async function takePicture( canvas, compression = 0.85 ): Promise<File> {\n    return new Promise((resolve, reject) => {\n        try {\n            canvas.toBlob( (blob) => {\n                const filename = \"pic_\" + Math.abs( Math.round( Math.random() * 1000))\n                var file = new File([blob], filename, {type: \"image/jpeg\"});\n                resolve(file);\n            }, \"image/jpeg\", compression)\n        } catch (error) {\n            reject(error);\n        }\n      });\n}\n\n\nexport function initWebcamToVideo(video, direction: CameraDirection = CameraDirection.Front) {\n    return new Promise((resolve, reject) => {\n\n        if (navigator.mediaDevices.getUserMedia) {\n            const facingMode = (direction == CameraDirection.Front) ? \"user\": \"environment\"\n    \n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { min: 200 },\n                    height: { min: 200 },\n                    facingMode: facingMode\n                }\n            })\n            .then((stream) => {\n                video.srcObject = stream;\n                resolve(stream);\n            })\n            .catch(function (err0r) {\n                reject(err0r);\n            });\n        }\n    });\n}"],"mappings":"IAEYA,GAAZ,SAAYA,GACRA,EAAA,eACAA,EAAA,gBACH,EAHD,CAAYA,MAAe,K,SASVC,IAGb,MAAMC,EAAQC,SAASC,cAAc,SACrCF,EAAMG,SAAW,KACjBH,EAAMI,MAAMC,QAAU,OAEtB,OAAOL,CACX,C,SAOiBM,EAAcC,GAG3B,MAAMC,EAASP,SAASC,cAAc,UACtCM,EAAOC,MAAQC,SAAUH,EAAcI,aAAa,UACpDH,EAAOI,OAASF,SAAUH,EAAcI,aAAa,WACrD,OAAOH,CACX,C,SAEgBK,EAAcb,EAAwBc,GAClD,OAAO,IAAIC,SAAQ,CAACC,EAASC,KACzB,IACI,MAAMT,EAASP,SAASC,cAAc,UACtC,MAAMgB,QAAEA,EAAOC,QAAEA,EAAOV,MAAEA,EAAKG,OAAEA,GAAWE,EAE5C,MAAMM,EAAYX,EAAQ,IAC1B,MAAMY,EAAYT,EAAS,EAG3B,MAAMU,EAASF,EAAYC,EAAYD,EAAYC,EACnD,MAAME,EAASH,EAAYC,EAAYD,EAAYC,EAEnDb,EAAOC,MAAQa,EACfd,EAAOI,OAASW,EAEhB,MAAMC,EAAMhB,EAAOiB,WAAW,MAE9B,MAAMC,GAAUJ,EAASb,GAAO,EAChC,MAAMkB,GAAUJ,EAASX,GAAQ,EACjCY,EAAII,UAAU5B,EAAOkB,EAAUQ,EAAOP,EAAUQ,EAAOL,EAAQC,EAAQ,EAAG,EAAGf,EAAOC,MAAOD,EAAOI,QAElGI,EAAQR,E,CACV,MAAOqB,GACLZ,EAAOY,E,IAGnB,C,SAGgBC,EAAY9B,EAAyBc,EAAmBiB,EAAsB,KAC1F,OAAO,IAAIhB,SAAQ,CAACC,EAASC,KACzB,IAEIJ,EAAcb,EAAOc,GAAKkB,MAAMxB,IAC5BA,EAAOyB,QAASC,IACZlB,EAAQkB,EAAK,GACd,aAAcH,EAAY,G,CAEnC,MAAOF,GACLZ,EAAOY,E,IAKnB,C,SAEgBM,EAAgB3B,EAAQR,EAAOoC,GAE3C,IAAIZ,EAAMhB,EAAOiB,WAAW,MAE5B,IAAIY,EAAWrC,EAAMsC,WACrB,IAAIC,EAAYvC,EAAMwC,YAEtB,IAAIC,EAAUC,KAAKC,IAAIN,EAAUE,GAIjC,IAAIK,GAAQP,EAAWI,GAAW,EAClC,IAAII,GAAON,EAAYE,GAAW,EAGlC,GAAKL,EAAc,CACfA,EAAYU,KAAKC,KAAMvB,EAAKxB,EAAO4C,EAAMC,EAAKJ,EAASA,EAAS,EAAE,EAAGjC,EAAOC,MAAOD,EAAOI,O,KACvF,CACHY,EAAII,UAAU5B,EAAO4C,EAAMC,EAAKJ,EAASA,EAAS,EAAE,EAAGjC,EAAOC,MAAOD,EAAOI,O,CAIhF,OAAOoC,uBAAsB,IAAMb,EAAgB3B,EAAQR,EAAOoC,IAEtE,CAGOa,eAAeC,EAAa1C,EAAQuB,EAAc,KACrD,OAAO,IAAIhB,SAAQ,CAACC,EAASC,KACzB,IACIT,EAAOyB,QAASC,IACZ,MAAMiB,EAAW,OAAST,KAAKU,IAAKV,KAAKW,MAAOX,KAAKY,SAAW,MAChE,IAAIC,EAAO,IAAIC,KAAK,CAACtB,GAAOiB,EAAU,CAACM,KAAM,eAC7CzC,EAAQuC,EAAK,GACd,aAAcxB,E,CACnB,MAAOF,GACLZ,EAAOY,E,IAGnB,C,SAGgB6B,EAAkB1D,EAAO2D,EAA6B7D,EAAgB8D,OAClF,OAAO,IAAI7C,SAAQ,CAACC,EAASC,KAEzB,GAAI4C,UAAUC,aAAaC,aAAc,CACrC,MAAMC,EAAcL,GAAa7D,EAAgB8D,MAAS,OAAQ,cAElEC,UAAUC,aAAaC,aAAa,CAChCE,MAAO,MACPjE,MAAO,CACHS,MAAO,CAAEkC,IAAK,KACd/B,OAAQ,CAAE+B,IAAK,KACfqB,WAAYA,KAGnBhC,MAAMkC,IACHlE,EAAMmE,UAAYD,EAClBlD,EAAQkD,EAAO,IAElBE,OAAM,SAAUC,GACbpD,EAAOoD,E,OAIvB,Q"}