{"version":3,"names":["WebCamera","initCamera","parentElement","direction","drawImageCb","this","resetCamera","elVideo","createVideo","canvas","createCanvas","appendChild","initWebcamToVideo","renderToCanvas","stream","_b","_a","getVideoTracks","forEach","track","stop","removeTrack","srcObject","takePicture","quality","camera","inputFileFromWebcamCss","InputFileFromWebcam","constructor","hostRef","cameraState","status","isFlipped","width","height","facingMode","CameraDirection","Front","showControls","autoStart","imageQuality","flashEffect","captureButtonText","flipButtonText","startCamera","el","cameraStarted","emit","error","webcamError","type","getErrorType","message","cameraError","stopCamera","cameraStopped","takePic","Object","assign","showFlashEffect","pic","pictureTaken","toggleCamera","__toogleFacingMode","onClickHandler","onFacingModeChange","name","flashEl","shadowRoot","querySelector","style","opacity","setTimeout","newFacingMode","Rear","facingModeChanged","handleCaptureClick","handleFlipClick","handleRetryClick","componentWillLoad","componentDidLoad","disconnectedCallback","renderLoadingState","h","class","renderErrorState","errorMessage","actionButton","onClick","renderInactiveState","renderControls","isCapturing","title","disabled","render","hostClasses","flipped","Host","key"],"sources":["src/utils/camera.ts","src/components/input-file-from-webcam/input-file-from-webcam.css?tag=input-file-from-webcam&encapsulation=shadow","src/components/input-file-from-webcam/input-file-from-webcam.tsx"],"sourcesContent":["import { createVideo, createCanvas, CameraDirection, initWebcamToVideo, renderToCanvas, takePicture } from \"./camera.service\";\n\n\n\ninterface SuperCamera {\n    initCamera(parentElement: HTMLElement, direction: CameraDirection, drawImageCb: Function): Promise<HTMLCanvasElement>,\n    takePicture(): Promise<Blob>,\n    resetCamera(): void,\n}\n\n\n\nexport class WebCamera implements SuperCamera {\n\n    private elVideo: HTMLVideoElement;\n    private stream: MediaStream;\n    private canvas: HTMLCanvasElement;\n\n\n    public async initCamera( parentElement: HTMLElement, direction: CameraDirection, drawImageCb: Function = null) {\n\n        this.resetCamera();\n\n        if ( !this.elVideo ) {\n            this.elVideo = createVideo()\n        }\n\n        if ( !this.canvas ) {\n            this.canvas = createCanvas(parentElement)\n            parentElement.appendChild(this.canvas)\n        }\n\n        initWebcamToVideo(this.elVideo, direction)\n\n        renderToCanvas(this.canvas, this.elVideo, drawImageCb)\n\n        return this.canvas\n    }\n\n\n    public resetCamera() {\n        if (this.stream) this.stream?.getVideoTracks()?.forEach(track => {\n            track?.stop()\n            this.stream?.removeTrack(track)\n        });\n        if (this.elVideo) this.elVideo.srcObject = null;\n    }\n\n    public async takePicture(quality: number = 0.85): Promise<File> {\n        return await takePicture(this.canvas, quality);\n    }\n\n}\n\n\nexport const camera = new WebCamera()\n",":host {\n  display: inline-block;\n  position: relative;\n  width: 460px;\n  height: 460px;\n  border-radius: 12px;\n  overflow: hidden;\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);\n  border: 2px solid #e0e0e0;\n  background: #f5f5f5;\n  transition: all 0.3s ease;\n}\n\n:host(.camera-ready) {\n  border-color: #4CAF50;\n  box-shadow: 0 8px 32px rgba(76, 175, 80, 0.2);\n}\n\n:host(.camera-error) {\n  border-color: #f44336;\n  box-shadow: 0 8px 32px rgba(244, 67, 54, 0.2);\n}\n\n:host(.camera-loading) {\n  border-color: #2196F3;\n  box-shadow: 0 8px 32px rgba(33, 150, 243, 0.2);\n}\n\n:host(.flipped) canvas {\n  transform: scaleX(-1);\n}\n\nvideo {\n  display: none;\n}\n\ncanvas {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  transition: transform 0.3s ease;\n}\n\n/* Camera states */\n.camera-state {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  padding: 20px;\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.camera-state.loading {\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  color: white;\n}\n\n.camera-state.error {\n  background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);\n  color: white;\n}\n\n.camera-state.inactive {\n  background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);\n  color: #333;\n}\n\n/* Loading spinner */\n.spinner {\n  width: 40px;\n  height: 40px;\n  border: 4px solid rgba(255, 255, 255, 0.3);\n  border-top: 4px solid white;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n  margin-bottom: 16px;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Icons */\n.error-icon,\n.inactive-icon {\n  font-size: 48px;\n  margin-bottom: 16px;\n}\n\n/* Messages */\n.camera-state p {\n  margin: 0 0 16px 0;\n  font-size: 16px;\n  font-weight: 500;\n  line-height: 1.4;\n}\n\n.error-message {\n  max-width: 300px;\n}\n\n/* Buttons */\n.retry-button,\n.start-button {\n  padding: 12px 24px;\n  border: none;\n  border-radius: 8px;\n  background: rgba(255, 255, 255, 0.2);\n  color: inherit;\n  font-size: 14px;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  backdrop-filter: blur(10px);\n}\n\n.retry-button:hover,\n.start-button:hover {\n  background: rgba(255, 255, 255, 0.3);\n  transform: translateY(-2px);\n}\n\n.start-button {\n  background: rgba(0, 0, 0, 0.1);\n}\n\n.start-button:hover {\n  background: rgba(0, 0, 0, 0.2);\n}\n\n/* Camera controls */\n.camera-controls {\n  position: absolute;\n  bottom: 16px;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  gap: 12px;\n  z-index: 10;\n}\n\n.control-button {\n  width: 56px;\n  height: 56px;\n  border: none;\n  border-radius: 50%;\n  background: rgba(0, 0, 0, 0.7);\n  color: white;\n  font-size: 24px;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: all 0.3s ease;\n  backdrop-filter: blur(10px);\n}\n\n.control-button:hover {\n  background: rgba(0, 0, 0, 0.9);\n  transform: scale(1.1);\n}\n\n.control-button:active {\n  transform: scale(0.95);\n}\n\n.capture-button {\n  width: 72px;\n  height: 72px;\n  background: rgba(255, 255, 255, 0.9);\n  color: #333;\n  font-size: 28px;\n}\n\n.capture-button:hover {\n  background: white;\n}\n\n.control-button:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n  transform: none;\n}\n\n.control-button:disabled:hover {\n  transform: none;\n  background: rgba(0, 0, 0, 0.7);\n}\n\n/* Flash effect */\n.flash-effect {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: white;\n  opacity: 0;\n  transition: opacity 0.2s ease;\n  pointer-events: none;\n  z-index: 5;\n}\n\n/* Responsive design */\n@media (max-width: 600px) {\n  :host {\n    width: 100%;\n    height: auto;\n    aspect-ratio: 1;\n    max-width: 400px;\n  }\n\n  .camera-controls {\n    bottom: 12px;\n  }\n\n  .control-button {\n    width: 48px;\n    height: 48px;\n    font-size: 20px;\n  }\n\n  .capture-button {\n    width: 64px;\n    height: 64px;\n    font-size: 24px;\n  }\n\n  .camera-state p {\n    font-size: 14px;\n  }\n\n  .error-icon,\n  .inactive-icon {\n    font-size: 36px;\n  }\n}\n\n/* High contrast mode support */\n@media (prefers-contrast: high) {\n  :host {\n    border-width: 3px;\n  }\n\n  .control-button {\n    border: 2px solid white;\n  }\n}\n\n/* Reduced motion support */\n@media (prefers-reduced-motion: reduce) {\n  * {\n    animation-duration: 0.01ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.01ms !important;\n  }\n}","import { Component, Host, h, Method, Listen, Prop, Event, EventEmitter, Element, State, Watch } from '@stencil/core';\nimport { camera } from '../../utils/camera';\nimport { CameraDirection } from '../../utils/camera.service';\n\nexport interface WebcamError {\n  type: 'permission' | 'device' | 'stream' | 'unknown';\n  message: string;\n}\n\nexport interface CameraState {\n  status: 'loading' | 'ready' | 'error' | 'capturing' | 'inactive';\n  error?: WebcamError;\n}\n\n@Component({\n  tag: 'input-file-from-webcam',\n  styleUrl: 'input-file-from-webcam.css',\n  shadow: true,\n})\nexport class InputFileFromWebcam {\n\n  @Element() el: HTMLElement;\n\n  @State() cameraState: CameraState = { status: 'inactive' };\n  @State() isFlipped: boolean = false;\n\n  /**\n   * Width of the video element\n   */\n  @Prop({reflect: true, mutable: true}) width?: number = 460\n\n  /**\n   * height of the video element\n   */\n  @Prop({reflect: true, mutable: true}) height?: number = 460\n\n  /**\n   * FacingModel optiones following https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode#value\n   */\n  @Prop({ mutable: true, reflect: true }) facingMode?: CameraDirection = CameraDirection.Front\n\n  /**\n   * Show camera controls (flip, capture button, etc)\n   */\n  @Prop() showControls?: boolean = true\n\n  /**\n   * Auto-start camera when component loads\n   */\n  @Prop() autoStart?: boolean = true\n\n  /**\n   * Image quality for captured photos (0.1 to 1.0)\n   */\n  @Prop() imageQuality?: number = 0.85\n\n  /**\n   * Enable flash effect when taking picture\n   */\n  @Prop() flashEffect?: boolean = true\n\n  /**\n   * Capture button text\n   */\n  @Prop() captureButtonText?: string = '📸'\n\n  /**\n   * Flip camera button text\n   */\n  @Prop() flipButtonText?: string = '🔄'\n\n  /**\n   * you can pass a function and override the canvas.drawImage function so you\n   * can change the image adding filters or any kind of magin in your image\n   * \n   * you just need to crear a function with all canvas.-drawImage arguments\n   * \n   * here you have the list of vars you get: videoElement, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height\n   */\n  @Prop() drawImageCb?: Function = null\n\n  /**\n   * Start the camera\n   */\n  @Method()\n  async startCamera(): Promise<void> {\n    try {\n      this.cameraState = { status: 'loading' };\n      await camera.initCamera(this.el, this.facingMode, this.drawImageCb);\n      this.cameraState = { status: 'ready' };\n      this.cameraStarted.emit();\n    } catch (error) {\n      const webcamError: WebcamError = {\n        type: this.getErrorType(error),\n        message: error.message || 'Unknown camera error'\n      };\n      this.cameraState = { status: 'error', error: webcamError };\n      this.cameraError.emit(webcamError);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the camera\n   */\n  @Method()\n  async stopCamera(): Promise<void> {\n    camera.resetCamera();\n    this.cameraState = { status: 'inactive' };\n    this.cameraStopped.emit();\n  }\n\n  /**\n   * Take a picture\n   * @returns a blob with the image\n   */\n  @Method()\n  async takePic(): Promise<Blob> {\n    try {\n      this.cameraState = { ...this.cameraState, status: 'capturing' };\n      \n      if (this.flashEffect) {\n        this.showFlashEffect();\n      }\n      \n      const pic = await camera.takePicture(this.imageQuality);\n      this.cameraState = { ...this.cameraState, status: 'ready' };\n      this.pictureTaken.emit(pic);\n      return pic;\n    } catch (error) {\n      this.cameraState = { ...this.cameraState, status: 'ready' };\n      throw error;\n    }\n  }\n\n  /**\n   * Reset camera\n   */\n  @Method()\n  async resetCamera(): Promise<void> {\n    await this.stopCamera();\n    if (this.autoStart) {\n      await this.startCamera();\n    }\n  }\n\n  /**\n   * Toogle webcam, for example in mobile show front or back camera\n   */\n  @Method()\n  async toggleCamera(): Promise<void>{\n    await this.__toogleFacingMode();\n  }\n\n\n  /**\n   * Event emitted when the user takes a picture\n   */\n  @Event({\n    eventName: 'pictureTaken',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) pictureTaken: EventEmitter<Blob>;\n\n  /**\n   * Event emitted when facing mode changes\n   */\n  @Event({\n    eventName: 'facingModeChanged',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) facingModeChanged: EventEmitter<CameraDirection>;\n\n  /**\n   * Event emitted when camera starts successfully\n   */\n  @Event({\n    eventName: 'cameraStarted',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraStarted: EventEmitter<void>;\n\n  /**\n   * Event emitted when camera stops\n   */\n  @Event({\n    eventName: 'cameraStopped',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraStopped: EventEmitter<void>;\n\n  /**\n   * Event emitted when camera encounters an error\n   */\n  @Event({\n    eventName: 'cameraError',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) cameraError: EventEmitter<WebcamError>;\n\n\n\n  @Listen('click')\n  onClickHandler() {\n    if (this.cameraState.status === 'ready') {\n      this.takePic();\n    }\n  }\n\n  @Watch('facingMode')\n  async onFacingModeChange() {\n    if (this.cameraState.status === 'ready') {\n      await this.resetCamera();\n    }\n  }\n\n  /**\n   * Get error type from error object\n   */\n  private getErrorType(error: any): WebcamError['type'] {\n    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n      return 'permission';\n    }\n    if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n      return 'device';\n    }\n    if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n      return 'stream';\n    }\n    return 'unknown';\n  }\n\n  /**\n   * Show flash effect when taking picture\n   */\n  private showFlashEffect() {\n    const flashEl = this.el.shadowRoot?.querySelector('.flash-effect') as HTMLElement;\n    if (flashEl) {\n      flashEl.style.opacity = '1';\n      setTimeout(() => {\n        flashEl.style.opacity = '0';\n      }, 200);\n    }\n  }\n\n  /**\n   * Toggle webcam facing mode\n   */\n  private async __toogleFacingMode() {\n    const newFacingMode = (this.facingMode !== CameraDirection.Front) ? CameraDirection.Front : CameraDirection.Rear;\n    this.facingMode = newFacingMode;\n    this.facingModeChanged.emit(this.facingMode);\n  }\n\n  /**\n   * Handle capture button click\n   */\n  private async handleCaptureClick() {\n    if (this.cameraState.status === 'ready') {\n      await this.takePic();\n    }\n  }\n\n  /**\n   * Handle flip button click\n   */\n  private async handleFlipClick() {\n    await this.__toogleFacingMode();\n  }\n\n  /**\n   * Handle retry button click\n   */\n  private async handleRetryClick() {\n    await this.startCamera();\n  }\n\n \n\n  componentWillLoad() {\n    this.isFlipped = this.facingMode === CameraDirection.Front;\n  }\n  \n  async componentDidLoad() {\n    if (this.autoStart) {\n      await this.startCamera();\n    }\n  }\n\n  async disconnectedCallback() {\n    await this.stopCamera();\n  }\n\n  /**\n   * Render loading state\n   */\n  private renderLoadingState() {\n    return (\n      <div class=\"camera-state loading\">\n        <div class=\"spinner\"></div>\n        <p>Iniciando cámara...</p>\n      </div>\n    );\n  }\n\n  /**\n   * Render error state\n   */\n  private renderErrorState() {\n    const { error } = this.cameraState;\n    let errorMessage = 'Error desconocido';\n    let actionButton = null;\n\n    switch (error?.type) {\n      case 'permission':\n        errorMessage = 'Permiso de cámara denegado. Por favor, permite el acceso a la cámara.';\n        break;\n      case 'device':\n        errorMessage = 'No se encontró ninguna cámara disponible.';\n        break;\n      case 'stream':\n        errorMessage = 'Error al acceder a la cámara. Puede estar siendo usada por otra aplicación.';\n        actionButton = (\n          <button class=\"retry-button\" onClick={() => this.handleRetryClick()}>\n            Reintentar\n          </button>\n        );\n        break;\n      default:\n        errorMessage = error?.message || 'Error desconocido al inicializar la cámara.';\n        actionButton = (\n          <button class=\"retry-button\" onClick={() => this.handleRetryClick()}>\n            Reintentar\n          </button>\n        );\n    }\n\n    return (\n      <div class=\"camera-state error\">\n        <div class=\"error-icon\">⚠️</div>\n        <p class=\"error-message\">{errorMessage}</p>\n        {actionButton}\n      </div>\n    );\n  }\n\n  /**\n   * Render inactive state\n   */\n  private renderInactiveState() {\n    return (\n      <div class=\"camera-state inactive\">\n        <div class=\"inactive-icon\">📹</div>\n        <p>Cámara inactiva</p>\n        <button class=\"start-button\" onClick={() => this.startCamera()}>\n          Iniciar Cámara\n        </button>\n      </div>\n    );\n  }\n\n  /**\n   * Render camera controls\n   */\n  private renderControls() {\n    if (!this.showControls || (this.cameraState.status !== 'ready' && this.cameraState.status !== 'capturing')) {\n      return null;\n    }\n\n    const isCapturing = this.cameraState.status === 'capturing';\n\n    return (\n      <div class=\"camera-controls\">\n        <button \n          class=\"control-button flip-button\" \n          onClick={() => this.handleFlipClick()}\n          title=\"Cambiar cámara\"\n          disabled={isCapturing}\n        >\n          {this.flipButtonText}\n        </button>\n        <button \n          class=\"control-button capture-button\" \n          onClick={() => this.handleCaptureClick()}\n          title=\"Tomar foto\"\n          disabled={isCapturing}\n        >\n          {isCapturing ? '⏳' : this.captureButtonText}\n        </button>\n      </div>\n    );\n  }\n\n  render() {\n    const hostClasses = {\n      'camera-ready': this.cameraState.status === 'ready',\n      'camera-loading': this.cameraState.status === 'loading',\n      'camera-error': this.cameraState.status === 'error',\n      'camera-inactive': this.cameraState.status === 'inactive',\n      'camera-capturing': this.cameraState.status === 'capturing',\n      'flipped': this.isFlipped && this.facingMode === CameraDirection.Front\n    };\n\n    return (\n      <Host \n        style={{height: this.height+\"px\", width: this.width+\"px\"}}\n        class={hostClasses}\n      >\n        <slot name='before'></slot>\n        \n        {this.cameraState.status === 'loading' && this.renderLoadingState()}\n        {this.cameraState.status === 'error' && this.renderErrorState()}\n        {this.cameraState.status === 'inactive' && this.renderInactiveState()}\n        \n        <slot></slot>\n        \n        {this.flashEffect && <div class=\"flash-effect\"></div>}\n        {this.renderControls()}\n        \n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"],"mappings":"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","ignoreList":[]}