(()=>{"use strict";const t=(t,n)=>{const e=globalThis[n];return e!=null&&t instanceof e};const n=e=>{if(e!=null){if(t(e,"ArrayBuffer")||t(e,"MessagePort")||t(e,"ImageBitmap")||t(e,"OffscreenCanvas")){return[e]}if(typeof e==="object"){if(e.constructor===Object){e=Object.values(e)}if(Array.isArray(e)){return e.flatMap(n)}return n(e.buffer)}}return[]};const e={};const s="stencil.distance.worker";const o=s+".cb";addEventListener("message",(async({data:t})=>{if(t&&t[0]===s){let r=t[1];let i=t[2];let c=t[3];let a=0;let u=c.length;let l;let f;try{for(;a<u;a++){if(Array.isArray(c[a])&&c[a][0]===o){const t=c[a][1];c[a]=(...n)=>{postMessage([o,t,n])}}}l=await e[i](...c)}catch(t){l=null;if(t instanceof Error){f={isError:true,value:{message:t.message,name:t.name,stack:t.stack}}}else{f={isError:false,value:t}}l=undefined}const h=n(l);postMessage([s,r,l,f],h)}}));function r(t,n){for(var e=0;e<n.length;e++){var s=n[e];if(typeof s!=="string"&&!Array.isArray(s)){for(var o in s){if(o!=="default"&&!(o in t)){t[o]=s[o]}}}}return Object.freeze(t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i=1e-7;const c=1e-4;class a{constructor(t,n){this.backend=t;this.dataMover=n;this.data=new WeakMap;this.dataIdsCount=0}get(t){if(!this.data.has(t)){this.dataMover.moveData(this.backend,t)}return this.data.get(t)}set(t,n){this.dataIdsCount++;this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){this.dataIdsCount--;return this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class u{refCount(t){return l("refCount")}incRef(t){return l("incRef")}timerAvailable(){return true}time(t){return l("time")}read(t){return l("read")}readSync(t){return l("readSync")}readToGPU(t,n){return l("readToGPU")}numDataIds(){return l("numDataIds")}disposeData(t,n){return l("disposeData")}write(t,n,e){return l("write")}move(t,n,e,s,o){return l("move")}createTensorFromGPUData(t,n,e){return l("createTensorFromGPUData")}memory(){return l("memory")}floatPrecision(){return l("floatPrecision")}epsilon(){return this.floatPrecision()===32?i:c}dispose(){return l("dispose")}}function l(t){throw new Error(`'${t}' not yet implemented or not found in the registry. `+`This kernel may not be supported by the tfjs backend you have chosen`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f(t){let n=t.length;let e=0;while(n>0){e=Math.random()*n|0;n--;p(t,n,e)}}function h(t,n,e){return Math.max(t,Math.min(n,e))}function d(t){return t%2===0?t:t+1}function p(t,n,e){const s=t[n];t[n]=t[e];t[e]=s}function m(t){let n=0;for(let e=0;e<t.length;e++){n+=t[e]}return n}function x(t,n){if(!t){throw new Error(typeof n==="string"?n:n())}}function b(t,n,e=""){x(v(t,n),(()=>e+` Shapes ${t} and ${n} must match`))}function g(t){x(t!=null,(()=>`The input to the tensor constructor must be a non-null value.`))}function w(t){if(t.length===0){return 1}let n=t[0];for(let e=1;e<t.length;e++){n*=t[e]}return n}function v(t,n){if(t===n){return true}if(t==null||n==null){return false}if(t.length!==n.length){return false}for(let e=0;e<t.length;e++){if(t[e]!==n[e]){return false}}return true}function $(t){return t%1===0}function y(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function k(t,n){if(n<=t.length){return t}return t+" ".repeat(n-t.length)}function C(t,n=t=>0,e,s){return new Promise(((o,r)=>{let i=0;const c=()=>{if(t()){o();return}i++;const a=n(i);if(e!=null&&i>=e){r();return}if(s!=null){s(c,a)}else{setTimeout(c,a)}};c()}))}function N(t,n){let e=1;let s=-1;for(let n=0;n<t.length;++n){if(t[n]>=0){e*=t[n]}else if(t[n]===-1){if(s!==-1){throw Error(`Shapes can only have 1 implicit size. `+`Found -1 at dim ${s} and dim ${n}`)}s=n}else if(t[n]<0){throw Error(`Shapes can not be < 0. Found ${t[n]} at dim ${n}`)}}if(s===-1){if(n>0&&n!==e){throw Error(`Size(${n}) must match the product of shape ${t}`)}return t}if(e===0){throw Error(`Cannot infer the missing size in [${t}] when `+`there are 0 elements`)}if(n%e!==0){throw Error(`The implicit shape can't be a fractional number. `+`Got ${n} / ${e}`)}const o=t.slice();o[s]=n/e;return o}function R(t,n){const e=n.length;t=t==null?n.map(((t,n)=>n)):[].concat(t);x(t.every((t=>t>=-e&&t<e)),(()=>`All values in axis param must be in range [-${e}, ${e}) but `+`got axis ${t}`));x(t.every((t=>$(t))),(()=>`All values in axis param must be integers but `+`got axis ${t}`));return t.map((t=>t<0?e+t:t))}function S(t,n){const e=[];const s=[];const o=n!=null&&Array.isArray(n)&&n.length===0;const r=n==null||o?null:R(n,t).sort();let i=0;for(let n=0;n<t.length;++n){if(r!=null){if(r[i]===n&&t[n]!==1){throw new Error(`Can't squeeze axis ${n} since its dim '${t[n]}' is not 1`)}if((r[i]==null||r[i]>n)&&t[n]===1){e.push(t[n]);s.push(n)}if(r[i]<=n){i++}}if(t[n]!==1){e.push(t[n]);s.push(n)}}return{newShape:e,keptDims:s}}function E(t,n){return T(t,n)}function T(t,n){let e=null;if(t==null||t==="float32"){e=new Float32Array(n)}else if(t==="int32"){e=new Int32Array(n)}else if(t==="bool"){e=new Uint8Array(n)}else if(t==="string"){e=new Array(n)}else{throw new Error(`Unknown data type ${t}`)}return e}function I(t,n){for(let e=0;e<t.length;e++){const s=t[e];if(isNaN(s)||!isFinite(s)){throw Error(`A tensor of type ${n} being uploaded contains ${s}.`)}}}function A(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function O(t,n){if(n==="complex64"){return false}if(n==="float32"&&t!=="complex64"){return false}if(n==="int32"&&t!=="float32"&&t!=="complex64"){return false}if(n==="bool"&&t==="bool"){return false}return true}function F(t){if(t==="float32"||t==="int32"){return 4}else if(t==="complex64"){return 8}else if(t==="bool"){return 1}else{throw new Error(`Unknown dtype ${t}`)}}function _(t){if(t==null){return 0}let n=0;t.forEach((t=>n+=t.length));return n}function M(t){return typeof t==="string"||t instanceof String}function D(t){return typeof t==="boolean"}function L(t){return typeof t==="number"}function z(t){if(Array.isArray(t)){return z(t[0])}if(t instanceof Float32Array){return"float32"}else if(t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray){return"int32"}else if(L(t)){return"float32"}else if(M(t)){return"string"}else if(D(t)){return"bool"}return"float32"}function P(t){return!!(t&&t.constructor&&t.call&&t.apply)}function V(t,n){for(let e=n;e<t;++e){if(t%e===0){return e}}return t}function B(t){const n=t.length;if(n<2){return[]}const e=new Array(n-1);e[n-2]=t[n-1];for(let s=n-3;s>=0;--s){e[s]=e[s+1]*t[s+1]}return e}function W(t,n,e,s=false){const o=new Array;if(n.length===1){const r=n[0]*(s?2:1);for(let n=0;n<r;n++){o[n]=e[t+n]}}else{const r=n[0];const i=n.slice(1);const c=i.reduce(((t,n)=>t*n))*(s?2:1);for(let n=0;n<r;n++){o[n]=W(t+n*c,i,e,s)}}return o}function G(t,n,e=false){if(t.length===0){return n[0]}const s=t.reduce(((t,n)=>t*n))*(e?2:1);if(s===0){return[]}if(s!==n.length){throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`)}return W(0,t,n,e)}function U(t,n){if(Array.isArray(t)){return t}if(n==="float32"){return t instanceof Float32Array?t:new Float32Array(t)}else if(n==="int32"){return t instanceof Int32Array?t:new Int32Array(t)}else if(n==="bool"||n==="string"){return Uint8Array.from(new Int32Array(t))}else{throw new Error(`Unknown dtype ${n}`)}}function H(t,n){const e=j(t,n);for(let t=0;t<e.length;t++){e[t]=1}return e}function j(t,n){if(n==null||n==="float32"||n==="complex64"){return new Float32Array(t)}else if(n==="int32"){return new Int32Array(t)}else if(n==="bool"){return new Uint8Array(t)}else{throw new Error(`Unknown data type ${n}`)}}function q(t,n){const e=t.reduce(((t,n)=>t*n),1);if(n==null||n==="float32"){return G(t,new Float32Array(e))}else if(n==="int32"){return G(t,new Int32Array(e))}else if(n==="bool"){return G(t,new Uint8Array(e))}else{throw new Error(`Unknown data type ${n}`)}}function X(t){t.forEach((n=>{x(Number.isInteger(n)&&n>=0,(()=>`Tensor must have a shape comprised of positive integers but got `+`shape [${t}].`))}))}function K(t,n,e){if(n===0){return 0}else if(n===1){return t[0]}let s=t[t.length-1];for(let n=0;n<t.length-1;++n){s+=e[n]*t[n]}return s}function J(t,n,e){if(n===0){return[]}else if(n===1){return[t]}const s=new Array(n);for(let n=0;n<s.length-1;++n){s[n]=Math.floor(t/e[n]);t-=s[n]*e[n]}s[s.length-1]=t;return s}function Y(t){return t&&t.then&&typeof t.then==="function"}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z="tfjsflags";class Q{constructor(t){this.global=t;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=tt;this.populateURLFlags()}setPlatform(t,n){if(this.platform!=null){if(!(st().getBool("IS_TEST")||st().getBool("PROD"))){console.warn(`Platform ${this.platformName} has already been set. `+`Overwriting the platform with ${t}.`)}}this.platformName=t;this.platform=n}registerFlag(t,n,e){this.flagRegistry[t]={evaluationFn:n,setHook:e};if(this.urlFlags[t]!=null){const n=this.urlFlags[t];if(!(st().getBool("IS_TEST")||st().getBool("PROD"))){console.warn(`Setting feature override from URL ${t}: ${n}.`)}this.set(t,n)}}async getAsync(t){if(t in this.flags){return this.flags[t]}this.flags[t]=await this.evaluateFlag(t);return this.flags[t]}get(t){if(t in this.flags){return this.flags[t]}const n=this.evaluateFlag(t);if(Y(n)){throw new Error(`Flag ${t} cannot be synchronously evaluated. `+`Please use getAsync() instead.`)}this.flags[t]=n;return this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null){throw new Error(`Cannot set flag ${t} as it has not been registered.`)}this.flags[t]=n;if(this.flagRegistry[t].setHook!=null){this.flagRegistry[t].setHook(n)}}evaluateFlag(t){if(this.flagRegistry[t]==null){throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`)}return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={};this.urlFlags={};this.populateURLFlags()}populateURLFlags(){if(typeof this.global==="undefined"||typeof this.global.location==="undefined"||typeof this.global.location.search==="undefined"){return}const t=this.getQueryParams(this.global.location.search);if(Z in t){const n=t[Z].split(",");n.forEach((t=>{const[n,e]=t.split(":");this.urlFlags[n]=et(n,e)}))}}}function tt(t){const n={};t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...e)=>{nt(n,e[0],e[1]);return e.join("=")}));return n}function nt(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}function et(t,n){const e=n.toLowerCase();if(e==="true"||e==="false"){return e==="true"}else if(`${+e}`===e){return+e}else{return n}}function st(){return ot}let ot=null;function rt(t){ot=t}var it=typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{};function ct(){throw new Error("setTimeout has not been defined")}function at(){throw new Error("clearTimeout has not been defined")}var ut=ct;var lt=at;if(typeof it.setTimeout==="function"){ut=setTimeout}if(typeof it.clearTimeout==="function"){lt=clearTimeout}function ft(t){if(ut===setTimeout){return setTimeout(t,0)}if((ut===ct||!ut)&&setTimeout){ut=setTimeout;return setTimeout(t,0)}try{return ut(t,0)}catch(n){try{return ut.call(null,t,0)}catch(n){return ut.call(this,t,0)}}}function ht(t){if(lt===clearTimeout){return clearTimeout(t)}if((lt===at||!lt)&&clearTimeout){lt=clearTimeout;return clearTimeout(t)}try{return lt(t)}catch(n){try{return lt.call(null,t)}catch(n){return lt.call(this,t)}}}var dt=[];var pt=false;var mt;var xt=-1;function bt(){if(!pt||!mt){return}pt=false;if(mt.length){dt=mt.concat(dt)}else{xt=-1}if(dt.length){gt()}}function gt(){if(pt){return}var t=ft(bt);pt=true;var n=dt.length;while(n){mt=dt;dt=[];while(++xt<n){if(mt){mt[xt].run()}}xt=-1;n=dt.length}mt=null;pt=false;ht(t)}function wt(t){var n=new Array(arguments.length-1);if(arguments.length>1){for(var e=1;e<arguments.length;e++){n[e-1]=arguments[e]}}dt.push(new vt(t,n));if(dt.length===1&&!pt){ft(gt)}}function vt(t,n){this.fun=t;this.array=n}vt.prototype.run=function(){this.fun.apply(null,this.array)};var $t="browser";var yt="browser";var kt=true;var Ct={};var Nt=[];var Rt="";var St={};var Et={};var Tt={};function It(){}var At=It;var Ot=It;var Ft=It;var _t=It;var Mt=It;var Dt=It;var Lt=It;function zt(t){throw new Error("process.binding is not supported")}function Pt(){return"/"}function Vt(t){throw new Error("process.chdir is not supported")}function Bt(){return 0}var Wt=it.performance||{};var Gt=Wt.now||Wt.mozNow||Wt.msNow||Wt.oNow||Wt.webkitNow||function(){return(new Date).getTime()};function Ut(t){var n=Gt.call(Wt)*.001;var e=Math.floor(n);var s=Math.floor(n%1*1e9);if(t){e=e-t[0];s=s-t[1];if(s<0){e--;s+=1e9}}return[e,s]}var Ht=new Date;function jt(){var t=new Date;var n=t-Ht;return n/1e3}var qt={nextTick:wt,title:$t,browser:kt,env:Ct,argv:Nt,version:Rt,versions:St,on:At,addListener:Ot,once:Ft,off:_t,removeListener:Mt,removeAllListeners:Dt,emit:Lt,binding:zt,cwd:Pt,chdir:Vt,umask:Bt,hrtime:Ut,platform:yt,release:Et,config:Tt,uptime:jt};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xt;function Kt(){if(Xt==null){let t;if(typeof window!=="undefined"){t=window}else if(typeof it!=="undefined"){t=it}else if(typeof qt!=="undefined"){t=qt}else if(typeof self!=="undefined"){t=self}else{throw new Error("Could not find a global object")}Xt=t}return Xt}function Jt(){const t=Kt();if(t._tfGlobals==null){t._tfGlobals=new Map}return t._tfGlobals}function Yt(t,n){const e=Jt();if(e.has(t)){return e.get(t)}else{const s=n();e.set(t,s);return e.get(t)}}const Zt="Abs";const Qt="Acos";const tn="Acosh";const nn="Add";const en="AddN";const sn="All";const on="Any";const rn="ArgMax";const cn="ArgMin";const an="Asin";const un="Asinh";const ln="Atan";const fn="Atanh";const hn="Atan2";const dn="AvgPool";const pn="AvgPoolGrad";const mn="AvgPool3D";const xn="AvgPool3DGrad";const bn="BatchMatMul";const gn="BatchToSpaceND";const wn="Bincount";const vn="BitwiseAnd";const $n="BroadcastTo";const yn="BroadcastArgs";const kn="Cast";const Cn="Ceil";const Nn="ClipByValue";const Rn="Complex";const Sn="ComplexAbs";const En="Concat";const Tn="Conv2D";const In="Conv2DBackpropFilter";const An="Conv2DBackpropInput";const On="Conv3D";const Fn="Conv3DBackpropFilterV2";const _n="Conv3DBackpropInputV2";const Mn="Cos";const Dn="Cosh";const Ln="Cumprod";const zn="Cumsum";const Pn="CropAndResize";const Vn="DenseBincount";const Bn="DepthToSpace";const Wn="DepthwiseConv2dNative";const Gn="DepthwiseConv2dNativeBackpropFilter";const Un="DepthwiseConv2dNativeBackpropInput";const Hn="Diag";const jn="Dilation2D";const qn="Dilation2DBackpropInput";const Xn="Dilation2DBackpropFilter";const Kn="Draw";const Jn="RealDiv";const Yn="Einsum";const Zn="Elu";const Qn="EluGrad";const te="Erf";const ne="Equal";const ee="Exp";const se="ExpandDims";const oe="Expm1";const re="FFT";const ie="Fill";const ce="FlipLeftRight";const ae="Floor";const ue="FloorDiv";const le="FusedBatchNorm";const fe="GatherV2";const he="GatherNd";const de="Greater";const pe="GreaterEqual";const me="Identity";const xe="IFFT";const be="Imag";const ge="IsFinite";const we="IsInf";const ve="IsNan";const $e="LeakyRelu";const ye="Less";const ke="LessEqual";const Ce="LinSpace";const Ne="Log";const Re="Log1p";const Se="LogicalAnd";const Ee="LogicalNot";const Te="LogicalOr";const Ie="LogSoftmax";const Ae="LRN";const Oe="LRNGrad";const Fe="Max";const _e="Maximum";const Me="MaxPool";const De="MaxPoolGrad";const Le="MaxPool3D";const ze="MaxPool3DGrad";const Pe="MaxPoolWithArgmax";const Ve="Mean";const Be="Min";const We="Minimum";const Ge="MirrorPad";const Ue="Mod";const He="Multinomial";const je="Multiply";const qe="Neg";const Xe="NotEqual";const Ke="NonMaxSuppressionV3";const Je="NonMaxSuppressionV4";const Ye="NonMaxSuppressionV5";const Ze="OnesLike";const Qe="OneHot";const ts="Pack";const ns="PadV2";const es="Pow";const ss="Prelu";const os="Prod";const rs="RaggedGather";const is="RaggedRange";const cs="RaggedTensorToTensor";const as="Range";const us="Real";const ls="Reciprocal";const fs="Relu";const hs="Reshape";const ds="ResizeNearestNeighbor";const ps="ResizeNearestNeighborGrad";const ms="ResizeBilinear";const xs="ResizeBilinearGrad";const bs="Relu6";const gs="Reverse";const ws="Round";const vs="Rsqrt";const $s="ScatterNd";const ys="TensorScatterUpdate";const ks="SearchSorted";const Cs="Select";const Ns="Selu";const Rs="Slice";const Ss="Sin";const Es="Sinh";const Ts="Sign";const Is="Sigmoid";const As="Softplus";const Os="Sqrt";const Fs="Sum";const _s="SpaceToBatchND";const Ms="SplitV";const Ds="Softmax";const Ls="SparseFillEmptyRows";const zs="SparseReshape";const Ps="SparseSegmentMean";const Vs="SparseSegmentSum";const Bs="SparseToDense";const Ws="SquaredDifference";const Gs="Square";const Us="StaticRegexReplace";const Hs="StridedSlice";const js="StringNGrams";const qs="StringSplit";const Xs="StringToHashBucketFast";const Ks="Sub";const Js="Tan";const Ys="Tanh";const Zs="Tile";const Qs="TopK";const to="Transform";const no="Transpose";const eo="Unique";const so="Unpack";const oo="UnsortedSegmentSum";const ro="ZerosLike";const io="Step";const co="FromPixels";const ao="RotateWithOffset";const uo="_FusedMatMul";const lo="FusedConv2D";const fo="FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ho(...t){if(!(st().getBool("IS_TEST")||st().getBool("PROD"))){console.warn(...t)}}function po(...t){if(!(st().getBool("IS_TEST")||st().getBool("PROD"))){console.log(...t)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=Yt("kernelRegistry",(()=>new Map));const xo=Yt("gradRegistry",(()=>new Map));function bo(t,n){const e=yo(t,n);return mo.get(e)}function go(t){return xo.get(t)}function wo(t){const n=mo.entries();const e=[];while(true){const{done:s,value:o}=n.next();if(s){break}const[r,i]=o;const[c]=r.split("_");if(c===t){e.push(i)}}return e}function vo(t){const{kernelName:n,backendName:e}=t;const s=yo(n,e);if(mo.has(s)){ho(`The kernel '${n}' for backend `+`'${e}' is already registered`)}mo.set(s,t)}function $o(t){const{kernelName:n}=t;if(xo.has(n)){if(st().getBool("DEBUG")){ho(`Overriding the gradient for '${n}'`)}}xo.set(n,t)}function yo(t,n){return`${n}_${t}`}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ko(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Co(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t["default"]:t}function No(t){if(t.__esModule)return t;var n=t.default;if(typeof n=="function"){var e=function t(){if(this instanceof t){return Reflect.construct(n,arguments,this.constructor)}return n.apply(this,arguments)};e.prototype=n.prototype}else e={};Object.defineProperty(e,"__esModule",{value:true});Object.keys(t).forEach((function(n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:true,get:function(){return t[n]}})}));return e}var Ro;var So;function Eo(){if(So)return Ro;So=1;Ro=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,n,e){this.low=t|0;this.high=n|0;this.unsigned=!!e}Object.defineProperty(n.prototype,"__isLong__",{value:true});function e(t){return(t&&t["__isLong__"])===true}n.isLong=e;var s={};var o={};function r(t,n){var e,r,i;if(n){t>>>=0;if(i=0<=t&&t<256){r=o[t];if(r)return r}e=c(t,(t|0)<0?-1:0,true);if(i)o[t]=e;return e}else{t|=0;if(i=-128<=t&&t<128){r=s[t];if(r)return r}e=c(t,t<0?-1:0,false);if(i)s[t]=e;return e}}n.fromInt=r;function i(t,n){if(isNaN(t))return n?g:b;if(n){if(t<0)return g;if(t>=p)return k}else{if(t<=-0x8000000000000000)return C;if(t+1>=m)return y}if(t<0)return i(-t,n).neg();return c(t%d|0,t/d|0,n)}n.fromNumber=i;function c(t,e,s){return new n(t,e,s)}n.fromBits=c;var a=Math.pow;function u(t,n,e){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return b;if(typeof n==="number"){e=n,n=false}else{n=!!n}e=e||10;if(e<2||36<e)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");else if(s===0){return u(t.substring(1),n,e).neg()}var o=i(a(e,8));var r=b;for(var c=0;c<t.length;c+=8){var l=Math.min(8,t.length-c),f=parseInt(t.substring(c,c+l),e);if(l<8){var h=i(a(e,l));r=r.mul(h).add(i(f))}else{r=r.mul(o);r=r.add(i(f))}}r.unsigned=n;return r}n.fromString=u;function l(t,n){if(typeof t==="number")return i(t,n);if(typeof t==="string")return u(t,n);return c(t.low,t.high,typeof n==="boolean"?n:t.unsigned)}n.fromValue=l;var f=1<<16;var h=1<<24;var d=f*f;var p=d*d;var m=p/2;var x=r(h);var b=r(0);n.ZERO=b;var g=r(0,true);n.UZERO=g;var w=r(1);n.ONE=w;var v=r(1,true);n.UONE=v;var $=r(-1);n.NEG_ONE=$;var y=c(4294967295|0,2147483647|0,false);n.MAX_VALUE=y;var k=c(4294967295|0,4294967295|0,true);n.MAX_UNSIGNED_VALUE=k;var C=c(0,2147483648|0,false);n.MIN_VALUE=C;var N=n.prototype;N.toInt=function t(){return this.unsigned?this.low>>>0:this.low};N.toNumber=function t(){if(this.unsigned)return(this.high>>>0)*d+(this.low>>>0);return this.high*d+(this.low>>>0)};N.toString=function t(n){n=n||10;if(n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(C)){var e=i(n),s=this.div(e),o=s.mul(e).sub(this);return s.toString(n)+o.toInt().toString(n)}else return"-"+this.neg().toString(n)}var r=i(a(n,6),this.unsigned),c=this;var u="";while(true){var l=c.div(r),f=c.sub(l.mul(r)).toInt()>>>0,h=f.toString(n);c=l;if(c.isZero())return h+u;else{while(h.length<6)h="0"+h;u=""+h+u}}};N.getHighBits=function t(){return this.high};N.getHighBitsUnsigned=function t(){return this.high>>>0};N.getLowBits=function t(){return this.low};N.getLowBitsUnsigned=function t(){return this.low>>>0};N.getNumBitsAbs=function t(){if(this.isNegative())return this.eq(C)?64:this.neg().getNumBitsAbs();var n=this.high!=0?this.high:this.low;for(var e=31;e>0;e--)if((n&1<<e)!=0)break;return this.high!=0?e+33:e+1};N.isZero=function t(){return this.high===0&&this.low===0};N.eqz=N.isZero;N.isNegative=function t(){return!this.unsigned&&this.high<0};N.isPositive=function t(){return this.unsigned||this.high>=0};N.isOdd=function t(){return(this.low&1)===1};N.isEven=function t(){return(this.low&1)===0};N.equals=function t(n){if(!e(n))n=l(n);if(this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1)return false;return this.high===n.high&&this.low===n.low};N.eq=N.equals;N.notEquals=function t(n){return!this.eq(n)};N.neq=N.notEquals;N.ne=N.notEquals;N.lessThan=function t(n){return this.comp(n)<0};N.lt=N.lessThan;N.lessThanOrEqual=function t(n){return this.comp(n)<=0};N.lte=N.lessThanOrEqual;N.le=N.lessThanOrEqual;N.greaterThan=function t(n){return this.comp(n)>0};N.gt=N.greaterThan;N.greaterThanOrEqual=function t(n){return this.comp(n)>=0};N.gte=N.greaterThanOrEqual;N.ge=N.greaterThanOrEqual;N.compare=function t(n){if(!e(n))n=l(n);if(this.eq(n))return 0;var s=this.isNegative(),o=n.isNegative();if(s&&!o)return-1;if(!s&&o)return 1;if(!this.unsigned)return this.sub(n).isNegative()?-1:1;return n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1};N.comp=N.compare;N.negate=function t(){if(!this.unsigned&&this.eq(C))return C;return this.not().add(w)};N.neg=N.negate;N.add=function t(n){if(!e(n))n=l(n);var s=this.high>>>16;var o=this.high&65535;var r=this.low>>>16;var i=this.low&65535;var a=n.high>>>16;var u=n.high&65535;var f=n.low>>>16;var h=n.low&65535;var d=0,p=0,m=0,x=0;x+=i+h;m+=x>>>16;x&=65535;m+=r+f;p+=m>>>16;m&=65535;p+=o+u;d+=p>>>16;p&=65535;d+=s+a;d&=65535;return c(m<<16|x,d<<16|p,this.unsigned)};N.subtract=function t(n){if(!e(n))n=l(n);return this.add(n.neg())};N.sub=N.subtract;N.multiply=function n(s){if(this.isZero())return b;if(!e(s))s=l(s);if(t){var o=t.mul(this.low,this.high,s.low,s.high);return c(o,t.get_high(),this.unsigned)}if(s.isZero())return b;if(this.eq(C))return s.isOdd()?C:b;if(s.eq(C))return this.isOdd()?C:b;if(this.isNegative()){if(s.isNegative())return this.neg().mul(s.neg());else return this.neg().mul(s).neg()}else if(s.isNegative())return this.mul(s.neg()).neg();if(this.lt(x)&&s.lt(x))return i(this.toNumber()*s.toNumber(),this.unsigned);var r=this.high>>>16;var a=this.high&65535;var u=this.low>>>16;var f=this.low&65535;var h=s.high>>>16;var d=s.high&65535;var p=s.low>>>16;var m=s.low&65535;var g=0,w=0,v=0,$=0;$+=f*m;v+=$>>>16;$&=65535;v+=u*m;w+=v>>>16;v&=65535;v+=f*p;w+=v>>>16;v&=65535;w+=a*m;g+=w>>>16;w&=65535;w+=u*p;g+=w>>>16;w&=65535;w+=f*d;g+=w>>>16;w&=65535;g+=r*m+a*p+u*d+f*h;g&=65535;return c(v<<16|$,g<<16|w,this.unsigned)};N.mul=N.multiply;N.divide=function n(s){if(!e(s))s=l(s);if(s.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&s.low===-1&&s.high===-1){return this}var o=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,s.low,s.high);return c(o,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?g:b;var r,u,f;if(!this.unsigned){if(this.eq(C)){if(s.eq(w)||s.eq($))return C;else if(s.eq(C))return w;else{var h=this.shr(1);r=h.div(s).shl(1);if(r.eq(b)){return s.isNegative()?w:$}else{u=this.sub(s.mul(r));f=r.add(u.div(s));return f}}}else if(s.eq(C))return this.unsigned?g:b;if(this.isNegative()){if(s.isNegative())return this.neg().div(s.neg());return this.neg().div(s).neg()}else if(s.isNegative())return this.div(s.neg()).neg();f=b}else{if(!s.unsigned)s=s.toUnsigned();if(s.gt(this))return g;if(s.gt(this.shru(1)))return v;f=g}u=this;while(u.gte(s)){r=Math.max(1,Math.floor(u.toNumber()/s.toNumber()));var d=Math.ceil(Math.log(r)/Math.LN2),p=d<=48?1:a(2,d-48),m=i(r),x=m.mul(s);while(x.isNegative()||x.gt(u)){r-=p;m=i(r,this.unsigned);x=m.mul(s)}if(m.isZero())m=w;f=f.add(m);u=u.sub(x)}return f};N.div=N.divide;N.modulo=function n(s){if(!e(s))s=l(s);if(t){var o=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,s.low,s.high);return c(o,t.get_high(),this.unsigned)}return this.sub(this.div(s).mul(s))};N.mod=N.modulo;N.rem=N.modulo;N.not=function t(){return c(~this.low,~this.high,this.unsigned)};N.and=function t(n){if(!e(n))n=l(n);return c(this.low&n.low,this.high&n.high,this.unsigned)};N.or=function t(n){if(!e(n))n=l(n);return c(this.low|n.low,this.high|n.high,this.unsigned)};N.xor=function t(n){if(!e(n))n=l(n);return c(this.low^n.low,this.high^n.high,this.unsigned)};N.shiftLeft=function t(n){if(e(n))n=n.toInt();if((n&=63)===0)return this;else if(n<32)return c(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned);else return c(0,this.low<<n-32,this.unsigned)};N.shl=N.shiftLeft;N.shiftRight=function t(n){if(e(n))n=n.toInt();if((n&=63)===0)return this;else if(n<32)return c(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned);else return c(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};N.shr=N.shiftRight;N.shiftRightUnsigned=function t(n){if(e(n))n=n.toInt();n&=63;if(n===0)return this;else{var s=this.high;if(n<32){var o=this.low;return c(o>>>n|s<<32-n,s>>>n,this.unsigned)}else if(n===32)return c(s,0,this.unsigned);else return c(s>>>n-32,0,this.unsigned)}};N.shru=N.shiftRightUnsigned;N.shr_u=N.shiftRightUnsigned;N.toSigned=function t(){if(!this.unsigned)return this;return c(this.low,this.high,false)};N.toUnsigned=function t(){if(this.unsigned)return this;return c(this.low,this.high,true)};N.toBytes=function t(n){return n?this.toBytesLE():this.toBytesBE()};N.toBytesLE=function t(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};N.toBytesBE=function t(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};n.fromBytes=function t(e,s,o){return o?n.fromBytesLE(e,s):n.fromBytesBE(e,s)};n.fromBytesLE=function t(e,s){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,s)};n.fromBytesBE=function t(e,s){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],s)};return Ro}var To=Eo();var Io=Co(To);var Ao=r({__proto__:null,default:Io},[To]);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=Io||Ao;function Fo(t){return Oo.fromString(t,true,16)}const _o=Fo("c3a5c85c97cb3127");const Mo=Fo("b492b66fbe98f273");const Do=Fo("9ae16a3b2f90404f");function Lo(t){return t.xor(t.shru(47))}function zo(t,n,e){const s=t.slice(n,n+e);return Oo.fromBytes(Array.from(s),true,true)}function Po(t,n){return zo(t,n,8)}function Vo(t,n){return zo(t,n,4)}function Bo(t,n){return n===0?t:t.shru(n).or(t.shl(64-n))}function Wo(t,n,e=Fo("9ddfea08eb382d69")){let s=t.xor(n).mul(e);s=s.xor(s.shru(47));let o=n.xor(s).mul(e);o=o.xor(o.shru(47));o=o.mul(e);return o}function Go(t,n,e,s,o,r){o=o.add(t);r=Bo(r.add(o).add(s),21);const i=o;o=o.add(n);o=o.add(e);r=r.add(Bo(o,44));return[o.add(s),r.add(i)]}function Uo(t,n,e,s){return Go(Po(t,n),Po(t,n+8),Po(t,n+16),Po(t,n+24),e,s)}function Ho(t,n=t.length){if(n>=8){const e=Do.add(n*2);const s=Po(t,0).add(Do);const o=Po(t,n-8);const r=Bo(o,37).mul(e).add(s);const i=Bo(s,25).add(o).mul(e);return Wo(r,i,e)}if(n>=4){const e=Do.add(n*2);const s=Vo(t,0);return Wo(s.shl(3).add(n),Vo(t,n-4),e)}if(n>0){const e=t[0];const s=t[n>>1];const o=t[n-1];const r=e+(s<<8);const i=n+(o<<2);return Lo(Do.mul(r).xor(_o.mul(i))).mul(Do)}return Do}function jo(t,n=t.length){const e=Do.add(n*2);const s=Po(t,0).mul(Mo);const o=Po(t,8);const r=Po(t,n-8).mul(e);const i=Po(t,n-16).mul(Do);return Wo(Bo(s.add(o),43).add(Bo(r,30)).add(i),s.add(Bo(o.add(Do),18)).add(r),e)}function qo(t,n=t.length){const e=Do.add(n*2);const s=Po(t,0).mul(Do);const o=Po(t,8);const r=Po(t,n-8).mul(e);const i=Po(t,n-16).mul(Do);const c=Bo(s.add(o),43).add(Bo(r,30)).add(i);const a=Wo(c,s.add(Bo(o.add(Do),18)).add(r),e);const u=Po(t,16).mul(e);const l=Po(t,24);const f=c.add(Po(t,n-32)).mul(e);const h=a.add(Po(t,n-24)).mul(e);return Wo(Bo(u.add(l),43).add(Bo(f,30)).add(h),u.add(Bo(l.add(s),18)).add(f),e)}function Xo(t,n=t.length){const e=Oo.fromNumber(81,true);if(n<=32){if(n<=16){return Ho(t,n)}else{return jo(t,n)}}else if(n<=64){return qo(t,n)}let s=e;let o=e.mul(Mo).add(113);let r=Lo(o.mul(Do).add(113)).mul(Do);let i=[Oo.UZERO,Oo.UZERO];let c=[Oo.UZERO,Oo.UZERO];s=s.mul(Do).add(Po(t,0));let a=0;const u=(n-1>>6)*64;const l=u+(n-1&63)-63;do{s=Bo(s.add(o).add(i[0]).add(Po(t,a+8)),37).mul(Mo);o=Bo(o.add(i[1]).add(Po(t,a+48)),42).mul(Mo);s=s.xor(c[1]);o=o.add(i[0]).add(Po(t,a+40));r=Bo(r.add(c[0]),33).mul(Mo);i=Uo(t,a,i[1].mul(Mo),s.add(c[0]));c=Uo(t,a+32,r.add(c[1]),o.add(Po(t,a+16)));[r,s]=[s,r];a+=64}while(a!==u);const f=Mo.add(r.and(255).shl(1));a=l;c[0]=c[0].add(n-1&63);i[0]=i[0].add(c[0]);c[0]=c[0].add(i[0]);s=Bo(s.add(o).add(i[0]).add(Po(t,a+8)),37).mul(f);o=Bo(o.add(i[1]).add(Po(t,a+48)),42).mul(f);s=s.xor(c[1].mul(9));o=o.add(i[0].mul(9).add(Po(t,a+40)));r=Bo(r.add(c[0]),33).mul(f);i=Uo(t,a,i[1].mul(f),s.add(c[0]));c=Uo(t,a+32,r.add(c[1]),o.add(Po(t,a+16)));[r,s]=[s,r];return Wo(Wo(i[0],c[0],f).add(Lo(o).mul(_o)).add(r),Wo(i[1],c[1],f).add(s),f)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(t,n){if(n==="string"){return Qo(t)}return Yo([t],n)}function Jo(t,n){return t instanceof Float32Array&&n==="float32"||t instanceof Int32Array&&n==="int32"||t instanceof Uint8Array&&n==="bool"}function Yo(t,n){if(n==="string"){throw new Error("Cannot convert a string[] to a TypedArray")}if(Array.isArray(t)){t=er(t)}if(st().getBool("DEBUG")){I(t,n)}if(Jo(t,n)){return t}if(n==null||n==="float32"||n==="complex64"){return new Float32Array(t)}else if(n==="int32"){return new Int32Array(t)}else if(n==="bool"){const n=new Uint8Array(t.length);for(let e=0;e<n.length;++e){if(Math.round(t[e])!==0){n[e]=1}}return n}else{throw new Error(`Unknown data type ${n}`)}}function Zo(){return st().platform.now()}function Qo(t,n="utf-8"){n=n||"utf-8";return st().platform.encode(t,n)}function tr(t,n="utf-8"){n=n||"utf-8";return st().platform.decode(t,n)}function nr(t){if(st().platform.isTypedArray!=null){return st().platform.isTypedArray(t)}else{return ko(t)}}function er(t,n=[],e=false){if(n==null){n=[]}if(typeof t==="boolean"||typeof t==="number"||typeof t==="string"||Y(t)||t==null||nr(t)&&e){n.push(t)}else if(Array.isArray(t)||nr(t)){for(let s=0;s<t.length;++s){er(t[s],n,e)}}else{let s=-1;for(const n of Object.keys(t)){if(/^([1-9]+[0-9]*|0)$/.test(n)){s=Math.max(s,Number(n))}}for(let o=0;o<=s;o++){er(t[o],n,e)}}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sr{constructor(t,n){this.backendTimer=t;this.logger=n;if(n==null){this.logger=new rr}}profileKernel(t,n,e){let s;const o=()=>{s=e()};let r;const i=Zo();if(this.backendTimer.timerAvailable()){r=this.backendTimer.time(o)}else{o();for(const t of s){t.dataSync()}r=Promise.resolve({kernelMs:Zo()-i})}if(st().getBool("CHECK_COMPUTATION_FOR_ERRORS")){for(let n=0;n<s.length;n++){const e=s[n];e.data().then((n=>{or(n,e.dtype,t)}))}}const c={kernelName:t,outputs:s,inputs:n,timeMs:r.then((t=>t.kernelMs)),extraInfo:r.then((t=>t.getExtraProfileInfo!=null?t.getExtraProfileInfo():""))};return c}logKernelProfile(t){const{kernelName:n,outputs:e,timeMs:s,inputs:o,extraInfo:r}=t;e.forEach((t=>{Promise.all([t.data(),s,r]).then((e=>{this.logger.logKernelProfile(n,t,e[0],e[1],o,e[2])}))}))}}function or(t,n,e){if(n!=="float32"){return false}for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s)){console.warn(`Found ${s} in the result of '${e}'`);return true}}return false}class rr{logKernelProfile(t,n,e,s,o,r){const i=typeof s==="number"?k(`${s}ms`,9):s["error"];const c=k(t,25);const a=n.rank;const u=n.size;const l=k(n.shape.toString(),14);let f="";for(const t in o){const e=o[t];if(e!=null){const s=e.shape||n.shape;const o=s.length;f+=`${t}: ${o}D ${o>0?s:""} `}}console.log(`%c${c}\t%c${i}\t%c${a}D ${l}\t%c${u}\t%c${f}\t%c${r}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ir(t,n,e){const s={};const o={};for(let t=0;t<n.length;t++){s[n[t].id]=true}for(let e=0;e<t.length;e++){const r=t[e];const i=r.inputs;for(const t in i){const e=i[t];let c=false;for(let t=0;t<n.length;t++){if(s[e.id]){r.outputs.forEach((t=>s[t.id]=true));c=true;o[r.id]=true;break}}if(c){break}}}const r={};r[e.id]=true;const i={};for(let n=t.length-1;n>=0;n--){const e=t[n];const s=e.inputs;for(let t=0;t<e.outputs.length;t++){if(r[e.outputs[t].id]){for(const t in s){r[s[t].id]=true;i[e.id]=true}break}}}const c=[];for(let n=0;n<t.length;n++){const e=t[n];if(o[e.id]&&i[e.id]){const t={};for(const n in e.inputs){const o=e.inputs[n];if(s[o.id]){t[n]=o}}const n=Object.assign({},e);n.inputs=t;n.outputs=e.outputs;c.push(n)}}return c}function cr(t,n,e,s){for(let o=n.length-1;o>=0;o--){const r=n[o];const i=[];r.outputs.forEach((n=>{const e=t[n.id];if(e!=null){i.push(e)}else{i.push(null)}}));if(r.gradient==null){throw new Error(`Cannot compute gradient: gradient function not found `+`for ${r.kernelName}.`)}const c=r.gradient(i);for(const n in r.inputs){if(!(n in c)){throw new Error(`Cannot backprop through input ${n}. `+`Available gradients found: ${Object.keys(c)}.`)}const o=e((()=>c[n]()));if(o.dtype!=="float32"){throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input `+`${n} must have 'float32' dtype, but has '${o.dtype}'`)}const i=r.inputs[n];if(!v(o.shape,i.shape)){throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input `+`'${n}' has shape '${o.shape}', which does not match `+`the shape of the input '${i.shape}'`)}if(t[i.id]==null){t[i.id]=o}else{const n=t[i.id];t[i.id]=s(n,o);n.dispose()}}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ar=20;const ur=3;const lr=7;function fr(t,n,e,s){const o=B(n);const r=hr(t,n,e,o);const i=n.length;const c=mr(t,n,e,o,r);const a=["Tensor"];if(s){a.push(`  dtype: ${e}`);a.push(`  rank: ${i}`);a.push(`  shape: [${n}]`);a.push(`  values:`)}a.push(c.map((t=>"    "+t)).join("\n"));return a.join("\n")}function hr(t,n,e,s){const o=w(n);const r=s[s.length-1];const i=new Array(r).fill(0);const c=n.length;const a=e==="complex64"?xr(t):t;if(c>1){for(let t=0;t<o/r;t++){const n=t*r;for(let t=0;t<r;t++){i[t]=Math.max(i[t],dr(a[n+t],0,e).length)}}}return i}function dr(t,n,e){let s;if(Array.isArray(t)){s=`${parseFloat(t[0].toFixed(lr))} + `+`${parseFloat(t[1].toFixed(lr))}j`}else if(M(t)){s=`'${t}'`}else if(e==="bool"){s=pr(t)}else{s=parseFloat(t.toFixed(lr)).toString()}return k(s,n)}function pr(t){return t===0?"false":"true"}function mr(t,n,e,s,o,r=true){const i=e==="complex64"?2:1;const c=n[0];const a=n.length;if(a===0){if(e==="complex64"){const n=xr(t);return[dr(n[0],0,e)]}if(e==="bool"){return[pr(t[0])]}return[t[0].toString()]}if(a===1){if(c>ar){const n=ur*i;let s=Array.from(t.slice(0,n));let r=Array.from(t.slice((c-ur)*i,c*i));if(e==="complex64"){s=xr(s);r=xr(r)}return["["+s.map(((t,n)=>dr(t,o[n],e))).join(", ")+", ..., "+r.map(((t,n)=>dr(t,o[c-ur+n],e))).join(", ")+"]"]}const n=e==="complex64"?xr(t):Array.from(t);return["["+n.map(((t,n)=>dr(t,o[n],e))).join(", ")+"]"]}const u=n.slice(1);const l=s.slice(1);const f=s[0]*i;const h=[];if(c>ar){for(let n=0;n<ur;n++){const s=n*f;const r=s+f;h.push(...mr(t.slice(s,r),u,e,l,o,false))}h.push("...");for(let n=c-ur;n<c;n++){const s=n*f;const r=s+f;h.push(...mr(t.slice(s,r),u,e,l,o,n===c-1))}}else{for(let n=0;n<c;n++){const s=n*f;const r=s+f;h.push(...mr(t.slice(s,r),u,e,l,o,n===c-1))}}const d=a===2?",":"";h[0]="["+(c>0?h[0]+d:"");for(let t=1;t<h.length-1;t++){h[t]=" "+h[t]+d}let p=",\n";for(let t=2;t<a;t++){p+="\n"}h[h.length-1]=" "+h[h.length-1]+"]"+(r?"":p);return h}function xr(t){const n=[];for(let e=0;e<t.length;e+=2){n.push([t[e],t[e+1]])}return n}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class br{constructor(t,n,e){this.dtype=n;this.shape=t.slice();this.size=w(t);if(e!=null){const t=e.length;x(t===this.size,(()=>`Length of values '${t}' does not match the size `+`inferred by the shape '${this.size}'.`))}if(n==="complex64"){throw new Error(`complex64 dtype TensorBuffers are not supported. Please create `+`a TensorBuffer for the real and imaginary parts separately and `+`call tf.complex(real, imag).`)}this.values=e||T(n,this.size);this.strides=B(t)}set(t,...n){if(n.length===0){n=[0]}x(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must `+`match the rank (${this.rank})`));const e=this.locToIndex(n);this.values[e]=t}get(...t){if(t.length===0){t=[0]}let n=0;for(const e of t){if(e<0||e>=this.shape[n]){const n=`Requested out of range element at ${t}. `+`  Buffer shape=${this.shape}`;throw new Error(n)}n++}let e=t[t.length-1];for(let n=0;n<t.length-1;++n){e+=this.strides[n]*t[n]}return this.values[e]}locToIndex(t){if(this.rank===0){return 0}else if(this.rank===1){return t[0]}let n=t[t.length-1];for(let e=0;e<t.length-1;++e){n+=this.strides[e]*t[e]}return n}indexToLoc(t){if(this.rank===0){return[]}else if(this.rank===1){return[t]}const n=new Array(this.shape.length);for(let e=0;e<n.length-1;++e){n[e]=Math.floor(t/this.strides[e]);t-=n[e]*this.strides[e]}n[n.length-1]=t;return n}get rank(){return this.shape.length}toTensor(){return gr().makeTensor(this.values,this.shape,this.dtype)}}let gr=null;let wr=null;function vr(t){gr=t}function $r(t){wr=t}class yr{constructor(t,n,e,s){this.kept=false;this.isDisposedInternal=false;this.shape=t.slice();this.dtype=n||"float32";this.size=w(t);this.strides=B(t);this.dataId=e;this.id=s;this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return wr.buffer(this.shape,this.dtype,t)}bufferSync(){return wr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return G(this.shape,t,this.dtype==="complex64")}arraySync(){return G(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=gr().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map((t=>tr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){this.throwIfDisposed();return gr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=gr().readSync(this.dataId);if(this.dtype==="string"){try{return t.map((t=>tr(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return t}async bytes(){this.throwIfDisposed();const t=await gr().read(this.dataId);if(this.dtype==="string"){return t}else{return new Uint8Array(t.buffer)}}dispose(){if(this.isDisposed){return}if(this.kerasMask){this.kerasMask.dispose()}gr().disposeTensor(this);this.isDisposedInternal=true}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed){throw new Error(`Tensor is disposed.`)}}print(t=false){return wr.print(this,t)}clone(){this.throwIfDisposed();return wr.clone(this)}toString(t=false){const n=this.dataSync();return fr(n,this.shape,this.dtype,t)}cast(t){this.throwIfDisposed();return wr.cast(this,t)}variable(t=true,n,e){this.throwIfDisposed();return gr().makeVariable(this,t,n,e)}}Object.defineProperty(yr,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function kr(){return Yt("Tensor",(()=>yr))}kr();class Cr extends yr{constructor(t,n,e,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=n;this.name=e}assign(t){if(t.dtype!==this.dtype){throw new Error(`dtype of the new value (${t.dtype}) and `+`previous value (${this.dtype}) must match`)}if(!v(t.shape,this.shape)){throw new Error(`shape of the new value (${t.shape}) and `+`previous value (${this.shape}) must match`)}gr().disposeTensor(this);this.dataId=t.dataId;gr().incRef(this,null)}dispose(){gr().disposeVariable(this);this.isDisposedInternal=true}}Object.defineProperty(Cr,Symbol.hasInstance,{value:t=>t instanceof yr&&t.assign!=null&&t.assign instanceof Function});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Nr;(function(t){t["R0"]="R0";t["R1"]="R1";t["R2"]="R2";t["R3"]="R3";t["R4"]="R4";t["R5"]="R5";t["R6"]="R6"})(Nr||(Nr={}));var Rr;(function(t){t["float32"]="float32";t["int32"]="int32";t["bool"]="int32";t["complex64"]="complex64"})(Rr||(Rr={}));var Sr;(function(t){t["float32"]="float32";t["int32"]="int32";t["bool"]="bool";t["complex64"]="complex64"})(Sr||(Sr={}));var Er;(function(t){t["float32"]="float32";t["int32"]="float32";t["bool"]="float32";t["complex64"]="complex64"})(Er||(Er={}));var Tr;(function(t){t["float32"]="complex64";t["int32"]="complex64";t["bool"]="complex64";t["complex64"]="complex64"})(Tr||(Tr={}));const Ir={float32:Er,int32:Rr,bool:Sr,complex64:Tr};function Ar(t,n){if(t==="string"||n==="string"){if(t==="string"&&n==="string"){return"string"}throw new Error(`Can not upcast ${t} with ${n}`)}return Ir[t][n]}function Or(t){return Ar(t,"int32")}function Fr(t){return t!=null&&typeof t==="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function _r(t){return typeof GPUBuffer!=="undefined"&&t!=null&&typeof t==="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(t,n){if(t.dtype===n.dtype){return[t,n]}const e=Ar(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function Dr(t){const n=[];const e=new Set;Lr(t,n,e);return n}function Lr(t,n,e){if(t==null){return}if(t instanceof yr){n.push(t);return}if(!zr(t)){return}const s=t;for(const t in s){const o=s[t];if(!e.has(o)){e.add(o);Lr(o,n,e)}}}function zr(t){return Array.isArray(t)||typeof t==="object"}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(t){return t.kernelName!=null}class Vr{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=false;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables){this.registeredVariables[t].dispose()}}}class Br{constructor(t){this.ENV=t;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new Vr}async ready(){if(this.pendingBackendInit!=null){return this.pendingBackendInit.then((()=>{}))}if(this.backendInstance!=null){return}const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n];const s=await this.initializeBackend(e).success;if(s){await this.setBackend(e);return}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}get backend(){if(this.pendingBackendInit!=null){throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make `+`sure to await tf.ready() or await tf.setBackend() before calling `+`other methods`)}if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n){throw new Error(`The highest priority backend '${t}' has not yet been `+`initialized. Make sure to await tf.ready() or `+`await tf.setBackend() before calling other methods`)}this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n){return null}}else{return null}}return this.registry[t]}findBackendFactory(t){if(!(t in this.registryFactory)){return null}return this.registryFactory[t].factory}registerBackend(t,n,e=1){if(t in this.registryFactory){ho(`${t} backend was already registered. `+`Reusing existing backend factory.`);return false}this.registryFactory[t]={factory:n,priority:e};return true}async setBackend(t){if(this.registryFactory[t]==null){throw new Error(`Backend name '${t}' not found in registry`)}this.backendName=t;if(this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:e}=this.initializeBackend(t);const s=e?await n:n;if(!s){return false}}this.backendInstance=this.registry[t];this.setupRegisteredKernels();this.profiler=new sr(this.backendInstance);return true}setupRegisteredKernels(){const t=wo(this.backendName);t.forEach((t=>{if(t.setupFunc!=null){t.setupFunc(this.backendInstance)}}))}disposeRegisteredKernels(t){const n=wo(t);n.forEach((n=>{if(n.disposeFunc!=null){n.disposeFunc(this.registry[t])}}))}initializeBackend(t){const n=this.registryFactory[t];if(n==null){throw new Error(`Cannot initialize backend ${t}, no registration found.`)}try{const e=n.factory();if(e&&!(e instanceof u)&&typeof e.then==="function"){const n=++this.pendingBackendInitId;const s=e.then((e=>{if(n<this.pendingBackendInitId){return false}this.registry[t]=e;this.pendingBackendInit=null;return true})).catch((e=>{if(n<this.pendingBackendInitId){return false}this.pendingBackendInit=null;ho(`Initialization of backend ${t} failed`);ho(e.stack||e.message);return false}));this.pendingBackendInit=s;return{success:s,asyncInit:true}}else{this.registry[t]=e;return{success:true,asyncInit:false}}}catch(n){ho(`Initialization of backend ${t} failed`);ho(n.stack||n.message);return{success:false,asyncInit:false}}}removeBackend(t){if(!(t in this.registryFactory)){throw new Error(`${t} backend not found in registry`)}if(this.backendName===t&&this.pendingBackendInit!=null){this.pendingBackendInitId++}if(t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}delete this.registryFactory[t];if(this.backendName===t){this.pendingBackendInit=null;this.backendName=null;this.backendInstance=null}}getSortedBackends(){if(Object.keys(this.registryFactory).length===0){throw new Error("No backend found in registry.")}return Object.keys(this.registryFactory).sort(((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n];const{success:s,asyncInit:o}=this.initializeBackend(e);if(o||s){return{name:e,asyncInit:o}}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}moveData(t,n){const e=this.state.tensorInfo.get(n);const s=e.backend;const o=this.readSync(n);const r=s.refCount(n);s.disposeData(n,true);e.backend=t;t.move(n,o,e.shape,e.dtype,r);if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}}tidy(t,n){let e=null;if(n==null){if(typeof t!=="function"){throw new Error("Please provide a function to tidy()")}n=t}else{if(typeof t!=="string"&&!(t instanceof String)){throw new Error("When calling with two arguments, the first argument "+"to tidy() must be a string")}if(typeof n!=="function"){throw new Error("When calling with two arguments, the 2nd argument "+"to tidy() must be a function")}e=t}let s;return this.scopedRun((()=>this.startScope(e)),(()=>this.endScope(s)),(()=>{s=n();if(s instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}return s}))}scopedRun(t,n,e){t();try{const t=e();n();return t}catch(t){n();throw t}}nextTensorId(){return Br.nextTensorId++}nextVariableId(){return Br.nextVariableId++}clone(t){const n=Ur.runKernel(me,{x:t});const e={x:t};const s=t=>({x:()=>{const n="float32";const e={x:t};const s={dtype:n};return Ur.runKernel(kn,e,s)}});const o=[];this.addTapeNode(this.state.activeScope.name,e,[n],s,o,{});return n}runKernel(t,n,e){const s=bo(t,this.backendName)!=null;if(!s){throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`)}return this.runKernelFunc({kernelName:t,inputs:n,attrs:e})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,e){const s=this.backend.numDataIds();let o=0;e.forEach((t=>{o+=t.dtype==="complex64"?3:1}));const r=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];const i=s-n-o-r;if(i>0){throw new Error(`Backend '${this.backendName}' has an internal memory leak `+`(${i} data ids) after running '${t}'`)}}runKernelFunc(t){let n;let e=[];const s=this.isTapeOn();const o=this.state.numBytes;const r=this.state.numTensors;if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack.push(0)}let i;let c;const a=Pr(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Pr(t)){const{kernelName:n,inputs:o,attrs:r}=t;const a=bo(n,this.backendName);x(a!=null,(()=>`Cannot find registered kernel '${n}' for backend '${this.backendName}'`));i=()=>{const t=this.backend.numDataIds();c=a.kernelFunc({inputs:o,attrs:r,backend:this.backend});const i=Array.isArray(c)?c:[c];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(n,t,i)}const u=i.map((t=>{if(t.rank!=null){return t}return this.makeTensorFromTensorInfo(t)}));if(s){const t=this.getTensorsForGradient(n,o,u);e=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:n}=t;const o=t=>{if(!s){return}e=t.map((t=>this.keep(this.clone(t))))};i=()=>{const t=this.backend.numDataIds();c=this.tidy((()=>n(this.backend,o)));const e=Array.isArray(c)?c:[c];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(a,t,e)}return e}}const{inputs:u,attrs:l}=t;const f=Pr(t)?null:t.backwardsFunc;let h;this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{if(!this.ENV.getBool("DEBUG")&&!this.state.profiling){n=i()}else{h=this.profiler.profileKernel(a,u,(()=>i()));if(this.ENV.getBool("DEBUG")){this.profiler.logKernelProfile(h)}n=h.outputs}}));if(s){this.addTapeNode(a,u,n,f,e,l)}if(this.state.profiling){this.state.activeProfile.kernels.push({name:a,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-r,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>u[t]!=null?u[t].shape:null)),outputShapes:n.map((t=>t.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo})}return Array.isArray(c)?n:n[0]}saveTensorsForBackwardMode(t){const n=t.map((t=>this.keep(this.clone(t))));return n}getTensorsForGradient(t,n,e){const s=go(t);if(s!=null){const t=s.inputsToSave||[];const o=s.outputsToSave||[];let r;if(s.saveAllInputs){x(Array.isArray(n),(()=>"saveAllInputs is true, expected inputs to be an array."));r=Object.keys(n).map((t=>n[t]))}else{r=t.map((t=>n[t]))}const i=e.filter(((t,n)=>o[n]));return r.concat(i)}return[]}makeTensor(t,n,e,s){if(t==null){throw new Error("Values passed to engine.makeTensor() are null")}e=e||"float32";s=s||this.backend;let o=t;if(e==="string"&&M(t[0])){o=t.map((t=>Qo(t)))}const r=s.write(o,n,e);const i=new yr(n,e,r,this.nextTensorId());this.trackTensor(i,s);if(e==="string"){const t=this.state.tensorInfo.get(r);const n=_(o);this.state.numBytes+=n-t.bytes;t.bytes=n}return i}makeTensorFromDataId(t,n,e,s){e=e||"float32";const o={dataId:t,shape:n,dtype:e};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(t,n){const{dataId:e,shape:s,dtype:o}=t;const r=new yr(s,o,e,this.nextTensorId());this.trackTensor(r,n);return r}makeVariable(t,n=true,e,s){e=e||this.nextVariableId().toString();if(s!=null&&s!==t.dtype){t=t.cast(s)}const o=new Cr(t,n,e,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null){throw new Error(`Variable with name ${o.name} was already registered`)}this.state.registeredVariables[o.name]=o;this.incRef(o,this.backend);return o}trackTensor(t,n){this.state.numTensors++;if(t.dtype==="string"){this.state.numStringTensors++}let e=0;if(t.dtype!=="complex64"&&t.dtype!=="string"){e=t.size*F(t.dtype)}this.state.numBytes+=e;if(!this.state.tensorInfo.has(t.dataId)){this.state.numDataBuffers++;this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:e})}if(!(t instanceof Cr)){this.track(t)}}incRef(t,n){this.trackTensor(t,n);this.backend.incRef(t.dataId)}removeDataId(t,n){if(this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n){this.state.tensorInfo.delete(t);this.state.numDataBuffers--}}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId)){return}const n=this.state.tensorInfo.get(t.dataId);this.state.numTensors--;if(t.dtype==="string"){this.state.numStringTensors--;this.state.numBytes-=n.bytes}if(t.dtype!=="complex64"&&t.dtype!=="string"){const n=t.size*F(t.dtype);this.state.numBytes-=n}if(n.backend.disposeData(t.dataId)){this.removeDataId(t.dataId,n.backend)}}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t);if(this.state.registeredVariables[t.name]!=null){delete this.state.registeredVariables[t.name]}}memory(){const t=this.backend.memory();t.numTensors=this.state.numTensors;t.numDataBuffers=this.state.numDataBuffers;t.numBytes=this.state.numBytes;if(this.state.numStringTensors>0){t.unreliable=true;if(t.reasons==null){t.reasons=[]}t.reasons.push("Memory usage by string tensors is approximate "+"(2 bytes per character)")}return t}async profile(t){this.state.profiling=true;const n=this.state.numBytes;const e=this.state.numTensors;this.state.activeProfile.kernels=[];this.state.activeProfile.result=await t();this.state.profiling=false;this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot)));this.state.activeProfile.newBytes=this.state.numBytes-n;this.state.activeProfile.newTensors=this.state.numTensors-e;for(const t of this.state.activeProfile.kernels){t.kernelTimeMs=await t.kernelTimeMs;t.extraInfo=await t.extraInfo}return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,e,s,o,r){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:e,saved:o};const c=go(t);if(c!=null){s=c.gradFunc}if(s!=null){i.gradient=t=>{t=t.map(((t,n)=>{if(t==null){const t=e[n];const s=j(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}));return s(t.length>1?t:t[0],o,r)}}this.state.activeTape.push(i)}keep(t){t.kept=true;return t}startTape(){if(this.state.gradientDepth===0){this.state.activeTape=[]}this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};if(t){n.name=t}this.state.scopeStack.push(n);this.state.activeScope=n}endScope(t){const n=Dr(t);const e=new Set(n.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const n=this.state.activeScope.track[t];if(!n.kept&&!e.has(n.id)){n.dispose()}}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1];n.forEach((t=>{if(!t.kept&&t.scopeId===s.id){this.track(t)}}))}gradients(t,n,e,s=false){x(n.length>0,(()=>"gradients() received an empty list of xs."));if(e!=null&&e.dtype!=="float32"){throw new Error(`dy must have 'float32' dtype, but has '${e.dtype}'`)}const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));x(o instanceof yr,(()=>"The result y returned by f() must be a tensor."));const r=ir(this.state.activeTape,n,o);if(!s&&r.length===0&&n.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure "+"that the f you passed encloses all operations that lead from x "+"to y.")}return this.tidy("backward",(()=>{const t={};t[o.id]=e==null?Wr(o.shape):e;cr(t,r,(t=>this.tidy(t)),Hr);const s=n.map((n=>t[n.id]));if(this.state.gradientDepth===0){this.state.activeTape.forEach((t=>{for(const n of t.saved){n.dispose()}}));this.state.activeTape=null}return{value:o,grads:s}}))}customGrad(t){x(P(t),(()=>"The f passed in customGrad(f) must be a function."));return(...n)=>{x(n.every((t=>t instanceof yr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be "+"tensors"));let e;const s={};n.forEach(((t,n)=>{s[n]=t}));const o=(s,o)=>{e=t(...[...n,o]);x(e.value instanceof yr,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.value` is a tensor"));x(P(e.gradFunc),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function."));return e.value};const r=(t,s)=>{const o=e.gradFunc(t,s);const r=Array.isArray(o)?o:[o];x(r.length===n.length,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"the same number of tensors as inputs passed to f(...)."));x(r.every((t=>t instanceof yr)),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"a list of only tensors."));const i={};r.forEach(((t,n)=>{i[n]=()=>t}));return i};return this.runKernelFunc({forwardFunc:o,backwardsFunc:r,inputs:s})}}readSync(t){const n=this.state.tensorInfo.get(t);return n.backend.readSync(t)}read(t){const n=this.state.tensorInfo.get(t);return n.backend.read(t)}readToGPU(t,n){const e=this.state.tensorInfo.get(t);return e.backend.readToGPU(t,n)}async time(t){const n=Zo();const e=await this.backend.time(t);e.wallMs=Zo()-n;return e}track(t){if(this.state.activeScope!=null){t.scopeId=this.state.activeScope.id;this.state.activeScope.track.push(t)}return t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++;this.state.dispose();this.ENV.reset();this.state=new Vr;for(const t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}this.backendName=null;this.backendInstance=null;this.pendingBackendInit=null}}Br.nextTensorId=0;Br.nextVariableId=0;function Wr(t){const n=H(w(t),"float32");return Ur.makeTensor(n,t,"float32")}function Gr(){const t=Kt();if(t._tfengine==null){const n=new Q(t);t._tfengine=new Br(n)}rt(t._tfengine.ENV);vr((()=>t._tfengine));return t._tfengine}const Ur=Gr();function Hr(t,n){const e={a:t,b:n};return Ur.runKernel(nn,e)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(){return typeof navigator!=="undefined"&&navigator!=null}function qr(t){if(t||jr()){if(!t){t=navigator}if(t.product==="ReactNative"){return true}const n=t.userAgent||t.vendor||(typeof window!=="undefined"?window.opera:"");if(!n){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return false}function Xr(){return typeof window!=="undefined"&&window.document!=null||typeof WorkerGlobalScope!=="undefined"}const Kr=st();Kr.registerFlag("DEBUG",(()=>false),(t=>{if(t){console.warn("Debugging mode is ON. The output of every math call will "+"be downloaded to CPU and checked for NaNs. "+"This significantly impacts performance.")}}));Kr.registerFlag("IS_BROWSER",(()=>Xr()));Kr.registerFlag("IS_NODE",(()=>typeof qt!=="undefined"&&typeof qt.versions!=="undefined"&&typeof qt.versions.node!=="undefined"));Kr.registerFlag("IS_CHROME",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)));Kr.registerFlag("IS_SAFARI",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)));Kr.registerFlag("PROD",(()=>false));Kr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Kr.getBool("DEBUG")));Kr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>true));Kr.registerFlag("IS_TEST",(()=>false));Kr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Kr.getBool("DEBUG")));Kr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>false));Kr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>false));Kr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>false));var Jr=[];var Yr=[];var Zr=typeof Uint8Array!=="undefined"?Uint8Array:Array;var Qr=false;function ti(){Qr=true;var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var n=0,e=t.length;n<e;++n){Jr[n]=t[n];Yr[t.charCodeAt(n)]=n}Yr["-".charCodeAt(0)]=62;Yr["_".charCodeAt(0)]=63}function ni(t){if(!Qr){ti()}var n,e,s,o,r,i;var c=t.length;if(c%4>0){throw new Error("Invalid string. Length must be a multiple of 4")}r=t[c-2]==="="?2:t[c-1]==="="?1:0;i=new Zr(c*3/4-r);s=r>0?c-4:c;var a=0;for(n=0,e=0;n<s;n+=4,e+=3){o=Yr[t.charCodeAt(n)]<<18|Yr[t.charCodeAt(n+1)]<<12|Yr[t.charCodeAt(n+2)]<<6|Yr[t.charCodeAt(n+3)];i[a++]=o>>16&255;i[a++]=o>>8&255;i[a++]=o&255}if(r===2){o=Yr[t.charCodeAt(n)]<<2|Yr[t.charCodeAt(n+1)]>>4;i[a++]=o&255}else if(r===1){o=Yr[t.charCodeAt(n)]<<10|Yr[t.charCodeAt(n+1)]<<4|Yr[t.charCodeAt(n+2)]>>2;i[a++]=o>>8&255;i[a++]=o&255}return i}function ei(t){return Jr[t>>18&63]+Jr[t>>12&63]+Jr[t>>6&63]+Jr[t&63]}function si(t,n,e){var s;var o=[];for(var r=n;r<e;r+=3){s=(t[r]<<16)+(t[r+1]<<8)+t[r+2];o.push(ei(s))}return o.join("")}function oi(t){if(!Qr){ti()}var n;var e=t.length;var s=e%3;var o="";var r=[];var i=16383;for(var c=0,a=e-s;c<a;c+=i){r.push(si(t,c,c+i>a?a:c+i))}if(s===1){n=t[e-1];o+=Jr[n>>2];o+=Jr[n<<4&63];o+="=="}else if(s===2){n=(t[e-2]<<8)+t[e-1];o+=Jr[n>>10];o+=Jr[n>>4&63];o+=Jr[n<<2&63];o+="="}r.push(o);return r.join("")}function ri(t,n,e,s,o){var r,i;var c=o*8-s-1;var a=(1<<c)-1;var u=a>>1;var l=-7;var f=e?o-1:0;var h=e?-1:1;var d=t[n+f];f+=h;r=d&(1<<-l)-1;d>>=-l;l+=c;for(;l>0;r=r*256+t[n+f],f+=h,l-=8){}i=r&(1<<-l)-1;r>>=-l;l+=s;for(;l>0;i=i*256+t[n+f],f+=h,l-=8){}if(r===0){r=1-u}else if(r===a){return i?NaN:(d?-1:1)*Infinity}else{i=i+Math.pow(2,s);r=r-u}return(d?-1:1)*i*Math.pow(2,r-s)}function ii(t,n,e,s,o,r){var i,c,a;var u=r*8-o-1;var l=(1<<u)-1;var f=l>>1;var h=o===23?Math.pow(2,-24)-Math.pow(2,-77):0;var d=s?0:r-1;var p=s?1:-1;var m=n<0||n===0&&1/n<0?1:0;n=Math.abs(n);if(isNaN(n)||n===Infinity){c=isNaN(n)?1:0;i=l}else{i=Math.floor(Math.log(n)/Math.LN2);if(n*(a=Math.pow(2,-i))<1){i--;a*=2}if(i+f>=1){n+=h/a}else{n+=h*Math.pow(2,1-f)}if(n*a>=2){i++;a/=2}if(i+f>=l){c=0;i=l}else if(i+f>=1){c=(n*a-1)*Math.pow(2,o);i=i+f}else{c=n*Math.pow(2,f-1)*Math.pow(2,o);i=0}}for(;o>=8;t[e+d]=c&255,d+=p,c/=256,o-=8){}i=i<<o|c;u+=o;for(;u>0;t[e+d]=i&255,d+=p,i/=256,u-=8){}t[e+d-p]|=m*128}var ci={}.toString;var ai=Array.isArray||function(t){return ci.call(t)=="[object Array]"};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */var ui=50;hi.TYPED_ARRAY_SUPPORT=it.TYPED_ARRAY_SUPPORT!==undefined?it.TYPED_ARRAY_SUPPORT:true;function li(){return hi.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function fi(t,n){if(li()<n){throw new RangeError("Invalid typed array length")}if(hi.TYPED_ARRAY_SUPPORT){t=new Uint8Array(n);t.__proto__=hi.prototype}else{if(t===null){t=new hi(n)}t.length=n}return t}function hi(t,n,e){if(!hi.TYPED_ARRAY_SUPPORT&&!(this instanceof hi)){return new hi(t,n,e)}if(typeof t==="number"){if(typeof n==="string"){throw new Error("If encoding is specified then the first argument must be a string")}return xi(this,t)}return di(this,t,n,e)}hi.poolSize=8192;hi._augment=function(t){t.__proto__=hi.prototype;return t};function di(t,n,e,s){if(typeof n==="number"){throw new TypeError('"value" argument must not be a number')}if(typeof ArrayBuffer!=="undefined"&&n instanceof ArrayBuffer){return wi(t,n,e,s)}if(typeof n==="string"){return bi(t,n,e)}return vi(t,n)}hi.from=function(t,n,e){return di(null,t,n,e)};if(hi.TYPED_ARRAY_SUPPORT){hi.prototype.__proto__=Uint8Array.prototype;hi.__proto__=Uint8Array}function pi(t){if(typeof t!=="number"){throw new TypeError('"size" argument must be a number')}else if(t<0){throw new RangeError('"size" argument must not be negative')}}function mi(t,n,e,s){pi(n);if(n<=0){return fi(t,n)}if(e!==undefined){return typeof s==="string"?fi(t,n).fill(e,s):fi(t,n).fill(e)}return fi(t,n)}hi.alloc=function(t,n,e){return mi(null,t,n,e)};function xi(t,n){pi(n);t=fi(t,n<0?0:$i(n)|0);if(!hi.TYPED_ARRAY_SUPPORT){for(var e=0;e<n;++e){t[e]=0}}return t}hi.allocUnsafe=function(t){return xi(null,t)};hi.allocUnsafeSlow=function(t){return xi(null,t)};function bi(t,n,e){if(typeof e!=="string"||e===""){e="utf8"}if(!hi.isEncoding(e)){throw new TypeError('"encoding" must be a valid string encoding')}var s=ki(n,e)|0;t=fi(t,s);var o=t.write(n,e);if(o!==s){t=t.slice(0,o)}return t}function gi(t,n){var e=n.length<0?0:$i(n.length)|0;t=fi(t,e);for(var s=0;s<e;s+=1){t[s]=n[s]&255}return t}function wi(t,n,e,s){if(e<0||n.byteLength<e){throw new RangeError("'offset' is out of bounds")}if(n.byteLength<e+(s||0)){throw new RangeError("'length' is out of bounds")}if(e===undefined&&s===undefined){n=new Uint8Array(n)}else if(s===undefined){n=new Uint8Array(n,e)}else{n=new Uint8Array(n,e,s)}if(hi.TYPED_ARRAY_SUPPORT){t=n;t.__proto__=hi.prototype}else{t=gi(t,n)}return t}function vi(t,n){if(yi(n)){var e=$i(n.length)|0;t=fi(t,e);if(t.length===0){return t}n.copy(t,0,0,e);return t}if(n){if(typeof ArrayBuffer!=="undefined"&&n.buffer instanceof ArrayBuffer||"length"in n){if(typeof n.length!=="number"||oc(n.length)){return fi(t,0)}return gi(t,n)}if(n.type==="Buffer"&&ai(n.data)){return gi(t,n.data)}}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function $i(t){if(t>=li()){throw new RangeError("Attempt to allocate Buffer larger than maximum "+"size: 0x"+li().toString(16)+" bytes")}return t|0}hi.isBuffer=rc;function yi(t){return!!(t!=null&&t._isBuffer)}hi.compare=function t(n,e){if(!yi(n)||!yi(e)){throw new TypeError("Arguments must be Buffers")}if(n===e)return 0;var s=n.length;var o=e.length;for(var r=0,i=Math.min(s,o);r<i;++r){if(n[r]!==e[r]){s=n[r];o=e[r];break}}if(s<o)return-1;if(o<s)return 1;return 0};hi.isEncoding=function t(n){switch(String(n).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return true;default:return false}};hi.concat=function t(n,e){if(!ai(n)){throw new TypeError('"list" argument must be an Array of Buffers')}if(n.length===0){return hi.alloc(0)}var s;if(e===undefined){e=0;for(s=0;s<n.length;++s){e+=n[s].length}}var o=hi.allocUnsafe(e);var r=0;for(s=0;s<n.length;++s){var i=n[s];if(!yi(i)){throw new TypeError('"list" argument must be an Array of Buffers')}i.copy(o,r);r+=i.length}return o};function ki(t,n){if(yi(t)){return t.length}if(typeof ArrayBuffer!=="undefined"&&typeof ArrayBuffer.isView==="function"&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer)){return t.byteLength}if(typeof t!=="string"){t=""+t}var e=t.length;if(e===0)return 0;var s=false;for(;;){switch(n){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case undefined:return Qi(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return e*2;case"hex":return e>>>1;case"base64":return ec(t).length;default:if(s)return Qi(t).length;n=(""+n).toLowerCase();s=true}}}hi.byteLength=ki;function Ci(t,n,e){var s=false;if(n===undefined||n<0){n=0}if(n>this.length){return""}if(e===undefined||e>this.length){e=this.length}if(e<=0){return""}e>>>=0;n>>>=0;if(e<=n){return""}if(!t)t="utf8";while(true){switch(t){case"hex":return Vi(this,n,e);case"utf8":case"utf-8":return Mi(this,n,e);case"ascii":return zi(this,n,e);case"latin1":case"binary":return Pi(this,n,e);case"base64":return _i(this,n,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Bi(this,n,e);default:if(s)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase();s=true}}}hi.prototype._isBuffer=true;function Ni(t,n,e){var s=t[n];t[n]=t[e];t[e]=s}hi.prototype.swap16=function t(){var n=this.length;if(n%2!==0){throw new RangeError("Buffer size must be a multiple of 16-bits")}for(var e=0;e<n;e+=2){Ni(this,e,e+1)}return this};hi.prototype.swap32=function t(){var n=this.length;if(n%4!==0){throw new RangeError("Buffer size must be a multiple of 32-bits")}for(var e=0;e<n;e+=4){Ni(this,e,e+3);Ni(this,e+1,e+2)}return this};hi.prototype.swap64=function t(){var n=this.length;if(n%8!==0){throw new RangeError("Buffer size must be a multiple of 64-bits")}for(var e=0;e<n;e+=8){Ni(this,e,e+7);Ni(this,e+1,e+6);Ni(this,e+2,e+5);Ni(this,e+3,e+4)}return this};hi.prototype.toString=function t(){var n=this.length|0;if(n===0)return"";if(arguments.length===0)return Mi(this,0,n);return Ci.apply(this,arguments)};hi.prototype.equals=function t(n){if(!yi(n))throw new TypeError("Argument must be a Buffer");if(this===n)return true;return hi.compare(this,n)===0};hi.prototype.inspect=function t(){var n="";var e=ui;if(this.length>0){n=this.toString("hex",0,e).match(/.{2}/g).join(" ");if(this.length>e)n+=" ... "}return"<Buffer "+n+">"};hi.prototype.compare=function t(n,e,s,o,r){if(!yi(n)){throw new TypeError("Argument must be a Buffer")}if(e===undefined){e=0}if(s===undefined){s=n?n.length:0}if(o===undefined){o=0}if(r===undefined){r=this.length}if(e<0||s>n.length||o<0||r>this.length){throw new RangeError("out of range index")}if(o>=r&&e>=s){return 0}if(o>=r){return-1}if(e>=s){return 1}e>>>=0;s>>>=0;o>>>=0;r>>>=0;if(this===n)return 0;var i=r-o;var c=s-e;var a=Math.min(i,c);var u=this.slice(o,r);var l=n.slice(e,s);for(var f=0;f<a;++f){if(u[f]!==l[f]){i=u[f];c=l[f];break}}if(i<c)return-1;if(c<i)return 1;return 0};function Ri(t,n,e,s,o){if(t.length===0)return-1;if(typeof e==="string"){s=e;e=0}else if(e>2147483647){e=2147483647}else if(e<-2147483648){e=-2147483648}e=+e;if(isNaN(e)){e=o?0:t.length-1}if(e<0)e=t.length+e;if(e>=t.length){if(o)return-1;else e=t.length-1}else if(e<0){if(o)e=0;else return-1}if(typeof n==="string"){n=hi.from(n,s)}if(yi(n)){if(n.length===0){return-1}return Si(t,n,e,s,o)}else if(typeof n==="number"){n=n&255;if(hi.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf==="function"){if(o){return Uint8Array.prototype.indexOf.call(t,n,e)}else{return Uint8Array.prototype.lastIndexOf.call(t,n,e)}}return Si(t,[n],e,s,o)}throw new TypeError("val must be string, number or Buffer")}function Si(t,n,e,s,o){var r=1;var i=t.length;var c=n.length;if(s!==undefined){s=String(s).toLowerCase();if(s==="ucs2"||s==="ucs-2"||s==="utf16le"||s==="utf-16le"){if(t.length<2||n.length<2){return-1}r=2;i/=2;c/=2;e/=2}}function a(t,n){if(r===1){return t[n]}else{return t.readUInt16BE(n*r)}}var u;if(o){var l=-1;for(u=e;u<i;u++){if(a(t,u)===a(n,l===-1?0:u-l)){if(l===-1)l=u;if(u-l+1===c)return l*r}else{if(l!==-1)u-=u-l;l=-1}}}else{if(e+c>i)e=i-c;for(u=e;u>=0;u--){var f=true;for(var h=0;h<c;h++){if(a(t,u+h)!==a(n,h)){f=false;break}}if(f)return u}}return-1}hi.prototype.includes=function t(n,e,s){return this.indexOf(n,e,s)!==-1};hi.prototype.indexOf=function t(n,e,s){return Ri(this,n,e,s,true)};hi.prototype.lastIndexOf=function t(n,e,s){return Ri(this,n,e,s,false)};function Ei(t,n,e,s){e=Number(e)||0;var o=t.length-e;if(!s){s=o}else{s=Number(s);if(s>o){s=o}}var r=n.length;if(r%2!==0)throw new TypeError("Invalid hex string");if(s>r/2){s=r/2}for(var i=0;i<s;++i){var c=parseInt(n.substr(i*2,2),16);if(isNaN(c))return i;t[e+i]=c}return i}function Ti(t,n,e,s){return sc(Qi(n,t.length-e),t,e,s)}function Ii(t,n,e,s){return sc(tc(n),t,e,s)}function Ai(t,n,e,s){return Ii(t,n,e,s)}function Oi(t,n,e,s){return sc(ec(n),t,e,s)}function Fi(t,n,e,s){return sc(nc(n,t.length-e),t,e,s)}hi.prototype.write=function t(n,e,s,o){if(e===undefined){o="utf8";s=this.length;e=0}else if(s===undefined&&typeof e==="string"){o=e;s=this.length;e=0}else if(isFinite(e)){e=e|0;if(isFinite(s)){s=s|0;if(o===undefined)o="utf8"}else{o=s;s=undefined}}else{throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported")}var r=this.length-e;if(s===undefined||s>r)s=r;if(n.length>0&&(s<0||e<0)||e>this.length){throw new RangeError("Attempt to write outside buffer bounds")}if(!o)o="utf8";var i=false;for(;;){switch(o){case"hex":return Ei(this,n,e,s);case"utf8":case"utf-8":return Ti(this,n,e,s);case"ascii":return Ii(this,n,e,s);case"latin1":case"binary":return Ai(this,n,e,s);case"base64":return Oi(this,n,e,s);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Fi(this,n,e,s);default:if(i)throw new TypeError("Unknown encoding: "+o);o=(""+o).toLowerCase();i=true}}};hi.prototype.toJSON=function t(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function _i(t,n,e){if(n===0&&e===t.length){return oi(t)}else{return oi(t.slice(n,e))}}function Mi(t,n,e){e=Math.min(t.length,e);var s=[];var o=n;while(o<e){var r=t[o];var i=null;var c=r>239?4:r>223?3:r>191?2:1;if(o+c<=e){var a,u,l,f;switch(c){case 1:if(r<128){i=r}break;case 2:a=t[o+1];if((a&192)===128){f=(r&31)<<6|a&63;if(f>127){i=f}}break;case 3:a=t[o+1];u=t[o+2];if((a&192)===128&&(u&192)===128){f=(r&15)<<12|(a&63)<<6|u&63;if(f>2047&&(f<55296||f>57343)){i=f}}break;case 4:a=t[o+1];u=t[o+2];l=t[o+3];if((a&192)===128&&(u&192)===128&&(l&192)===128){f=(r&15)<<18|(a&63)<<12|(u&63)<<6|l&63;if(f>65535&&f<1114112){i=f}}}}if(i===null){i=65533;c=1}else if(i>65535){i-=65536;s.push(i>>>10&1023|55296);i=56320|i&1023}s.push(i);o+=c}return Li(s)}var Di=4096;function Li(t){var n=t.length;if(n<=Di){return String.fromCharCode.apply(String,t)}var e="";var s=0;while(s<n){e+=String.fromCharCode.apply(String,t.slice(s,s+=Di))}return e}function zi(t,n,e){var s="";e=Math.min(t.length,e);for(var o=n;o<e;++o){s+=String.fromCharCode(t[o]&127)}return s}function Pi(t,n,e){var s="";e=Math.min(t.length,e);for(var o=n;o<e;++o){s+=String.fromCharCode(t[o])}return s}function Vi(t,n,e){var s=t.length;if(!n||n<0)n=0;if(!e||e<0||e>s)e=s;var o="";for(var r=n;r<e;++r){o+=Zi(t[r])}return o}function Bi(t,n,e){var s=t.slice(n,e);var o="";for(var r=0;r<s.length;r+=2){o+=String.fromCharCode(s[r]+s[r+1]*256)}return o}hi.prototype.slice=function t(n,e){var s=this.length;n=~~n;e=e===undefined?s:~~e;if(n<0){n+=s;if(n<0)n=0}else if(n>s){n=s}if(e<0){e+=s;if(e<0)e=0}else if(e>s){e=s}if(e<n)e=n;var o;if(hi.TYPED_ARRAY_SUPPORT){o=this.subarray(n,e);o.__proto__=hi.prototype}else{var r=e-n;o=new hi(r,undefined);for(var i=0;i<r;++i){o[i]=this[i+n]}}return o};function Wi(t,n,e){if(t%1!==0||t<0)throw new RangeError("offset is not uint");if(t+n>e)throw new RangeError("Trying to access beyond buffer length")}hi.prototype.readUIntLE=function t(n,e,s){n=n|0;e=e|0;if(!s)Wi(n,e,this.length);var o=this[n];var r=1;var i=0;while(++i<e&&(r*=256)){o+=this[n+i]*r}return o};hi.prototype.readUIntBE=function t(n,e,s){n=n|0;e=e|0;if(!s){Wi(n,e,this.length)}var o=this[n+--e];var r=1;while(e>0&&(r*=256)){o+=this[n+--e]*r}return o};hi.prototype.readUInt8=function t(n,e){if(!e)Wi(n,1,this.length);return this[n]};hi.prototype.readUInt16LE=function t(n,e){if(!e)Wi(n,2,this.length);return this[n]|this[n+1]<<8};hi.prototype.readUInt16BE=function t(n,e){if(!e)Wi(n,2,this.length);return this[n]<<8|this[n+1]};hi.prototype.readUInt32LE=function t(n,e){if(!e)Wi(n,4,this.length);return(this[n]|this[n+1]<<8|this[n+2]<<16)+this[n+3]*16777216};hi.prototype.readUInt32BE=function t(n,e){if(!e)Wi(n,4,this.length);return this[n]*16777216+(this[n+1]<<16|this[n+2]<<8|this[n+3])};hi.prototype.readIntLE=function t(n,e,s){n=n|0;e=e|0;if(!s)Wi(n,e,this.length);var o=this[n];var r=1;var i=0;while(++i<e&&(r*=256)){o+=this[n+i]*r}r*=128;if(o>=r)o-=Math.pow(2,8*e);return o};hi.prototype.readIntBE=function t(n,e,s){n=n|0;e=e|0;if(!s)Wi(n,e,this.length);var o=e;var r=1;var i=this[n+--o];while(o>0&&(r*=256)){i+=this[n+--o]*r}r*=128;if(i>=r)i-=Math.pow(2,8*e);return i};hi.prototype.readInt8=function t(n,e){if(!e)Wi(n,1,this.length);if(!(this[n]&128))return this[n];return(255-this[n]+1)*-1};hi.prototype.readInt16LE=function t(n,e){if(!e)Wi(n,2,this.length);var s=this[n]|this[n+1]<<8;return s&32768?s|4294901760:s};hi.prototype.readInt16BE=function t(n,e){if(!e)Wi(n,2,this.length);var s=this[n+1]|this[n]<<8;return s&32768?s|4294901760:s};hi.prototype.readInt32LE=function t(n,e){if(!e)Wi(n,4,this.length);return this[n]|this[n+1]<<8|this[n+2]<<16|this[n+3]<<24};hi.prototype.readInt32BE=function t(n,e){if(!e)Wi(n,4,this.length);return this[n]<<24|this[n+1]<<16|this[n+2]<<8|this[n+3]};hi.prototype.readFloatLE=function t(n,e){if(!e)Wi(n,4,this.length);return ri(this,n,true,23,4)};hi.prototype.readFloatBE=function t(n,e){if(!e)Wi(n,4,this.length);return ri(this,n,false,23,4)};hi.prototype.readDoubleLE=function t(n,e){if(!e)Wi(n,8,this.length);return ri(this,n,true,52,8)};hi.prototype.readDoubleBE=function t(n,e){if(!e)Wi(n,8,this.length);return ri(this,n,false,52,8)};function Gi(t,n,e,s,o,r){if(!yi(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>o||n<r)throw new RangeError('"value" argument is out of bounds');if(e+s>t.length)throw new RangeError("Index out of range")}hi.prototype.writeUIntLE=function t(n,e,s,o){n=+n;e=e|0;s=s|0;if(!o){var r=Math.pow(2,8*s)-1;Gi(this,n,e,s,r,0)}var i=1;var c=0;this[e]=n&255;while(++c<s&&(i*=256)){this[e+c]=n/i&255}return e+s};hi.prototype.writeUIntBE=function t(n,e,s,o){n=+n;e=e|0;s=s|0;if(!o){var r=Math.pow(2,8*s)-1;Gi(this,n,e,s,r,0)}var i=s-1;var c=1;this[e+i]=n&255;while(--i>=0&&(c*=256)){this[e+i]=n/c&255}return e+s};hi.prototype.writeUInt8=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,1,255,0);if(!hi.TYPED_ARRAY_SUPPORT)n=Math.floor(n);this[e]=n&255;return e+1};function Ui(t,n,e,s){if(n<0)n=65535+n+1;for(var o=0,r=Math.min(t.length-e,2);o<r;++o){t[e+o]=(n&255<<8*(s?o:1-o))>>>(s?o:1-o)*8}}hi.prototype.writeUInt16LE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,2,65535,0);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n&255;this[e+1]=n>>>8}else{Ui(this,n,e,true)}return e+2};hi.prototype.writeUInt16BE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,2,65535,0);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n>>>8;this[e+1]=n&255}else{Ui(this,n,e,false)}return e+2};function Hi(t,n,e,s){if(n<0)n=4294967295+n+1;for(var o=0,r=Math.min(t.length-e,4);o<r;++o){t[e+o]=n>>>(s?o:3-o)*8&255}}hi.prototype.writeUInt32LE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,4,4294967295,0);if(hi.TYPED_ARRAY_SUPPORT){this[e+3]=n>>>24;this[e+2]=n>>>16;this[e+1]=n>>>8;this[e]=n&255}else{Hi(this,n,e,true)}return e+4};hi.prototype.writeUInt32BE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,4,4294967295,0);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n>>>24;this[e+1]=n>>>16;this[e+2]=n>>>8;this[e+3]=n&255}else{Hi(this,n,e,false)}return e+4};hi.prototype.writeIntLE=function t(n,e,s,o){n=+n;e=e|0;if(!o){var r=Math.pow(2,8*s-1);Gi(this,n,e,s,r-1,-r)}var i=0;var c=1;var a=0;this[e]=n&255;while(++i<s&&(c*=256)){if(n<0&&a===0&&this[e+i-1]!==0){a=1}this[e+i]=(n/c>>0)-a&255}return e+s};hi.prototype.writeIntBE=function t(n,e,s,o){n=+n;e=e|0;if(!o){var r=Math.pow(2,8*s-1);Gi(this,n,e,s,r-1,-r)}var i=s-1;var c=1;var a=0;this[e+i]=n&255;while(--i>=0&&(c*=256)){if(n<0&&a===0&&this[e+i+1]!==0){a=1}this[e+i]=(n/c>>0)-a&255}return e+s};hi.prototype.writeInt8=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,1,127,-128);if(!hi.TYPED_ARRAY_SUPPORT)n=Math.floor(n);if(n<0)n=255+n+1;this[e]=n&255;return e+1};hi.prototype.writeInt16LE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,2,32767,-32768);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n&255;this[e+1]=n>>>8}else{Ui(this,n,e,true)}return e+2};hi.prototype.writeInt16BE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,2,32767,-32768);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n>>>8;this[e+1]=n&255}else{Ui(this,n,e,false)}return e+2};hi.prototype.writeInt32LE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,4,2147483647,-2147483648);if(hi.TYPED_ARRAY_SUPPORT){this[e]=n&255;this[e+1]=n>>>8;this[e+2]=n>>>16;this[e+3]=n>>>24}else{Hi(this,n,e,true)}return e+4};hi.prototype.writeInt32BE=function t(n,e,s){n=+n;e=e|0;if(!s)Gi(this,n,e,4,2147483647,-2147483648);if(n<0)n=4294967295+n+1;if(hi.TYPED_ARRAY_SUPPORT){this[e]=n>>>24;this[e+1]=n>>>16;this[e+2]=n>>>8;this[e+3]=n&255}else{Hi(this,n,e,false)}return e+4};function ji(t,n,e,s,o,r){if(e+s>t.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function qi(t,n,e,s,o){if(!o){ji(t,n,e,4)}ii(t,n,e,s,23,4);return e+4}hi.prototype.writeFloatLE=function t(n,e,s){return qi(this,n,e,true,s)};hi.prototype.writeFloatBE=function t(n,e,s){return qi(this,n,e,false,s)};function Xi(t,n,e,s,o){if(!o){ji(t,n,e,8)}ii(t,n,e,s,52,8);return e+8}hi.prototype.writeDoubleLE=function t(n,e,s){return Xi(this,n,e,true,s)};hi.prototype.writeDoubleBE=function t(n,e,s){return Xi(this,n,e,false,s)};hi.prototype.copy=function t(n,e,s,o){if(!s)s=0;if(!o&&o!==0)o=this.length;if(e>=n.length)e=n.length;if(!e)e=0;if(o>0&&o<s)o=s;if(o===s)return 0;if(n.length===0||this.length===0)return 0;if(e<0){throw new RangeError("targetStart out of bounds")}if(s<0||s>=this.length)throw new RangeError("sourceStart out of bounds");if(o<0)throw new RangeError("sourceEnd out of bounds");if(o>this.length)o=this.length;if(n.length-e<o-s){o=n.length-e+s}var r=o-s;var i;if(this===n&&s<e&&e<o){for(i=r-1;i>=0;--i){n[i+e]=this[i+s]}}else if(r<1e3||!hi.TYPED_ARRAY_SUPPORT){for(i=0;i<r;++i){n[i+e]=this[i+s]}}else{Uint8Array.prototype.set.call(n,this.subarray(s,s+r),e)}return r};hi.prototype.fill=function t(n,e,s,o){if(typeof n==="string"){if(typeof e==="string"){o=e;e=0;s=this.length}else if(typeof s==="string"){o=s;s=this.length}if(n.length===1){var r=n.charCodeAt(0);if(r<256){n=r}}if(o!==undefined&&typeof o!=="string"){throw new TypeError("encoding must be a string")}if(typeof o==="string"&&!hi.isEncoding(o)){throw new TypeError("Unknown encoding: "+o)}}else if(typeof n==="number"){n=n&255}if(e<0||this.length<e||this.length<s){throw new RangeError("Out of range index")}if(s<=e){return this}e=e>>>0;s=s===undefined?this.length:s>>>0;if(!n)n=0;var i;if(typeof n==="number"){for(i=e;i<s;++i){this[i]=n}}else{var c=yi(n)?n:Qi(new hi(n,o).toString());var a=c.length;for(i=0;i<s-e;++i){this[i+e]=c[i%a]}}return this};var Ki=/[^+\/0-9A-Za-z-_]/g;function Ji(t){t=Yi(t).replace(Ki,"");if(t.length<2)return"";while(t.length%4!==0){t=t+"="}return t}function Yi(t){if(t.trim)return t.trim();return t.replace(/^\s+|\s+$/g,"")}function Zi(t){if(t<16)return"0"+t.toString(16);return t.toString(16)}function Qi(t,n){n=n||Infinity;var e;var s=t.length;var o=null;var r=[];for(var i=0;i<s;++i){e=t.charCodeAt(i);if(e>55295&&e<57344){if(!o){if(e>56319){if((n-=3)>-1)r.push(239,191,189);continue}else if(i+1===s){if((n-=3)>-1)r.push(239,191,189);continue}o=e;continue}if(e<56320){if((n-=3)>-1)r.push(239,191,189);o=e;continue}e=(o-55296<<10|e-56320)+65536}else if(o){if((n-=3)>-1)r.push(239,191,189)}o=null;if(e<128){if((n-=1)<0)break;r.push(e)}else if(e<2048){if((n-=2)<0)break;r.push(e>>6|192,e&63|128)}else if(e<65536){if((n-=3)<0)break;r.push(e>>12|224,e>>6&63|128,e&63|128)}else if(e<1114112){if((n-=4)<0)break;r.push(e>>18|240,e>>12&63|128,e>>6&63|128,e&63|128)}else{throw new Error("Invalid code point")}}return r}function tc(t){var n=[];for(var e=0;e<t.length;++e){n.push(t.charCodeAt(e)&255)}return n}function nc(t,n){var e,s,o;var r=[];for(var i=0;i<t.length;++i){if((n-=2)<0)break;e=t.charCodeAt(i);s=e>>8;o=e%256;r.push(o);r.push(s)}return r}function ec(t){return ni(Ji(t))}function sc(t,n,e,s){for(var o=0;o<s;++o){if(o+e>=n.length||o>=t.length)break;n[o+e]=t[o]}return o}function oc(t){return t!==t}function rc(t){return t!=null&&(!!t._isBuffer||ic(t)||cc(t))}function ic(t){return!!t.constructor&&typeof t.constructor.isBuffer==="function"&&t.constructor.isBuffer(t)}function cc(t){return typeof t.readFloatLE==="function"&&typeof t.slice==="function"&&ic(t.slice(0,0))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ac(t,n){let e=t;if(nr(t)){return n==="string"?[]:[t.length]}if(Fr(t)){const n=t.channels||"RGBA";return[t.height,t.width*n.length]}else if(_r(t)){return[t.buffer.size/(n==null?4:F(n))]}if(!Array.isArray(t)){return[]}const s=[];while(Array.isArray(e)||nr(e)&&n!=="string"){s.push(e.length);e=e[0]}if(Array.isArray(t)&&st().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")){uc(t,s,[])}return s}function uc(t,n,e){e=e||[];if(!Array.isArray(t)&&!nr(t)){x(n.length===0,(()=>`Element arr[${e.join("][")}] is a primitive, `+`but should be an array/TypedArray of ${n[0]} elements`));return}x(n.length>0,(()=>`Element arr[${e.join("][")}] should be a primitive, `+`but is an array of ${t.length} elements`));x(t.length===n[0],(()=>`Element arr[${e.join("][")}] should have ${n[0]} `+`elements, but has ${t.length} elements`));const s=n.slice(1);for(let n=0;n<t.length;++n){uc(t[n],s,e.concat(n))}}function lc(t,n,e,s){if(t==="string_or_numeric"){return}if(t==null){throw new Error(`Expected dtype cannot be null.`)}if(t!=="numeric"&&t!==n||t==="numeric"&&n==="string"){throw new Error(`Argument '${e}' passed to '${s}' must `+`be ${t} tensor, but got ${n} tensor`)}}function fc(t,n,e,s="numeric"){if(t instanceof kr()){lc(s,t.dtype,n,e);return t}let o=z(t);if(o!=="string"&&["bool","int32","float32"].indexOf(s)>=0){o=s}lc(s,o,n,e);if(t==null||!nr(t)&&!Array.isArray(t)&&typeof t!=="number"&&typeof t!=="boolean"&&typeof t!=="string"){const s=t==null?"null":t.constructor.name;throw new Error(`Argument '${n}' passed to '${e}' must be a `+`Tensor or TensorLike, but got '${s}'`)}const r=ac(t,o);if(!nr(t)&&!Array.isArray(t)){t=[t]}const i=true;const c=o!=="string"?Yo(t,o):er(t,[],i);return Ur.makeTensor(c,r,o)}function hc(t,n,e,s="numeric"){if(!Array.isArray(t)){throw new Error(`Argument ${n} passed to ${e} must be a `+"`Tensor[]` or `TensorLike[]`")}const o=t;return o.map(((t,o)=>fc(t,`${n}[${o}]`,e,s)))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dc="__op";function pc(t){const n=Object.keys(t);if(n.length!==1){throw new Error(`Please provide an object with a single key `+`(operation name) mapping to a function. Got an object with `+`${n.length} keys.`)}let e=n[0];const s=t[e];if(e.endsWith("_")){e=e.substring(0,e.length-1)}e=e+dc;const o=(...t)=>{Ur.startScope(e);try{const n=s(...t);if(Y(n)){console.error("Cannot return a Promise inside of tidy.")}Ur.endScope(n);return n}catch(t){Ur.endScope(null);throw t}};Object.defineProperty(o,"name",{value:e,configurable:true});return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mc(t,n){const e=fc(t,"real","complex");const s=fc(n,"imag","complex");b(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, `+`must match in call to tf.complex().`);const o={real:e,imag:s};return Ur.runKernel(Rn,o)}const xc=pc({complex_:mc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bc(t,n,e,s){if(s==null){s=z(t)}else if(s==="complex64"){throw new Error(`Cannot construct a complex64 tensor directly. `+`Please use tf.complex(real, imag).`)}if(_r(t)||Fr(t)){if(s!=="float32"&&s!=="int32"){throw new Error(`Creating tensor from GPU data only supports `+`'float32'|'int32' dtype, while the dtype is ${s}.`)}return Ur.backend.createTensorFromGPUData(t,n||e,s)}if(!nr(t)&&!Array.isArray(t)&&typeof t!=="number"&&typeof t!=="boolean"&&typeof t!=="string"){throw new Error("values passed to tensor(values) must be a number/boolean/string or "+"an array of numbers/booleans/strings, or a TypedArray")}if(n!=null){X(n);const t=w(n);const s=w(e);x(t===s,(()=>`Based on the provided shape, [${n}], the tensor should have `+`${t} values but has ${s}`));for(let t=0;t<e.length;++t){const s=e[t];const o=t===e.length-1?s!==w(n.slice(t)):true;x(e[t]===n[t]||!o,(()=>`Error creating a new Tensor. Inferred shape `+`(${e}) does not match the provided `+`shape (${n}). `))}}if(!nr(t)&&!Array.isArray(t)){t=[t]}n=n||e;t=s!=="string"?Yo(t,s):er(t,[],true);return Ur.makeTensor(t,n,s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(t,n,e){const s=ac(t,e);return bc(t,n,s,e)}class wc{static join(t){return new wc(t).slice()}constructor(t){this.shards=[];this.previousShardIndex=0;if(t==null){return}if(!(t instanceof Array)){t=[t]}t=t.map((t=>{if(nr(t)){return t.buffer}return t}));if(t.length===0){return}this.bufferUniformSize=t[0].byteLength;let n=0;for(let e=0;e<t.length;e++){const s=t[e];if(e!==t.length-1&&s.byteLength!==this.bufferUniformSize){this.bufferUniformSize=undefined}const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o});n=o}if(this.shards.length===0){this.byteLength=0}this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0){return new ArrayBuffer(0)}t=isNaN(Number(t))?0:t;n=isNaN(Number(n))?0:n;t=Math.max(0,t);n=Math.min(this.byteLength,n);if(n<=t){return new ArrayBuffer(0)}const e=this.findShardForByte(t);if(e===-1){throw new Error(`Could not find start shard for byte ${t}`)}const s=n-t;const o=new ArrayBuffer(s);const r=new Uint8Array(o);let i=0;for(let s=e;s<this.shards.length;s++){const e=this.shards[s];const o=t+i;const c=o-e.start;const a=i;const u=Math.min(n,e.end);const l=u-e.start;const f=new Uint8Array(e.buffer,c,l-c);r.set(f,a);i+=f.length;if(n<e.end){break}}return o}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength){return-1}if(this.bufferUniformSize!=null){this.previousShardIndex=Math.floor(t/this.bufferUniformSize);return this.previousShardIndex}function n(n){if(t<n.start){return-1}if(t>=n.end){return 1}return 0}if(n(this.shards[this.previousShardIndex])===0){return this.previousShardIndex}const e=vc(this.shards,n);if(e===-1){return-1}this.previousShardIndex=e;return this.previousShardIndex}}function vc(t,n){let e=0;let s=t.length;while(e<=s){const o=Math.floor((s-e)/2)+e;const r=n(t[o]);if(r===0){return o}else if(r<0){s=o}else{e=o+1}}return-1}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $c(){return Ur}function yc(){return Ur.memory()}function kc(t,n){return Ur.tidy(t,n)}function Cc(t){const n=Dr(t);n.forEach((t=>t.dispose()))}function Nc(t){return Ur.keep(t)}function Rc(t,n,e=1){return Ur.registerBackend(t,n,e)}function Sc(){return Ur.backend}const Ec=4;async function Tc(t,n){const e=[];const s=[];const o=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let r=0;r<o.length;++r){const i=o[r];const c=Array.isArray(t)?t[r].tensor:t[i];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64"){throw new Error(`Unsupported dtype in weight '${i}': ${c.dtype}`)}const a={name:i,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const t=new Promise((async t=>{const n=await c.bytes();const e=n.reduce(((t,n)=>t+n.length),0)+Ec*n.length;const s=new Uint8Array(e);let o=0;for(let t=0;t<n.length;t++){const e=n[t];const r=new Uint8Array(new Uint32Array([e.length]).buffer);s.set(r,o);o+=Ec;s.set(e,o);o+=e.length}t(s)}));s.push(t)}else{s.push(c.data())}if(n!=null){a.group=n}e.push(a)}const r=await Promise.all(s);return{data:Ic(r),specs:e}}function Ic(t){if(t===null){throw new Error(`Invalid input value: ${JSON.stringify(t)}`)}let n=0;const e=[];t.forEach((t=>{n+=t.byteLength;e.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t));if(!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array)){throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}}));const s=new Uint8Array(n);let o=0;e.forEach((t=>{s.set(new Uint8Array(t.buffer),o);o+=t.byteLength}));return s.buffer}const Ac=typeof hi!=="undefined"&&(typeof Blob==="undefined"||typeof atob==="undefined"||typeof btoa==="undefined");function Oc(t){if(Ac){return hi.byteLength(t,"utf8")}return new Blob([t]).size}function Fc(t){if(Ac){return hi.from(t).toString("base64")}const n=new Uint8Array(t);let e="";for(let t=0,s=n.length;t<s;t++){e+=String.fromCharCode(n[t])}return btoa(e)}function _c(t){if(Ac){const n=hi.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t);const e=new Uint8Array(n.length);for(let t=0;t<n.length;++t){e.set([n.charCodeAt(t)],t)}return e.buffer}function Mc(t){return wc.join(t)}function Dc(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:Oc(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:Oc(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new wc(t.weightData).byteLength}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lc{constructor(){this.saveRouters=[];this.loadRouters=[]}static getInstance(){if(Lc.instance==null){Lc.instance=new Lc}return Lc.instance}static registerSaveRouter(t){Lc.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Lc.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Lc.getHandlers(t,"save")}static getLoadHandlers(t,n){return Lc.getHandlers(t,"load",n)}static getHandlers(t,n,e){const s=[];const o=n==="load"?Lc.getInstance().loadRouters:Lc.getInstance().saveRouters;o.forEach((n=>{const o=n(t,e);if(o!==null){s.push(o)}}));return s}}const zc=t=>Lc.getSaveHandlers(t)
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const Pc="tensorflowjs";const Vc=1;const Bc="models_store";const Wc="model_info_store";function Gc(){if(!st().getBool("IS_BROWSER")){throw new Error("Failed to obtain IndexedDB factory because the current environment"+"is not a web browser.")}const t=typeof window==="undefined"?self:window;const n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(n==null){throw new Error("The current browser does not appear to support IndexedDB.")}return n}function Uc(t){const n=t.result;n.createObjectStore(Bc,{keyPath:"modelPath"});n.createObjectStore(Wc,{keyPath:"modelPath"})}class Hc{constructor(t){this.indexedDB=Gc();if(t==null||!t){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise(((t,e)=>{const s=this.indexedDB.open(Pc,Vc);s.onupgradeneeded=()=>Uc(s);s.onsuccess=()=>{const o=s.result;if(n==null){const n=o.transaction(Bc,"readonly");const s=n.objectStore(Bc);const r=s.get(this.modelPath);r.onsuccess=()=>{if(r.result==null){o.close();return e(new Error(`Cannot find model with path '${this.modelPath}' `+`in IndexedDB.`))}else{t(r.result.modelArtifacts)}};r.onerror=t=>{o.close();return e(r.error)};n.oncomplete=()=>o.close()}else{n.weightData=wc.join(n.weightData);const s=Dc(n);const r=o.transaction(Wc,"readwrite");let i=r.objectStore(Wc);let c;try{c=i.put({modelPath:this.modelPath,modelArtifactsInfo:s})}catch(t){return e(t)}let a;c.onsuccess=()=>{a=o.transaction(Bc,"readwrite");const c=a.objectStore(Bc);let u;try{u=c.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:s})}catch(t){return e(t)}u.onsuccess=()=>t({modelArtifactsInfo:s});u.onerror=t=>{i=r.objectStore(Wc);const n=i.delete(this.modelPath);n.onsuccess=()=>{o.close();return e(u.error)};n.onerror=t=>{o.close();return e(u.error)}}};c.onerror=t=>{o.close();return e(c.error)};r.oncomplete=()=>{if(a==null){o.close()}else{a.oncomplete=()=>o.close()}}}};s.onerror=t=>e(s.error)}))}}Hc.URL_SCHEME="indexeddb://";const jc=t=>{if(!st().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(t)&&t.startsWith(Hc.URL_SCHEME)){return qc(t.slice(Hc.URL_SCHEME.length))}else{return null}}};Lc.registerSaveRouter(jc);Lc.registerLoadRouter(jc);function qc(t){return new Hc(t)}function Xc(t){return t.startsWith(Hc.URL_SCHEME)?t.slice(Hc.URL_SCHEME.length):t}class Kc{constructor(){this.indexedDB=Gc()}async listModels(){return new Promise(((t,n)=>{const e=this.indexedDB.open(Pc,Vc);e.onupgradeneeded=()=>Uc(e);e.onsuccess=()=>{const s=e.result;const o=s.transaction(Wc,"readonly");const r=o.objectStore(Wc);const i=r.getAll();i.onsuccess=()=>{const n={};for(const t of i.result){n[t.modelPath]=t.modelArtifactsInfo}t(n)};i.onerror=t=>{s.close();return n(i.error)};o.oncomplete=()=>s.close()};e.onerror=t=>n(e.error)}))}async removeModel(t){t=Xc(t);return new Promise(((n,e)=>{const s=this.indexedDB.open(Pc,Vc);s.onupgradeneeded=()=>Uc(s);s.onsuccess=()=>{const o=s.result;const r=o.transaction(Wc,"readwrite");const i=r.objectStore(Wc);const c=i.get(t);let a;c.onsuccess=()=>{if(c.result==null){o.close();return e(new Error(`Cannot find model with path '${t}' `+`in IndexedDB.`))}else{const s=i.delete(t);const r=()=>{a=o.transaction(Bc,"readwrite");const s=a.objectStore(Bc);const r=s.delete(t);r.onsuccess=()=>n(c.result.modelArtifactsInfo);r.onerror=t=>e(c.error)};s.onsuccess=r;s.onerror=t=>{r();o.close();return e(c.error)}}};c.onerror=t=>{o.close();return e(c.error)};r.oncomplete=()=>{if(a==null){o.close()}else{a.oncomplete=()=>o.close()}}};s.onerror=t=>e(s.error)}))}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jc="/";const Yc="tensorflowjs_models";const Zc="info";const Qc="model_topology";const ta="weight_specs";const na="weight_data";const ea="model_metadata";function sa(t){return{info:[Yc,t,Zc].join(Jc),topology:[Yc,t,Qc].join(Jc),weightSpecs:[Yc,t,ta].join(Jc),weightData:[Yc,t,na].join(Jc),modelMetadata:[Yc,t,ea].join(Jc)}}function oa(t){for(const n of Object.values(t)){window.localStorage.removeItem(n)}}function ra(t){const n=t.split(Jc);if(n.length<3){throw new Error(`Invalid key format: ${t}`)}return n.slice(1,n.length-1).join(Jc)}function ia(t){return t.startsWith(ca.URL_SCHEME)?t.slice(ca.URL_SCHEME.length):t}class ca{constructor(t){if(!st().getBool("IS_BROWSER")||typeof window==="undefined"||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(t==null||!t){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=t;this.keys=sa(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}else{const n=JSON.stringify(t.modelTopology);const e=JSON.stringify(t.weightSpecs);const s=Dc(t);const o=wc.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s));this.LS.setItem(this.keys.topology,n);this.LS.setItem(this.keys.weightSpecs,e);this.LS.setItem(this.keys.weightData,Fc(o));const r={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:undefined,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:undefined,modelInitializer:t.modelInitializer!=null?t.modelInitializer:undefined,initializerSignature:t.initializerSignature!=null?t.initializerSignature:undefined,trainingConfig:t.trainingConfig!=null?t.trainingConfig:undefined};this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r));return{modelArtifactsInfo:s}}catch(t){oa(this.keys);throw new Error(`Failed to save model '${this.modelPath}' to local storage: `+`size quota being exceeded is a possible cause of this failure: `+`modelTopologyBytes=${s.modelTopologyBytes}, `+`weightSpecsBytes=${s.weightSpecsBytes}, `+`weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null){throw new Error(`In local storage, there is no model with name '${this.modelPath}'`)}if(t.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model "+"topology yet.")}const n={};const e=JSON.parse(this.LS.getItem(this.keys.topology));if(e==null){throw new Error(`In local storage, the topology of model '${this.modelPath}' `+`is missing.`)}n.modelTopology=e;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null){throw new Error(`In local storage, the weight specs of model '${this.modelPath}' `+`are missing.`)}n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const t=JSON.parse(o);n.format=t.format;n.generatedBy=t.generatedBy;n.convertedBy=t.convertedBy;if(t.signature!=null){n.signature=t.signature}if(t.userDefinedMetadata!=null){n.userDefinedMetadata=t.userDefinedMetadata}if(t.modelInitializer!=null){n.modelInitializer=t.modelInitializer}if(t.initializerSignature!=null){n.initializerSignature=t.initializerSignature}if(t.trainingConfig!=null){n.trainingConfig=t.trainingConfig}}const r=this.LS.getItem(this.keys.weightData);if(r==null){throw new Error(`In local storage, the binary weight values of model `+`'${this.modelPath}' are missing.`)}n.weightData=_c(r);return n}}ca.URL_SCHEME="localstorage://";const aa=t=>{if(!st().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(t)&&t.startsWith(ca.URL_SCHEME)){return ua(t.slice(ca.URL_SCHEME.length))}else{return null}}};Lc.registerSaveRouter(aa);Lc.registerLoadRouter(aa);function ua(t){return new ca(t)}class la{constructor(){x(st().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser"));x(typeof window==="undefined"||typeof window.localStorage!=="undefined",(()=>"Current browser does not appear to support localStorage"));this.LS=window.localStorage}async listModels(){const t={};const n=Yc+Jc;const e=Jc+Zc;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(e)){const n=ra(o);t[n]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=ia(t);const n=sa(t);if(this.LS.getItem(n.info)==null){throw new Error(`Cannot find model at path '${t}'`)}const e=JSON.parse(this.LS.getItem(n.info));oa(n);return e}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa="://";class ha{constructor(){this.managers={}}static getInstance(){if(ha.instance==null){ha.instance=new ha}return ha.instance}static registerManager(t,n){x(t!=null,(()=>"scheme must not be undefined or null."));if(t.endsWith(fa)){t=t.slice(0,t.indexOf(fa))}x(t.length>0,(()=>"scheme must not be an empty string."));const e=ha.getInstance();x(e.managers[t]==null,(()=>`A model store manager is already registered for scheme '${t}'.`));e.managers[t]=n}static getManager(t){const n=ha.getInstance().managers[t];if(n==null){throw new Error(`Cannot find model manager for scheme '${t}'`)}return n}static getSchemes(){return Object.keys(ha.getInstance().managers)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class da{constructor(){this.messageName="setTimeoutCustom";this.functionRefs=[];this.handledMessageCount=0;this.hasEventListener=false}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Browser's encoder only supports utf-8, but got ${n}`)}if(this.textEncoder==null){this.textEncoder=new TextEncoder}return this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window==="undefined"||!st().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t);setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),n);if(!this.hasEventListener){this.hasEventListener=true;window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();const n=this.functionRefs[t.data.index];n();this.handledMessageCount++;if(this.handledMessageCount===this.functionRefs.length){this.functionRefs=[];this.handledMessageCount=0}}}),true)}}isTypedArray(t){return ko(t)}}if(st().get("IS_BROWSER")){st().setPlatform("browser",new da);try{ha.registerManager(ca.URL_SCHEME,new la)}catch(t){}try{ha.registerManager(Hc.URL_SCHEME,new Kc)}catch(t){}}const pa={importFetch:()=>require("node-fetch")};let ma;class xa{constructor(){this.util=require("util");this.textEncoder=new this.util.TextEncoder}fetch(t,n){if(st().global.fetch!=null){return st().global.fetch(t,n)}if(ma==null){ma=pa.importFetch()}return ma(t,n)}now(){const t=qt.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`)}return this.textEncoder.encode(t)}decode(t,n){if(t.length===0){return""}return new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}if(st().get("IS_NODE")&&!st().get("IS_BROWSER")){st().setPlatform("node",new xa)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(t,n="float32",e){n=n||"float32";X(t);return new br(t,n,e)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(t,n){const e=fc(t,"x","cast");if(!A(n)){throw new Error(`Failed to cast to unknown dtype ${n}`)}if(n==="string"&&e.dtype!=="string"||n!=="string"&&e.dtype==="string"){throw new Error("Only strings can be casted to strings")}const s={x:e};const o={dtype:n};return Ur.runKernel(kn,s,o)}const wa=pc({cast_:ga});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function va(t){const n=fc(t,"x","clone","string_or_numeric");const e={x:n};return Ur.runKernel(me,e)}const $a=pc({clone_:va});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(t,n=false){console.log(t.toString(n))}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Gr();const ka={buffer:ba,cast:wa,clone:$a,print:ya};$r(ka);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(t,n){let e=fc(t,"a","add");let s=fc(n,"b","add");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(nn,o)}const Na=pc({add_:Ca});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ra(t,n){let e=fc(t,"a","floorDiv");let s=fc(n,"b","floorDiv");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(ue,o)}const Sa=pc({floorDiv_:Ra});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(t,n){let e=fc(t,"a","div");let s=fc(n,"b","div");[e,s]=Mr(e,s);if(e.dtype==="int32"&&s.dtype==="int32"){return Sa(e,s)}const o={a:e,b:s};const r={};return Ur.runKernel(Jn,o,r)}const Ta=pc({div_:Ea});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(t,n){let e=fc(t,"a","mul");let s=fc(n,"b","mul");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(je,o)}const Aa=pc({mul_:Ia});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(t){const n=fc(t,"x","abs");if(n.dtype==="complex64"){const t={x:n};return Ur.runKernel(Sn,t)}else{const t={x:n};return Ur.runKernel(Zt,t)}}const Fa=pc({abs_:Oa});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(t){const n=fc(t,"x","acos");const e={x:n};return Ur.runKernel(Qt,e)}const Ma=pc({acos_:_a});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Da(t){const n=fc(t,"x","acosh");const e={x:n};return Ur.runKernel(tn,e)}const La=pc({acosh_:Da});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function za(t,n=null,e=false){const s=fc(t,"x","all","bool");const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(sn,o,r)}const Pa=pc({all_:za});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Va(t,n=null,e=false){const s=fc(t,"x","any","bool");const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(on,o,r)}const Ba=pc({any_:Va});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(t,n=0){const e=fc(t,"x","argMax");const s={x:e};const o={axis:n};return Ur.runKernel(rn,s,o)}const Ga=pc({argMax_:Wa});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(t,n=0){const e=fc(t,"x","argMin");const s={x:e};const o={axis:n};return Ur.runKernel(cn,s,o)}const Ha=pc({argMin_:Ua});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(t){const n=fc(t,"x","asin");const e={x:n};return Ur.runKernel(an,e)}const qa=pc({asin_:ja});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(t){const n=fc(t,"x","asinh");const e={x:n};return Ur.runKernel(un,e)}const Ka=pc({asinh_:Xa});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(t){const n=fc(t,"x","atan");const e={x:n};return Ur.runKernel(ln,e)}const Ya=pc({atan_:Ja});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(t,n){let e=fc(t,"a","atan2");let s=fc(n,"b","atan2");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(hn,o)}const Qa=pc({atan2_:Za});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(t){const n=fc(t,"x","atanh");const e={x:n};return Ur.runKernel(fn,e)}const nu=pc({atanh_:tu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(t,n,e,s,o="NHWC",r){const i=t[3];const c=[...n,i];const a=wu(o);return ru(t,c,e,r,s,null,null,a)}function su(t,n,e,s,o,r,i="channelsLast"){const[c,a]=lu(n);let u;if(i==="channelsLast"){u=[c,a,t[3],t[3]]}else if(i==="channelsFirst"){u=[c,a,t[1],t[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return ru(t,u,e,s,o,r,false,i)}function ou(t,n,e,s,o,r,i="NDHWC"){const[c,a,u]=fu(n);let l;let f;if(i==="NDHWC"){f="channelsLast";l=[c,a,u,t[4],t[4]]}else if(i==="NCDHW"){f="channelsFirst";l=[c,a,u,t[1],t[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return iu(t,l,e,s,o,false,f,r)}function ru(t,n,e,s,o,r,i=false,c="channelsLast"){let[a,u,l,f]=[-1,-1,-1,-1];if(c==="channelsLast"){[a,u,l,f]=t}else if(c==="channelsFirst"){[a,f,u,l]=t}else{throw new Error(`Unknown dataFormat ${c}`)}const[h,d,,p]=n;const[m,x]=lu(e);const[b,g]=lu(s);const w=hu(h,b);const v=hu(d,g);const{padInfo:$,outHeight:y,outWidth:k}=du(o,u,l,m,x,w,v,r,c);const C=i?p*f:p;let N;if(c==="channelsFirst"){N=[a,C,y,k]}else if(c==="channelsLast"){N=[a,y,k,C]}return{batchSize:a,dataFormat:c,inHeight:u,inWidth:l,inChannels:f,outHeight:y,outWidth:k,outChannels:C,padInfo:$,strideHeight:m,strideWidth:x,filterHeight:h,filterWidth:d,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:g,inShape:t,outShape:N,filterShape:n}}function iu(t,n,e,s,o,r=false,i="channelsLast",c){let[a,u,l,f,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast"){[a,u,l,f,h]=t}else if(i==="channelsFirst"){[a,h,u,l,f]=t}else{throw new Error(`Unknown dataFormat ${i}`)}const[d,p,m,,x]=n;const[b,g,w]=fu(e);const[v,$,y]=fu(s);const k=hu(d,v);const C=hu(p,$);const N=hu(m,y);const{padInfo:R,outDepth:S,outHeight:E,outWidth:T}=pu(o,u,l,f,b,g,w,k,C,N,c);const I=r?x*h:x;let A;if(i==="channelsFirst"){A=[a,I,S,E,T]}else if(i==="channelsLast"){A=[a,S,E,T,I]}return{batchSize:a,dataFormat:i,inDepth:u,inHeight:l,inWidth:f,inChannels:h,outDepth:S,outHeight:E,outWidth:T,outChannels:I,padInfo:R,strideDepth:b,strideHeight:g,strideWidth:w,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:$,dilationWidth:y,inShape:t,outShape:A,filterShape:n}}function cu(t,n,e,s,o){if(s==null){s=uu(t,n,e)}const r=t[0];const i=t[1];const c=mu((r-n+2*s)/e+1,o);const a=mu((i-n+2*s)/e+1,o);return[c,a]}function au(t,n,e,s,o,r){if(o==null){o=uu(t,n[0],s[0])}const i=[0,0,0,e];for(let e=0;e<3;e++){if(t[e]+2*o>=n[e]){i[e]=mu((t[e]-n[e]+2*o)/s[e]+1,r)}}return i}function uu(t,n,e,s=1){const o=hu(n,s);return Math.floor((t[0]*(e-1)-e+o)/2)}function lu(t){if(typeof t==="number"){return[t,t,t]}if(t.length===2){return[t[0],t[1],1]}return t}function fu(t){return typeof t==="number"?[t,t,t]:t}function hu(t,n){if(n<=1){return t}return t+(t-1)*(n-1)}function du(t,n,e,s,o,r,i,c,a){let u;let l;let f;if(typeof t==="number"){const o=t===0?"VALID":"NUMBER";u={top:t,bottom:t,left:t,right:t,type:o};const i=cu([n,e],r,s,t,c);l=i[0];f=i[1]}else if(t==="same"){l=Math.ceil(n/s);f=Math.ceil(e/o);const t=Math.max(0,(l-1)*s+r-n);const c=Math.max(0,(f-1)*o+i-e);const a=Math.floor(t/2);const h=t-a;const d=Math.floor(c/2);const p=c-d;u={top:a,bottom:h,left:d,right:p,type:"SAME"}}else if(t==="valid"){u={top:0,bottom:0,left:0,right:0,type:"VALID"};l=Math.ceil((n-r+1)/s);f=Math.ceil((e-i+1)/o)}else if(typeof t==="object"){const h=a==="channelsLast"?t[1][0]:t[2][0];const d=a==="channelsLast"?t[1][1]:t[2][1];const p=a==="channelsLast"?t[2][0]:t[3][0];const m=a==="channelsLast"?t[2][1]:t[3][1];const x=h===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT";u={top:h,bottom:d,left:p,right:m,type:x};l=mu((n-r+h+d)/s+1,c);f=mu((e-i+p+m)/o+1,c)}else{throw Error(`Unknown padding parameter: ${t}`)}return{padInfo:u,outHeight:l,outWidth:f}}function pu(t,n,e,s,o,r,i,c,a,u,l){let f;let h;let d;let p;if(t==="valid"){t=0}if(typeof t==="number"){const m=t===0?"VALID":"NUMBER";f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:m};const x=au([n,e,s,1],[c,a,u],1,[o,r,i],t,l);h=x[0];d=x[1];p=x[2]}else if(t==="same"){h=Math.ceil(n/o);d=Math.ceil(e/r);p=Math.ceil(s/i);const t=(h-1)*o+c-n;const l=(d-1)*r+a-e;const m=(p-1)*i+u-s;const x=Math.floor(t/2);const b=t-x;const g=Math.floor(l/2);const w=l-g;const v=Math.floor(m/2);const $=m-v;f={top:g,bottom:w,left:v,right:$,front:x,back:b,type:"SAME"}}else{throw Error(`Unknown padding parameter: ${t}`)}return{padInfo:f,outDepth:h,outHeight:d,outWidth:p}}function mu(t,n){if(!n){return Math.trunc(t)}switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function xu(t){const[n,e,s]=lu(t);return n===1&&e===1&&s===1}function bu(t,n){return xu(t)||xu(n)}function gu(t){return lu(t).every((t=>t>0))}function wu(t){if(t==="NHWC"){return"channelsLast"}else if(t==="NCHW"){return"channelsFirst"}else{throw new Error(`Unknown dataFormat ${t}`)}}function vu(t,n,e){if(e!=null){if(typeof n==="string"){throw Error(`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`)}else if(typeof n==="number"){x($(n),(()=>`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`))}else if(typeof n==="object"){n.forEach((n=>{n.forEach((n=>{x($(n),(()=>`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`))}))}))}else{throw Error(`Error in ${t}: Unknown padding parameter: ${n}`)}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(t,n){const e=fc(t,"x","reshape","string_or_numeric");const s={x:e};const o={shape:n};return Ur.runKernel(hs,s,o)}const yu=pc({reshape_:$u});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(t,n,e,s,o){const r=fc(t,"x","avgPool","float32");const i=1;x(bu(e,i),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${i}'`));let c=r;let a=false;if(r.rank===3){a=true;c=yu(r,[1,r.shape[0],r.shape[1],r.shape[2]])}x(c.rank===4,(()=>`Error in avgPool: x must be rank 4 but got rank ${c.rank}.`));vu("avgPool",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o};let f=Ur.runKernel(dn,u,l);f=wa(f,r.dtype);if(a){return yu(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const Cu=pc({avgPool_:ku});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(t,n,e,s,o,r="NDHWC"){const i=fc(t,"x","avgPool3d","float32");let c=i;let a=false;if(i.rank===4){a=true;c=yu(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}x(c.rank===5,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${c.rank}.`));x(r==="NDHWC",(()=>`Error in avgPool3d: Only NDHWC is currently supported, `+`but got dataFormat of ${r}`));x(typeof e==="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`));vu("avgPool3d",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o,dataFormat:r};let f=Ur.runKernel(mn,u,l);f=wa(f,c.dtype);if(a){return yu(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const Ru=pc({avgPool3d_:Nu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(t,n=0){x(t.length>=1,(()=>"Pass at least one tensor to concat"));const e=hc(t,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"){e.forEach((t=>{if(t.dtype!=="complex64"){throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}}))}if(e.length===1){return $a(e[0])}const s=e;const o={axis:n};return Ur.runKernel(En,s,o)}const Eu=pc({concat_:Su});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(t,n,e=false,s=false){let o=fc(t,"a","matMul");let r=fc(n,"b","matMul");[o,r]=Mr(o,r);const i={a:o,b:r};const c={transposeA:e,transposeB:s};return Ur.runKernel(bn,i,c)}const Iu=pc({matMul_:Tu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(t){const n=fc(t,"x","sigmoid","float32");const e={x:n};return Ur.runKernel(Is,e)}const Ou=pc({sigmoid_:Au});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fu(t,n,e){const s=fc(t,"x","slice","string_or_numeric");if(s.rank===0){throw new Error("Slicing scalar is not possible")}const o={x:s};const r={begin:n,size:e};return Ur.runKernel(Rs,o,r)}const _u=pc({slice_:Fu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mu(t){const n=fc(t,"x","tanh","float32");const e={x:n};return Ur.runKernel(Ys,e)}const Du=pc({tanh_:Mu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lu(t,n,e){const s=fc(t,"x","batchToSpaceND");const o=n.reduce(((t,n)=>t*n));x(s.rank>=1+n.length,(()=>`input rank is ${s.rank} but should be > than blockShape.length ${n.length}`));x(e.length===n.length,(()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`));x(s.shape[0]%o===0,(()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of `+`the elements of blockShape ${n.join(" * ")} === ${o}`));const r={x:s};const i={blockShape:n,crops:e};return Ur.runKernel(gn,r,i)}const zu=pc({batchToSpaceND_:Lu});function Pu(t){let n;if(t.rank===0||t.rank===1){n=yu(t,[1,1,1,t.size])}else if(t.rank===2){n=yu(t,[1,1,t.shape[0],t.shape[1]])}else if(t.rank===3){n=yu(t,[1,t.shape[0],t.shape[1],t.shape[2]])}else{n=t}return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vu(t,n,e,s,o,r){if(r==null){r=.001}const i=fc(t,"x","batchNorm");const c=fc(n,"mean","batchNorm");const a=fc(e,"variance","batchNorm");let u;if(o!=null){u=fc(o,"scale","batchNorm")}let l;if(s!=null){l=fc(s,"offset","batchNorm")}x(c.rank===a.rank,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));x(l==null||c.rank===l.rank,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));x(u==null||c.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));const f=Pu(i);const h={x:f,scale:u,offset:l,mean:c,variance:a};const d={varianceEpsilon:r};const p=Ur.runKernel(le,h,d);return yu(p,i.shape)}const Bu=pc({batchNorm_:Vu});function Wu(t,n,e,s,o,r){const i=fc(t,"x","batchNorm");const c=fc(n,"mean","batchNorm");const a=fc(e,"variance","batchNorm");let u;if(o!=null){u=fc(o,"scale","batchNorm")}let l;if(s!=null){l=fc(s,"offset","batchNorm")}x(i.rank===2,(()=>`Error in batchNorm2D: x must be rank 2 but got rank `+`${i.rank}.`));x(c.rank===2||c.rank===1,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but `+`got rank ${c.rank}.`));x(a.rank===2||a.rank===1,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){x(u.rank===2||u.rank===1,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){x(l.rank===2||l.rank===1,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 `+`but got rank ${l.rank}.`))}return Bu(i,c,a,l,u,r)}const Gu=pc({batchNorm2d_:Wu});function Uu(t,n,e,s,o,r){const i=fc(t,"x","batchNorm");const c=fc(n,"mean","batchNorm");const a=fc(e,"variance","batchNorm");let u;if(o!=null){u=fc(o,"scale","batchNorm")}let l;if(s!=null){l=fc(s,"offset","batchNorm")}x(i.rank===3,(()=>`Error in batchNorm3D: x must be rank 3 but got rank `+`${i.rank}.`));x(c.rank===3||c.rank===1,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but `+`got rank ${c.rank}.`));x(a.rank===3||a.rank===1,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){x(u.rank===3||u.rank===1,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){x(l.rank===3||l.rank===1,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 `+`but got rank ${l.rank}.`))}return Bu(i,c,a,l,u,r)}const Hu=pc({batchNorm3d_:Uu});function ju(t,n,e,s,o,r){const i=fc(t,"x","batchNorm");const c=fc(n,"mean","batchNorm");const a=fc(e,"variance","batchNorm");let u;if(o!=null){u=fc(o,"scale","batchNorm")}let l;if(s!=null){l=fc(s,"offset","batchNorm")}x(i.rank===4,(()=>`Error in batchNorm4D: x must be rank 4 but got rank `+`${i.rank}.`));x(c.rank===4||c.rank===1,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but `+`got rank ${c.rank}.`));x(a.rank===4||a.rank===1,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){x(u.rank===4||u.rank===1,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){x(l.rank===4||l.rank===1,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 `+`but got rank ${l.rank}.`))}return Bu(i,c,a,l,u,r)}const qu=pc({batchNorm4d_:ju});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xu(t,n,e){const s=fc(t,"x","bincount");const o=fc(n,"weights","bincount");x(s.dtype==="int32",(()=>`Error in bincount: input `+`dtype must be int32, but got ${s.dtype}`));x(e>=0,(()=>`size must be non-negative, but got ${e}.`));x(o.size===s.size||o.size===0,(()=>`Error in bincount: weights must have the same size as input or`+`0-length, but got input shape: ${s.shape}, weights shape: `+`${o.shape}.`));const r={x:s,weights:o};const i={size:e};return Ur.runKernel(wn,r,i)}const Ku=pc({bincount_:Xu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(t,n){let e=fc(t,"broadcastTo","x");const s=e.shape;X(n);if(n.length<e.rank){throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`)}if(n.length>e.rank){const t=e.shape.slice();while(t.length<n.length){t.unshift(1)}e=yu(e,t)}const o=e.shape;const r=Array.from(n);for(let t=n.length-1;t>=0;t--){if(o[t]===n[t]){r[t]=1}else if(e.shape[t]!==1){throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${n}].`)}}const i=r.map(((t,n)=>t>1?n:-1)).filter((t=>t>=0));if(i.length===0){return $a(e)}const c={x:e};const a={reps:r};return Ur.runKernel(Zs,c,a)}const Yu=pc({broadcastTo_:Ju});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zu(t){const n=fc(t,"x","ceil","float32");const e={x:n};return Ur.runKernel(Cn,e)}const Qu=pc({ceil_:Zu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(t,n,e){X(t);e=e||z(n);const s={shape:t,value:n,dtype:e};return Ur.runKernel(ie,{},s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(t,n,e){const s=fc(t,"x","clipByValue");x(n<=e,(()=>`Error in clip: min (${n}) must be `+`less than or equal to max (${e}).`));if(n===e){return tl(s.shape,n,s.dtype)}const o={x:s};const r={clipValueMin:n,clipValueMax:e};return Ur.runKernel(Nn,o,r)}const el=pc({clipByValue_:nl});function sl(t){return Eu(t,0)}const ol=pc({concat1d_:sl});function rl(t,n){return Eu(t,n)}const il=pc({concat2d_:rl});function cl(t,n){return Eu(t,n)}const al=pc({concat3d_:cl});function ul(t,n){return Eu(t,n)}const ll=pc({concat4d_:ul});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fl(t,n,e,s,o="NHWC",r=[1,1],i){const c=fc(t,"x","conv2d","float32");const a=fc(n,"filter","conv2d","float32");let u=c;let l=false;if(c.rank===3){l=true;u=yu(c,[1,c.shape[0],c.shape[1],c.shape[2]])}x(u.rank===4,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`));x(a.rank===4,(()=>`Error in conv2d: filter must be rank 4, but got rank `+`${a.rank}.`));vu("conv2d",s,i);const f=o==="NHWC"?u.shape[3]:u.shape[1];x(f===a.shape[2],(()=>`Error in conv2d: depth of input (${f}) must match `+`input depth for filter ${a.shape[2]}.`));x(bu(e,r),(()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));x(gu(r),(()=>"Error in conv2D: Dilated rates should be larger than 0."));x(gu(e),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:a};const d={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i};const p=Ur.runKernel(Tn,h,d);if(l){return yu(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const hl=pc({conv2d_:fl});function dl(t,n,e,s,o="NWC",r=1,i){const c=fc(t,"x","conv1d");const a=fc(n,"filter","conv1d");let u=c;let l=false;if(c.rank===2){l=true;u=yu(c,[1,c.shape[0],c.shape[1]])}x(u.rank===3,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`));x(a.rank===3,(()=>`Error in conv1d: filter must be rank 3, but got rank `+`${a.rank}.`));vu("conv1d",s,i);x(u.shape[2]===a.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match `+`input depth for filter ${a.shape[1]}.`));x(bu(e,r),(()=>"Error in conv1D: Either stride or dilation must be 1. "+`Got stride ${e} and dilation '${r}'`));x(gu(r),(()=>"Error in conv1D: Dilated rates should be larger than 0."));x(gu(e),(()=>"Error in conv1D: Stride should be larger than 0."));x(o==="NWC",(()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`));const f=yu(a,[1,a.shape[0],a.shape[1],a.shape[2]]);const h=yu(u,[u.shape[0],1,u.shape[1],u.shape[2]]);const d=[1,e];const p=[1,r];const m="NHWC";const b=hl(h,f,d,s,m,p,i);if(l){return yu(b,[b.shape[2],b.shape[3]])}return yu(b,[b.shape[0],b.shape[2],b.shape[3]])}const pl=pc({conv1d_:dl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(t,n,e,s,o,r="NHWC",i){x(t.length===n.rank,(()=>`Length of inShape `+`(${t.length}) and rank of dy (${n.rank}) must match`));let c=t;let a=n;let u=false;if(n.rank===3){u=true;a=yu(n,[1,n.shape[0],n.shape[1],n.shape[2]]);c=[1,t[0],t[1],t[2]]}x(c.length===4,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length `+`${c.length}.`));x(a.rank===4,(()=>`Error in conv2dDerInput: dy must be rank 4, but got `+`rank ${a.rank}`));x(e.rank===4,(()=>`Error in conv2dDerInput: filter must be rank 4, but got `+`rank ${e.rank}`));const l=r==="NHWC"?c[3]:c[1];const f=r==="NHWC"?a.shape[3]:a.shape[1];x(l===e.shape[2],(()=>`Error in conv2dDerInput: depth of input (${l}) must `+`match input depth for filter ${e.shape[2]}.`));x(f===e.shape[3],(()=>`Error in conv2dDerInput: depth of output (${f}) must `+`match output depth for filter ${e.shape[3]}.`));vu("conv2dDerInput",o,i);const h={dy:a,filter:e};const d={strides:s,pad:o,dataFormat:r,dimRoundingMode:i,inputShape:c};const p=Ur.runKernel(An,h,d);if(u){return yu(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const xl=pc({conv2DBackpropInput_:ml});function bl(t,n,e,s,o,r){const i=fc(t,"x","conv2dTranspose");const c=fc(n,"filter","conv2dTranspose");return xl(e,i,c,s,o,"NHWC",r)}const gl=pc({conv2dTranspose_:bl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(t,n,e,s,o="NDHWC",r=[1,1,1]){const i=fc(t,"x","conv3d");const c=fc(n,"filter","conv3d");let a=i;let u=false;if(i.rank===4){u=true;a=yu(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}x(a.rank===5,(()=>`Error in conv3d: input must be rank 5, but got rank ${a.rank}.`));x(c.rank===5,(()=>`Error in conv3d: filter must be rank 5, but got rank `+`${c.rank}.`));x(a.shape[4]===c.shape[3],(()=>`Error in conv3d: depth of input (${a.shape[4]}) must match `+`input depth for filter ${c.shape[3]}.`));x(bu(e,r),(()=>"Error in conv3D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));x(o==="NDHWC",(()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`));x(gu(r),(()=>"Error in conv3D: Dilated rates should be larger than 0."));x(gu(e),(()=>"Error in conv3D: Strides should be larger than 0."));const l={x:a,filter:c};const f={strides:e,pad:s,dataFormat:o,dilations:r};const h=Ur.runKernel(On,l,f);if(u){return yu(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const vl=pc({conv3d_:wl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(t,n,e,s,o){x(t.length===n.rank,(()=>`Length of inShape `+`(${t.length}) and rank of dy (${n.rank}) must match`));let r=t;let i=n;let c=false;if(n.rank===4){c=true;i=yu(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]);r=[1,t[0],t[1],t[2],t[3]]}const a=r[4];const u=i.shape[4];x(r.length===5,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length `+`${r.length}.`));x(i.rank===5,(()=>`Error in conv3dDerInput: dy must be rank 5, but got `+`rank ${i.rank}`));x(e.rank===5,(()=>`Error in conv3dDerInput: filter must be rank 5, but got `+`rank ${e.rank}`));x(a===e.shape[3],(()=>`Error in conv3dDerInput: depth of input (${a}) must `+`match input depth for filter ${e.shape[3]}.`));x(u===e.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must `+`match output depth for filter ${e.shape[4]}.`));const l={dy:i,filter:e};const f={pad:o,strides:s,inputShape:r};const h=Ur.runKernel(_n,l,f);if(c){return yu(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const yl=pc({conv3DBackpropInput_:$l});function kl(t,n,e,s,o){const r=fc(t,"x","conv3dTranspose");const i=fc(n,"filter","conv3dTranspose");return yl(e,r,i,s,o)}const Cl=pc({conv3dTranspose_:kl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(t){const n=fc(t,"x","cos","float32");const e={x:n};return Ur.runKernel(Mn,e)}const Rl=pc({cos_:Nl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(t){const n=fc(t,"x","cosh","float32");const e={x:n};return Ur.runKernel(Dn,e)}const El=pc({cosh_:Sl});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(t,n=0,e=false,s=false){const o=fc(t,"x","cumprod");const r={x:o};const i={axis:n,exclusive:e,reverse:s};return Ur.runKernel(Ln,r,i)}const Il=pc({cumprod_:Tl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(t,n=0,e=false,s=false){const o=fc(t,"x","cumsum");const r={x:o};const i={axis:n,exclusive:e,reverse:s};return Ur.runKernel(zn,r,i)}const Ol=pc({cumsum_:Al});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(t,n,e,s=false){const o=fc(t,"x","denseBincount");const r=fc(n,"weights","denseBincount");x(o.dtype==="int32",(()=>`Error in denseBincount: input `+`dtype must be int32, but got ${o.dtype}`));x(o.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got `+`rank ${o.rank}.`));x(e>=0,(()=>`size must be non-negative, but got ${e}.`));x(r.size===o.size||r.size===0,(()=>`Error in denseBincount: weights must have the same shape as x or `+`0-length, but got x shape: ${o.shape}, weights shape: `+`${r.shape}.`));const i={x:o,weights:r};const c={size:e,binaryOutput:s};return Ur.runKernel(Vn,i,c)}const _l=pc({denseBincount_:Fl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(t,n,e="NHWC"){const s=fc(t,"x","depthToSpace","float32");const o=e==="NHWC"?s.shape[1]:s.shape[2];const r=e==="NHWC"?s.shape[2]:s.shape[3];const i=e==="NHWC"?s.shape[3]:s.shape[1];x(n>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`));x(o*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n}  for depthToSpace with input shape\n    ${s.shape}`));x(r*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${n} for depthToSpace with input shape\n        ${s.shape}`));x(i%(n*n)===0,(()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${s.shape}`));const c={x:s};const a={blockSize:n,dataFormat:e};return Ur.runKernel(Bn,c,a)}const Dl=pc({depthToSpace_:Ml});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ll(t,n,e,s,o="NHWC",r=[1,1],i){const c=fc(t,"x","depthwiseConv2d","float32");const a=fc(n,"filter","depthwiseConv2d","float32");let u=c;let l=false;if(c.rank===3){l=true;u=yu(c,[1,c.shape[0],c.shape[1],c.shape[2]])}x(u.rank===4,(()=>`Error in depthwiseConv2d: input must be rank 4, but got `+`rank ${u.rank}.`));x(a.rank===4,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank `+`${a.rank}.`));const f=o==="NHWC"?u.shape[3]:u.shape[1];x(f===a.shape[2],(()=>`Error in depthwiseConv2d: number of input channels `+`(${f}) must match the inChannels dimension in `+`filter ${a.shape[2]}.`));vu("depthwiseConv2d",s,i);const h={x:u,filter:a};const d={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i};const p=Ur.runKernel(Wn,h,d);if(l){return yu(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const zl=pc({depthwiseConv2d_:Ll});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pl(t,n,e,s,o=[1,1],r="NHWC"){const i=fc(t,"x","dilation2d");const c=fc(n,"filter","dilation2d");x(i.rank===3||i.rank===4,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank `+`${i.rank}.`));x(c.rank===3,(()=>`Error in dilation2d: filter must be rank 3, but got rank `+`${c.rank}.`));x(r==="NHWC",(()=>`Error in dilation2d: Only NHWC is currently supported, `+`but got dataFormat of ${r}`));let a=i;let u=false;if(i.rank===3){a=yu(i,[1,i.shape[0],i.shape[1],i.shape[2]]);u=true}x(a.shape[3]===c.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${a.shape[3]} vs ${c.shape[2]}`));const l={x:a,filter:c};const f={strides:e,pad:s,dilations:o};const h=Ur.runKernel(jn,l,f);if(u){return yu(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}const Vl=pc({dilation2d_:Pl});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(t,n){const e=t.length;const s=[];for(let o=0;o<e;o++){const r=e-1-o;const i=t[r]||1;const c=n[n.length-1-o]||1;if(c>1&&i===1){s.unshift(r)}}return s}function Wl(t,n){const e=[];for(let s=0;s<n.length;s++){const o=t[t.length-s-1];const r=n.length-s-1;const i=n[r];if(o==null||o===1&&i>1){e.unshift(r)}}return e}function Gl(t,n){const e=Math.max(t.length,n.length);const s=new Array(e);for(let o=0;o<e;o++){let r=t[t.length-o-1];if(r==null){r=1}let i=n[n.length-o-1];if(i==null){i=1}if(r===1){s[e-o-1]=i}else if(i===1){s[e-o-1]=r}else if(r!==i){const e=`Operands could not be broadcast together with shapes `+`${t} and ${n}.`;throw Error(e)}else{s[e-o-1]=r}}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(t,n){let e=fc(t,"a","equal","string_or_numeric");let s=fc(n,"b","equal","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(ne,o)}const Hl=pc({equal_:Ul});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jl(t,n,e){const s=fc(n,"a","where");const o=fc(e,"b","where");const r=fc(t,"condition","where","bool");const i=Gl(Gl(r.shape,s.shape),o.shape);const c=Yu(r,i);const a=Yu(s,i);const u=Yu(o,i);const l={condition:c,t:a,e:u};return Ur.runKernel(Cs,l)}const ql=pc({where_:jl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xl(t){const n=fc(t,"x","zerosLike");const e={x:n};return Ur.runKernel(ro,e)}const Kl=pc({zerosLike_:Xl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jl(t,n){let e=fc(t,"a","div");let s=fc(n,"b","div");[e,s]=Mr(e,s);const o=Ta(e,s);const r=Kl(o);const i=Hl(s,r);return ql(i,r,o)}const Yl=pc({divNoNan_:Jl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zl(t,n){const e=fc(t,"t1","dot");const s=fc(n,"t2","dot");x((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks `+`${e.rank} and ${s.rank}.`));const o=e.rank===1?e.size:e.shape[1];const r=s.rank===1?s.size:s.shape[0];x(o===r,(()=>`Error in dot: inner dimensions of inputs must match, but got `+`${o} and ${r}.`));if(e.rank===1&&s.rank===1){const t=yu(e,[1,-1]);const n=yu(s,[-1,1]);const o=Iu(t,n);return yu(o,[])}else if(e.rank===1&&s.rank===2){const t=yu(e,[1,-1]);const n=yu(s,[s.shape[0],s.shape[1]]);const o=Iu(t,n);return yu(o,[o.size])}else if(e.rank===2&&s.rank===1){const t=yu(s,[-1,1]);const n=Iu(e,t);return yu(n,[n.size])}else{const t=yu(s,[s.shape[0],s.shape[1]]);const n=Iu(e,t);return n}}const Ql=pc({dot_:Zl});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tf(t,...n){const e=n.map(((t,n)=>fc(t,`tensors${n}`,"einsum")));const s={equation:t};return Ur.runKernel(Yn,e,s)}const nf=pc({einsum_:tf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ef(t){const n=fc(t,"x","elu","float32");const e={x:n};return Ur.runKernel(Zn,e)}const sf=pc({elu_:ef});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function of(t){let n=fc(t,"x","erf");x(n.dtype==="int32"||n.dtype==="float32",(()=>"Input dtype must be `int32` or `float32`."));if(n.dtype==="int32"){n=wa(n,"float32")}const e={x:n};return Ur.runKernel(te,e)}const rf=pc({erf_:of});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cf(t,n){for(let e=0;e<t.length;++e){if(t[t.length-e-1]!==n-1-e){return false}}return true}function af(t,n,e){const s=t.length+n.length;const o=[];let r=0;let i=0;for(let c=0;c<s;c++){if(e.indexOf(c)===-1){o.push(t[r++])}else{o.push(n[i++])}}return o}function uf(t,n){const e=[];const s=t.length;for(let o=0;o<s;o++){if(n.indexOf(o)===-1){e.push(t[o])}}const o=n.map((n=>t[n]));return[e,o]}function lf(t,n){const e=n.map((t=>1));return af(t,e,n)}function ff(t,n,e){x(cf(n,e),(()=>`${t} supports only inner-most axes for now. `+`Got axes ${n} and rank-${e} input.`))}function hf(t,n){if(cf(t,n)){return null}const e=[];for(let s=0;s<n;++s){if(t.indexOf(s)===-1){e.push(s)}}t.forEach((t=>e.push(t)));return e}function df(t){return t.map(((t,n)=>[n,t])).sort(((t,n)=>t[1]-n[1])).map((t=>t[0]))}function pf(t,n){const e=[];for(let s=n-t;s<n;++s){e.push(s)}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(t,n=null,e=false){const s=fc(t,"x","max");const o={x:s};const r={reductionIndices:n,keepDims:e};return Ur.runKernel(Fe,o,r)}const xf=pc({max_:mf});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(t,n=null,e=false){const s=fc(t,"x","min");const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(Be,o,r)}const gf=pc({min_:bf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(t,n){let e=fc(t,"base","pow");let s=fc(n,"exp","pow");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(es,o)}const vf=pc({pow_:wf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(t,n){if((nr(t)&&n!=="string"||Array.isArray(t))&&n!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive "+"(number|boolean|string)")}if(n==="string"&&nr(t)&&!(t instanceof Uint8Array)){throw new Error("When making a scalar from encoded string, "+"the value must be `Uint8Array`.")}const e=[];const s=[];return bc(t,e,s,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(t){const n=fc(t,"x","sqrt","float32");const e={x:n};return Ur.runKernel(Os,e)}const kf=pc({sqrt_:yf});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cf(t){const n=fc(t,"x","square");const e={};return Ur.runKernel("Square",{x:n},e)}const Nf=pc({square_:Cf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(t,n=null,e=false){let s=fc(t,"x","sum");if(s.dtype==="bool"){s=wa(s,"int32")}const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(Fs,o,r)}const Sf=pc({sum_:Rf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ef(t,n="euclidean",e=null,s=false){t=fc(t,"x","norm");const o=Tf(t,n,e);let r=o.shape;if(s){const n=R(e,t.shape);r=lf(o.shape,n)}return yu(o,r)}function Tf(t,n,e=null){if(t.rank===0){return Fa(t)}if(t.rank!==1&&e===null){return Tf(yu(t,[-1]),n,e)}if(t.rank===1||typeof e==="number"||Array.isArray(e)&&e.length===1){if(n===1){return Sf(Fa(t),e)}if(n===Infinity){return xf(Fa(t),e)}if(n===-Infinity){return gf(Fa(t),e)}if(n==="euclidean"||n===2){return kf(Sf(vf(Fa(t),$f(2,"int32")),e))}throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&e.length===2){if(n===1){return xf(Sf(Fa(t),e[0]),e[1]-1)}if(n===Infinity){return xf(Sf(Fa(t),e[1]),e[0])}if(n===-Infinity){return gf(Sf(Fa(t),e[1]),e[0])}if(n==="fro"||n==="euclidean"){return kf(Sf(Nf(t),e))}throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const If=pc({norm_:Ef});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(t,n=null,e=false){return If(t,"euclidean",n,e)}const Of=pc({euclideanNorm_:Af});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(t){const n=fc(t,"x","exp");const e={x:n};return Ur.runKernel(ee,e)}const _f=pc({exp_:Ff});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mf(t,n=0){const e=fc(t,"x","expandDims","string_or_numeric");x(n<=e.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:e};const o={dim:n};return Ur.runKernel(se,s,o)}const Df=pc({expandDims_:Mf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lf(t){const n=fc(t,"x","expm1");const e={x:n};return Ur.runKernel(oe,e)}const zf=pc({expm1_:Lf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(t,n){const e=fc(t,"x","tile","string_or_numeric");x(e.rank===n.length,(()=>`Error in transpose: rank of input ${e.rank} `+`must match length of reps ${n}.`));const s={x:e};const o={reps:n};return Ur.runKernel(Zs,s,o)}const Vf=pc({tile_:Pf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(t,n,e,s="float32"){if(n==null){n=t}const o=ba([t,n],s);const r=t<=n?t:n;for(let t=0;t<r;++t){o.set(1,t,t)}const i=yu(o.toTensor(),[t,n]);if(e==null){return i}else{if(e.length===1){return Vf(Df(i,0),[e[0],1,1])}else if(e.length===2){return Vf(Df(Df(i,0),0),[e[0],e[1],1,1])}else if(e.length===3){return Vf(Df(Df(Df(i,0),0),0),[e[0],e[1],e[2],1,1])}else{throw new Error(`eye() currently supports only 1D and 2D `+`batchShapes, but received ${e.length}D.`)}}}const Wf=pc({eye_:Bf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(t){const n=fc(t,"x","floor","float32");const e={x:n};return Ur.runKernel(ae,e)}const Uf=pc({floor_:Gf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hf(t,n,e=0,s=0){const o=fc(t,"x","gather");const r=fc(n,"indices","gather","int32");const i={x:o,indices:r};const c={axis:e,batchDims:s};return Ur.runKernel(fe,i,c)}const jf=pc({gather_:Hf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(t,n){let e=fc(t,"a","greater","string_or_numeric");let s=fc(n,"b","greater","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(de,o)}const Xf=pc({greater_:qf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kf(t,n){let e=fc(t,"a","greaterEqual","string_or_numeric");let s=fc(n,"b","greaterEqual","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(pe,o)}const Jf=pc({greaterEqual_:Kf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yf(t){const n=fc(t,"input","imag");const e={input:n};return Ur.runKernel(be,e)}const Zf=pc({imag_:Yf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qf(t){const n=fc(t,"x","isFinite");const e={x:n};return Ur.runKernel(ge,e)}const th=pc({isFinite_:Qf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nh(t){const n=fc(t,"x","isInf");const e={x:n};return Ur.runKernel(we,e)}const eh=pc({isInf_:nh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(t){const n=fc(t,"x","isNaN");const e={x:n};return Ur.runKernel(ve,e)}const oh=pc({isNaN_:sh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rh(t,n=.2){const e=fc(t,"x","leakyRelu");const s={x:e};const o={alpha:n};return Ur.runKernel($e,s,o)}const ih=pc({leakyRelu_:rh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ch(t,n){let e=fc(t,"a","less","string_or_numeric");let s=fc(n,"b","less","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(ye,o)}const ah=pc({less_:ch});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(t,n){let e=fc(t,"a","lessEqual","string_or_numeric");let s=fc(n,"b","lessEqual","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(ke,o)}const lh=pc({lessEqual_:uh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fh(t,n=5,e=1,s=1,o=.5){const r=fc(t,"x","localResponseNormalization");x(r.rank===4||r.rank===3,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${r.rank}.`));x($(n),(()=>`Error in localResponseNormalization: depthRadius must be an `+`integer but got depthRadius ${n}.`));let i=r;let c=false;if(r.rank===3){c=true;i=yu(r,[1,r.shape[0],r.shape[1],r.shape[2]])}const a={x:i};const u={depthRadius:n,bias:e,alpha:s,beta:o};const l=Ur.runKernel(Ae,a,u);if(c){return yu(l,[l.shape[1],l.shape[2],l.shape[3]])}else{return l}}const hh=pc({localResponseNormalization_:fh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dh(t){const n=fc(t,"x","log","float32");const e={x:n};return Ur.runKernel(Ne,e)}const ph=pc({log_:dh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(t){const n=fc(t,"x","log1p");const e={x:n};return Ur.runKernel(Re,e)}const xh=pc({log1p_:mh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bh(t,n){x(P(t),(()=>"The f passed in variableGrads(f) must be a function"));x(n==null||Array.isArray(n)&&n.every((t=>t instanceof Cr)),(()=>"The varList passed in variableGrads(f, varList) must be an array "+"of variables"));const e=n!=null;if(!e){n=[];for(const t in Ur.registeredVariables){n.push(Ur.registeredVariables[t])}}const s=e?n.filter((t=>!t.trainable)):null;const o=n.length;n=n.filter((t=>t.trainable));x(n.length>0,(()=>`variableGrads() expects at least one of the input variables to `+`be trainable, but none of the ${o} variables is `+`trainable.`));const r=true;const{value:i,grads:c}=Ur.gradients(t,n,null,r);x(c.some((t=>t!=null)),(()=>"Cannot find a connection between any variable and the result of "+"the loss function y=f(x). Please make sure the operations that "+"use variables are inside the function f passed to minimize()."));x(i.rank===0,(()=>`The f passed in variableGrads(f) must return a scalar, but it `+`returned a rank-${i.rank} tensor`));const a={};n.forEach(((t,n)=>{if(c[n]!=null){a[t.name]=c[n]}}));if(s!=null){s.forEach((t=>a[t.name]=null))}return{value:i,grads:a}}function gh(t){return Ur.customGrad(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wh(t){const n=fc(t,"x","neg");const e={x:n};return Ur.runKernel(qe,e)}const vh=pc({neg_:wh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $h(t){const n=fc(t,"x","softplus");const e={x:n};return Ur.runKernel(As,e)}const yh=pc({softplus_:$h});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kh(t){const n=fc(t,"x","logSigmoid");const e=gh((t=>{const n=vh(yh(vh(t)));const e=n=>{const e=Aa(n,Ou(vh(t)));return e};return{value:n,gradFunc:e}}));return e(n)}const Ch=pc({logSigmoid_:kh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nh(t,n){let e=fc(t,"a","sub");let s=fc(n,"b","sub");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(Ks,o)}const Rh=pc({sub_:Nh});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(t,n=-1){const e=fc(t,"logits","logSoftmax");if(n===-1){n=e.rank-1}if(n!==e.rank-1){throw Error("Log Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${e.rank} and axis was ${n}`)}const s=gh(((t,e)=>{const s=true;const o=xf(t,n,true);const r=Rh(t,o);const i=Rh(wa(r,"float32"),ph(Sf(_f(r),n,s)));e([i]);const c=(t,e)=>{const[s]=e;const o=true;const r=_f(s);return Rh(t,Aa(Sf(t,n,o),r))};return{value:i,gradFunc:c}}));return s(e)}const Eh=pc({logSoftmax_:Sh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Th(t,n=null,e=false){const s=fc(t,"x","logSumExp");const o=R(n,s.shape);const r=xf(s,o,true);const i=Rh(s,r);const c=_f(i);const a=Sf(c,o);const u=ph(a);const l=Na(yu(r,u.shape),u);if(e){const t=lf(l.shape,o);return yu(l,t)}return l}const Ih=pc({logSumExp_:Th});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ah(t,n){const e=fc(t,"a","logicalAnd","bool");const s=fc(n,"b","logicalAnd","bool");Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(Se,o)}const Oh=pc({logicalAnd_:Ah});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fh(t){const n=fc(t,"x","logicalNot","bool");const e={x:n};return Ur.runKernel(Ee,e)}const _h=pc({logicalNot_:Fh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mh(t,n){const e=fc(t,"a","logicalOr","bool");const s=fc(n,"b","logicalOr","bool");Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(Te,o)}const Dh=pc({logicalOr_:Mh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(t,n){const e=fc(t,"a","logicalXor","bool");const s=fc(n,"b","logicalXor","bool");Gl(e.shape,s.shape);return Oh(Dh(t,n),_h(Oh(t,n)))}const zh=pc({logicalXor_:Lh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(t,n,e,s,o){const r=fc(t,"x","maxPool");const i=1;let c=r;let a=false;if(r.rank===3){a=true;c=yu(r,[1,r.shape[0],r.shape[1],r.shape[2]])}x(c.rank===4,(()=>`Error in maxPool: input must be rank 4 but got rank ${c.rank}.`));x(bu(e,i),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${i}'`));vu("maxPool",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o};const f=Ur.runKernel(Me,u,l);if(a){return yu(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const Vh=pc({maxPool_:Ph});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bh(t,n=[1,1,1],e,s,o,r="NDHWC"){const i=fc(t,"x","maxPool3d");let c=i;let a=false;if(i.rank===4){a=true;c=yu(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}x(c.rank===5,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${c.rank}.`));x(r==="NDHWC",(()=>`Error in maxPool3d: Only NDHWC is currently supported, `+`but got dataFormat of ${r}`));vu("maxPool3d",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o,dataFormat:r};const f=Ur.runKernel(Le,u,l);if(a){return yu(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const Wh=pc({maxPool3d_:Bh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gh(t,n){let e=fc(t,"a","maximum");let s=fc(n,"b","maximum");[e,s]=Mr(e,s);if(e.dtype==="bool"){e=wa(e,"int32");s=wa(s,"int32")}Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(_e,o)}const Uh=pc({maximum_:Gh});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hh(t,n=null,e=false){const s=fc(t,"x","mean");const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(Ve,o,r)}const jh=pc({mean_:Hh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qh(t,n="float32"){X(t);if(n==="complex64"){const n=qh(t,"float32");const e=qh(t,"float32");return xc(n,e)}const e=j(w(t),n);return Ur.makeTensor(e,t,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xh(t,n="float32"){X(t);if(n==="complex64"){const n=Xh(t,"float32");const e=qh(t,"float32");return xc(n,e)}const e=H(w(t),n);return Ur.makeTensor(e,t,n)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kh(t,n){let e=fc(t,"a","minimum");let s=fc(n,"b","minimum");[e,s]=Mr(e,s);if(e.dtype==="bool"){e=wa(e,"int32");s=wa(s,"int32")}Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(We,o)}const Jh=pc({minimum_:Kh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yh(t,n,e){x(e==="reflect"||e==="symmetric",(()=>`Invalid mode. Mode must be either reflect or symmetric. `+`Got ${e}.`));const s=fc(t,"x","mirrorPad");if(s.rank===0){throw new Error("mirrorPad(scalar) is not defined. "+"Pass non-scalar to mirrorPad")}x(n.length===s.rank,(()=>`Padding doesn't match input. Must be ${s.rank}. `+`Got ${n.length}.`));const o=e==="reflect"?1:0;for(let t=0;t<s.rank;t++){x(n[t].length===2,(()=>`Invalid number of paddings. Must be length of 2 each.`));x(n[t][0]>=0&&n[t][0]<=s.shape[t]-o&&n[t][1]>=0&&n[t][1]<=s.shape[t]-o,(()=>`Padding in dimension ${t} cannot be greater than or equal `+`to ${s.shape[t]-o} or less than 0 for input of `+`shape ${s.shape}`))}const r={paddings:n,mode:e};const i={x:s};return Ur.runKernel(Ge,i,r)}const Zh=pc({mirrorPad_:Yh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(t,n){let e=fc(t,"a","mod");let s=fc(n,"b","mod");[e,s]=Mr(e,s);const o={a:e,b:s};return Ur.runKernel(Ue,o)}const td=pc({mod_:Qh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nd(t,n=null,e=false){t=fc(t,"x","moments");const s=R(n,t.shape);const o=jh(t,s,e);let r=o.shape;if(!e){r=lf(o.shape,s)}const i=Nf(Rh(wa(t,"float32"),yu(o,r)));const c=jh(i,s,e);return{mean:o,variance:c}}const ed=pc({moments_:nd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sd(t,n){let e=fc(t,"a","notEqual","string_or_numeric");let s=fc(n,"b","notEqual","string_or_numeric");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};return Ur.runKernel(Xe,o)}const od=pc({notEqual_:sd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rd(t,n,e=1,s=0,o="int32"){if(n<2){throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`)}const r=fc(t,"indices","oneHot","int32");const i={indices:r};const c={dtype:o,depth:n,onValue:e,offValue:s};return Ur.runKernel(Qe,i,c)}const id=pc({oneHot_:rd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cd(t){const n=fc(t,"x","onesLike");const e={x:n};return Ur.runKernel(Ze,e)}const ad=pc({onesLike_:cd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(t,n,e=0){const s=fc(t,"x","pad");if(s.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}const o={paddings:n,constantValue:e};const r={x:s};return Ur.runKernel(ns,r,o)}const ld=pc({pad_:ud});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fd(t,n,e){const s=fc(t,"x","spaceToBatchND");x(s.rank>=1+n.length,(()=>`input rank ${s.rank} should be > than [blockShape] ${n.length}`));x(e.length===n.length,(()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`));x(s.shape.reduce(((t,s,o)=>{if(o>0&&o<=n.length){return t&&(s+e[o-1][0]+e[o-1][1])%n[o-1]===0}return t}),true),(()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`));const o={x:s};const r={blockShape:n,paddings:e};return Ur.runKernel(_s,o,r)}const hd=pc({spaceToBatchND_:fd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(t,n,e,s,o,r,i){if(o==null){o=[1,1]}if(r==null){r=1}if(s===0){s="valid"}const c=fc(t,"x","maxPool");let a=c;let u=false;if(c.rank===3){u=true;a=yu(c,[1,c.shape[0],c.shape[1],c.shape[2]])}x(bu(r,o),(()=>"Error in pool: Either strides or dilations must be 1. "+`Got strides ${r} and dilations '${o}'`));const l=su(a.shape,n,r,o,s);const f=[l.dilationHeight,l.dilationWidth];let h;if(s==="same"){h=md([l.filterHeight,l.filterWidth],f)}else{h=[[0,0],[0,0]]}const d=f[0]===1&&f[1]===1;const[p,m]=pd([l.inHeight,l.inWidth],f,h);const b=d?s:"valid";const g=d?a:hd(a,f,p);const w=e==="avg"?()=>Cu(g,n,r,b,i):()=>Vh(g,n,r,b,i);const v=w();const $=d?v:zu(v,f,m);if(u){return yu($,[$.shape[1],$.shape[2],$.shape[3]])}return $}function pd(t,n,e){const s=e.map((t=>t[0]));const o=e.map((t=>t[1]));const r=t.concat(s,o);const i=n.map(((t,n)=>(t-r[n]%t)%t));const c=o.map(((t,n)=>t+i[n]));const a=n.map(((t,n)=>[s[n],c[n]]));const u=n.map(((t,n)=>[0,i[n]]));return[a,u]}function md(t,n){const e=t.map(((t,e)=>t+(t-1)*(n[e]-1)));const s=e.map((t=>t-1));const o=s.map((t=>Math.floor(t/2)));const r=s.map(((t,n)=>t-o[n]));return s.map(((t,n)=>[o[n],r[n]]))}const xd=pc({pool_:dd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bd(t,n){const e=fc(t,"x","prelu");const s=fc(n,"alpha","prelu");const o={x:e,alpha:s};return Ur.runKernel(ss,o)}const gd=pc({prelu_:bd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(t,n=null,e=false){let s=fc(t,"x","prod");if(s.dtype==="bool"){s=wa(s,"int32")}const o={x:s};const r={axis:n,keepDims:e};return Ur.runKernel(os,o,r)}const vd=pc({prod_:wd});var $d={exports:{}};var yd=$d.exports;var kd;function Cd(){if(kd)return $d.exports;kd=1;(function(t){(function(t,n,e){function s(t){var n=this,e=i();n.next=function(){var t=2091639*n.s0+n.c*2.3283064365386963e-10;n.s0=n.s1;n.s1=n.s2;return n.s2=t-(n.c=t|0)};n.c=1;n.s0=e(" ");n.s1=e(" ");n.s2=e(" ");n.s0-=e(t);if(n.s0<0){n.s0+=1}n.s1-=e(t);if(n.s1<0){n.s1+=1}n.s2-=e(t);if(n.s2<0){n.s2+=1}e=null}function o(t,n){n.c=t.c;n.s0=t.s0;n.s1=t.s1;n.s2=t.s2;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=e.next;i.int32=function(){return e.next()*4294967296|0};i.double=function(){return i()+(i()*2097152|0)*11102230246251565e-32};i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}function i(){var t=4022871197;var n=function(n){n=String(n);for(var e=0;e<n.length;e++){t+=n.charCodeAt(e);var s=.02519603282416938*t;t=s>>>0;s-=t;s*=t;t=s>>>0;s-=t;t+=s*4294967296}return(t>>>0)*2.3283064365386963e-10};return n}if(n&&n.exports){n.exports=r}else{this.alea=r}})(yd,t)})($d);return $d.exports}var Nd={exports:{}};var Rd=Nd.exports;var Sd;function Ed(){if(Sd)return Nd.exports;Sd=1;(function(t){(function(t,n,e){function s(t){var n=this,e="";n.x=0;n.y=0;n.z=0;n.w=0;n.next=function(){var t=n.x^n.x<<11;n.x=n.y;n.y=n.z;n.z=n.w;return n.w^=n.w>>>19^t^t>>>8};if(t===(t|0)){n.x=t}else{e+=t}for(var s=0;s<e.length+64;s++){n.x^=e.charCodeAt(s)|0;n.next()}}function o(t,n){n.x=t.x;n.y=t.y;n.z=t.z;n.w=t.w;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else{this.xor128=r}})(Rd,t)})(Nd);return Nd.exports}var Td={exports:{}};var Id=Td.exports;var Ad;function Od(){if(Ad)return Td.exports;Ad=1;(function(t){(function(t,n,e){function s(t){var n=this,e="";n.next=function(){var t=n.x^n.x>>>2;n.x=n.y;n.y=n.z;n.z=n.w;n.w=n.v;return(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^(t^t<<1))|0};n.x=0;n.y=0;n.z=0;n.w=0;n.v=0;if(t===(t|0)){n.x=t}else{e+=t}for(var s=0;s<e.length+64;s++){n.x^=e.charCodeAt(s)|0;if(s==e.length){n.d=n.x<<10^n.x>>>4}n.next()}}function o(t,n){n.x=t.x;n.y=t.y;n.z=t.z;n.w=t.w;n.v=t.v;n.d=t.d;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else{this.xorwow=r}})(Id,t)})(Td);return Td.exports}var Fd={exports:{}};var _d=Fd.exports;var Md;function Dd(){if(Md)return Fd.exports;Md=1;(function(t){(function(t,n,e){function s(t){var n=this;n.next=function(){var t=n.x,e=n.i,s,o;s=t[e];s^=s>>>7;o=s^s<<24;s=t[e+1&7];o^=s^s>>>10;s=t[e+3&7];o^=s^s>>>3;s=t[e+4&7];o^=s^s<<7;s=t[e+7&7];s=s^s<<13;o^=s^s<<9;t[e]=o;n.i=e+1&7;return o};function e(t,n){var e,s=[];if(n===(n|0)){s[0]=n}else{n=""+n;for(e=0;e<n.length;++e){s[e&7]=s[e&7]<<15^n.charCodeAt(e)+s[e+1&7]<<13}}while(s.length<8)s.push(0);for(e=0;e<8&&s[e]===0;++e);if(e==8)s[7]=-1;t.x=s;t.i=0;for(e=256;e>0;--e){t.next()}}e(n,t)}function o(t,n){n.x=t.x.slice();n.i=t.i;return n}function r(t,n){if(t==null)t=+new Date;var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(r.x)o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else{this.xorshift7=r}})(_d,t)})(Fd);return Fd.exports}var Ld={exports:{}};var zd=Ld.exports;var Pd;function Vd(){if(Pd)return Ld.exports;Pd=1;(function(t){(function(t,n,e){function s(t){var n=this;n.next=function(){var t=n.w,e=n.X,s=n.i,o,r;n.w=t=t+1640531527|0;r=e[s+34&127];o=e[s=s+1&127];r^=r<<13;o^=o<<17;r^=r>>>15;o^=o>>>12;r=e[s]=r^o;n.i=s;return r+(t^t>>>16)|0};function e(t,n){var e,s,o,r,i,c=[],a=128;if(n===(n|0)){s=n;n=null}else{n=n+"\0";s=0;a=Math.max(a,n.length)}for(o=0,r=-32;r<a;++r){if(n)s^=n.charCodeAt((r+32)%n.length);if(r===0)i=s;s^=s<<10;s^=s>>>15;s^=s<<4;s^=s>>>13;if(r>=0){i=i+1640531527|0;e=c[r&127]^=s+i;o=0==e?o+1:0}}if(o>=128){c[(n&&n.length||0)&127]=-1}o=127;for(r=4*128;r>0;--r){s=c[o+34&127];e=c[o=o+1&127];s^=s<<13;e^=e<<17;s^=s>>>15;e^=e>>>12;c[o]=s^e}t.w=i;t.X=c;t.i=o}e(n,t)}function o(t,n){n.i=t.i;n.w=t.w;n.X=t.X.slice();return n}function r(t,n){if(t==null)t=+new Date;var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(r.X)o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else{this.xor4096=r}})(zd,t)})(Ld);return Ld.exports}var Bd={exports:{}};var Wd=Bd.exports;var Gd;function Ud(){if(Gd)return Bd.exports;Gd=1;(function(t){(function(t,n,e){function s(t){var n=this,e="";n.next=function(){var t=n.b,e=n.c,s=n.d,o=n.a;t=t<<25^t>>>7^e;e=e-s|0;s=s<<24^s>>>8^o;o=o-t|0;n.b=t=t<<20^t>>>12^e;n.c=e=e-s|0;n.d=s<<16^e>>>16^o;return n.a=o-t|0};n.a=0;n.b=0;n.c=2654435769|0;n.d=1367130551;if(t===Math.floor(t)){n.a=t/4294967296|0;n.b=t|0}else{e+=t}for(var s=0;s<e.length+20;s++){n.b^=e.charCodeAt(s)|0;n.next()}}function o(t,n){n.a=t.a;n.b=t.b;n.c=t.c;n.d=t.d;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else{this.tychei=r}})(Wd,t)})(Bd);return Bd.exports}var Hd={exports:{}};var jd={};var qd=Object.freeze({__proto__:null,default:jd});var Xd=No(qd);var Kd=Hd.exports;var Jd;function Yd(){if(Jd)return Hd.exports;Jd=1;(function(t){(function(n,e,s){var o=256,r=6,i=52,c="random",a=s.pow(o,r),u=s.pow(2,i),l=u*2,f=o-1,h;function d(t,n,i){var f=[];n=n==true?{entropy:true}:n||{};var h=b(x(n.entropy?[t,w(e)]:t==null?g():t,3),f);var d=new p(f);var v=function(){var t=d.g(r),n=a,e=0;while(t<u){t=(t+e)*o;n*=o;e=d.g(1)}while(t>=l){t/=2;n/=2;e>>>=1}return(t+e)/n};v.int32=function(){return d.g(4)|0};v.quick=function(){return d.g(4)/4294967296};v.double=v;b(w(d.S),e);return(n.pass||i||function(t,n,e,o){if(o){if(o.S){m(o,d)}t.state=function(){return m(d,{})}}if(e){s[c]=t;return n}else return t})(v,h,"global"in n?n.global:this==s,n.state)}function p(t){var n,e=t.length,s=this,r=0,i=s.i=s.j=0,c=s.S=[];if(!e){t=[e++]}while(r<o){c[r]=r++}for(r=0;r<o;r++){c[r]=c[i=f&i+t[r%e]+(n=c[r])];c[i]=n}(s.g=function(t){var n,e=0,r=s.i,i=s.j,c=s.S;while(t--){n=c[r=f&r+1];e=e*o+c[f&(c[r]=c[i=f&i+n])+(c[i]=n)]}s.i=r;s.j=i;return e})(o)}function m(t,n){n.i=t.i;n.j=t.j;n.S=t.S.slice();return n}function x(t,n){var e=[],s=typeof t,o;if(n&&s=="object"){for(o in t){try{e.push(x(t[o],n-1))}catch(t){}}}return e.length?e:s=="string"?t:t+"\0"}function b(t,n){var e=t+"",s,o=0;while(o<e.length){n[f&o]=f&(s^=n[f&o]*19)+e.charCodeAt(o++)}return w(n)}function g(){try{var t;if(h&&(t=h.randomBytes)){t=t(o)}else{t=new Uint8Array(o);(n.crypto||n.msCrypto).getRandomValues(t)}return w(t)}catch(t){var s=n.navigator,r=s&&s.plugins;return[+new Date,n,r,n.screen,w(e)]}}function w(t){return String.fromCharCode.apply(0,t)}b(s.random(),e);if(t.exports){t.exports=d;try{h=Xd}catch(t){}}else{s["seed"+c]=d}})(typeof self!=="undefined"?self:Kd,[],Math)})(Hd);return Hd.exports}var Zd;var Qd;function tp(){if(Qd)return Zd;Qd=1;var t=Cd();var n=Ed();var e=Od();var s=Dd();var o=Vd();var r=Ud();var i=Yd();i.alea=t;i.xor128=n;i.xorwow=e;i.xorshift7=s;i.xor4096=o;i.tychei=r;Zd=i;return Zd}var np=tp();
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ep{constructor(t,n,e,s,o){this.mean=t;this.stdDev=n;this.dtype=e;this.nextVal=NaN;this.truncated=s;if(this.truncated){this.upper=this.mean+this.stdDev*2;this.lower=this.mean-this.stdDev*2}const r=o?o:Math.random();this.random=np.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;this.nextVal=NaN;return t}let t,n;let e=false;while(!e){let s,o,r;do{s=2*this.random()-1;o=2*this.random()-1;r=s*s+o*o}while(r>=1||r===0);const i=Math.sqrt(-2*Math.log(r)/r);t=this.mean+this.stdDev*s*i;n=this.mean+this.stdDev*o*i;if(!this.truncated||this.isValidTruncated(t)){e=true}}if(!this.truncated||this.isValidTruncated(n)){this.nextVal=this.convertValue(n)}return this.convertValue(t)}convertValue(t){if(this.dtype==null||this.dtype==="float32"){return t}return Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class sp{constructor(t=0,n=1,e,s){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";this.min=t;this.range=n-t;this.dtype=e;if(s==null){s=Math.random()}if(typeof s==="number"){s=s.toString()}if(!this.canReturnFloat()&&this.range<=1){throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`)}this.random=np.alea(s)}convertValue(t){if(this.canReturnFloat()){return t}return Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function op(t,n=0,e=1,s,o){X(t);if(s!=null&&s==="bool"){throw new Error(`Unsupported data type ${s}`)}const r=new ep(n,e,s,false,o);const i=ba(t,s);for(let t=0;t<i.values.length;t++){i.values[t]=r.nextValue()}return i.toTensor()}const rp=pc({randomNormal_:op});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ip(t,n=0,e=1,s="float32",o){X(t);const r=ba(t,s);const i=new sp(n,e,null,o);for(let t=0;t<r.values.length;t++){r.values[t]=i.nextValue()}return r.toTensor()}const cp=pc({randomUniform_:ip});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ap(t,n,e=1,s="float32"){if(e===0){throw new Error("Cannot have a step of zero")}const o={start:t,stop:n,step:e,dtype:s};return Ur.runKernel(as,{},o)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function up(t){const n=fc(t,"input","real");const e={input:n};return Ur.runKernel(us,e)}const lp=pc({real_:up});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fp(t){const n=fc(t,"x","reciprocal");const e={x:n};return Ur.runKernel(ls,e)}const hp=pc({reciprocal_:fp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(t){const n=fc(t,"x","relu");const e={x:n};return Ur.runKernel(fs,e)}const pp=pc({relu_:dp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(t){const n=fc(t,"x","relu6");const e={x:n};return Ur.runKernel(bs,e)}const xp=pc({relu6_:mp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bp(t,n){const e=fc(t,"x","reverse");const s={x:e};const o={dims:n};return Ur.runKernel(gs,s,o)}const gp=pc({reverse_:bp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wp(t){const n=fc(t,"x","round");const e={x:n};return Ur.runKernel(ws,e)}const vp=pc({round_:wp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $p(t){const n=fc(t,"x","rsqrt","float32");const e={x:n};return Ur.runKernel(vs,e)}const yp=pc({rsqrt_:$p});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(t){const n=fc(t,"x","selu");const e={x:n};return Ur.runKernel(Ns,e)}const Cp=pc({selu_:kp});function Np(t,n,e,s,o,r=[1,1],i="NHWC"){const c=fc(t,"x","separableConv2d");const a=fc(n,"depthwiseFilter","separableConv2d");const u=fc(e,"pointwiseFilter","separableConv2d");let l=c;let f=false;if(c.rank===3){f=true;l=yu(c,[1,c.shape[0],c.shape[1],c.shape[2]])}if(i==="NCHW"){throw new Error("separableConv2d currently does not support dataFormat NCHW; only "+"NHWC is supported")}x(l.rank===4,(()=>`Error in separableConv2d: input must be rank 4, but got `+`rank ${l.rank}.`));x(a.rank===4,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but `+`got rank ${a.rank}.`));x(u.rank===4,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but `+`got rank ${a.rank}.`));x(u.shape[0]===1,(()=>`Error in separableConv2d: the first dimension of pointwise filter `+` must be 1, but got ${u.shape[0]}.`));x(u.shape[1]===1,(()=>`Error in separableConv2d: the second dimension of pointwise `+`filter must be 1, but got ${u.shape[1]}.`));const h=a.shape[2];const d=a.shape[3];x(u.shape[2]===h*d,(()=>`Error in separableConv2d: the third dimension of pointwise filter `+`must be ${h*d}, `+`but got ${u.shape[2]}.`));const p=zl(l,a,s,o,i,r);const m=1;const b=hl(p,u,m,"valid",i);if(f){return yu(b,[b.shape[1],b.shape[2],b.shape[3]])}return b}const Rp=pc({separableConv2d_:Np});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sp(t){const n=fc(t,"x","sign");const e={x:n};return Ur.runKernel(Ts,e)}const Ep=pc({sign_:Sp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tp(t){const n=fc(t,"x","sin","float32");const e={x:n};return Ur.runKernel(Ss,e)}const Ip=pc({sin_:Tp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(t){const n=fc(t,"x","sinh");const e={x:n};return Ur.runKernel(Es,e)}const Op=pc({sinh_:Ap});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fp(t,n,e){const s=fc(t,"x","slice1d");x(s.rank===1,(()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`));return _u(s,[n],[e])}const _p=pc({slice1d_:Fp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mp(t,n,e){const s=fc(t,"x","slice2d");x(s.rank===2,(()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`));return _u(s,n,e)}const Dp=pc({slice2d_:Mp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(t,n,e){const s=fc(t,"x","slice3d");x(s.rank===3,(()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`));return _u(s,n,e)}const zp=pc({slice3d_:Lp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pp(t,n,e){const s=fc(t,"x","slice4d");x(s.rank===4,(()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`));return _u(s,n,e)}const Vp=pc({slice4d_:Pp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bp(t,n=-1){const e=fc(t,"logits","softmax","float32");if(n===-1){n=e.rank-1}if(n!==e.rank-1){throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${e.rank} and dim was ${n}`)}const s={logits:e};const o={dim:n};return Ur.runKernel(Ds,s,o)}const Wp=pc({softmax_:Bp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gp(t){x(t.dtype==="complex64",(()=>`The dtype for tf.spectral.fft() must be complex64 `+`but got ${t.dtype}.`));const n={input:t};return Ur.runKernel(re,n)}const Up=pc({fft_:Gp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hp(t){x(t.dtype==="complex64",(()=>`The dtype for tf.spectral.ifft() must be complex64 `+`but got ${t.dtype}.`));const n={input:t};return Ur.runKernel(xe,n)}const jp=pc({ifft_:Hp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qp(t){const n=t.shape[t.shape.length-1];const e=t.size/n;let s;if(n<=2){const o=yu(t,[e,n]);s=jp(o)}else{const o=[e,2*(n-1)];const r=yu(lp(t),[e,n]);const i=yu(Zf(t),[e,n]);const c=gp(_u(r,[0,1],[e,n-2]),1);const a=Aa(gp(_u(i,[0,1],[e,n-2]),1),$f(-1));const u=Eu([r,c],1);const l=Eu([i,a],1);const f=yu(xc(u,l),[o[0],o[1]]);s=jp(f)}s=lp(s);if(t.rank===3&&t.shape[0]!==0){const n=s;const e=t.shape[0];s=yu(s,[e,s.shape[0]/e,s.shape[1]]);n.dispose()}return s}const Xp=pc({irfft_:qp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(t,n,e=0){const s=fc(t,"x","split");const o={x:s};const r={numOrSizeSplits:n,axis:e};return Ur.runKernel(Ms,o,r)}const Jp=pc({split_:Kp});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yp(t,n){x(t.dtype==="float32",(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let e=t.shape[t.shape.length-1];const s=t.size/e;let o;if(n!=null&&n<e){const s=t.shape.map((t=>0));const r=t.shape.map((t=>t));r[t.shape.length-1]=n;o=_u(t,s,r);e=n}else if(n!=null&&n>e){const s=t.shape.map((t=>t));s[t.shape.length-1]=n-e;o=Eu([t,qh(s)],t.shape.length-1);e=n}else{o=t}const r=Kl(o);const i=yu(xc(o,r),[s,e]);const c=Up(i);const a=Math.floor(e/2)+1;const u=lp(c);const l=Zf(c);const f=Jp(u,[a,e-a],u.shape.length-1);const h=Jp(l,[a,e-a],l.shape.length-1);const d=o.shape.slice();d[o.shape.length-1]=a;return yu(xc(f[0],h[0]),d)}const Zp=pc({rfft_:Yp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qp(t,n){let e=fc(t,"a","squaredDifference");let s=fc(n,"b","squaredDifference");[e,s]=Mr(e,s);Gl(e.shape,s.shape);const o={a:e,b:s};const r={};return Ur.runKernel(Ws,o,r)}const tm=pc({squaredDifference_:Qp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nm(t,n){const e=fc(t,"x","squeeze","string_or_numeric");return yu(e,S(e.shape,n).newShape)}const em=pc({squeeze_:nm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sm(t,n=0){const e=hc(t,"tensors","stack","string_or_numeric");x(e.length>=1,(()=>"Pass at least one tensor to tf.stack"));if(e.length>0){x(n<=e[0].rank,(()=>"Axis must be <= rank of the tensor"))}const s=e;const o={axis:n};return Ur.runKernel(ts,s,o)}const om=pc({stack_:sm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rm(t,n=0){const e=fc(t,"x","step");const s={x:e};const o={alpha:n};return Ur.runKernel(io,s,o)}const im=pc({step_:rm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cm(t,n,e,s,o=0,r=0,i=0,c=0,a=0){const u=fc(t,"x","stridedSlice","string_or_numeric");const l={x:u};const f={begin:n,end:e,strides:s,beginMask:o,endMask:r,ellipsisMask:i,newAxisMask:c,shrinkAxisMask:a};return Ur.runKernel(Hs,l,f)}const am=pc({stridedSlice_:cm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function um(t){const n=fc(t,"x","tan","float32");const e={x:n};return Ur.runKernel(Js,e)}const lm=pc({tan_:um});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fm(t,n){g(t);const e=ac(t,n);if(e.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}const s=null;return bc(t,s,e,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hm(t,n,e){g(t);if(n!=null&&n.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}const s=ac(t,e);if(s.length!==2&&s.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(s.length===1&&n==null){throw new Error("tensor2d() requires shape to be provided when `values` "+"are a flat/TypedArray")}return bc(t,n,s,e)}function dm(t,n,e){const s=n.rank>1?n.shape[n.rank-1]:1;const o=n.rank>1?n.rank-1:1;const r="Must have updates.shape = indices.shape[:batchDim] + "+`shape[sliceDim:], got updates.shape: ${e.shape}`+`, indices.shape: ${n.shape}, shape: ${t}`+`, sliceDim: ${s}, and batchDim: ${o}.`;if(e.rank<o){throw new Error(r+` update.rank < ${o}. `)}if(t.length<s+(e.rank-o)){throw new Error(r+` Output shape length < ${s+(e.rank-o)}`)}if(e.rank!==o+t.length-s){throw new Error(r+` update.rank != ${o+t.length-s}`)}for(let t=0;t<o;++t){if(e.shape[t]!==n.shape[t]){throw new Error(r+` updates.shape[${t}] (${e.shape[t]}) != indices.shape[${t}] (${n.shape[t]}).`)}}for(let n=0;n<e.rank-o;++n){if(e.shape[n+o]!==t[n+s]){throw new Error(r+` updates.shape[${n+o}] (${e.shape[n+o]}) != shape[${n+o}] (${t[n+o]})`)}}}function pm(t,n,e){if(n.rank<1){throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+` but the rank was ${n.rank}.`)}if(t.rank<1){throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+` but the rank was ${t.rank}.`)}if(n.dtype!=="int32"){throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`)}if(e.length<1){throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`)}if(e.length===0){if(n.size===0){throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`)}if(t.size===0){throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}}dm(e,n,t)}function mm(t,n,e){const s=n.shape.length;const o=s>1?n.shape[s-1]:1;const r=e.length;let i=1;for(let t=o;t<r;++t){i*=e[t]}const c=o<1?1:o;const a=w(n.shape)/c;const u=[...B(e.slice(0,o)),1];const l=w(e);return{sliceRank:o,numUpdates:a,sliceSize:i,strides:u,outputSize:l}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xm(t,n=1,e=true){const s=fc(t,"x","topk");if(s.rank===0){throw new Error("topk() expects the input to be of rank 1 or higher")}const o=s.shape[s.shape.length-1];if(n<0){throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`)}if(n>o){throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) `+`but got ${n}`)}const r={x:s};const i={k:n,sorted:e};const[c,a]=Ur.runKernel(Qs,r,i);return{values:c,indices:a}}const bm=pc({topk_:xm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gm(t,n=0,e=1,s,o){X(t);if(s!=null&&s==="bool"){throw new Error(`Unsupported data type $ { dtype }`)}const r=new ep(n,e,s,true,o);const i=ba(t,s);for(let t=0;t<i.values.length;t++){i.values[t]=r.nextValue()}return i.toTensor()}const wm=pc({truncatedNormal_:gm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vm(t,n=0){const e=fc(t,"x","unique","string_or_numeric");x(e.rank>0,(()=>"The input tensor must be at least 1D"));const s={x:e};const o={axis:n};const[r,i]=Ur.runKernel(eo,s,o);return{values:r,indices:i}}const $m=pc({unique_:vm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ym(t,n,e){const s=fc(t,"x","unsortedSegmentSum");const o=fc(n,"segmentIds","unsortedSegmentSum","int32");x($(e),(()=>"numSegments must be of dtype int"));const r={x:s,segmentIds:o};const i={numSegments:e};return Ur.runKernel(oo,r,i)}const km=pc({unsortedSegmentSum_:ym});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cm(t,n=0){const e=fc(t,"x","unstack","string_or_numeric");x(n>=-e.shape.length&&n<e.shape.length,(()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`));const s={value:e};const o={axis:n};return Ur.runKernel(so,s,o)}const Nm=pc({unstack_:Cm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rm(t,n=true,e,s){return Ur.makeVariable(t,n,e,s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sm(t,n){const e=[];for(let t=0;t<n.length;t++){if(n[t]){e.push(t)}}const s=ba(t,"int32");const o=ba([e.length,t.length],"int32");for(let n=0;n<e.length;n++){const r=s.indexToLoc(e[n]);const i=n*t.length;o.values.set(r,i)}return o.toTensor()}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Em(t,n,e){const s=fc(t,"x","transpose");if(n==null){n=s.shape.map(((t,n)=>n)).reverse()}x(s.rank===n.length,(()=>`Error in transpose: rank of input ${s.rank} `+`must match length of perm ${n}.`));n.forEach((t=>{x(t>=0&&t<s.rank,(()=>`All entries in 'perm' must be between 0 and ${s.rank-1}`+` but got ${n}`))}));if(s.rank<=1){return s.clone()}const o={x:s};const r={perm:n};if(s.dtype==="complex64"){return kc((()=>{let t=lp(s);let n=Zf(s);t=Ur.runKernel(no,{x:t},r);n=Ur.runKernel(no,{x:n},r);if(e){n=vh(n)}return xc(t,n)}))}return Ur.runKernel(no,o,r)}const Tm=pc({transpose_:Em});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Im(t,n){if(n==null){return t.shape.slice()}if(v(t.shape,n)){return n}if(t.shape.length===n.length){const e=[];for(let s=0;s<t.shape.length;s++){if(n[s]==null&&t.shape[s]!=null){e.push(t.shape[s])}else{e.push(n[s])}}return e}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Am(t,n,e,s){const o=fc(t,"x","dropout");x(o.dtype==="float32",(()=>`x has to be a floating point tensor since it's going to be `+`scaled, but got a ${o.dtype} tensor instead.`));x(n>=0&&n<1,(()=>`rate must be a float in the range [0, 1), but got ${n}.`));if(n===0){return t instanceof yr?o.clone():o}const r=Im(o,e);const i=1-n;const c=Ta(Uf(Na(cp(r,0,1,"float32",s),i)),i);return Aa(o,c)}const Om=pc({dropout_:Am});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fm(t,n,e,s,o,r="NHWC",i){let c=t;if(t.rank===3){c=yu(t,[1,t.shape[0],t.shape[1],t.shape[2]])}let a=n;if(a.rank===3){a=yu(n,[1,n.shape[0],n.shape[1],n.shape[2]])}x(c.rank===4,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape `+`${c.shape}.`));x(a.rank===4,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape `+`${a.shape}.`));x(e.length===4,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got `+`${e}.`));const u=r==="NHWC"?c.shape[3]:c.shape[1];const l=r==="NHWC"?a.shape[3]:a.shape[1];x(u===e[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must `+`match input depth in filter (${e[2]}.`));x(l===e[3],(()=>`Error in conv2dDerFilter: depth of dy (${l}) must `+`match output depth for filter (${e[3]}).`));vu("conv2dDerFilter",o,i);const f={x:c,dy:a};const h={strides:s,pad:o,dataFormat:r,dimRoundingMode:i,filterShape:e};return Ur.runKernel(In,f,h)}const _m=pc({conv2DBackpropFilter_:Fm});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(t,n,e){if(e==null||e==="linear"){return t}if(e==="relu"){return Aa(t,im(n))}throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Dm(t,n){let e=n;const s=Wl(t.shape,n.shape);if(s.length>0){e=Sf(e,s)}return yu(e,t.shape)}function Lm(t,n,e,s){if(n==="linear"){return t}else if(n==="relu"){return pp(t)}else if(n==="elu"){return sf(t)}else if(n==="relu6"){return xp(t)}else if(n==="prelu"){return gd(t,e)}else if(n==="leakyrelu"){return ih(t,s)}else if(n==="sigmoid"){return Ou(t)}throw new Error(`Unknown fused activation ${n}.`)}const zm=(t,n)=>{const e=t>0;return!e||n==="linear"};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pm({x:t,filter:n,strides:e,pad:s,dataFormat:o="NHWC",dilations:r=[1,1],dimRoundingMode:i,bias:c,activation:a="linear",preluActivationWeights:u,leakyreluAlpha:l}){a=a||"linear";if(zm(Ur.state.gradientDepth,a)===false){x(o==="NHWC",(()=>`Error in fused conv2d: got dataFormat of ${o} but `+`only NHWC is currently supported for the case of gradient depth `+`is 0 and the activation is not linear.`));let f=hl(t,n,e,s,o,r,i);if(c!=null){f=Na(f,c)}return Lm(f,a,u,l)}const f=fc(t,"x","conv2d","float32");const h=fc(n,"filter","conv2d","float32");let d=f;let p=false;if(f.rank===3){p=true;d=yu(f,[1,f.shape[0],f.shape[1],f.shape[2]])}x(d.rank===4,(()=>`Error in fused conv2d: input must be rank 4, but got rank `+`${d.rank}.`));x(h.rank===4,(()=>`Error in fused conv2d: filter must be rank 4, but got rank `+`${h.rank}.`));vu("fused conv2d",s,i);const m=o==="NHWC"?d.shape[3]:d.shape[1];x(h.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match `+`input depth for filter ${h.shape[2]}.`));x(bu(e,r),(()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));const b=ru(d.shape,h.shape,e,r,s,i);let g;if(c!=null){g=fc(c,"bias","fused conv2d");[g]=Mr(g,f);if(o==="NHWC"){Gl(b.outShape,g.shape)}else{x(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor `+`bias for NCHW format but got the bias of `+`rank-${g.shape.length}.`));x(g.shape.length===0||g.shape[0]===b.outChannels||g.shape[0]===1,(()=>`Error in fused conv2d: bias shape (${g.shape}) is not `+`compatible with the number of output channels `+`(${b.outChannels})`))}}let w;if(u!=null){const t=u.shape;x(t.length<=1||t.length===3,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or `+`3-D Tensor PReLU activation weights but got a tensor of `+`rank-${t.length}.`));if(t.length===1){x(t[0]===1||t[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights `+`(${t}) is not compatible with the number of output `+`channels (${b.outChannels}).`))}else if(t.length===3){try{Gl(t,b.outShape)}catch(n){const e=`Error in fused conv2d: PReLU activation weights (${t}) `+`is not compatible with the output shape of the conv2d `+`(${b.outShape}).`;throw Error(e)}}w=fc(u,"prelu weights","fused conv2d")}const v=(t,n)=>{x(o==="NHWC",(()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`));const[i,c,u,l]=n;const f=Mm(t,u,a);x(xu(r),(()=>"Error in gradient of fused conv2D: "+`dilation rates greater than 1 `+`are not yet supported in gradients. Got dilations '${r}'`));const h=xl(c.shape,f,i,e,s);const d=_m(c,f,i.shape,e,s);const p=[h,d];if(l!=null){const t=Dm(l,f);p.push(t)}return p};const $={x:d,filter:h,bias:g,preluActivationWeights:w};const y={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i,activation:a,leakyreluAlpha:l};if(c==null){const t=gh(((t,n,e)=>{let s=Ur.runKernel(lo,$,y);e([n,t,s]);if(p){s=yu(s,[s.shape[1],s.shape[2],s.shape[3]])}return{value:s,gradFunc:v}}));return t(d,h)}else{const t=gh(((t,n,e,s)=>{let o=Ur.runKernel(lo,$,y);s([n,t,o,e]);if(p){o=yu(o,[o.shape[1],o.shape[2],o.shape[3]])}return{value:o,gradFunc:v}}));return t(d,h,g)}}const Vm=pc({fusedConv2d_:Pm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bm(t,n,e,s,o,r=[1,1],i){let c=t;if(t.rank===3){c=yu(t,[1,t.shape[0],t.shape[1],t.shape[2]])}let a=n;if(a.rank===3){a=yu(n,[1,n.shape[0],n.shape[1],n.shape[2]])}const u={x:c,dy:a};const l={strides:s,pad:o,dimRoundingMode:i,dilations:r,filterShape:e};return Ur.runKernel(Gn,u,l)}const Wm=pc({depthwiseConv2dNativeBackpropFilter_:Bm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gm(t,n,e,s,o,r=[1,1],i){let c=n;let a=false;if(n.rank===3){a=true;c=yu(n,[1,n.shape[0],n.shape[1],n.shape[2]])}const u={dy:c,filter:e};const l={strides:s,pad:o,dimRoundingMode:i,dilations:r,inputShape:t};const f=Ur.runKernel(Un,u,l);if(a){return yu(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const Um=pc({depthwiseConv2dNativeBackpropInput_:Gm});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hm({a:t,b:n,transposeA:e=false,transposeB:s=false,bias:o,activation:r="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}){if(zm(Ur.state.gradientDepth,r)===false){let a=Iu(t,n,e,s);if(o!=null){a=Na(a,o)}return Lm(a,r,i,c)}let a=fc(t,"a","fused matMul");let u=fc(n,"b","fused matMul");[a,u]=Mr(a,u);const l=e?a.shape[a.rank-2]:a.shape[a.rank-1];const f=s?u.shape[u.rank-1]:u.shape[u.rank-2];const h=e?a.shape[a.rank-1]:a.shape[a.rank-2];const d=s?u.shape[u.rank-2]:u.shape[u.rank-1];const p=a.shape.slice(0,-2);const m=u.shape.slice(0,-2);const b=w(p);const g=w(m);x(l===f,(()=>`Error in fused matMul: inner shapes (${l}) and (`+`${f}) of Tensors with shapes ${a.shape} and `+`${u.shape} and transposeA=${e}`+` and transposeB=${s} must match.`));const v=Gl(a.shape.slice(0,-2),u.shape.slice(0,-2));const $=v.concat([h,d]);const y=e?yu(a,[b,l,h]):yu(a,[b,h,l]);const k=s?yu(u,[g,d,f]):yu(u,[g,f,d]);let C;if(o!=null){C=fc(o,"bias","fused matMul");[C]=Mr(C,a);Gl($,C.shape)}let N;if(i!=null){N=fc(i,"prelu weights","fused matMul")}const R=(t,n)=>{const[i,c,a,u]=n;const l=Mm(yu(t,a.shape),a,r);let f;let h;if(!e&&!s){f=Iu(l,c,false,true);h=Iu(i,l,true,false)}else if(!e&&s){f=Iu(l,c,false,false);h=Iu(l,i,true,false)}else if(e&&!s){f=Iu(c,l,false,true);h=Iu(i,l,false,false)}else{f=Iu(c,l,true,true);h=Iu(l,i,true,true)}if(o!=null){const t=Dm(u,l);return[f,h,t]}else{return[f,h]}};const S={a:y,b:k,bias:C,preluActivationWeights:N};const E={transposeA:e,transposeB:s,activation:r,leakyreluAlpha:c};if(o==null){const t=gh(((t,n,e)=>{const s=Ur.runKernel(uo,S,E);e([t,n,s]);return{value:yu(s,$),gradFunc:R}}));return t(y,k)}else{const t=gh(((t,n,e,s)=>{const o=Ur.runKernel(uo,S,E);s([t,n,o,e]);return{value:yu(o,$),gradFunc:R}}));return t(y,k,C)}}const jm=pc({fusedMatMul_:Hm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qm(t,n,e,s,o="bilinear",r=0){const i=fc(t,"image","cropAndResize");const c=fc(n,"boxes","cropAndResize","float32");const a=fc(e,"boxInd","cropAndResize","int32");const u=c.shape[0];x(i.rank===4,(()=>"Error in cropAndResize: image must be rank 4,"+`but got rank ${i.rank}.`));x(c.rank===2&&c.shape[1]===4,(()=>`Error in cropAndResize: boxes must be have size [${u},4] `+`but had shape ${c.shape}.`));x(a.rank===1&&a.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] `+`but had shape ${c.shape}.`));x(s.length===2,(()=>`Error in cropAndResize: cropSize must be of length 2, but got `+`length ${s.length}.`));x(s[0]>=1&&s[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${s}`));x(o==="bilinear"||o==="nearest",(()=>`method must be bilinear or nearest, but was ${o}`));const l={image:i,boxes:c,boxInd:a};const f={method:o,extrapolationValue:r,cropSize:s};const h=Ur.runKernel(Pn,l,f);return h}const Xm=pc({cropAndResize_:qm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Km(t){const n=fc(t,"image","flipLeftRight","float32");x(n.rank===4,(()=>"Error in flipLeftRight: image must be rank 4,"+`but got rank ${n.rank}.`));const e={image:n};const s=Ur.runKernel(ce,e,{});return s}const Jm=pc({flipLeftRight_:Km});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(t){const n=fc(t,"image","grayscaleToRGB");const e=n.rank-1;const s=n.shape[e];x(n.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+`but got rank ${n.rank}.`));x(s===1,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+`should be size 1, but got size ${s}.`));const o=new Array(n.rank);o.fill(1,0,e);o[e]=3;return Vf(n,o)}const Zm=pc({grayscaleToRGB_:Ym});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qm(t){const n=fc(t,"image","RGBToGrayscale");const e=n.rank-1;const s=n.shape[e];x(n.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+`but got rank ${n.rank}.`));x(s===3,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+`should be size 3, but got size ${s}.`));const o=n.dtype;const r=wa(n,"float32");const i=fm([.2989,.587,.114]);let c;switch(n.rank){case 2:c=nf("ij,j->i",r,i);break;case 3:c=nf("ijk,k->ij",r,i);break;case 4:c=nf("ijkl,l->ijk",r,i);break;case 5:c=nf("ijklm,m->ijkl",r,i);break;case 6:c=nf("ijklmn,n->ijklm",r,i);break;default:throw new Error("Not a valid tensor rank.")}c=Df(c,-1);return wa(c,o)}const tx=pc({rgbToGrayscale_:Qm});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(t,n,e=0,s=.5){const o=fc(t,"image","rotateWithOffset","float32");x(o.rank===4,(()=>"Error in rotateWithOffset: image must be rank 4,"+`but got rank ${o.rank}.`));const r={image:o};const i={radians:n,fillValue:e,center:s};const c=Ur.runKernel(ao,r,i);return c}const ex=pc({rotateWithOffset_:nx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(t,n,e,s,o,r){if(s==null){s=.5}if(o==null){o=Number.NEGATIVE_INFINITY}if(r==null){r=0}const i=t.shape[0];e=Math.min(e,i);x(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`));x(t.rank===2,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`));x(t.shape[1]===4,(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`));x(n.rank===1,(()=>"scores must be a 1D tensor"));x(n.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, `+`but was ${n.shape[0]}`));x(0<=r&&r<=1,(()=>`softNmsSigma must be in [0, 1], but was '${r}'`));return{maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:r}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ox(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY){const r=fc(t,"boxes","nonMaxSuppression","float32");const i=fc(n,"scores","nonMaxSuppression","float32");const c=sx(r,i,e,s,o);e=c.maxOutputSize;s=c.iouThreshold;o=c.scoreThreshold;const a={maxOutputSize:e,iouThreshold:s,scoreThreshold:o};return Ur.runKernel(Ke,{boxes:r,scores:i},a)}const rx=pc({nonMaxSuppression_:ox});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ix(t,n,e){const s=cx(t,n,e);const o=s<0?-(s+1):s;t.splice(o,0,n)}function cx(t,n,e){return ux(t,n,e||ax)}function ax(t,n){return t>n?1:t<n?-1:0}function ux(t,n,e){let s=0;let o=t.length;let r=0;let i=false;while(s<o){r=s+(o-s>>>1);const c=e(n,t[r]);if(c>0){s=r+1}else{o=r;i=!c}}return i?s:-s-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lx(t,n,e,s,o){return dx(t,n,e,s,o,0)}function fx(t,n,e,s,o,r){return dx(t,n,e,s,o,0,false,r,true)}function hx(t,n,e,s,o,r){return dx(t,n,e,s,o,r,true)}function dx(t,n,e,s,o,r,i=false,c=false,a=false){const u=[];for(let t=0;t<n.length;t++){if(n[t]>o){u.push({score:n[t],boxIndex:t,suppressBeginIndex:0})}}u.sort(xx);const l=r>0?-.5/r:0;const f=[];const h=[];while(f.length<e&&u.length>0){const n=u.pop();const{score:e,boxIndex:r,suppressBeginIndex:i}=n;if(e<o){break}let c=false;for(let e=f.length-1;e>=i;--e){const i=px(t,r,f[e]);if(i>=s){c=true;break}n.score=n.score*mx(s,l,i);if(n.score<=o){break}}n.suppressBeginIndex=f.length;if(!c){if(n.score===e){f.push(r);h.push(n.score)}else if(n.score>o){ix(u,n,xx)}}}const d=f.length;const p=e-d;if(c&&p>0){f.push(...new Array(p).fill(0));h.push(...new Array(p).fill(0))}const m={selectedIndices:f};if(i){m["selectedScores"]=h}if(a){m["validOutputs"]=d}return m}function px(t,n,e){const s=t.subarray(n*4,n*4+4);const o=t.subarray(e*4,e*4+4);const r=Math.min(s[0],s[2]);const i=Math.min(s[1],s[3]);const c=Math.max(s[0],s[2]);const a=Math.max(s[1],s[3]);const u=Math.min(o[0],o[2]);const l=Math.min(o[1],o[3]);const f=Math.max(o[0],o[2]);const h=Math.max(o[1],o[3]);const d=(c-r)*(a-i);const p=(f-u)*(h-l);if(d<=0||p<=0){return 0}const m=Math.max(r,u);const x=Math.max(i,l);const b=Math.min(c,f);const g=Math.min(a,h);const w=Math.max(b-m,0)*Math.max(g-x,0);return w/(d+p-w)}function mx(t,n,e){const s=Math.exp(n*e*e);return e<=t?s:0}function xx(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bx(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY){const r=fc(t,"boxes","nonMaxSuppressionAsync");const i=fc(n,"scores","nonMaxSuppressionAsync");const c=sx(r,i,e,s,o);e=c.maxOutputSize;s=c.iouThreshold;o=c.scoreThreshold;const a=await Promise.all([r.data(),i.data()]);const u=a[0];const l=a[1];const{selectedIndices:f}=lx(u,l,e,s,o);if(r!==t){r.dispose()}if(i!==n){i.dispose()}return fm(f,"int32")}const gx=bx;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=0){const i=fc(t,"boxes","nonMaxSuppression");const c=fc(n,"scores","nonMaxSuppression");const a=sx(i,c,e,s,o,r);e=a.maxOutputSize;s=a.iouThreshold;o=a.scoreThreshold;r=a.softNmsSigma;const u={boxes:i,scores:c};const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:r};const f=Ur.runKernel(Ye,u,l);return{selectedIndices:f[0],selectedScores:f[1]}}const vx=pc({nonMaxSuppressionWithScore_:wx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $x(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=0){const i=fc(t,"boxes","nonMaxSuppressionAsync");const c=fc(n,"scores","nonMaxSuppressionAsync");const a=sx(i,c,e,s,o,r);e=a.maxOutputSize;s=a.iouThreshold;o=a.scoreThreshold;r=a.softNmsSigma;const u=await Promise.all([i.data(),c.data()]);const l=u[0];const f=u[1];const{selectedIndices:h,selectedScores:d}=hx(l,f,e,s,o,r);if(i!==t){i.dispose()}if(c!==n){c.dispose()}return{selectedIndices:fm(h,"int32"),selectedScores:fm(d)}}const yx=$x;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kx(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=false){const i=fc(t,"boxes","nonMaxSuppression");const c=fc(n,"scores","nonMaxSuppression");const a=sx(i,c,e,s,o,null);const u=a.maxOutputSize;const l=a.iouThreshold;const f=a.scoreThreshold;const h={boxes:i,scores:c};const d={maxOutputSize:u,iouThreshold:l,scoreThreshold:f,padToMaxOutputSize:r};const p=Ur.runKernel(Je,h,d);return{selectedIndices:p[0],validOutputs:p[1]}}const Cx=pc({nonMaxSuppressionPadded_:kx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Nx(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=false){const i=fc(t,"boxes","nonMaxSuppressionAsync");const c=fc(n,"scores","nonMaxSuppressionAsync");const a=sx(i,c,e,s,o,null);const u=a.maxOutputSize;const l=a.iouThreshold;const f=a.scoreThreshold;const[h,d]=await Promise.all([i.data(),c.data()]);const{selectedIndices:p,validOutputs:m}=fx(h,d,u,l,f,r);if(i!==t){i.dispose()}if(c!==n){c.dispose()}return{selectedIndices:fm(p,"int32"),validOutputs:$f(m,"int32")}}const Rx=Nx;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(t,n,e=false,s=false){const o=fc(t,"images","resizeBilinear");x(o.rank===3||o.rank===4,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got `+`rank ${o.rank}.`));x(n.length===2,(()=>`Error in resizeBilinear: new shape must 2D, but got shape `+`${n}.`));x(s===false||e===false,(()=>`Error in resizeBilinear: If halfPixelCenters is true, `+`alignCorners must be false.`));let r=o;let i=false;if(o.rank===3){i=true;r=yu(o,[1,o.shape[0],o.shape[1],o.shape[2]])}const c={images:r};const a={alignCorners:e,halfPixelCenters:s,size:n};const u=Ur.runKernel(ms,c,a);if(i){return yu(u,[u.shape[1],u.shape[2],u.shape[3]])}return u}const Ex=pc({resizeBilinear_:Sx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tx(t,n,e=false,s=false){const o=fc(t,"images","resizeNearestNeighbor");x(o.rank===3||o.rank===4,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got `+`rank ${o.rank}.`));x(n.length===2,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape `+`${n}.`));x(o.dtype==="float32"||o.dtype==="int32",(()=>"`images` must have `int32` or `float32` as dtype"));x(s===false||e===false,(()=>`Error in resizeNearestNeighbor: If halfPixelCenters is true, `+`alignCorners must be false.`));let r=o;let i=false;if(o.rank===3){i=true;r=yu(o,[1,o.shape[0],o.shape[1],o.shape[2]])}const c={images:r};const a={alignCorners:e,halfPixelCenters:s,size:n};const u=Ur.runKernel(ds,c,a);if(i){return yu(u,[u.shape[1],u.shape[2],u.shape[3]])}return u}const Ix=pc({resizeNearestNeighbor_:Tx});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(t,n="binary",e=false,s=.5){const o=fc(t,"image","threshold");const r=.2989;const i=.587;const c=.114;const a=o.shape[0]*o.shape[1];let u=Aa(fm([s]),255);let l,f,h,d;x(o.rank===3,(()=>"Error in threshold: image must be rank 3,"+`but got rank ${o.rank}.`));x(o.shape[2]===3||o.shape[2]===1,(()=>"Error in threshold: "+"image color channel must be equal to 3 or 1"+`but got ${o.shape[2]}.`));x(o.dtype==="int32"||o.dtype==="float32",(()=>"Error in dtype: image dtype must be int32 or float32,"+`but got dtype ${o.dtype}.`));x(n==="otsu"||n==="binary",(()=>`Method must be binary or otsu, but was ${n}`));if(o.shape[2]===3){[l,f,h]=Jp(o,[1,1,1],-1);const t=Aa(l,r);const n=Aa(f,i);const e=Aa(h,c);d=Na(Na(t,n),e)}else{d=t}if(n==="otsu"){const t=Ku(wa(vp(d),"int32"),gc([]),256);u=Ox(t,a)}const p=e?lh(d,u):Xf(d,u);const m=wa(Aa(p,255),"int32");return m}function Ox(t,n){let e=fm([-1]);let s=fm([0]);let o=fm([0]);let r,i,c,a,u,l;for(let f=0;f<t.size-1;f++){r=_u(t,0,f+1);i=_u(t,f+1);u=Ta(Sf(r),n);l=Ta(Sf(i),n);const h=Sf(Aa(r,ap(0,r.size)));c=Ta(h,Sf(r));const d=tl(i.shape,r.size);const p=Na(ap(0,i.size),d);const m=Aa(i,p);a=Ta(Sf(m),Sf(i));const x=Rh(c,a);const b=Rh(c,a);const g=Aa(u,l);o=Aa(Aa(g,x),b);const w=Xf(o,s);s=ql(w,o,s);e=ql(w,fm([f]),e)}return e}const Fx=pc({threshold_:Ax});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(t,n,e="nearest",s="constant",o=0,r){const i=fc(t,"image","transform","float32");const c=fc(n,"transforms","transform","float32");x(i.rank===4,(()=>"Error in transform: image must be rank 4,"+`but got rank ${i.rank}.`));x(c.rank===2&&(c.shape[0]===i.shape[0]||c.shape[0]===1)&&c.shape[1]===8,(()=>`Error in transform: Input transform should be batch x 8 or 1 x 8`));x(r==null||r.length===2,(()=>"Error in transform: outputShape must be [height, width] or null, "+`but got ${r}.`));const a={image:i,transforms:c};const u={interpolation:e,fillMode:s,fillValue:o,outputShape:r};return Ur.runKernel(to,a,u)}const Mx=pc({transform_:_x});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dx(t,n,e){const s=fc(t,"a","bandPart");x(s.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`));const o=s.shape;const[r,i]=s.shape.slice(-2);let c;let a;if(typeof n==="number"){x(n%1===0,(()=>`bandPart(): numLower must be an integer, got ${n}.`));x(n<=r,(()=>`bandPart(): numLower (${n})`+` must not be greater than the number of rows (${r}).`));c=fc(n<0?r:n,"numLower","bandPart")}else{x(n.dtype==="int32",(()=>`bandPart(): numLower's dtype must be an int32.`));c=ql(ah(n,0),r,Jh(n,r))}if(typeof e==="number"){x(e%1===0,(()=>`bandPart(): numUpper must be an integer, got ${e}.`));x(e<=i,(()=>`bandPart(): numUpper (${e})`+` must not be greater than the number of columns (${i}).`));a=fc(e<0?i:e,"numUpper","bandPart")}else{x(e.dtype==="int32",(()=>`bandPart(): numUpper's dtype must be an int32.`));a=ql(ah(e,0),i,Jh(e,i))}const u=yu(ap(0,r,1,"int32"),[-1,1]);const l=ap(0,i,1,"int32");const f=Rh(u,l);const h=Oh(lh(f,c),Jf(f,vh(a)));const d=qh([r,i],s.dtype);return yu(om(Nm(yu(s,[-1,r,i])).map((t=>ql(h,t,d)))),o)}const Lx=pc({bandPart_:Dx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(t){let n;if(Array.isArray(t)){n=false;x(t!=null&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or "+"empty"));const e=t[0].shape[0];for(let n=1;n<t.length;++n){x(t[n].shape[0]===e,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+`(${t[n].shape[0]} vs. ${e})`))}}else{n=true;t=Jp(t,t.shape[0],0).map((t=>em(t,[0])))}x(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds `+`number of dimensions (${t[0].shape[0]}).`));const e=[];const s=t;for(let n=0;n<t.length;++n){e.push(Ur.tidy((()=>{let t=s[n];if(n>0){for(let s=0;s<n;++s){const n=Aa(Sf(Aa(e[s],t)),e[s]);t=Rh(t,n)}}return Ta(t,If(t,"euclidean"))})))}if(n){return om(e,0)}else{return e}}const Px=pc({gramSchmidt_:zx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(t,n=false){x(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`));if(t.rank===2){return Bx(t,n)}else{const e=t.shape.slice(0,t.shape.length-2).reduce(((t,n)=>t*n));const s=Nm(yu(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0);const o=[];const r=[];s.forEach((t=>{const[e,s]=Bx(t,n);o.push(e);r.push(s)}));const i=yu(om(o,0),t.shape);const c=yu(om(r,0),t.shape);return[i,c]}}function Bx(t,n=false){return Ur.tidy((()=>{x(t.shape.length===2,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const e=t.shape[0];const s=t.shape[1];let o=Wf(e);let r=$a(t);const i=hm([[1]],[1,1]);let c=$a(i);const a=e>=s?s:e;for(let t=0;t<a;++t){const n=r;const a=c;const u=o;[c,r,o]=Ur.tidy((()=>{const n=_u(r,[t,t],[e-t,1]);const a=If(n);const u=_u(r,[t,t],[1,1]);const l=ql(Xf(u,0),hm([[-1]]),hm([[1]]));const f=Rh(u,Aa(l,a));const h=Ta(n,f);if(h.shape[0]===1){c=$a(i)}else{c=Eu([i,_u(h,[1,0],[h.shape[0]-1,h.shape[1]])],0)}const d=vh(Ta(Iu(l,f),a));const p=_u(r,[t,0],[e-t,s]);const m=Aa(d,c);const x=Tm(c);if(t===0){r=Rh(p,Iu(m,Iu(x,p)))}else{const n=Rh(p,Iu(m,Iu(x,p)));r=Eu([_u(r,[0,0],[t,s]),n],0)}const b=Tm(m);const g=_u(o,[0,t],[e,o.shape[1]-t]);if(t===0){o=Rh(g,Iu(Iu(g,c),b))}else{const n=Rh(g,Iu(Iu(g,c),b));o=Eu([_u(o,[0,0],[e,t]),n],1)}return[c,r,o]}));Cc([n,a,u])}if(!n&&e>s){o=_u(o,[0,0],[e,s]);r=_u(r,[0,0],[s,s])}return[o,r]}))}const Wx=pc({qr_:Vx});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gx={flipLeftRight:Jm,grayscaleToRGB:Zm,resizeNearestNeighbor:Ix,resizeBilinear:Ex,rgbToGrayscale:tx,rotateWithOffset:ex,cropAndResize:Xm,nonMaxSuppression:rx,nonMaxSuppressionAsync:gx,nonMaxSuppressionWithScore:vx,nonMaxSuppressionWithScoreAsync:yx,nonMaxSuppressionPadded:Cx,nonMaxSuppressionPaddedAsync:Rx,threshold:Fx,transform:Mx};const Ux={bandPart:Lx,gramSchmidt:Px,qr:Wx};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hx=new Map;const jx=new Map;class qx{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Xx{constructor(){this.classNameMap={}}static getMap(){if(Xx.instance==null){Xx.instance=new Xx}return Xx.instance}static register(t){Xx.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Kx(t,n,e){x(t.className!=null,(()=>`Class being registered does not have the static className `+`property defined.`));x(typeof t.className==="string",(()=>`className is required to be a string, but got type `+typeof t.className));x(t.className.length>0,(()=>`Class being registered has an empty-string as its className, `+`which is disallowed.`));if(typeof n==="undefined"){n="Custom"}if(typeof e==="undefined"){e=t.className}const s=e;const o=n+">"+s;Xx.register(t);Hx.set(o,t);jx.set(t,o);return t}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jx extends qx{minimize(t,n=false,e){const{value:s,grads:o}=this.computeGradients(t,e);if(e!=null){const t=e.map((t=>({name:t.name,tensor:o[t.name]})));this.applyGradients(t)}else{this.applyGradients(o)}Cc(o);if(n){return s}else{s.dispose();return null}}get iterations(){if(this.iterations_==null){this.iterations_=0}return this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return bh(t,n)}dispose(){if(this.iterations_!=null){Cc(this.iterations_)}}async saveIterations(){if(this.iterations_==null){this.iterations_=0}return{name:"iter",tensor:$f(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class `+`${this.getClassName()}`)}async extractIterations(t){this.iterations_=(await t[0].tensor.data())[0];return t.slice(1)}}Object.defineProperty(Jx,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yx extends Jx{static get className(){return"Adadelta"}constructor(t,n,e=null){super();this.learningRate=t;this.rho=n;this.epsilon=e;this.accumulatedGrads=[];this.accumulatedUpdates=[];if(e==null){this.epsilon=Ur.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Ur.registeredVariables[n];const o=false;if(this.accumulatedGrads[e]==null){this.accumulatedGrads[e]={originalName:`${n}/accum_grad`,variable:kc((()=>Kl(s).variable(o)))}}if(this.accumulatedUpdates[e]==null){this.accumulatedUpdates[e]={originalName:`${n}/accum_var`,variable:kc((()=>Kl(s).variable(o)))}}const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}const i=this.accumulatedGrads[e].variable;const c=this.accumulatedUpdates[e].variable;kc((()=>{const t=Na(Aa(i,this.rho),Aa(Nf(r),1-this.rho));const n=Aa(Ta(kf(Na(c,this.epsilon)),kf(Na(i,this.epsilon))),r);const e=Na(Aa(c,this.rho),Aa(Nf(n),1-this.rho));i.assign(t);c.assign(e);const o=Na(Aa(n,-this.learningRate),s);s.assign(o)}))}));this.incrementIterations()}dispose(){if(this.accumulatedUpdates!=null){Cc(this.accumulatedGrads.map((t=>t.variable)));Cc(this.accumulatedUpdates.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2;const e=false;this.accumulatedGrads=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedUpdates=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n["learningRate"],n["rho"],n["epsilon"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zx extends Jx{static get className(){return"Adagrad"}constructor(t,n=.1){super();this.learningRate=t;this.initialAccumulatorValue=n;this.accumulatedGrads=[]}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Ur.registeredVariables[n];if(this.accumulatedGrads[e]==null){const t=false;this.accumulatedGrads[e]={originalName:`${n}/accumulator`,variable:kc((()=>tl(s.shape,this.initialAccumulatorValue).variable(t)))}}const o=Array.isArray(t)?t[e].tensor:t[n];if(o==null){return}const r=this.accumulatedGrads[e].variable;kc((()=>{const t=Na(r,Nf(o));r.assign(t);const n=Na(Aa(Ta(o,kf(Na(t,Ur.backend.epsilon()))),-this.learningRate),s);s.assign(n)}))}));this.incrementIterations()}dispose(){if(this.accumulatedGrads!=null){Cc(this.accumulatedGrads.map((t=>t.variable)))}}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=false;this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n["learningRate"],n["initialAccumulatorValue"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qx extends Jx{static get className(){return"Adam"}constructor(t,n,e,s=null){super();this.learningRate=t;this.beta1=n;this.beta2=e;this.epsilon=s;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];kc((()=>{this.accBeta1=$f(n).variable();this.accBeta2=$f(e).variable()}));if(s==null){this.epsilon=Ur.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);kc((()=>{const e=Rh(1,this.accBeta1);const s=Rh(1,this.accBeta2);n.forEach(((n,o)=>{const r=Ur.registeredVariables[n];const i=false;if(this.accumulatedFirstMoment[o]==null){this.accumulatedFirstMoment[o]={originalName:`${n}/m`,variable:kc((()=>Kl(r).variable(i)))}}if(this.accumulatedSecondMoment[o]==null){this.accumulatedSecondMoment[o]={originalName:`${n}/v`,variable:kc((()=>Kl(r).variable(i)))}}const c=Array.isArray(t)?t[o].tensor:t[n];if(c==null){return}const a=this.accumulatedFirstMoment[o].variable;const u=this.accumulatedSecondMoment[o].variable;const l=Na(Aa(a,this.beta1),Aa(c,1-this.beta1));const f=Na(Aa(u,this.beta2),Aa(Nf(c),1-this.beta2));const h=Ta(l,e);const d=Ta(f,s);a.assign(l);u.assign(f);const p=Na(Aa(Ta(h,Na(kf(d),this.epsilon)),-this.learningRate),r);r.assign(p)}));this.accBeta1.assign(Aa(this.accBeta1,this.beta1));this.accBeta2.assign(Aa(this.accBeta2,this.beta2))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.accBeta2.dispose();if(this.accumulatedFirstMoment!=null){Cc(this.accumulatedFirstMoment.map((t=>t.variable)))}if(this.accumulatedSecondMoment!=null){Cc(this.accumulatedSecondMoment.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);kc((()=>{this.accBeta1.assign(vf(this.beta1,this.iterations_+1));this.accBeta2.assign(vf(this.beta2,this.iterations_+1))}));const n=t.length/2;const e=false;this.accumulatedFirstMoment=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedSecondMoment=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n["learningRate"],n["beta1"],n["beta2"],n["epsilon"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tb extends Jx{static get className(){return"Adamax"}constructor(t,n,e,s=null,o=0){super();this.learningRate=t;this.beta1=n;this.beta2=e;this.epsilon=s;this.decay=o;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];kc((()=>{this.iteration=$f(0).variable();this.accBeta1=$f(n).variable()}));if(s==null){this.epsilon=Ur.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);kc((()=>{const e=Rh(1,this.accBeta1);const s=Ta(-this.learningRate,Na(Aa(this.iteration,this.decay),1));n.forEach(((n,o)=>{const r=Ur.registeredVariables[n];const i=false;if(this.accumulatedFirstMoment[o]==null){this.accumulatedFirstMoment[o]={originalName:`${n}/m`,variable:Kl(r).variable(i)}}if(this.accumulatedWeightedInfNorm[o]==null){this.accumulatedWeightedInfNorm[o]={originalName:`${n}/v`,variable:Kl(r).variable(i)}}const c=Array.isArray(t)?t[o].tensor:t[n];if(c==null){return}const a=this.accumulatedFirstMoment[o].variable;const u=this.accumulatedWeightedInfNorm[o].variable;const l=Na(Aa(a,this.beta1),Aa(c,1-this.beta1));const f=Aa(u,this.beta2);const h=Fa(c);const d=Uh(f,h);a.assign(l);u.assign(d);const p=Na(Aa(Ta(s,e),Ta(l,Na(d,this.epsilon))),r);r.assign(p)}));this.iteration.assign(Na(this.iteration,1));this.accBeta1.assign(Aa(this.accBeta1,this.beta1))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.iteration.dispose();if(this.accumulatedFirstMoment!=null){Cc(this.accumulatedFirstMoment.map((t=>t.variable)))}if(this.accumulatedWeightedInfNorm!=null){Cc(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n["learningRate"],n["beta1"],n["beta2"],n["epsilon"],n["decay"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nb extends Jx{static get className(){return"SGD"}constructor(t){super();this.learningRate=t;this.setLearningRate(t)}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Array.isArray(t)?t[e].tensor:t[n];if(s==null){return}const o=Ur.registeredVariables[n];kc((()=>{const t=Na(Aa(this.c,s),o);o.assign(t)}))}));this.incrementIterations()}setLearningRate(t){this.learningRate=t;if(this.c!=null){this.c.dispose()}this.c=Nc($f(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){t=await this.extractIterations(t);if(t.length!==0){throw new Error("SGD optimizer does not have settable weights.")}}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n["learningRate"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eb extends nb{static get className(){return"Momentum"}constructor(t,n,e=false){super(t);this.learningRate=t;this.momentum=n;this.useNesterov=e;this.accumulations=[];this.m=$f(this.momentum)}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Ur.registeredVariables[n];if(this.accumulations[e]==null){const t=false;this.accumulations[e]={originalName:`${n}/momentum`,variable:kc((()=>Kl(s).variable(t)))}}const o=this.accumulations[e].variable;const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}kc((()=>{let t;const n=Na(Aa(this.m,o),r);if(this.useNesterov){t=Na(Aa(this.c,Na(r,Aa(n,this.m))),s)}else{t=Na(Aa(this.c,n),s)}o.assign(n);s.assign(t)}))}));this.incrementIterations()}dispose(){this.m.dispose();if(this.accumulations!=null){Cc(this.accumulations.map((t=>t.variable)))}}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=false;this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n["learningRate"],n["momentum"],n["useNesterov"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sb extends Jx{static get className(){return"RMSProp"}constructor(t,n=.9,e=0,s=null,o=false){super();this.learningRate=t;this.decay=n;this.momentum=e;this.epsilon=s;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];this.centered=o;if(s==null){this.epsilon=Ur.backend.epsilon()}if(t==null){throw new Error(`learningRate for RMSPropOptimizer must be defined.`)}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Ur.registeredVariables[n];const o=false;if(this.accumulatedMeanSquares[e]==null){this.accumulatedMeanSquares[e]={originalName:`${n}/rms`,variable:kc((()=>Kl(s).variable(o)))}}if(this.accumulatedMoments[e]==null){this.accumulatedMoments[e]={originalName:`${n}/momentum`,variable:kc((()=>Kl(s).variable(o)))}}if(this.accumulatedMeanGrads[e]==null&&this.centered){this.accumulatedMeanGrads[e]={originalName:`${n}/mg`,variable:kc((()=>Kl(s).variable(o)))}}const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}const i=this.accumulatedMeanSquares[e].variable;const c=this.accumulatedMoments[e].variable;kc((()=>{const t=Na(Aa(i,this.decay),Aa(Nf(r),1-this.decay));if(this.centered){const n=this.accumulatedMeanGrads[e].variable;const o=Na(Aa(n,this.decay),Aa(r,1-this.decay));const a=Ta(Aa(r,this.learningRate),kf(Rh(t,Na(Nf(o),this.epsilon))));const u=Na(Aa(c,this.momentum),a);i.assign(t);n.assign(o);c.assign(u);const l=Rh(s,u);s.assign(l)}else{const t=Na(Aa(i,this.decay),Aa(Nf(r),1-this.decay));const n=Na(Aa(c,this.momentum),Ta(Aa(r,this.learningRate),kf(Na(t,this.epsilon))));i.assign(t);c.assign(n);const e=Rh(s,n);s.assign(e)}}))}));this.incrementIterations()}dispose(){if(this.accumulatedMeanSquares!=null){Cc(this.accumulatedMeanSquares.map((t=>t.variable)))}if(this.accumulatedMeanGrads!=null&&this.centered){Cc(this.accumulatedMeanGrads.map((t=>t.variable)))}if(this.accumulatedMoments!=null){Cc(this.accumulatedMoments.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];if(this.centered){t.push(...this.accumulatedMeanGrads)}return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2;const e=false;this.accumulatedMeanSquares=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedMoments=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));if(this.centered){this.accumulatedMeanGrads=t.slice(n*2,n*3).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n["learningRate"],n["decay"],n["momentum"],n["epsilon"],n["centered"])}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob=[Yx,Zx,Qx,tb,eb,sb,nb];function rb(){for(const t of ob){Kx(t)}}function ib(t,n){const e=t.shape.length;const s=n.shape.length;if(e<1){throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+` but the rank was ${e}.`)}if(s<1){throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+` but the rank was ${s}.`)}if(n.dtype!=="int32"){throw new Error("tf.gatherND() expects the indices to be int32 type,"+` but the dtype was ${n.dtype}.`)}if(n.shape[s-1]>e){throw new Error("index innermost dimension length must be <= tensor rank; saw: "+`${n.shape[s-1]} vs. ${e}`)}if(w(t.shape)===0){throw new Error("Requested more than 0 entries, but input is empty."+` Input shape: ${t.shape}.`)}const o=n.shape;const r=o[o.length-1];let i=1;for(let t=0;t<o.length-1;++t){i*=o[t]}const c=t.shape;const a=o.slice();a.pop();let u=1;for(let t=r;t<e;++t){u*=c[t];a.push(c[t])}const l=[...B(t.shape).map((t=>t/u)),1].slice(0,r);return[a,i,u,l]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cb=-2;const ab=-1;function ub(t,n,e){const s=t.shape.length;x(s===n.length,(()=>`Error in slice${s}D: Length of begin ${n} must `+`match the rank of the array (${s}).`));x(s===e.length,(()=>`Error in slice${s}D: Length of size ${e} must `+`match the rank of the array (${s}).`));for(let o=0;o<s;++o){x(n[o]+e[o]<=t.shape[o],(()=>`Error in slice${s}D: begin[${o}] + size[${o}] `+`(${n[o]+e[o]}) would overflow input.shape[${o}] (${t.shape[o]})`))}}function lb(t){const n=[];let e=0;while(t>0){if(t&1){n.push(e)}t/=2;e++}return n}function fb(t,n,e){const s=[];for(let o=0;o<t.length;o++){s[o]=Math.ceil((n[o]-t[o])/e[o])}return s}function hb(t,n,e,s){const o=[...t];for(let t=o.length;t<s.length;t++){o.push(1)}for(let t=0;t<e;t++){if(t===0){o[n]=1}else{o.splice(n,0,1);o.pop()}}return o}function db(t,n,e){if(e<=t){return e}return e-(n-1)}function pb(t,n){const e=[];for(let s=0;s<t;s++){e.push(n+s)}return e}function mb(t,n,e,s,o,r,i,c,a){const u=t.length;let l=new Array(u),f=new Array(u),h=new Array(u);if(n.length&&e>0){const a=n[0];const u=e+1;l=xb(i,a,u,s,t);f=bb(c,a,u,o,t);h=hb(r,a,u,t)}else{for(let n=0;n<u;n++){l[n]=wb(i,s,r,t,n,a);f[n]=vb(c,o,r,t,n,a);h[n]=gb(r,n,a)}}return{begin:l,end:f,strides:h}}function xb(t,n,e,s,o){const r=[...o];const i=pb(e,n);for(let o=0;o<r.length;o++){if(i.indexOf(o)>-1){r[o]=0}else{const i=db(n,e,o);let c=s[i];if(t&1<<i){c=0}r[o]=c}}return r}function bb(t,n,e,s,o){const r=[...o];const i=pb(e,n);for(let o=0;o<r.length;o++){if(i.indexOf(o)>-1){r[o]=Number.MAX_SAFE_INTEGER}else{const i=db(n,e,o);let c=s[i];if(t&1<<i){c=Number.MAX_SAFE_INTEGER}r[o]=c}}for(let t=0;t<r.length;t++){const n=o[t];if(r[t]<0){r[t]+=n}r[t]=h(0,r[t],o[t])}return r}function gb(t,n,e){let s=t[n];if(e&1<<n||s==null){s=1}return s}function wb(t,n,e,s,o,r){let i=n[o];const c=e[o]||1;if(t&1<<o||r&1<<o||i==null){if(c>0){i=Number.MIN_SAFE_INTEGER}else{i=Number.MAX_SAFE_INTEGER}}const a=s[o];if(i<0){i+=a}i=h(0,i,a-1);return i}function vb(t,n,e,s,o,r){let i=n[o];const c=e[o]||1;if(t&1<<o||r&1<<o||i==null){if(c>0){i=Number.MAX_SAFE_INTEGER}else{i=Number.MIN_SAFE_INTEGER}}const a=s[o];if(i<0){i+=a}if(c>0){i=h(0,i,a)}else{i=h(-1,i,a-1)}return i}function $b(t,n,e){let s=e.length;for(let t=0;t<e.length;t++){if(e[t]>1){s=t;break}}for(let o=s+1;o<e.length;o++){if(n[o]>0||e[o]!==t[o]){return false}}return true}function yb(t,n){let e=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++){e+=t[s]*n[s]}return e}function kb(t,n,e){let s;const o=t.shape.length;if(typeof n==="number"){s=[n,...new Array(o-1).fill(0)]}else if(n.length<o){s=n.concat(new Array(o-n.length).fill(0))}else{s=n.slice()}s.forEach((t=>{x(t!==-1,(()=>"slice() does not support negative begin indexing."))}));let r;if(e==null){r=new Array(o).fill(-1)}else if(typeof e==="number"){r=[e,...new Array(o-1).fill(-1)]}else if(e.length<o){r=e.concat(new Array(o-e.length).fill(-1))}else{r=e}r=r.map(((n,e)=>{if(n>=0){return n}else{x(n===-1,(()=>`Negative size values should be exactly -1 but got `+`${n} for the slice() size at index ${e}.`));return t.shape[e]-s[e]}}));return[s,r]}function Cb(t,n,e,s,o,r,i,c,a){let u;if(s==null){u=new Array(n.length);u.fill(1)}else{u=s}if(i!=null&&(i&i-1)!==0){throw new Error("Multiple ellipses in slice is not allowed.")}let l=false;const f={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:u.slice(),beginMask:o,endMask:r,ellipsisMask:i,newAxisMask:c,shrinkAxisMask:a};for(let t=0;t<f.dims;t++){if(l&&(1<<t&c)!==0){f.numAddAxisAfterEllipsis++}if(1<<t&i){l=true}}if(!l){f.ellipsisMask|=1<<f.dims;f.dims++}const h={dims:t.length,beginMask:0,endMask:0,beginValid:false,endValid:false};Nb(f,h);let d=true;let p=true;let m=true;const x=[];const b=[];for(let n=0;n<t.length;++n){if(h.strides[n]===0){throw Error(`strides[${n}] must be non-zero`)}const e=!!(h.shrinkAxisMask&1<<n);const s=t[n];if(s===-1){x.push(e?1:-1);continue}const o=[h.beginMask&1<<n,h.endMask&1<<n];const r=[h.strides[n]>0?0:-1,h.strides[n]>0?s:s-1];if(e&&h.strides[n]<=0){throw Error("only stride 1 allowed on non-range indexing.")}m=m&&h.strides[n]===1;const i=!!(h.beginMask&1<<n&&h.endMask&1<<n);if(h.beginValid&&h.endValid){if(e){const t=h.begin[n]<0?s+h.begin[n]:h.begin[n];h.begin[n]=t;h.end[n]=h.begin[n]+1;if(t<0||t>=s){throw Error(`slice index ${h.begin[n]} of dimension ${n} out of bounds.`)}}else{h.begin[n]=Rb(h.begin[n],0,h.strides[n],s,o,r);h.end[n]=Rb(h.end[n],1,h.strides[n],s,o,r)}const t=h.strides[n]===1&&h.begin[n]===0&&h.end[n]===s;d=d&&t;p=p&&(n===0&&h.strides[n]===1||t)}else{d=d&&(h.strides[n]===1&&i);p=p&&(n===0&&h.strides[n]===1||i)}let c;let a=false;if(h.beginValid&&h.endValid){c=h.end[n]-h.begin[n];a=true}else if(e){c=1;a=true}else if(i){if(s>=0){if(h.strides[n]<0){c=-s}else{c=s}a=true}}if(a){let t;if(c===0||c<0!==h.strides[n]<0){t=0}else{t=Math.trunc(c/h.strides[n])+(c%h.strides[n]!==0?1:0)}x.push(t)}else{x.push(-1)}}for(let t=0;t<h.finalShapeGatherIndices.length;++t){const n=h.finalShapeGatherIndices[t];if(n>=0){b.push(x[n])}else if(n===cb){b.push(1)}}const g=b.filter(((t,n)=>h.finalShapeGatherIndices[n]!==cb));return{finalShapeSparse:g,finalShape:b,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Nb(t,n){n.beginMask=0;n.endMask=0;n.shrinkAxisMask=0;let e=0;n.beginValid=t.begin!=null;n.endValid=t.end!=null;n.begin=new Array(n.dims);n.end=new Array(n.dims);n.strides=new Array(n.dims);n.finalShapeGatherIndices=[];n.finalShapeGatherIndicesSparse=[];n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let s=0;s<t.dims;s++){if(1<<s&t.ellipsisMask){const o=Math.min(n.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<o;e++){n.begin[e]=0;n.end[e]=0;n.strides[e]=1;n.beginMask|=1<<e;n.endMask|=1<<e;n.finalShapeGatherIndices.push(e);n.finalShapeGatherIndicesSparse.push(-1);n.inputShapeGatherIndicesSparse[e]=s}}else if(1<<s&t.newAxisMask){n.finalShapeGatherIndices.push(cb);n.finalShapeGatherIndicesSparse.push(-1)}else{if(e===n.begin.length){throw Error(`Index out of range using input dim ${e}; input `+`has only ${n.dims} dims, ${n.begin.length}.`)}if(t.begin!=null){n.begin[e]=t.begin[s]}if(t.end!=null){n.end[e]=t.end[s]}n.strides[e]=t.strides[s];if(t.beginMask&1<<s){n.beginMask|=1<<e}if(t.endMask&1<<s){n.endMask|=1<<e}if(t.shrinkAxisMask&1<<s){n.finalShapeGatherIndices.push(ab);n.finalShapeGatherIndicesSparse.push(-1);n.shrinkAxisMask|=1<<e}else{n.finalShapeGatherIndices.push(e);n.finalShapeGatherIndicesSparse.push(s)}n.inputShapeGatherIndicesSparse[e]=s;e++}}}function Rb(t,n,e,s,o,r){if(o[n]){return e>0?r[n]:r[n+1&1]}else{const n=t<0?s+t:t;return n<r[0]?r[0]:n>r[1]?r[1]:n}}var Sb=Object.freeze({__proto__:null,assertParamsValid:ub,computeFlatOffset:yb,computeOutShape:fb,getNormalizedAxes:mb,isSliceContinous:$b,maskToAxes:lb,parseSliceParams:kb,sliceInfo:Cb,startForAxis:wb,startIndicesWithElidedDims:xb,stopForAxis:vb,stopIndicesWithElidedDims:bb,stridesForAxis:gb,stridesWithElidedDims:hb});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eb{static sgd(t){return new nb(t)}static momentum(t,n,e=false){return new eb(t,n,e)}static rmsprop(t,n=.9,e=0,s=null,o=false){return new sb(t,n,e,s,o)}static adam(t=.001,n=.9,e=.999,s=null){return new Qx(t,n,e,s)}static adadelta(t=.001,n=.95,e=null){return new Yx(t,n,e)}static adamax(t=.002,n=.9,e=.999,s=null,o=0){return new tb(t,n,e,s,o)}static adagrad(t,n=.1){return new Zx(t,n)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tb=Eb;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ib=(()=>{if(typeof requestAnimationFrame!=="undefined"){return requestAnimationFrame}else if(typeof setImmediate!=="undefined"){return setImmediate}return t=>t()})();function Ab(){return new Promise((t=>Ib((()=>t()))))}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ob(t,n){const e=t[0].length;t.forEach(((t,n)=>{x(t.length===e,(()=>`Error in concat${e}D: rank of tensors[${n}] must be the same `+`as the rank of the rest (${e})`))}));x(n>=0&&n<e,(()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`));const s=t[0];t.forEach(((t,o)=>{for(let r=0;r<e;r++){x(r===n||t[r]===s[r],(()=>`Error in concat${e}D: Shape of tensors[${o}] (${t}) `+`does not match the shape of the rest (${s}) `+`along the non-concatenated axis ${o}.`))}}))}function Fb(t,n){const e=t[0].slice();for(let s=1;s<t.length;s++){e[n]+=t[s][n]}return e}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _b;(function(t){t[t["FIRST_DIM_SIZE"]=0]="FIRST_DIM_SIZE";t[t["VALUE_ROWIDS"]=1]="VALUE_ROWIDS";t[t["ROW_LENGTHS"]=2]="ROW_LENGTHS";t[t["ROW_SPLITS"]=3]="ROW_SPLITS";t[t["ROW_LIMITS"]=4]="ROW_LIMITS";t[t["ROW_STARTS"]=5]="ROW_STARTS"})(_b||(_b={}));function Mb(t,n,e){let s=new Array;if(e==null&&n==null){return s}if(n==null){while(s.length<t+e.length){s.push(-1)}}else{s=n.slice()}if(e==null){return s}if(t+e.length!==s.length){throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${s.length}`)}for(let o=1;o<e.length;++o){const r=e[o];const i=s[s.length-e.length+o];const c=s[i];if(r>=0){if(c>=0){if(c!==r){throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${o+t}] = ${r} but shape[${o+t}] = ${c}`)}}else{s[i]=r}}}return s}function Db(t){const n={FIRST_DIM_SIZE:_b.FIRST_DIM_SIZE,VALUE_ROWIDS:_b.VALUE_ROWIDS,ROW_LENGTHS:_b.ROW_LENGTHS,ROW_SPLITS:_b.ROW_SPLITS,ROW_LIMITS:_b.ROW_LIMITS,ROW_STARTS:_b.ROW_STARTS};const e=[];for(const s of t){if(s in n){e.push(n[s])}else{break}}return e}function Lb(t){if(t.length===0){return 0}if(t[0]===_b.FIRST_DIM_SIZE){return t.length-1}return t.length}function zb(t,n){if(t==null||n==null){return}const e=t.length;const s=n.length;if(e>=s){throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`)}for(let o=0;o<Math.min(e,s-1);++o){const e=t[o];const s=n[o+1];if(e>=0&&s>=0&&e!==1&&e!==s){throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${o-t.length}] = ${e} but ragged tensor input.flatValues.shape[${o-t.length}] = ${s}`)}}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb=30;function Vb(t){if(t<=Pb){return t}return V(t,Math.floor(Math.sqrt(t)))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bb(t,n,e){const s=e*(typeof t==="number"?t:t[0]);const o=n*(typeof t==="number"?t:t[1]);return[s,o]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(t,n,e,s=true){let o=[];if(s){o=o.concat(n.slice(0));o.push(t[0]/e);o=o.concat(t.slice(1))}else{o=o.concat(t[0]);const e=n.length;for(let s=0;s<e;++s){o=o.concat([t[s+1]/n[s],n[s]])}o=o.concat(t.slice(e+1))}return o}function Gb(t,n,e=true){const s=[];if(e){s.push(n);for(let e=n+1;e<t;++e){if(e<=2*n){s.push(e);s.push(e-(n+1))}else{s.push(e)}}}else{const e=[];const o=[];for(let s=1;s<t;++s){if(s>=n*2+1||s%2===1){o.push(s)}else{e.push(s)}}s.push(...e);s.push(0);s.push(...o)}return s}function Ub(t,n,e,s=true){const o=[];if(s){o.push(t[0]/e)}else{o.push(t[0]*e)}for(let e=1;e<t.length;++e){if(e<=n.length){if(s){o.push(n[e-1]*t[e])}else{o.push(t[e]/n[e-1])}}else{o.push(t[e])}}return o}function Hb(t,n){const e=[0];for(let s=0;s<n;++s){e.push(t[s][0])}return e}function jb(t,n,e){const s=t.slice(0,1);for(let o=0;o<e;++o){s.push(t[o+1]-n[o][0]-n[o][1])}return s}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb=1.7580993408473768;const Xb=1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb=.3275911;const Jb=.254829592;const Yb=-.284496736;const Zb=1.421413741;const Qb=-1.453152027;const tg=1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ng(t,n){if(t.length!==n.length){throw new Error(`Cannot merge real and imag arrays of different lengths. real:`+`${t.length}, imag: ${n.length}.`)}const e=new Float32Array(t.length*2);for(let s=0;s<e.length;s+=2){e[s]=t[s/2];e[s+1]=n[s/2]}return e}function eg(t){const n=new Float32Array(t.length/2);const e=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2){n[s/2]=t[s];e[s/2]=t[s+1]}return{real:n,imag:e}}function sg(t){const n=Math.ceil(t.length/4);const e=new Float32Array(n);const s=new Float32Array(n);for(let n=0;n<t.length;n+=4){e[Math.floor(n/4)]=t[n];s[Math.floor(n/4)]=t[n+1]}return{real:e,imag:s}}function og(t){const n=Math.floor(t.length/4);const e=new Float32Array(n);const s=new Float32Array(n);for(let n=2;n<t.length;n+=4){e[Math.floor(n/4)]=t[n];s[Math.floor(n/4)]=t[n+1]}return{real:e,imag:s}}function rg(t,n){const e=t[n*2];const s=t[n*2+1];return{real:e,imag:s}}function ig(t,n,e,s){t[s*2]=n;t[s*2+1]=e}function cg(t,n){const e=new Float32Array(t/2);const s=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const r=(n?2:-2)*Math.PI*(o/t);e[o]=Math.cos(r);s[o]=Math.sin(r)}return{real:e,imag:s}}function ag(t,n,e){const s=(e?2:-2)*Math.PI*(t/n);const o=Math.cos(s);const r=Math.sin(s);return{real:o,imag:r}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ug="->";const lg=/->/g;const fg=",";const hg="...";function dg(t,n){t=t.replace(/\s/g,"");const e=(t.length-t.replace(lg,"").length)/ug.length;if(e<1){throw new Error("Equations without an arrow are not supported.")}else if(e>1){throw new Error(`Equation must contain exactly one arrow ("${ug}").`)}const[s,o]=t.split(ug);x(s.indexOf(hg)===-1,(()=>`The ellipsis notation ("${hg}") is not supported yet.`));const r=s.split(fg);const i=r.length;if(n!==i){throw new Error(`Expected ${i} input tensors, received ${n}`)}if(i>2){throw new Error("Support for more than 2 input tensors is not implemented yet.")}const c=[];for(let t=0;t<o.length;++t){const n=o[t];if(!r.some((t=>t.indexOf(n)!==-1))){throw new Error(`Output subscripts contain the label ${n} `+`not present in the input subscripts.`)}if(c.indexOf(n)===-1){c.push(n)}}for(let t=0;t<s.length;++t){const n=s[t];if(c.indexOf(n)===-1&&n!==fg){c.push(n)}}const a=new Array(r.length);for(let t=0;t<i;++t){if(new Set(r[t].split("")).size!==r[t].length){throw new Error(`Found duplicate axes in input component ${r[t]}. `+`Support for duplicate axes in input is not implemented yet.`)}a[t]=[];for(let n=0;n<r[t].length;++n){a[t].push(c.indexOf(r[t][n]))}}const u=c.length;const l=o.length;const f=[];for(let t=l;t<u;++t){f.push(t)}return{allDims:c,summedDims:f,idDims:a}}function pg(t,n){let e=new Array(t);e.fill(-1);for(let t=0;t<n.length;++t){e[n[t]]=t}const s=[];for(let n=0;n<t;++n){if(e[n]===-1){s.push(n)}}e=e.filter((t=>t!==-1));return{permutationIndices:e,expandDims:s}}function mg(t,n,e){const s=new Array(t);for(let t=0;t<e.length;++t){const o=e[t].shape;for(let e=0;e<n[t].length;++e){if(s[n[t][e]]===undefined){s[n[t][e]]=o[e]}else{x(s[n[t][e]]===o[e],(()=>`Expected dimension ${s[n[t][e]]} at axis ${e} `+`of input shaped ${JSON.stringify(o)}, `+`but got dimension ${o[e]}`))}}}}function xg(t,n){const e=t;const s=[];let o=0;if(t.length===0){e.push(-1)}o=t.length+1;for(let t=0;t<o;++t){s.push([])}const r=[];for(let t=0;t<e.length;++t){const o=e[t];const i=gg(n,o);for(const n of i){if(r.indexOf(n)===-1){s[t].push(n);r.push(n)}}}return{path:e,steps:s}}function bg(t){return t.every(((t,n)=>t===n))}function gg(t,n){const e=[];for(let s=0;s<t.length;++s){if(t[s].length===0||t[s].indexOf(n)!==-1||n===-1){e.push(s)}}return e}function wg(t,n,e=0){let s=[];if(typeof n==="number"){x(t.shape[e]%n===0,(()=>"Number of splits must evenly divide the axis."));s=new Array(n).fill(t.shape[e]/n)}else{const o=n.reduce(((t,n)=>{if(n===-1){t+=1}return t}),0);x(o<=1,(()=>"There should be only one negative value in split array."));const r=n.indexOf(-1);if(r!==-1){const s=n.reduce(((t,n)=>n>0?t+n:t));n[r]=t.shape[e]-s}x(t.shape[e]===n.reduce(((t,n)=>t+n)),(()=>"The sum of sizes must match the size of the axis dimension."));s=n}return s}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vg(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function $g(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function yg(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kg(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function Cg(t,n){return`size ${t} must be non-negative, not ${n}`}function Ng(){return"reshape cannot infer the missing input size for an empty tensor "+"unless all specified input sizes are non-zero"}function Rg(t,n){const e=w(t);const s=w(n);return`Input to reshape is a SparseTensor with ${e}\n  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${n}`}function Sg(t,n){const e=w(t);const s=w(n);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${n}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eg(){return`segment ids must be >= 0`}function Tg(){return`segment ids are not increasing`}function Ig(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function Ag(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Og(t,n){let e=false;let s;if(t<=Pb){s=t;e=true}else{s=V(t,Math.floor(Math.sqrt(t)))}while(!e){if(s>n||s===t){e=true}else{s=V(t,s+1)}}return s}function Fg(t,n,e){const s=[];const o=t.length;for(let r=0;r<o;r++){if(r!==n){s.push(t[r])}else{s.push(e)}}return s}function _g(t,n,e,s){const o=n.shape.length;const r=t.shape.length;if(s!==0){if(s<-o||s>o){throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`)}}if(s<0){s+=o}if(s>r){throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${r}).`)}if(e<s){throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`)}for(let e=0;e<s;++e){if(t.shape[e]!==n.shape[e]){throw new Error(`x.shape[${e}]: ${t.shape[e]} should be equal to indices.shape[${e}]: ${n.shape[e]}.`)}}const i=t.shape[e];const c=[];let a=1;let u=1;let l=1;for(let n=0;n<s;++n){c.push(t.shape[n]);a*=t.shape[n]}for(let n=s;n<e;n++){c.push(t.shape[n]);u*=t.shape[n]}for(let t=s;t<o;t++){c.push(n.shape[t])}for(let n=e+1;n<r;n++){c.push(t.shape[n]);l*=t.shape[n]}return{batchSize:a,sliceSize:l,outerSize:u,dimSize:i,outputShape:c}}var Mg=Object.freeze({__proto__:null,collectGatherOpShapeInfo:_g,computeOutShape:Fg,segOpComputeOptimalWindowSize:Og});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dg(t){try{return t.map((t=>tr(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Lg(t){return t.map((t=>Qo(t)))}var zg=Object.freeze({__proto__:null,ERF_A1:Jb,ERF_A2:Yb,ERF_A3:Zb,ERF_A4:Qb,ERF_A5:tg,ERF_P:Kb,PARALLELIZE_THRESHOLD:Pb,get RowPartitionType(){return _b},SELU_SCALE:Xb,SELU_SCALEALPHA:qb,applyActivation:Lm,assertAndGetBroadcastShape:Gl,assertAxesAreInnerMostDims:ff,assertParamsConsistent:Ob,assignToTypedArray:ig,axesAreInnerMostDims:cf,calculateShapes:mm,checkEinsumDimSizes:mg,checkPadOnDimRoundingMode:vu,combineLocations:af,combineRaggedTensorToTensorShapes:Mb,complexWithEvenIndex:sg,complexWithOddIndex:og,computeConv2DInfo:ru,computeConv3DInfo:iu,computeDefaultPad:uu,computeDilation2DInfo:eu,computeOptimalWindowSize:Vb,computeOutAndReduceShapes:uf,computeOutShape:Fb,computePool2DInfo:su,computePool3DInfo:ou,convertConv2DDataFormat:wu,decodeEinsumEquation:dg,eitherStridesOrDilationsAreOne:bu,expandShapeToKeepDim:lf,exponent:ag,exponents:cg,fromStringArrayToUint8:Lg,fromUint8ToStringArray:Dg,getAxesPermutation:hf,getBroadcastDims:Bl,getComplexWithIndex:rg,getEinsumComputePath:xg,getEinsumPermutation:pg,getFusedBiasGradient:Dm,getFusedDyActivation:Mm,getImageCenter:Bb,getInnerMostAxes:pf,getPermuted:Gb,getRaggedRank:Lb,getReductionAxes:Wl,getReshaped:Wb,getReshapedPermuted:Ub,getRowPartitionTypesHelper:Db,getSliceBeginCoords:Hb,getSliceSize:jb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:vg,getSparseFillEmptyRowsNegativeIndexErrorMessage:$g,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:yg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ng,getSparseReshapeInputOutputMismatchErrorMessage:Sg,getSparseReshapeInputOutputMultipleErrorMessage:Rg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:kg,getSparseReshapeNegativeOutputDimErrorMessage:Cg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Ag,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Eg,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Tg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Ig,getUndoAxesPermutation:df,isIdentityPermutation:bg,log:po,mergeRealAndImagArrays:ng,prepareAndValidate:ib,prepareSplitSize:wg,segment_util:Mg,shouldFuse:zm,slice_util:Sb,splitRealAndImagArrays:eg,stridesOrDilationsArePositive:gu,tupleValuesAreOne:xu,upcastType:Ar,validateDefaultValueShape:zb,validateInput:pm,validateUpdateShape:dm,warn:ho});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */rb();
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pg={kernelName:Zt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,im(wa(e,"float32"),-1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vg={kernelName:Qt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=Nf(wa(e,"float32"));const s=kf(Rh($f(1),n));return vh(Ta(t,s))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bg={kernelName:tn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=kf(Rh(Nf(wa(e,"float32")),1));return Ta(t,n)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wg={kernelName:nn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{let n=t;const s=Wl(e.shape,o);if(s.length>0){n=Sf(n,s)}return yu(n,e.shape)};const i=()=>{let n=t;const e=Wl(s.shape,o);if(e.length>0){n=Sf(n,e)}return yu(n,s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gg={kernelName:en,saveAllInputs:true,gradFunc:(t,n)=>{const e={};n.forEach(((n,s)=>{e[s]=()=>t.clone()}));return e}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ug={kernelName:rn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Kl(e)}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hg={kernelName:cn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Kl(e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jg={kernelName:an,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,kf(Rh($f(1),Nf(wa(e,"float32")))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qg={kernelName:un,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=kf(Na($f(1),Nf(wa(e,"float32"))));return Ta(t,n)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xg={kernelName:hn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{const n=Na(Nf(e),Nf(s));let r=Aa(t,Ta(s,n));const i=Wl(e.shape,o);if(i.length>0){r=Sf(r,i)}return yu(r,e.shape)};const i=()=>{const n=Na(Nf(e),Nf(s));let r=vh(Aa(t,Ta(e,n)));const i=Wl(s.shape,o);if(i.length>0){r=Sf(r,i)}return yu(r,s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kg={kernelName:ln,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,Na(Nf(wa(e,"float32")),1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jg={kernelName:fn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,Rh($f(1),Nf(wa(e,"float32"))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yg(t,n,e,s,o,r){const i=fc(t,"dy","avgPool3dGrad");const c=fc(n,"input","avgPool3dGrad");let a=i;let u=c;let l=false;if(c.rank===4){l=true;a=yu(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]);u=yu(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])}x(a.rank===5,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank `+`${a.rank}.`));x(u.rank===5,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank `+`${u.rank}.`));vu("avgPool3dGrad",o,r);const f={dy:a,input:u};const h={filterSize:e,strides:s,pad:o,dimRoundingMode:r};const d=Ur.runKernel(xn,f,h);if(l){return yu(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]])}return d}const Zg=pc({avgPool3dGrad_:Yg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qg={kernelName:mn,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{filterSize:o,strides:r,pad:i,dimRoundingMode:c}=e;return{x:()=>Zg(t,s,o,r,i,c)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(t,n,e,s,o){const r=fc(t,"dy","avgPoolGrad");const i=fc(n,"input","avgPoolGrad");x(i.rank===r.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${r.rank})`));let c=i;let a=r;let u=false;if(i.rank===3){u=true;c=yu(i,[1,i.shape[0],i.shape[1],i.shape[2]]);a=yu(r,[1,r.shape[0],r.shape[1],r.shape[2]])}x(a.rank===4,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank `+`${a.rank}.`));x(c.rank===4,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank `+`${c.rank}.`));const l={dy:a,input:c};const f={filterSize:e,strides:s,pad:o};const h=Ur.runKernel(pn,l,f);if(u){return yu(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}const nw=pc({avgPoolGrad_:tw});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ew={kernelName:dn,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{filterSize:o,strides:r,pad:i}=e;return{x:()=>nw(t,s,o,r,i)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sw={kernelName:bn,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[s,o]=n;const{transposeA:r,transposeB:i}=e;if(!r&&!i){return{a:()=>Iu(t,o,false,true),b:()=>Iu(s,t,true,false)}}else if(!r&&i){return{a:()=>Iu(t,o,false,false),b:()=>Iu(t,s,true,false)}}else if(r&&!i){return{a:()=>Iu(o,t,false,true),b:()=>Iu(s,t,false,false)}}else{return{a:()=>Iu(o,t,true,true),b:()=>Iu(t,s,true,true)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ow={kernelName:gn,gradFunc:(t,n,e)=>{const{blockShape:s,crops:o}=e;return{x:()=>hd(t,s,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rw={kernelName:$n,gradFunc:(t,n,e)=>{const s=e;const o=s.inputShape;const r=s.shape;const i=Array.from(r);for(let t=o.length-1;t>=0;t--){if(o[t]===r[t]){i[t]=1}else if(o[t]!==1){throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${r}].`)}}const c=[];for(let t=0;t<i.length;t++){if(i[t]>1){c.push(t)}}return{x:()=>Sf(t,c,true)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iw={kernelName:kn,gradFunc:t=>({x:()=>t.clone()})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cw={kernelName:Cn,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aw={kernelName:Nn,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{clipValueMin:o,clipValueMax:r}=e;return{x:()=>ql(Oh(Jf(s,o),lh(s,r)),t,Kl(t))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uw={kernelName:Sn,inputsToSave:["x"],gradFunc:Pg.gradFunc};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lw={kernelName:En,saveAllInputs:true,gradFunc:(t,n,e)=>{const s=n.map((t=>t.shape));const{axis:o}=e;const r=R(o,n[0].shape)[0];const i=s.map((t=>t[r]));const c=Jp(t,i,r);return c.map((t=>()=>t))}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fw={kernelName:Tn,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const{dilations:r,strides:i,pad:c,dataFormat:a}=e;x(xu(r),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+`are not yet supported in gradients. Got dilations '${r}'`));return{x:()=>xl(s.shape,t,o,i,c,a),filter:()=>_m(s,t,o.shape,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hw={kernelName:An,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const{strides:r,pad:i,dataFormat:c,dimRoundingMode:a}=e;return{dy:()=>hl(t,o,r,i,c,1,a),filter:()=>_m(t,s,o.shape,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(t,n,e,s,o){let r=t;if(t.rank===4){r=yu(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])}let i=n;if(i.rank===4){i=yu(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])}x(r.rank===5,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape `+`${r.shape}.`));x(i.rank===5,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape `+`${i.shape}.`));x(e.length===5,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got `+`${e}.`));x(r.shape[4]===e[3],(()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must `+`match input depth in filter (${e[3]}.`));x(i.shape[4]===e[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must `+`match output depth for filter (${e[4]}).`));const c={x:r,dy:i};const a={strides:s,pad:o,filterShape:e};return Ur.runKernel(Fn,c,a)}const pw=pc({conv3DBackpropFilter_:dw});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mw={kernelName:On,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:s,strides:o,pad:r}=e;x(xu(s),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+`not yet supported in gradients. Got dilations '${s}'`));const[i,c]=n;return{x:()=>yl(i.shape,t,c,o,r),filter:()=>pw(i,t,c.shape,o,r)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xw={kernelName:Mn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(vh(Ip(wa(e,"float32"))),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bw={kernelName:Dn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(Op(wa(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gw={kernelName:zn,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o,exclusive:r,reverse:i}=e;return{x:()=>{const n=hf([o],s.rank);let e=Ol(t,o,r,!i);if(n!=null){e=Tm(e,n)}return e}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ww={kernelName:Wn,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:s,strides:o,pad:r,dimRoundingMode:i}=e;const c=s==null?[1,1]:s;x(xu(c),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates "+`greater than 1 are not yet supported. Got dilations `+`'${c}'`));const[a,u]=n;x(a.rank===4,(()=>`Error in gradient of depthwiseConv2dNative: input must be `+`rank 4, but got rank ${a.rank}.`));x(u.rank===4,(()=>`Error in gradient of depthwiseConv2dNative: filter must be `+`rank 4, but got rank ${u.rank}.`));x(a.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input `+`channels (${a.shape[3]}) must match the inChannels dimension `+`in filter ${u.shape[2]}.`));x(bu(o,c),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+`dilations must be  1. Got strides ${o} and dilations `+`'${c}'.`));vu("depthwiseConv2d",r,i);return{x:()=>Um(a.shape,t,u,o,r,c,i),filter:()=>Wm(a,t,u.shape,o,r,c,i)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vw={kernelName:jn,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const r={x:s,filter:o,dy:t};const i={x:s,filter:o,dy:t};return{x:()=>Ur.runKernel(qn,r,e),filter:()=>Ur.runKernel(Xn,i,e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $w={kernelName:Zn,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;const s={dy:t,y:e};return{x:()=>Ur.runKernel(Qn,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yw={kernelName:te,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;const s=Aa(_f(vh(Nf(e))),2/Math.sqrt(Math.PI));return{x:()=>Aa(t,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kw={kernelName:ee,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cw={kernelName:se,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>yu(t,e.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nw={kernelName:oe,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,_f(e))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rw={kernelName:ae,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sw={kernelName:ue,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{const n=Ta(t,wa(s,"float32"));const r=Wl(e.shape,o);if(r.length>0){return yu(Sf(n,r),e.shape)}return n};const i=()=>{let n=Aa(t,wa(e,"float32"));const r=Wl(s.shape,o);if(r.length>0){n=yu(Sf(n,r),s.shape)}const i=Nf(s);return vh(Ta(n,wa(i,"float32")))};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ew={kernelName:le,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:s}=e;const[o,r,i,c]=n;const a=c==null?$f(1):c;const u=Wl(r.shape,o.shape);const l=[];if(r.rank===1){for(let t=0;t<o.shape.length-1;++t){l.push(o.shape[t])}l.push(1)}const f=Rh(o,r);const h=Aa(t,a);const d=yp(Na(i,$f(s)));const p=Aa(Aa(Aa(d,d),d),$f(-.5));const m=()=>{if(r.rank===1){return yu(Aa(Aa(t,Vf(yu(d,[1,1,1,r.shape[0]]),l)),a),o.shape)}else{return yu(Aa(Aa(t,d),a),o.shape)}};const x=()=>{let t=Aa(Aa(d,$f(-1)),h);if(r.rank===1){t=Sf(t,u)}return yu(t,r.shape)};const b=()=>{let t=Aa(Aa(p,f),h);if(r.rank===1){t=Sf(t,u)}return yu(t,r.shape)};const g=()=>{const n=Aa(f,d);let e=Aa(t,n);if(r.rank===1){e=Sf(e,u)}return yu(e,r.shape)};const w=()=>{let n=t;if(r.rank===1){n=Sf(n,u)}return yu(n,r.shape)};return{x:m,mean:x,variance:b,scale:g,offset:w}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tw={kernelName:fe,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[s,o]=n;const{axis:r,batchDims:i}=e;const c=R(r,s.shape)[0];const a=(t,n,e)=>()=>{const s=t.shape;const o=n.size;const i=s.slice(0,c);const a=i.length;const u=s.slice(r,s.length).slice(1);const l=u.length;const f=Iw(0,a);const h=Iw(a+1,a+1+l);const d=Aw([i,[o],u]);const p=yu(e,d);const m=yu(n,[o]);const x=Aw([[a],f,h]);const b=Tm(p,x);let g=km(b,m,t.shape[c]);const w=df(x);g=Tm(g,w);return g};if(i===1){const n=s.shape[0];const e=s.split(n,0);const r=()=>{const n=om(e.map(((n,e)=>a(n,o.slice(e,1),t.slice(e,1))())));return n.reshape(s.shape)};return{x:r,indices:()=>o}}else{return{x:a(s,o,t),indices:()=>o}}}};function Iw(t,n){const e=[];for(let s=t;s<n;++s){e.push(s)}return e}function Aw(t){const n=[];for(let e=0;e<t.length;++e){for(let s=0;s<t[e].length;++s){n.push(t[e][s])}}return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ow={kernelName:pe,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;return{a:()=>Kl(e),b:()=>Kl(s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fw={kernelName:me,gradFunc:t=>({x:()=>wa(t,"float32")})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _w={kernelName:ge,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mw={kernelName:we,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dw={kernelName:ve,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lw={kernelName:$e,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{alpha:o}=e;const r=Xf(s,0);return{x:()=>ql(r,t,Aa(t,o))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zw={kernelName:Re,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,Na(e,1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pw={kernelName:Ne,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,wa(e,"float32"))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vw={kernelName:Ie,inputsToSave:[],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;return{logits:()=>{const n=true;const e=_f(s);return Rh(t,Aa(Sf(t,o,n),e))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(t,n,e,s=5,o=1,r=1,i=.5){const c={x:t,y:n,dy:e};const a={depthRadius:s,bias:o,alpha:r,beta:i};return Ur.runKernel(Oe,c,a)}const Ww=pc({localResponseNormalizationBackprop_:Bw});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gw={kernelName:Ae,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=e;return{x:()=>Ww(s,o,t,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(t,n,e,s){if(n.rank<e.rank){n=yu(n,lf(n.shape,s))}if(t.rank<e.rank){t=yu(t,lf(t.shape,s))}return{x:()=>{const s=Aa(t,wa(Hl(e,n),t.dtype));return s}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hw={kernelName:Fe,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const s=e;const{reductionIndices:o}=s;const r=n[0];const i=n[1];const c=R(o,r.shape);const a=Uw(t,i,r,c);return{x:()=>a["x"]()}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jw={kernelName:_e,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=()=>Aa(t,wa(Jf(e,s),"float32"));const r=()=>Aa(t,wa(ah(e,s),"float32"));return{a:o,b:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(t,n,e,s,o,r,i){const c=fc(t,"dy","maxPool3dGrad");const a=fc(n,"input","maxPool3dGrad");const u=fc(e,"output","maxPool3dGrad");let l=c;let f=a;let h=u;let d=false;if(a.rank===4){d=true;l=yu(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]);f=yu(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]);h=yu(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])}x(l.rank===5,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank `+`${l.rank}.`));x(f.rank===5,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank `+`${f.rank}.`));x(h.rank===5,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank `+`${h.rank}.`));vu("maxPool3dGrad",r,i);const p={dy:l,input:f,output:h};const m={filterSize:s,strides:o,pad:r,dimRoundingMode:i};const b=Ur.runKernel(ze,p,m);if(d){return yu(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]])}return b}const Xw=pc({maxPool3dGrad_:qw});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kw={kernelName:Le,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=e;return{x:()=>Xw(t,s,o,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(t,n,e,s,o,r,i){const c=fc(t,"dy","maxPoolGrad");const a=fc(n,"input","maxPoolGrad");const u=fc(e,"output","maxPoolGrad");x(a.rank===c.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy `+`(${c.rank})`));x(c.rank===4,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank `+`${c.rank}.`));x(a.rank===4,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank `+`${a.rank}.`));vu("maxPoolGrad",r,i);const l={dy:c,input:a,output:u};const f={filterSize:s,strides:o,pad:r,dimRoundingMode:i};return Ur.runKernel(De,l,f)}const Yw=pc({maxPoolGrad_:Jw});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zw={kernelName:Me,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{filterSize:r,strides:i,pad:c}=e;return{x:()=>Yw(t,s,o,r,i,c)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qw={kernelName:Ve,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;const r=R(o,s.shape);const i=uf(s.shape,r);const c=i[1];const a=w(c);const u=()=>{const n=s.shape.slice();r.forEach((t=>{n[t]=1}));const e=yu(t,n);const o=Ta(Aa(e,Xh(s.shape,"float32")),a);return o};return{x:u}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tv={kernelName:Be,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const s=e;const{axis:o}=s;const[r,i]=n;const c=R(o,r.shape);const a=Uw(t,i,r,c);return{x:()=>a["x"]()}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nv={kernelName:We,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=()=>Aa(t,wa(lh(e,s),"float32"));const r=()=>Aa(t,wa(Xf(e,s),"float32"));return{a:o,b:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ev={kernelName:Ge,inputsToSave:["x"],gradFunc:(t,n,e)=>{const s=n[0];const{paddings:o}=e;const r=o.map((t=>t[0]));return{x:()=>_u(t,r,s.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv={kernelName:Ue,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{const n=Wl(e.shape,o);if(n.length>0){return yu(Sf(t,n),e.shape)}return t};const i=()=>{const n=Aa(t,vh(Uf(Ta(e,s))));const r=Wl(s.shape,o);if(r.length>0){return yu(Sf(n,r),s.shape)}return n};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov={kernelName:je,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{const n=Aa(t,wa(s,"float32"));const r=Wl(e.shape,o);if(r.length>0){return yu(Sf(n,r),e.shape)}return n};const i=()=>{const n=Aa(t,wa(e,"float32"));const r=Wl(s.shape,o);if(r.length>0){return yu(Sf(n,r),s.shape)}return n};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rv={kernelName:qe,gradFunc:t=>({x:()=>vh(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iv={kernelName:Qe,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>qh(e.shape,"float32")}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv={kernelName:Ze,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const av={kernelName:ts,saveAllInputs:true,gradFunc:(t,n,e)=>{const{axis:s}=e;const o=Nm(t,s);return o.map((t=>()=>t))}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv={kernelName:ns,inputsToSave:["x"],gradFunc:(t,n,e)=>{const s=n[0];const{paddings:o}=e;const r=o.map((t=>t[0]));return{x:()=>_u(t,r,s.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lv={kernelName:es,inputsToSave:["a","b"],outputsToSave:[true],gradFunc:(t,n)=>{const[e,s,o]=n;const r=e;const i=s;const c=Gl(r.shape,i.shape);const a=()=>{const n=wa(i,"float32");let e=Aa(t,Aa(n,vf(r,Rh(n,$f(1)))));const s=Wl(r.shape,c);if(s.length>0){e=Sf(e,s)}return yu(e,r.shape)};const u=()=>{const n=Xf(r,0);const e=ql(n,ph(r),Kl(r));let s=Aa(t,Aa(o,e));const a=Wl(i.shape,c);if(a.length>0){s=Sf(s,a)}return yu(s,i.shape)};return{a,b:u}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fv={kernelName:ss,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,s]=n;const o=Xf(e,0);return{x:()=>ql(o,t,Aa(t,s)),alpha:()=>{let n=ql(o,Kl(t),Aa(t,e));const r=Wl(s.shape,t.shape);if(r.length>0){n=Sf(n,r)}return yu(n,s.shape)}}}};
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(t,n,e){const s=t.shape.slice();s[e]=1;const o=yu(n,s);const r=Il(t,e,true,false);const i=Il(t,e,true,true);const c=Aa(r,i);return Aa(o,c)}function dv(t,n,e){const s=t.shape.length;const o=s-e.length;const r=hf(e,s);let i=t;if(r!=null){i=Tm(t,r)}const c=i.shape.slice();const a=c.splice(s-e.length,e.length);const u=a.reduce(((t,n)=>t*n),1);c.push(u);const l=i.reshape(c);let f=hv(l,n,o);f=f.reshape(i.shape);if(r!=null){const t=df(r);f=Tm(f,t)}return f}const pv={kernelName:os,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;let r=[];if(o===undefined||o===null){r=s.shape.map(((t,n)=>n))}else if(typeof o==="number"){r=[o]}else{r=o}return{x:()=>dv(s,t,r)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv={kernelName:Jn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{const n=Ta(t,wa(s,"float32"));const r=Wl(e.shape,o);if(r.length>0){return yu(Sf(n,r),e.shape)}return n};const i=()=>{let n=Aa(t,wa(e,"float32"));const r=Wl(s.shape,o);if(r.length>0){n=yu(Sf(n,r),s.shape)}const i=Nf(s);return vh(Ta(n,wa(i,"float32")))};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xv={kernelName:ls,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,vh(Nf(e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bv={kernelName:bs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;const s=Aa(lh(e,6),im(e));return{x:()=>Aa(t,wa(s,"float32"))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gv={kernelName:fs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,wa(im(e),"float32"))}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wv={kernelName:hs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>yu(t,e.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vv={kernelName:ms,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[s]=n;const o={dy:t,images:s};const r=()=>Ur.runKernel(xs,o,e);return{images:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $v={kernelName:ds,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[s]=n;const o={dy:t,images:s};const r=()=>Ur.runKernel(ps,o,e);return{images:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yv={kernelName:gs,gradFunc:(t,n,e)=>{const{dims:s}=e;const o=R(s,t.shape);return{x:()=>gp(t,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kv={kernelName:ws,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cv={kernelName:vs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>vh(Ta(t,Aa(vf(e,1.5),2)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nv={kernelName:Cs,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>wa(Kl(e),"float32"),t:()=>Aa(t,wa(e,t.dtype)),e:()=>Aa(t,wa(_h(e),t.dtype))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rv={kernelName:Ns,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=Xf(e,$f(0));const s=$f(qb);const o=$f(Xb);const r=Aa(t,o);const i=Aa(Aa(t,s),_f(wa(e,"float32")));return ql(n,r,i)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sv={kernelName:Is,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,Aa(e,Rh($f(1),e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ev={kernelName:Ts,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tv={kernelName:Ss,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(Rl(wa(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iv={kernelName:Es,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(El(wa(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Av={kernelName:Rs,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{begin:o,size:r}=e;const i=s.shape;const[c,a]=kb(s,o,r);const u=[];for(let n=0;n<t.rank;n++){u.push([c[n],i[n]-c[n]-a[n]])}return{x:()=>ld(t,u)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ov={kernelName:Ds,outputsToSave:[true],gradFunc:(t,n,e)=>{const[s]=n;const{dim:o}=e;const r=true;const i=Aa(t,s);return{logits:()=>Rh(i,Aa(Sf(i,[o],r),s))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv={kernelName:As,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,Ou(e))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _v={kernelName:_s,gradFunc:(t,n,e)=>{const{blockShape:s,paddings:o}=e;return{x:()=>zu(t,s,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mv={kernelName:Ms,gradFunc:(t,n,e)=>{const{axis:s}=e;return{x:()=>Eu(t,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dv={kernelName:Os,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,Aa(kf(wa(e,"float32")),2))}}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lv={kernelName:Gs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(t,Aa(wa(e,"float32"),2))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zv={kernelName:Ws,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=$f(2);const r=()=>Aa(t,Aa(o,Rh(e,s)));const i=()=>Aa(t,Aa(o,Rh(s,e)));return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pv={kernelName:io,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vv={kernelName:Ks,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gl(e.shape,s.shape);const r=()=>{let n=t;const s=Wl(e.shape,o);if(s.length>0){n=Sf(n,s)}return yu(n,e.shape)};const i=()=>{let n=t;const e=Wl(s.shape,o);if(e.length>0){n=Sf(n,e)}return yu(vh(n),s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bv={kernelName:Fs,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const o=s.shape.slice();const{axis:r}=e;const i=R(r,s.shape);i.forEach((t=>{o[t]=1}));const c=yu(t,o);const a=Aa(c,Xh(s.shape,"float32"));return{x:()=>a}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wv={kernelName:Js,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Ta(t,Nf(Rl(e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gv={kernelName:Ys,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Aa(Rh($f(1),Nf(e)),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uv={kernelName:Zs,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{reps:o}=e;const r=()=>{let n=Kl(s);if(s.rank===1){for(let e=0;e<o[0];++e){n=Na(n,_u(t,[e*s.shape[0]],[s.shape[0]]))}}else if(s.rank===2){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){n=Na(n,_u(t,[e*s.shape[0],r*s.shape[1]],[s.shape[0],s.shape[1]]))}}}else if(s.rank===3){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){for(let i=0;i<o[2];++i){n=Na(n,_u(t,[e*s.shape[0],r*s.shape[1],i*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]))}}}}else if(s.rank===4){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){for(let i=0;i<o[2];++i){for(let c=0;c<o[3];++c){n=Na(n,_u(t,[e*s.shape[0],r*s.shape[1],i*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}}}}}else{throw new Error(`Gradient for tile operation is not implemented for rank-`+`${s.rank} tensors yet.`)}return n};return{x:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hv={kernelName:no,gradFunc:(t,n,e)=>{const s=e;const{perm:o}=s;const r=df(o);return{x:()=>Tm(t,r)}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jv={kernelName:so,gradFunc:(t,n,e)=>{const s=e;const{axis:o}=s;return{value:()=>om(t,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qv={kernelName:oo,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;const s=()=>Xv(t,e);return{x:s}}};function Xv(t,n){const e=Uh(n,Kl(n));const s=jf(t,e);let o=Jf(n,$f(0,"int32"));const r=s.rank-o.rank;for(let t=0;t<r;++t){o=Df(o,t+1)}o=Oh(o,Xh(s.shape,"bool"));const i=Kl(s);return ql(o,s,i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kv={kernelName:ro,gradFunc:t=>({x:()=>Kl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jv=[Pg,Vg,Bg,Wg,Gg,Ug,Hg,jg,qg,Xg,Kg,Jg,Qg,ew,sw,ow,rw,iw,cw,aw,uw,lw,hw,fw,mw,xw,bw,gw,ww,vw,mv,$w,yw,kw,Cw,Nw,Sw,Rw,Ew,Tw,Ow,Fw,_w,Mw,Dw,Lw,zw,Pw,Vw,Gw,Hw,Hw,jw,Kw,Zw,Qw,tv,nv,ev,sv,ov,rv,iv,cv,av,uv,uv,lv,fv,pv,xv,bv,gv,wv,vv,$v,yv,kv,Cv,Nv,Rv,Sv,Ev,Tv,Iv,Av,Ov,Fv,_v,_v,Mv,Mv,Dv,zv,Lv,Pv,Vv,Bv,Wv,Gv,Uv,Hv,jv,qv,Kv];for(const t of Jv){$o(t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.abs=function(){this.throwIfDisposed();return Fa(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.acos=function(){this.throwIfDisposed();return Ma(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.acosh=function(){this.throwIfDisposed();return La(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.add=function(t){this.throwIfDisposed();return Na(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.all=function(t,n){this.throwIfDisposed();return Pa(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.any=function(t,n){this.throwIfDisposed();return Ba(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.argMax=function(t){this.throwIfDisposed();return Ga(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.argMin=function(t){this.throwIfDisposed();return Ha(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.asScalar=function(){this.throwIfDisposed();x(this.size===1,(()=>"The array must have only 1 element."));return yu(this,[])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.asType=function(t){this.throwIfDisposed();return wa(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.as1D=function(){this.throwIfDisposed();return yu(this,[this.size])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.as2D=function(t,n){this.throwIfDisposed();return yu(this,[t,n])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.as3D=function(t,n,e){this.throwIfDisposed();return yu(this,[t,n,e])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.as4D=function(t,n,e,s){this.throwIfDisposed();return yu(this,[t,n,e,s])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.as5D=function(t,n,e,s,o){this.throwIfDisposed();return yu(this,[t,n,e,s,o])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.asin=function(){this.throwIfDisposed();return qa(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.asinh=function(){this.throwIfDisposed();return Ka(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.atan=function(){this.throwIfDisposed();return Ya(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.atan2=function(t){this.throwIfDisposed();return Qa(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.atanh=function(){this.throwIfDisposed();return nu(this)};kr().prototype.avgPool=function(t,n,e,s){this.throwIfDisposed();return Cu(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.batchToSpaceND=function(t,n){this.throwIfDisposed();return zu(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.batchNorm=function(t,n,e,s,o){this.throwIfDisposed();return Bu(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.broadcastTo=function(t){this.throwIfDisposed();return Yu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.cast=function(t){this.throwIfDisposed();return wa(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.ceil=function(){this.throwIfDisposed();return Qu(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.clipByValue=function(t,n){this.throwIfDisposed();return el(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.concat=function(t,n){this.throwIfDisposed();if(t instanceof yr){t=[t]}return Eu([this,...t],n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.conv1d=function(t,n,e,s,o,r){this.throwIfDisposed();return pl(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.conv2dTranspose=function(t,n,e,s,o){this.throwIfDisposed();return gl(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.conv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return hl(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.cos=function(){this.throwIfDisposed();return Rl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.cosh=function(){this.throwIfDisposed();return El(this)};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.cumprod=function(t,n,e){this.throwIfDisposed();return Il(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.cumsum=function(t,n,e){this.throwIfDisposed();return Ol(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.depthToSpace=function(t,n){this.throwIfDisposed();return Dl(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.depthwiseConv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return zl(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.dilation2d=function(t,n,e,s,o){this.throwIfDisposed();return Vl(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.divNoNan=function(t){this.throwIfDisposed();return Yl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.div=function(t){this.throwIfDisposed();return Ta(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.dot=function(t){this.throwIfDisposed();return Ql(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.elu=function(){this.throwIfDisposed();return sf(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.equal=function(t){this.throwIfDisposed();return Hl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.erf=function(){this.throwIfDisposed();return rf(this)};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.euclideanNorm=function(t,n){this.throwIfDisposed();return Of(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.exp=function(){this.throwIfDisposed();return _f(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.expandDims=function(t){this.throwIfDisposed();return Df(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.expm1=function(){this.throwIfDisposed();return zf(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.fft=function(){this.throwIfDisposed();return Up(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.flatten=function(){this.throwIfDisposed();return yu(this,[this.size])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.floor=function(){this.throwIfDisposed();return Uf(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.floorDiv=function(t){this.throwIfDisposed();return Sa(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.gather=function(t,n,e){this.throwIfDisposed();return jf(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.greaterEqual=function(t){this.throwIfDisposed();return Jf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.greater=function(t){this.throwIfDisposed();return Xf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.ifft=function(){this.throwIfDisposed();return jp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.irfft=function(){this.throwIfDisposed();return Xp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.isFinite=function(){this.throwIfDisposed();return th(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.isInf=function(){this.throwIfDisposed();return eh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.isNaN=function(){this.throwIfDisposed();return oh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.leakyRelu=function(t){this.throwIfDisposed();return ih(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.lessEqual=function(t){this.throwIfDisposed();return lh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.less=function(t){this.throwIfDisposed();return ah(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.localResponseNormalization=function(t,n,e,s){this.throwIfDisposed();return hh(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logSigmoid=function(){this.throwIfDisposed();return Ch(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logSoftmax=function(t){this.throwIfDisposed();return Eh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logSumExp=function(t,n){this.throwIfDisposed();return Ih(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.log=function(){this.throwIfDisposed();return ph(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.log1p=function(){this.throwIfDisposed();return xh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logicalAnd=function(t){this.throwIfDisposed();return Oh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logicalNot=function(){this.throwIfDisposed();return _h(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logicalOr=function(t){this.throwIfDisposed();return Dh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.logicalXor=function(t){this.throwIfDisposed();return zh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.matMul=function(t,n,e){this.throwIfDisposed();return Iu(this,t,n,e)};kr().prototype.maxPool=function(t,n,e,s){this.throwIfDisposed();return Vh(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.max=function(t,n){this.throwIfDisposed();return xf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.maximum=function(t){this.throwIfDisposed();return Uh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.mean=function(t,n){this.throwIfDisposed();return jh(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.min=function(t,n){this.throwIfDisposed();return gf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.minimum=function(t){this.throwIfDisposed();return Jh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.mirrorPad=function(t,n){this.throwIfDisposed();return Zh(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.mod=function(t){this.throwIfDisposed();return td(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.mul=function(t){this.throwIfDisposed();return Aa(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.neg=function(){this.throwIfDisposed();return vh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.norm=function(t,n,e){this.throwIfDisposed();return If(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.notEqual=function(t){this.throwIfDisposed();return od(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.oneHot=function(t,n=1,e=0){this.throwIfDisposed();return id(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.onesLike=function(){this.throwIfDisposed();return ad(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.pad=function(t,n){this.throwIfDisposed();return ld(this,t,n)};kr().prototype.pool=function(t,n,e,s,o,r){this.throwIfDisposed();return xd(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.pow=function(t){this.throwIfDisposed();return vf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.prelu=function(t){this.throwIfDisposed();return gd(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.prod=function(t,n){this.throwIfDisposed();return vd(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.reciprocal=function(){this.throwIfDisposed();return hp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.relu=function(){this.throwIfDisposed();return pp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.relu6=function(){this.throwIfDisposed();return xp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.reshapeAs=function(t){this.throwIfDisposed();return yu(this,t.shape)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.reshape=function(t){this.throwIfDisposed();return yu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.resizeBilinear=function(t,n,e){this.throwIfDisposed();return Ex(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.resizeNearestNeighbor=function(t,n,e){this.throwIfDisposed();return Ix(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.reverse=function(t){this.throwIfDisposed();return gp(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.rfft=function(){this.throwIfDisposed();return Zp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.round=function(){this.throwIfDisposed();return vp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.rsqrt=function(){this.throwIfDisposed();return yp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.selu=function(){this.throwIfDisposed();return Cp(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.separableConv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return Rp(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sigmoid=function(){this.throwIfDisposed();return Ou(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sign=function(){this.throwIfDisposed();return Ep(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sin=function(){this.throwIfDisposed();return Ip(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sinh=function(){this.throwIfDisposed();return Op(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.slice=function(t,n){this.throwIfDisposed();return _u(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.softmax=function(t){this.throwIfDisposed();return Wp(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.softplus=function(){this.throwIfDisposed();return yh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.spaceToBatchND=function(t,n){this.throwIfDisposed();return hd(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.split=function(t,n){this.throwIfDisposed();return Jp(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sqrt=function(){this.throwIfDisposed();return kf(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.square=function(){this.throwIfDisposed();return Nf(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.squaredDifference=function(t){this.throwIfDisposed();return tm(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.squeeze=function(t){this.throwIfDisposed();return em(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof yr?[this,t]:[this,...t];return om(e,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.step=function(t){this.throwIfDisposed();return im(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.stridedSlice=function(t,n,e,s,o,r,i,c){this.throwIfDisposed();return am(this,t,n,e,s,o,r,i,c)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sub=function(t){this.throwIfDisposed();return Rh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.sum=function(t,n){this.throwIfDisposed();return Sf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.tan=function(){this.throwIfDisposed();return lm(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.tanh=function(){this.throwIfDisposed();return Du(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.tile=function(t){this.throwIfDisposed();return Vf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.toBool=function(){this.throwIfDisposed();return wa(this,"bool")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.toFloat=function(){this.throwIfDisposed();return wa(this,"float32")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.toInt=function(){this.throwIfDisposed();return wa(this,"int32")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.topk=function(t,n){this.throwIfDisposed();return bm(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.transpose=function(t){this.throwIfDisposed();return Tm(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.unique=function(t){this.throwIfDisposed();return $m(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.unsortedSegmentSum=function(t,n){this.throwIfDisposed();return km(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.unstack=function(t){this.throwIfDisposed();return Nm(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.where=function(t,n){this.throwIfDisposed();return ql(t,this,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kr().prototype.zerosLike=function(){this.throwIfDisposed();return Kl(this)};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Yv extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Yv.prototype)}}class Zv extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Zv.prototype)}}class Qv extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Qv.prototype)}}class t$ extends Error{constructor(t){super(t);Object.setPrototypeOf(this,t$.prototype)}}class n$ extends Error{constructor(t){super(t);Object.setPrototypeOf(this,n$.prototype)}}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class e${constructor(t){this.maxEntries=t||100;this.cache=new Map}get(t){let n;if(this.cache.has(t)){n=this.cache.get(t);this.cache.delete(t);this.cache.set(t,n)}return n}put(t,n){if(this.cache.has(t)){this.cache.delete(t)}else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0){throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`)}if(this.maxEntries>t){for(let n=0;n<this.maxEntries-t;n++){const t=this.cache.keys().next().value;this.cache.delete(t)}}this.maxEntries=t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function s$(t,n){if(Array.isArray(t)){let e=[];for(let s=0;s<n;s++){e=e.concat(t)}return e}else{const e=new Array(n);e.fill(t);return e}}function o$(t,n){if(!t){throw new n$(n)}}function r$(t,n){let e=0;for(const s of t){if(s===n){e++}}return e}function i$(t){if(t.length===1){return t[0]}return t}function c$(t){if(Array.isArray(t)){return t}return[t]}function a$(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2");const e=n.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();if(e[0]!=="_"){return e}return"private"+e}function u$(t){if(t.length<=1){return t}if(t.indexOf("_")===-1){return t}return t.replace(/[_]+(\w|$)/g,((t,n)=>n.toUpperCase()))}let l$={};function f$(t){if(t===null||t===undefined){return null}const n={};n["className"]=t.getClassName();n["config"]=t.getConfig();return n}function h$(t){if(t==null||typeof t!=="object"){return}else if(Array.isArray(t)){t.forEach((t=>h$(t)))}else{const n=Object.keys(t);for(const e of n){const n=t[e];if(n!=null&&typeof n==="object"){if(!Array.isArray(n)&&n["type"]==="ndarray"&&typeof n["value"]==="number"){t[e]=n["value"]}else{h$(n)}}}}}function d$(t,n={},e={},s="object",o=false){if(typeof t==="string"){const o=t;let r;if(o in e){r=e[o]}else if(o in l$){r=l$[o]}else{r=n[o];if(r==null){throw new Qv(`Unknown ${s}: ${t}. `+`This may be due to one of the following reasons:\n`+`1. The ${s} is defined in Python, in which `+`case it needs to be ported to TensorFlow.js or your JavaScript `+`code.\n`+`2. The custom ${s} is defined in JavaScript, `+`but is not registered properly with `+`tf.serialization.registerClass().`)}}return r}else{const r=t;if(r["className"]==null||r["config"]==null){throw new Qv(`${s}: Improper config format: `+`${JSON.stringify(r)}.\n`+`'className' and 'config' must set.`)}const i=r["className"];let c,a;if(i in e){[c,a]=e[i]}else if(i in l$){[c,a]=l$["className"]}else if(i in n){[c,a]=n[i]}if(c==null){throw new Qv(`Unknown ${s}: ${i}. `+`This may be due to one of the following reasons:\n`+`1. The ${s} is defined in Python, in which `+`case it needs to be ported to TensorFlow.js or your JavaScript `+`code.\n`+`2. The custom ${s} is defined in JavaScript, `+`but is not registered properly with `+`tf.serialization.registerClass().`)}if(a!=null){const t={};for(const n of Object.keys(l$)){t[n]=l$[n]}for(const n of Object.keys(e)){t[n]=e[n]}const n=r["config"];n["customObjects"]=t;const s=Object.assign({},l$);for(const t of Object.keys(e)){l$[t]=e[t]}h$(r["config"]);const i=a(c,r["config"],e,o);l$=Object.assign({},s);return i}else{const t=Object.assign({},l$);for(const t of Object.keys(e)){l$[t]=e[t]}const n=new c(r["config"]);l$=Object.assign({},t);return n}}}function p$(t,n){return t<n?-1:t>n?1:0}function m$(t,n){return-1*p$(t,n)}function x$(t){if(t==null){return t}const n=[];for(const e of t){if(n.indexOf(e)===-1){n.push(e)}}return n}function b$(t){if(t==null){throw new Qv(`Invalid value in obj: ${JSON.stringify(t)}`)}for(const n in t){if(t.hasOwnProperty(n)){return false}}return true}function g$(t,n,e){if(e==null){return}if(t.indexOf(e)<0){throw new Qv(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}}function w$(t,n,e=0,s=Infinity){o$(e>=0);o$(s>=e);return Array.isArray(t)&&t.length>=e&&t.length<=s&&t.every((t=>typeof t===n))}function v$(t,n){if(Array.isArray(t)){x(t.length>0,(()=>`${n} is unexpectedly an empty array.`));t.forEach(((t,e)=>v$(t,`element ${e+1} of ${n}`)))}else{x(Number.isInteger(t)&&t>0,(()=>`Expected ${n} to be a positive integer, but got `+`${$$(t)}.`))}}function $$(t){if(t===null){return"null"}else if(Array.isArray(t)){return"["+t.map((t=>$$(t))).join(",")+"]"}else if(typeof t==="string"){return`"${t}"`}else{return`${t}`}}function y$(t,n,e){let s=e!=null?e():Zo();let o;const r=(...r)=>{const i=e!=null?e():Zo();if(i-s<n){return o}s=i;o=t(...r);return o};return r}function k$(t){if(t==="relu"){return"relu"}if(t==="linear"){return"linear"}if(t==="elu"){return"elu"}return null}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let C$=0;function N$(){return C$++}const R$={};function S$(t=""){if(!(t in R$)){R$[t]=0}R$[t]+=1;return t+R$[t].toString()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const E$=["channelsFirst","channelsLast"];const T$=["nearest","bilinear"];const I$=["valid","same","causal"];const A$=["max","avg"];const O$=["sum","mul","concat","ave"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const F$=new Map;function _$(t){g$(E$,"DataFormat",t)}function M$(t){g$(T$,"InterpolationFormat",t)}function D$(t){g$(I$,"PaddingMode",t)}function L$(t){g$(A$,"PoolMode",t)}const z$=[];const P$="/";function V$(t,n){z$.push(t);try{const t=n();z$.pop();return t}catch(t){z$.pop();throw t}}function B$(){if(z$.length===0){return""}else{return z$.join(P$)+P$}}function W$(t){if(!H$(t)){throw new Error("Not a valid tensor name: '"+t+"'")}return B$()+t}function G$(t){if(!H$(t)){throw new Error("Not a valid tensor name: '"+t+"'")}if(!F$.has(t)){F$.set(t,0)}const n=F$.get(t);F$.set(t,F$.get(t)+1);if(n>0){const e=`${t}_${n}`;F$.set(e,1);return e}else{return t}}const U$=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function H$(t){return!!t.match(U$)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j$(t){return t===parseInt(t.toString(),10)}function q$(t,n,e){if(n==null){n=0}if(e==null){e=t.length}let s=1;for(let o=n;o<e;++o){s*=t[o]}return s}function X$(t){if(t.length===0){return Number.NaN}let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const s=t[e];if(s<n){n=s}}return n}function K$(t){if(t.length===0){return Number.NaN}let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const s=t[e];if(s>n){n=s}}return n}function J$(t,n){if(n<t){throw new Qv(`end (${n}) < begin (${t}) is forbidden.`)}const e=[];for(let s=t;s<n;++s){e.push(s)}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Y$;function Z$(){if(Y$==null){Y$=Sc().epsilon()}return Y$}function Q$(){return"channelsLast"}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ty(t,n){return wa(t,n)}function ny(t,n=-1){const e=t.shape.slice();if(n<0){n=e.length+n+1}e.splice(n,0,1);return yu(t,e)}function ey(t,n){return kc((()=>{if(t.shape.length!==2){throw new Qv(`repeat() expects a rank-2 tensor, but received a `+`rank-${t.shape.length} tensor.`)}const e=ny(t,1);return ly(e,[1,n,1])}))}function sy(t){const n=[q$(t.shape)];return yu(t,n)}function oy(t){if(t.rank<=1){throw new Qv(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`)}const n=[t.shape[0],q$(t.shape,1)];return yu(t,n)}function ry(t,n,e){return kc((()=>{switch(t.rank){case 1:return _p(t,n,e);case 2:return Dp(t,[n,0],[e,t.shape[1]]);case 3:return zp(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return Vp(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return _u(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return _u(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new Qv(`sliceAlongFirstAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function iy(t,n,e){return kc((()=>{switch(t.rank){case 1:return _p(t,n,e);case 2:return Dp(t,[0,n],[t.shape[0],e]);case 3:return zp(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return Vp(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new Qv(`sliceAlongLastAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function cy(t,n,e,s){return kc((()=>{switch(t.rank){case 1:return _p(t,n,e);case 2:switch(s){case 1:return ry(t,n,e);case 2:return iy(t,n,e);default:throw new Qv(`The axis is not within the rank of the tensor `+`${s}`)}case 3:switch(s){case 1:return ry(t,n,e);case 2:return zp(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return iy(t,n,e);default:throw new Qv(`The axis is not within the rank of the tensor `+`${s}`)}case 4:switch(s){case 1:return ry(t,n,e);case 2:return Vp(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return Vp(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return iy(t,n,e);default:throw new Qv(`The axis is not within the rank of the tensor `+`${s}`)}default:throw new Qv(`sliceAlongLastAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function ay(t,n=-1){let e;if(n<0){e=t[0].rank;if(e!==0){n=e}else{n=0}}if(n===t[0].rank){n=-1}return Eu(t,n)}function uy(t,n){switch(t.rank){case 1:return ol([t,n]);case 2:return il([t,n],0);case 3:return al([t,n],0);case 4:return ll([t,n],0);default:throw new Qv(`concatAlongFirstAxis() received an unsupported `+`tensor rank: ${t.rank}`)}}function ly(t,n){if(!Array.isArray(n)){n=[n]}if(t.rank!==n.length){throw new Qv(`The length of input n (${n.length}) does not match `+`the number of dimensions in input x (${t.rank})`)}return Vf(t,n)}function fy(t,n=0,e=1,s,o){return rp(t,n,e,s,o)}function hy(t,n,e,s){if(t.rank<2||n.rank<2){throw new t$(`dot requires both inputs to be rank >= 2`+` but got x shape = ${t.shape} and y shape = ${n.shape}`)}if(n.rank>=3){const e=t.shape.slice(-1)[0];const s=n.shape.slice(-2)[0];if(e!==s){throw new t$(`If rank y >= 3, then the second last dim`+` of y must equal the last dim of x but got x shape = ${t.shape} and `+` y shape = ${n.shape}`)}}if(t.rank===2&&n.rank===2){const o=false;const r=false;return jm({a:t,b:n,transposeA:o,transposeB:r,bias:s?my(t.rank,s,Q$()):null,activation:e})}else{const o=t.shape.slice();const r=o.pop();t=yu(t,[-1,r]);const i=n.shape.slice();const c=i.pop();const a=i.pop();const u=[...i,c];const l=Array.from({length:n.rank},((t,e)=>{if(e===0){return n.rank-2}else if(e<=n.rank-2){return e-1}return e}));n=yu(Tm(n,l),[a,-1]);const f=[...o,...u];const h=false;const d=false;return yu(jm({a:t,b:n,transposeA:h,transposeB:d,bias:s?my(t.rank,s,Q$()):null,activation:e}),f)}}function dy(t,n,e){return kc((()=>{if(Array.isArray(n)){n=fm(n,"int32")}else{n=wa(n,"int32")}return jf(t,n,e)}))}function py(t){return Aa(t,t)}function my(t,n,e){const s=n.shape;if(n.rank!==1&&n.rank!==t){throw new Qv(`Unexpected bias dimensions: ${n.rank}`+`; expected it to be 1 or ${t}`)}if(t===5){if(e==="channelsFirst"){if(s.length===1){return yu(n,[1,s[0],1,1,1])}else{return yu(n,[1,s[3],s[0],s[1],s[2]])}}else if(e==="channelsLast"){if(s.length===1){return yu(n,[1,1,1,1,s[0]])}else{return yu(n,[1].concat(s))}}}else if(t===4){if(e==="channelsFirst"){if(s.length===1){return yu(n,[1,s[0],1,1])}else{return yu(n,[1,s[2],s[0],s[1]])}}else if(e==="channelsLast"){if(s.length===1){return yu(n,[1,1,1,s[0]])}else{return yu(n,[1].concat(s))}}}else if(t===3){if(e==="channelsFirst"){if(s.length===1){return yu(n,[1,s[0],1])}else{return yu(n,[1,s[1],s[0]])}}else if(e==="channelsLast"){if(s.length===1){return yu(n,[1,1,s[0]])}else{return yu(n,[1].concat(s))}}}else if(t<3){return n}throw new Qv(`Unsupported input rank by biasAdd: ${n.rank}`)}function xy(t,n,e){return kc((()=>{if(e==null){e=Q$()}_$(e);return Na(t,my(t.rank,n,e))}))}function by(t,n=1){if(n!==1){throw new t$(`Support for alpha values other than 1 (${n}) is not implemented `+`yet.`)}return sf(t)}function gy(t){return kc((()=>Ta(t,Na(Fa(t),1))))}function wy(t,n,e,s){return kc((()=>Om(t,n,e,s)))}function vy(t){return kc((()=>{const n=Na(.5,Aa(.2,t));return el(n,0,1)}))}function $y(t,n,e=false){return e?t():n()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const yy=["fanIn","fanOut","fanAvg"];const ky=["normal","uniform","truncatedNormal"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cy(t){g$(yy,"FanMode",t)}function Ny(t){g$(ky,"Distribution",t)}class Ry extends qx{fromConfigUsesCustomObjects(){return false}getConfig(){return{}}}class Sy extends Ry{apply(t,n){return qh(t,n)}}Sy.className="Zeros";Kx(Sy);class Ey extends Ry{apply(t,n){return Xh(t,n)}}Ey.className="Ones";Kx(Ey);class Ty extends Ry{constructor(t){super();if(typeof t!=="object"){throw new Qv(`Expected argument of type ConstantConfig but got ${t}`)}if(t.value===undefined){throw new Qv(`config must have value set but got ${t}`)}this.value=t.value}apply(t,n){return kc((()=>Aa($f(this.value),Xh(t,n))))}getConfig(){return{value:this.value}}}Ty.className="Constant";Kx(Ty);class Iy extends Ry{constructor(t){super();this.DEFAULT_MINVAL=-.05;this.DEFAULT_MAXVAL=.05;this.minval=t.minval||this.DEFAULT_MINVAL;this.maxval=t.maxval||this.DEFAULT_MAXVAL;this.seed=t.seed}apply(t,n){return cp(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Iy.className="RandomUniform";Kx(Iy);class Ay extends Ry{constructor(t){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=t.mean||this.DEFAULT_MEAN;this.stddev=t.stddev||this.DEFAULT_STDDEV;this.seed=t.seed}apply(t,n){n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new t$(`randomNormal does not support dType ${n}.`)}return fy(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ay.className="RandomNormal";Kx(Ay);class Oy extends Ry{constructor(t){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=t.mean||this.DEFAULT_MEAN;this.stddev=t.stddev||this.DEFAULT_STDDEV;this.seed=t.seed}apply(t,n){n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new t$(`truncatedNormal does not support dType ${n}.`)}return wm(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Oy.className="TruncatedNormal";Kx(Oy);class Fy extends Ry{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,n){return kc((()=>{if(t.length!==2||t[0]!==t[1]){throw new Qv("Identity matrix initializer can only be used for"+" 2D square matrices.")}else{return Aa(this.gain,Wf(t[0]))}}))}getConfig(){return{gain:this.gain}}}Fy.className="Identity";Kx(Fy);function _y(t,n="channelsLast"){let e;let s;_$(n);if(t.length===2){e=t[0];s=t[1]}else if([3,4,5].indexOf(t.length)!==-1){if(n==="channelsFirst"){const n=q$(t,2);e=t[1]*n;s=t[0]*n}else if(n==="channelsLast"){const n=q$(t,0,t.length-2);e=t[t.length-2]*n;s=t[t.length-1]*n}}else{const n=q$(t);e=Math.sqrt(n);s=Math.sqrt(n)}return[e,s]}class My extends Ry{constructor(t){super();if(t.scale<0){throw new Qv(`scale must be a positive float. Got: ${t.scale}`)}this.scale=t.scale==null?1:t.scale;this.mode=t.mode==null?"fanIn":t.mode;Cy(this.mode);this.distribution=t.distribution==null?"normal":t.distribution;Ny(this.distribution);this.seed=t.seed}apply(t,n){const e=_y(t);const s=e[0];const o=e[1];let r=this.scale;if(this.mode==="fanIn"){r/=Math.max(1,s)}else if(this.mode==="fanOut"){r/=Math.max(1,o)}else{r/=Math.max(1,(s+o)/2)}if(this.distribution==="normal"){const e=Math.sqrt(r);n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new t$(`${this.getClassName()} does not support dType ${n}.`)}return wm(t,0,e,n,this.seed)}else{const e=Math.sqrt(3*r);return cp(t,-e,e,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}My.className="VarianceScaling";Kx(My);class Dy extends My{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return My.className}}Dy.className="GlorotUniform";Kx(Dy);class Ly extends My{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return My.className}}Ly.className="GlorotNormal";Kx(Ly);class zy extends My{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return My.className}}zy.className="HeNormal";Kx(zy);class Py extends My{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return My.className}}Py.className="HeUniform";Kx(Py);class Vy extends My{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return My.className}}Vy.className="LeCunNormal";Kx(Vy);class By extends My{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return My.className}}By.className="LeCunUniform";Kx(By);class Wy extends Ry{constructor(t){super();this.DEFAULT_GAIN=1;this.ELEMENTS_WARN_SLOW=2e3;this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain;this.seed=t.seed}apply(t,n){return kc((()=>{if(t.length<2){throw new t$("Shape must be at least 2D.")}if(n!=="int32"&&n!=="float32"&&n!==undefined){throw new TypeError(`Unsupported data type ${n}.`)}n=n;const e=w(t.slice(0,-1));const s=t[t.length-1];const o=e*s;if(o>this.ELEMENTS_WARN_SLOW){console.warn(`Orthogonal initializer is being called on a matrix with more `+`than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: `+`Slowness may result.`)}const r=[Math.max(s,e),Math.min(s,e)];const i=fy(r,0,1,n,this.seed);const c=Ux.qr(i,false);let a=c[0];const u=c[1];const l=u.flatten().stridedSlice([0],[Math.min(s,e)*Math.min(s,e)],[Math.min(s,e)+1]);a=Aa(a,l.sign());if(e<s){a=a.transpose()}return Aa($f(this.gain),a.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Wy.className="Orthogonal";Kx(Wy);const Gy={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Uy(t,n={}){return d$(t,Xx.getMap().classNameMap,n,"initializer")}function Hy(t){return f$(t)}function jy(t){if(typeof t==="string"){const n=t in Gy?Gy[t]:t;if(n==="GlorotNormal"){return new Ly}else if(n==="GlorotUniform"){return new Dy}else if(n==="HeNormal"){return new zy}else if(n==="HeUniform"){return new Py}else if(n==="LeCunNormal"){return new Vy}else if(n==="LeCunUniform"){return new By}else{const t={};t["className"]=n;t["config"]={};return Uy(t)}}else if(t instanceof Ry){return t}else{return Uy(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qy(t){return Array.isArray(t)&&Array.isArray(t[0])}function Xy(t){if(t.length===0){return[]}if(!Array.isArray(t[0])){return[t]}return t}function Ky(t){let n;if(Array.isArray(t)){if(t.length!==1){throw new Qv(`Expected Tensor length to be 1; got ${t.length}`)}n=t[0]}else{n=t}return n}function Jy(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1){t=t;return t[0]}else{throw new Qv(`Expected exactly 1 Shape; got ${t.length}`)}}else{return t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yy(t){let n=0;for(const e of t){if(e.shape.length===0){n+=1}else{n+=e.shape.reduce(((t,n)=>t*n))}}return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Zy="Variable";class Qy{constructor(t,n="float32",e=Zy,s=true,o=null){this.dtype=n==null?"float32":n;this.shape=t.shape;this.id=N$();e=e==null?Zy:e;this.originalName=W$(e);this.name=G$(this.originalName);this.trainable_=s;this.constraint=o;this.val=Rm(t,this.trainable_,this.name,this.dtype)}read(){this.assertNotDisposed();return this.val}write(t){this.assertNotDisposed();tk(this.val,t);if(this.val.id!==t.id){this.val.assign(t);if(this.constraint!=null){this.val.assign(this.constraint.apply(this.val))}}return this}dispose(){this.assertNotDisposed();this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed){throw new Error(`LayersVariable ${this.name} is already disposed.`)}}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t;this.val.trainable=t}}function tk(t,n){if(t.shape.toString()!==n.shape.toString()){throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}}function nk(t){return t.map((t=>t.read()))}function ek(t){t.forEach((t=>{const n=t[0];n.write(t[1])}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sk{constructor(t){this.dtype=t.dtype;this.shape=t.shape;if(t.shape!=null){this.ndim=t.shape.length}else{this.ndim=t.ndim}this.maxNDim=t.maxNDim;this.minNDim=t.minNDim;this.axes=t.axes||{}}}class ok{constructor(t,n,e,s,o,r,i){this.dtype=t;this.shape=n;this.sourceLayer=e;this.inputs=s;this.callArgs=o;this.outputTensorIndex=i;this.id=N$();if(r!=null){this.originalName=W$(r);this.name=G$(this.originalName)}this.rank=n.length}}let rk=0;class ik{constructor(t,n){this.callArgs=n;this.id=rk++;this.outboundLayer=t.outboundLayer;this.inboundLayers=t.inboundLayers;this.nodeIndices=t.nodeIndices;this.tensorIndices=t.tensorIndices;this.inputTensors=t.inputTensors;this.outputTensors=t.outputTensors;this.inputMasks=t.inputMasks;this.outputMasks=t.outputMasks;this.inputShapes=t.inputShapes;this.outputShapes=t.outputShapes;for(const n of t.inboundLayers){if(n!=null){n.outboundNodes.push(this)}}t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers){if(n!=null){t.push(n.name)}else{t.push(null)}}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ck=0;class ak extends qx{constructor(t={}){super();this._callHook=null;this._addedWeightNames=[];this._stateful=false;this.id=ck++;this.activityRegularizer=null;this.inputSpec=null;this.supportsMasking=false;this._trainableWeights=[];this._nonTrainableWeights=[];this._losses=[];this._updates=[];this._built=false;this.inboundNodes=[];this.outboundNodes=[];let n=t.name;if(!n){const t=this.getClassName();n=a$(t)+"_"+S$(t)}this.name=n;this.trainable_=t.trainable==null?true:t.trainable;if(t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null){n=t.batchInputShape}else if(t.inputShape!=null){let e=null;if(t.batchSize!=null){e=t.batchSize}n=[e].concat(t.inputShape)}this.batchInputShape=n;let e=t.dtype;if(e==null){e=t.inputDType}if(e==null){e="float32"}this.dtype=e}if(t.weights!=null){this.initialWeights=t.weights}else{this.initialWeights=null}this._refCount=null;this.fastWeightInitDuringBuild=false}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0){throw new Zv("The layer has never been called "+`and thus has no defined ${n}.`)}if(this.inboundNodes.length<=t){throw new Qv(`Asked to get ${n} at node ${t}, `+`but the layer has only ${this.inboundNodes.length} inbound nodes.`)}return this.inboundNodes[t]}getInputAt(t){return i$(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return i$(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1){throw new Yv(`Layer ${this.name}`+" has multiple inbound nodes, "+'hence the notion of "layer input" '+"is ill-defined. "+"Use `getInputAt(nodeIndex)` instead.")}else if(this.inboundNodes.length===0){throw new Yv(`Layer ${this.name}`+" is not connected, no input to return.")}return i$(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0){throw new Yv(`Layer ${this.name}`+" has no inbound nodes.")}if(this.inboundNodes.length>1){throw new Yv(`Layer ${this.name}`+" has multiple inbound nodes, "+'hence the notion of "layer output" '+"is ill-defined. "+"Use `getOutputAt(nodeIndex)` instead.")}return i$(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((n=>n.trainable=t));this.trainable_=t}get trainableWeights(){if(this.trainable_){return this._trainableWeights.filter((t=>t.trainable))}else{return[]}}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){if(this.trainable){return this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights)}else{return this._trainableWeights.concat(this._nonTrainableWeights)}}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful){throw new Error("Cannot call the resetStates() method of a non-stateful Layer "+"object.")}}assertInputCompatibility(t){const n=c$(t);if(this.inputSpec==null||this.inputSpec.length===0){return}const e=c$(this.inputSpec);if(n.length!==e.length){throw new Qv(`Layer ${this.name} expects ${e.length} inputs, `+`but it received ${n.length} input tensors. `+`Input received: ${t}`)}for(let t=0;t<n.length;t++){const s=n[t];const o=e[t];if(o==null){continue}const r=s.rank;if(o.ndim!=null){if(r!==o.ndim){throw new Qv(`Input ${t} is incompatible with layer ${this.name}: `+`expected ndim=${o.ndim}, found ndim=${r}`)}}if(o.maxNDim!=null){if(r>o.maxNDim){throw new Qv(`Input ${t} is incompatible with layer ${this.name}`+`: expected max_ndim=${o.maxNDim}, found ndim=${r}`)}}if(o.minNDim!=null){if(r<o.minNDim){throw new Qv(`Input ${t} is incompatible with layer ${this.name}`+`: expected min_ndim=${o.minNDim}, found ndim=${r}.`)}}if(o.dtype!=null){if(s.dtype!==o.dtype){throw new Qv(`Input ${t} is incompatible with layer ${this.name} `+`: expected dtype=${o.dtype}, found dtype=${s.dtype}.`)}}if(o.axes){const n=s.shape;for(const e in o.axes){const s=Number(e);const r=o.axes[e];const i=s>=0?n[s]:n[n.length+s];if(r!=null&&[r,null].indexOf(i)===-1){throw new Qv(`Input ${t} is incompatible with layer `+`${this.name}: expected axis ${s} of input shape to `+`have value ${r} but got shape ${n}.`)}}}if(o.shape!=null){for(let n=0;n<o.shape.length;++n){const e=o.shape[n];const r=s.shape[n];if(e!=null&&r!=null){if(e!==r){throw new Qv(`Input ${t} is incompatible with layer `+`${this.name}: expected shape=${o.shape}, `+`found shape=${s.shape}.`)}}}}}}call(t,n){return t}invokeCallHook(t,n){if(this._callHook!=null){this._callHook(t,n)}}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{};this.assertNotDisposed();const e=c$(t);const s=hk(t);const o=dk(t);if(s===o){throw new Qv("Arguments to apply() must be all "+"SymbolicTensors or all Tensors")}return V$(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const n=[];for(const e of c$(t)){n.push(e.shape)}this.build(i$(n));this.built=true;if(this.initialWeights){this.setWeights(this.initialWeights)}if(this._refCount===null&&o){this._refCount=1}}this.assertInputCompatibility(t);if(o){let s=this.call(t,n);if(this.supportsMasking){this.setMaskMetadata(t,s)}const o=c$(s);const r=[];for(let t of o){if(e.indexOf(t)!==-1){t=t.clone()}r.push(t)}s=i$(r);if(this.activityRegularizer!=null){throw new t$("Layer invocation in the presence of activity "+"regularizer(s) is not supported yet.")}return s}else{const e=uk(t);const s=this.computeOutputShape(e);let o;const r=lk();this.warnOnIncompatibleInputShape(Array.isArray(t)?e[0]:e);if(s!=null&&s.length>0&&Array.isArray(s[0])){o=s.map(((e,s)=>new ok(r,e,this,c$(t),n,this.name,s)))}else{o=new ok(r,s,this,c$(t),n,this.name)}this.addInboundNode(t,o,null,null,e,s,n);this._refCount++;if(this.activityRegularizer!=null){throw new t$("Layer invocation in the presence of activity "+"regularizer(s) is not supported yet.")}return o}}))}warnOnIncompatibleInputShape(t){if(this.batchInputShape==null){return}else if(t.length!==this.batchInputShape.length){console.warn(`The rank of the input tensor provided (shape: `+`${JSON.stringify(t)}) does not match that of the `+`batchInputShape (${JSON.stringify(this.batchInputShape)}) `+`of the layer ${this.name}`)}else{let n=false;this.batchInputShape.forEach(((e,s)=>{if(e!=null&&t[s]!=null&&t[s]!==e){n=true}}));if(n){console.warn(`The shape of the input tensor `+`(${JSON.stringify(t)}) does not `+`match the expectation of layer ${this.name}: `+`${JSON.stringify(this.batchInputShape)}`)}}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0){throw new Yv(`The layer ${this.name} has never been called and thus has no `+`defined output shape.`)}const t=[];for(const n of this.inboundNodes){const e=JSON.stringify(n.outputShapes);if(t.indexOf(e)===-1){t.push(e)}}if(t.length===1){const t=this.inboundNodes[0].outputShapes;if(Array.isArray(t)&&Array.isArray(t[0])&&t.length===1){return t[0]}else{return t}}else{throw new Yv(`The layer ${this.name} has multiple inbound nodes with different `+`output shapes. Hence the notion of "output shape" is ill-defined `+`for the layer.`)}}countParams(){if(!this.built){throw new Zv(`You tried to call countParams() on ${this.name}, `+`but the layer is not built yet. Build it first by calling `+`build(batchInputShape).`)}return Yy(this.weights)}build(t){this.built=true}getWeights(t=false){return nk(t?this.trainableWeights:this.weights)}setWeights(t){kc((()=>{const n=this.weights;if(n.length!==t.length){throw new Qv(`You called setWeights(weights) on layer "${this.name}" `+`with a weight list of length ${t.length}, `+`but the layer was expecting ${n.length} weights. `+`Provided weights: ${t}...`)}if(n.length===0){return}const e=[];const s=nk(n);for(let o=0;o<s.length;++o){const r=s[o];const i=n[o];const c=t[o];if(!v(r.shape,c.shape)){throw new Qv(`Layer weight shape ${r.shape} `+`not compatible with provided weight shape ${c.shape}`)}e.push([i,c])}ek(e)}))}addWeight(t,n,e,s,o,r,i,c){if(this._addedWeightNames.indexOf(t)!==-1){throw new Qv(`Duplicate weight name ${t} for layer ${this.name}`)}this._addedWeightNames.push(t);if(e==null){e="float32"}if(this.fastWeightInitDuringBuild){s=c!=null?c():jy("zeros")}const a=s.apply(n,e);const u=new Qy(a,e,t,r,i);a.dispose();if(o!=null){this.addLoss((()=>o.apply(u.read())))}if(r==null){r=true}if(r){this._trainableWeights.push(u)}else{this._nonTrainableWeights.push(u)}return u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){if(t==null||Array.isArray(t)&&t.length===0){return}t=c$(t);if(this._losses!==undefined&&this._losses!==null){this.losses.push(...t)}}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null){if(Array.isArray(n)){n.forEach((t=>{if(t!=null){throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.")}}))}else{throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.")}}return null}return n}setMaskMetadata(t,n,e){if(!this.supportsMasking){return}const s=this.computeMask(t,e);const o=c$(n);const r=c$(s);if(o.length!==r.length){throw new Error(`${this.name} outputs ${o.length} tensors `+`but ${o.length} masks for those tensors`)}for(let t=0;t<o.length;t++){o[t].kerasMask=r[t]}}addInboundNode(t,n,e,s,o,r,i=null){const c=c$(t);n=c$(n);e=c$(e);s=c$(s);o=Xy(o);r=Xy(r);const a=[];const u=[];const l=[];for(const t of c){a.push(t.sourceLayer);u.push(t.nodeIndex);l.push(t.tensorIndex)}new ik({outboundLayer:this,inboundLayers:a,nodeIndices:u,tensorIndices:l,inputTensors:c,outputTensors:n,inputMasks:e,outputMasks:s,inputShapes:o,outputShapes:r},i);for(let t=0;t<n.length;t++){n[t].sourceLayer=this;n[t].nodeIndex=this.inboundNodes.length-1;n[t].tensorIndex=t}}getConfig(){const t={name:this.name,trainable:this.trainable};if(this.batchInputShape!=null){t["batchInputShape"]=this.batchInputShape}if(this.dtype!=null){t["dtype"]=this.dtype}return t}disposeWeights(){this.weights.forEach((t=>t.dispose()));return this.weights.length}assertNotDisposed(){if(this._refCount===0){throw new Error(`Layer '${this.name}' is already disposed.`)}}dispose(){if(!this.built){throw new Error(`Cannot dispose Layer ${this.name} because it has not been `+`built yet.`)}if(this._refCount===null){throw new Error(`Cannot dispose Layer ${this.name} because it has not been used `+`yet.`)}this.assertNotDisposed();let t=0;if(--this._refCount===0){t=this.disposeWeights()}return{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function uk(t){t=c$(t);const n=[];for(const e of t){n.push(e.shape)}return i$(n)}function lk(t){return"float32"}function fk(t,n,e){if(n==null||e!=null&&e>0){n=t.sourceLayer;e=t.nodeIndex}if(n.inboundNodes.length===0){return[t]}else{const t=n.inboundNodes[e];if(t.inboundLayers.length===0){return t.inputTensors}else{const n=[];for(let e=0;e<t.inboundLayers.length;e++){const s=t.inputTensors[e];const o=t.inboundLayers[e];const r=t.nodeIndices[e];const i=fk(s,o,r);for(const t of i){if(n.indexOf(t)===-1){n.push(t)}}}return n}}}function hk(t){let n=true;for(const e of c$(t)){if(!(e instanceof ok)){n=false;break}}return n}function dk(t){let n=true;for(const e of c$(t)){if(e instanceof ok){n=false;break}}return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pk extends ak{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:S$("input").toString()});if(t.batchSize==null){t.batchSize=null}if(t.sparse==null){t.sparse=false}this.trainable=false;this.built=true;this.sparse=t.sparse;if(t.inputShape!=null&&t.batchInputShape!=null){throw new Qv("Only provide the inputShape OR "+"batchInputShape argument to inputLayer, not both at the same time.")}let n=t.batchInputShape;if(n==null){if(t.inputShape==null){throw new Qv("An InputLayer should be passed either a "+"`batchInputShape` or an `inputShape`.")}else{n=[t.batchSize].concat(t.inputShape)}}else{if(t.batchSize!=null){throw new Qv("Cannot specify batchSize if batchInputShape is "+"specified when creating an InputLayer.")}}const e=t.dtype||"float32";this.batchInputShape=n;this.dtype=e;this.inputSpec=[{shape:n}];const s=new ok(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0;s.tensorIndex=0;new ik({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new Qv("Cannot pass any input to an "+`InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}pk.className="InputLayer";Kx(pk);function mk(t){if(t.batchShape==null&&t.shape==null){throw new Error("Please provide to Input either a `shape`"+" or a `batchShape` argument. Note that "+"`shape` does not include the batch "+"dimension.")}if(t.batchShape!=null&&t.shape!=null){throw new Qv("Please provide either a `shape` or `batchShape` "+"argument to Input, but not both.")}let n=t.batchShape;if(t.shape!=null&&n==null){n=[null].concat(t.shape)}let e=t.dtype;if(e==null){e="float32"}const s=new pk({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse});const o=s.inboundNodes[0].outputTensors;return o[0]}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xk(t,n){if(t.dtype==null||t.dtype===n.dtype){return n}try{return wa(n,t.dtype)}catch(e){throw new Qv(`The dtype of the feed (${n.dtype}) can not be cast to the dtype `+`of the key '${t.name}' (${t.dtype}).`)}}class bk{constructor(t){this.id2Value={};this.id2Mask={};this.name2Id={};if(t instanceof bk){for(const n in t.id2Value){this.id2Value[n]=t.id2Value[n];if(n in t.id2Mask){this.id2Mask[n]=t.id2Mask[n]}}}else{if(t==null){return}for(const n of t){this.add(n.key,n.value)}}}add(t,n,e){if(this.id2Value[t.id]==null){this.id2Value[t.id]=xk(t,n);this.name2Id[t.name]=t.id;if(e!=null){this.id2Mask[t.id]=e}}else{throw new Qv(`Duplicate key: name=${t.name}, id=${t.id}`)}return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ok){if(this.id2Value[t.id]==null){throw new Qv(`Nonexistent key: ${t.name}`)}else{return this.id2Value[t.id]}}else{const n=this.name2Id[t];if(n==null){throw new Qv(`Feed dict has no SymbolicTensor name: ${t}`)}return this.id2Value[n]}}getMask(t){if(t instanceof ok){if(this.id2Value[t.id]==null){throw new Qv(`Nonexistent key: ${t.name}`)}else{return this.id2Mask[t.id]}}else{const n=this.name2Id[t];if(n==null){throw new Qv(`Feed dict has no SymbolicTensor name: ${t}`)}return this.id2Mask[n]}}disposeMasks(){if(this.id2Mask!=null){Cc(this.id2Mask)}}}const gk=new e$;const wk=new e$;function vk(t){if(gk!=null){gk.setMaxEntries(t)}if(wk!=null){wk.setMaxEntries(t)}}function $k(t,n,e,s){const o=e==null?false:e["training"];const r=Array.isArray(t);const i=r?t:[t];const c=i.map((t=>t.name));const a=[];const u=n.names();for(const t of c){if(u.indexOf(t)!==-1){a.push(n.getValue(t))}else{a.push(null)}}const l=c.join(",")+"|"+n.names().sort().join(",");let f=gk.get(l);let h;if(f==null){const t=yk(i,n);f=t.sorted;h=t.recipientCounts;gk.put(l,f);wk.put(l,h)}h={};if(!o){Object.assign(h,wk.get(l))}const d=new bk(n);for(let t=0;t<f.length;++t){const s=f[t];const r=s.sourceLayer;if(r instanceof pk){continue}const i=[];const u=[];const l=[];let p=false;for(const t of s.inputs){const e=d.getValue(t);const s=d.getMask(t);i.push(e);u.push(s);if(s!=null){p=true}if(!o){h[t.name]--;if(h[t.name]===0&&!n.hasKey(t)&&c.indexOf(t.name)===-1&&!e.isDisposed&&t.sourceLayer.stateful!==true){l.push(e)}}}if(p){e=e||{};e["mask"]=u[0]}const m=c$(r.apply(i,e));let x=null;if(r.supportsMasking){x=r.computeMask(i,u)}const b=Nk(s);const g=Array.isArray(b)?b:[b];for(let t=0;t<g.length;++t){if(!d.hasKey(g[t])){d.add(g[t],m[t],Array.isArray(x)?x[0]:x)}const n=c.indexOf(g[t].name);if(n!==-1){a[n]=m[t]}}if(!o){Cc(l)}}d.disposeMasks();return r?a:a[0]}function yk(t,n){x(t!=null&&t.length>0,(()=>`Expected at least one fetch, got none`));let e=[];let s={};if(t.length===1){const o=Ck(t[0],n);e=o.sorted;s=o.recipientMap}else{const o=new Set;for(const r of t){const{sorted:t,recipientMap:i}=Ck(r,n);for(const n of t){if(!o.has(n.name)){e.push(n);o.add(n.name)}}for(const t in i){if(s[t]==null){s[t]=new Set}i[t].forEach((n=>s[t].add(n)))}}}return{sorted:e,recipientCounts:kk(s)}}function kk(t){const n={};for(const e in t){n[e]=t[e].size}return n}function Ck(t,n){const e=new Set;const s=[];const o={};for(const t of n.names()){e.add(t)}const r=[];const i=[];r.push(t);while(r.length>0){const t=r[r.length-1];if(e.has(t.name)){r.pop();continue}const n=i[i.length-1]===r.length-1;if(t.inputs.length===0||n){r.pop();s.push(t);e.add(t.name);if(n){i.pop()}}else{i.push(r.length-1);for(const n of t.inputs){if(o[n.name]==null){o[n.name]=new Set}o[n.name].add(t.name);if(e.has(n.name)){continue}r.push(n)}}}return{sorted:s,recipientMap:o}}function Nk(t){let n;if(t.sourceLayer.inboundNodes.length===1){n=t.sourceLayer.output}else{let e=null;for(let n=0;n<t.sourceLayer.inboundNodes.length;++n){for(const s of t.sourceLayer.inboundNodes[n].outputTensors){if(s.id===t.id){e=n;break}}}n=t.sourceLayer.getOutputAt(e)}return n}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=st();Rk.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),vk);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Sk(t,n){return kc((()=>kf(Sf(Aa(t,t),n,true))))}class Ek extends qx{getConfig(){return{}}}class Tk extends Ek{constructor(t){super();this.defaultMaxValue=2;this.defaultAxis=0;this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return kc((()=>{const n=Sk(t,this.axis);const e=el(n,0,this.maxValue);return Aa(t,Ta(e,Na(Z$(),n)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Tk.className="MaxNorm";Kx(Tk);class Ik extends Ek{constructor(t){super();this.defaultAxis=0;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return kc((()=>Ta(t,Na(Z$(),Sk(t,this.axis)))))}getConfig(){return{axis:this.axis}}}Ik.className="UnitNorm";Kx(Ik);class Ak extends Ek{apply(t){return pp(t)}}Ak.className="NonNeg";Kx(Ak);class Ok extends Ek{constructor(t){super();this.defaultMinValue=0;this.defaultMaxValue=1;this.defaultRate=1;this.defaultAxis=0;this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue;this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue;this.rate=t.rate!=null?t.rate:this.defaultRate;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return kc((()=>{const n=Sk(t,this.axis);const e=Na(Aa(this.rate,el(n,this.minValue,this.maxValue)),Aa(1-this.rate,n));return Aa(t,Ta(e,Na(Z$(),n)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Ok.className="MinMaxNorm";Kx(Ok);const Fk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _k(t){return f$(t)}function Mk(t,n={}){return d$(t,Xx.getMap().classNameMap,n,"constraint")}function Dk(t){if(t==null){return null}if(typeof t==="string"){const n=t in Fk?Fk[t]:t;const e={className:n,config:{}};return Mk(e)}else if(t instanceof Ek){return t}else{return Mk(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Lk(t){if(t==null){return}const n=[];const e=[];const s=[];for(const o in t){const r=t[o];if(typeof r!=="number"){const t=r;n.push(t.data());e.push(o);s.push(t)}}if(n.length>0){const o=await Promise.all(n);for(let n=0;n<o.length;++n){t[e[n]]=o[n][0]}Cc(s)}}function zk(t){if(t==null){return}for(const n in t){const e=t[n];if(typeof e!=="number"){e.dispose()}}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Pk;(function(t){t[t["SILENT"]=0]="SILENT";t[t["VERBOSE"]=1]="VERBOSE"})(Pk||(Pk={}));const Vk=125;class Bk{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Wk{constructor(t,n=10){if(t==null){t=[]}this.callbacks=t;this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks){n.setParams(t)}}setModel(t){for(const n of this.callbacks){n.setModel(t)}}async onEpochBegin(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onEpochBegin(t,n)}}async onEpochEnd(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onEpochEnd(t,n)}}async onBatchBegin(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onBatchBegin(t,n)}}async onBatchEnd(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onBatchEnd(t,n)}}async onTrainBegin(t){if(t==null){t={}}for(const n of this.callbacks){await n.onTrainBegin(t)}}async onTrainEnd(t){if(t==null){t={}}for(const n of this.callbacks){await n.onTrainEnd(t)}}}class Gk extends Bk{constructor(){super()}async onEpochBegin(t){this.seen=0;this.totals={}}async onBatchEnd(t,n){if(n==null){n={}}const e=n["size"]==null?0:n["size"];this.seen+=e;for(const t in n){const s=n[t];if(typeof s==="number"){if(!this.totals.hasOwnProperty(t)){this.totals[t]=0}this.totals[t]=this.totals[t]+s*e}else{let n;if(t in this.totals){n=this.totals[t]}else{this.totals[t]=0}const o=kc((()=>Na(this.totals[t],Aa(s,e))));this.totals[t]=o;if(n!=null){n.dispose()}}}}async onEpochEnd(t,n){if(n!=null){for(const t of this.params["metrics"]){if(this.totals[t]==null){continue}if(typeof this.totals[t]==="number"){n[t]=this.totals[t]/this.seen}else{kc((()=>{const e=Aa(Ta(1,this.seen),this.totals[t]);n[t]=e;this.totals[t].dispose();Nc(n[t])}))}}}}}class Uk extends Bk{async onTrainBegin(t){this.epoch=[];this.history={}}async onEpochEnd(t,n){if(n==null){n={}}this.epoch.push(t);for(const t in n){if(this.history[t]==null){this.history[t]=[]}this.history[t].push(n[t])}}async syncData(){const t=[];const n=[];const e=[];for(const s in this.history){const o=this.history[s];for(let r=0;r<o.length;++r){if(typeof o[r]!=="number"){const i=o[r];t.push(i.data());n.push(s);e.push(r)}}}const s=await Promise.all(t);for(let t=0;t<s.length;++t){const o=this.history[n[t]][e[t]];o.dispose();this.history[n[t]][e[t]]=s[t][0]}}}class Hk extends Bk{constructor(t,n){super();this.currentEpoch=0;this.nowFunc=t.nowFunc;this.nextFrameFunc=t.nextFrameFunc||Ab;this.yieldEvery=n||"auto";if(this.yieldEvery==="auto"){this.yieldEvery=Vk}if(this.yieldEvery==="never"&&t.onYield!=null){throw new Error("yieldEvery is `never` but you provided an `onYield` callback. "+"Either change `yieldEvery` or remove the callback")}if(L(this.yieldEvery)){this.maybeWait=y$(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)}this.trainBegin=t.onTrainBegin;this.trainEnd=t.onTrainEnd;this.epochBegin=t.onEpochBegin;this.epochEnd=t.onEpochEnd;this.batchBegin=t.onBatchBegin;this.batchEnd=t.onBatchEnd;this.yield=t.onYield}async maybeWait(t,n,e){const s=[];if(this.yield!=null){await Lk(e);s.push(this.yield(t,n,e))}s.push(this.nextFrameFunc());await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t;if(this.epochBegin!=null){await Lk(n);await this.epochBegin(t,n)}}async onEpochEnd(t,n){const e=[];if(this.epochEnd!=null){await Lk(n);e.push(this.epochEnd(t,n))}if(this.yieldEvery==="epoch"){e.push(this.nextFrameFunc())}await Promise.all(e)}async onBatchBegin(t,n){if(this.batchBegin!=null){await Lk(n);await this.batchBegin(t,n)}}async onBatchEnd(t,n){const e=[];if(this.batchEnd!=null){await Lk(n);e.push(this.batchEnd(t,n))}if(this.yieldEvery==="batch"){e.push(this.nextFrameFunc())}else if(L(this.yieldEvery)){e.push(this.maybeWait(this.currentEpoch,t,n))}await Promise.all(e)}async onTrainBegin(t){if(this.trainBegin!=null){await Lk(t);await this.trainBegin(t)}}async onTrainEnd(t){if(this.trainEnd!=null){await Lk(t);await this.trainEnd(t)}}}function jk(t,n){if(t==null){t={}}if(t instanceof Bk){return[t]}if(Array.isArray(t)&&t[0]instanceof Bk){return t}const e=c$(t);return e.map((t=>new Hk(t,n)))}class qk{constructor(){}static registerCallbackConstructor(t,n){x(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, `+`but got ${t}`));qk.checkForDuplicate(n);if(qk.constructors[t]==null){qk.constructors[t]=[]}qk.constructors[t].push(n)}static checkForDuplicate(t){for(const n in qk.constructors){const e=qk.constructors[+n];e.forEach((n=>{if(n===t){throw new Qv("Duplicate callback constructor.")}}))}}static clear(){qk.constructors={}}static createCallbacks(t){const n=[];for(const e in qk.constructors){const s=+e;if(t>=s){n.push(...qk.constructors[s])}}return n.map((t=>new t))}}qk.constructors={};function Xk(t,n,e,s,o,r,i,c,a){const u=new Uk;const l=[new Gk,...qk.createCallbacks(n)];if(t!=null){l.push(...t)}l.push(u);const f=new Wk(l);f.setParams({epochs:e,initialEpoch:s,samples:o,steps:r,batchSize:i,verbose:n,doValidation:c,metrics:a});return{callbackList:f,history:u}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kk(t,n={},e=false){return d$(t,Xx.getMap().classNameMap,n,"layer",e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jk(t,n){return kc((()=>{if(t.dtype!=="float32"){t=wa(t,"float32")}const e=Sf(py(t),n,true);const s=tl(e.shape,Z$());const o=kf(Uh(e,s));return Ta(t,o)}))}function Yk(t,n){return kc((()=>jh(py(Rh(n,t)),-1)))}function Zk(t,n){return kc((()=>jh(Fa(Rh(n,t)),-1)))}function Qk(t,n){return kc((()=>{const e=Rh(t,n);const s=el(Fa(t),Z$(),Number.MAX_VALUE);const o=Fa(Ta(e,s));return Aa(100,jh(o,-1))}))}function tC(t,n){return kc((()=>{const e=el(n,Z$(),Number.MAX_VALUE);const s=ph(Na(1,e));const o=el(t,Z$(),Number.MAX_VALUE);const r=ph(Na(1,o));return jh(py(Rh(s,r)),-1)}))}function nC(t,n){return kc((()=>{const e=Uh(0,Rh(1,Aa(t,n)));return jh(py(e),-1)}))}function eC(t,n){return kc((()=>{const e=Uh(0,Rh(1,Aa(t,n)));return jh(e,-1)}))}function sC(t,n){return kc((()=>{const e=Sf(Aa(t,n),-1);const s=xf(Aa(Rh(1,t),n),-1);return Uh(0,Na(1,Rh(s,e)))}))}function oC(t,n){return kc((()=>{const e=Math.log(2);const s=Rh(n,t);const o=Rh(Na(s,yh(Aa(-2,s))),e);return jh(o,-1)}))}function rC(t,n,e=false){return kc((()=>{if(e){n=Wp(n)}else{const t=Sf(n,n.shape.length-1,true);n=Ta(n,t)}n=el(n,Z$(),1-Z$());return vh(Sf(Aa(wa(t,"float32"),ph(n)),n.shape.length-1))}))}function iC(t,n,e=false){return kc((()=>{const s=wa(Uf(sy(t)),"int32");n=el(n,Z$(),1-Z$());const o=n.shape;const r=yu(id(s,o[o.length-1]),o);return rC(r,n,e)}))}function cC(t,n){if(!v(t.shape,n.shape)){throw new Qv(`logits and labels must have the same shape, but got shapes `+`${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`)}return kc((()=>{const e=pp(n);const s=vh(Fa(n));return Na(Rh(e,Aa(n,t)),xh(_f(s)))}))}function aC(t,n){return kc((()=>{let e;e=el(n,Z$(),1-Z$());e=ph(Ta(e,Rh(1,e)));return jh(cC(t,e),-1)}))}function uC(t,n){return kc((()=>{const e=el(t,Z$(),1);const s=el(n,Z$(),1);return Sf(Aa(t,ph(Ta(e,s))),-1)}))}function lC(t,n){return kc((()=>{const e=ph(Na(Z$(),n));return jh(Rh(n,Aa(t,e)),-1)}))}function fC(t,n){return kc((()=>{const e=Jk(t,-1);const s=Jk(n,-1);const o=Aa(e,s);return vh(Sf(o,-1))}))}const hC={meanSquaredError:Yk,meanAbsoluteError:Zk,meanAbsolutePercentageError:Qk,meanSquaredLogarithmicError:tC,squaredHinge:nC,hinge:eC,categoricalHinge:sC,logcosh:oC,categoricalCrossentropy:rC,sparseCategoricalCrossentropy:iC,binaryCrossentropy:aC,kullbackLeiblerDivergence:uC,poisson:lC,cosineProximity:fC};function dC(t){if(typeof t==="string"){if(t in hC){return hC[t]}let n=`Unknown loss ${t}`;if(t.toLowerCase().includes("softmaxcrossentropy")){n=`Unknown loss ${t}. `+'Use "categoricalCrossentropy" as the string name for '+"tf.losses.softmaxCrossEntropy"}throw new Qv(n)}else{return t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pC(t,n){return kc((()=>{const e=Aa(.5,ad(n));const s=ty(Xf(n,e),t.dtype);return jh(Hl(t,s),-1)}))}function mC(t,n){return kc((()=>ty(Hl(Ga(t,-1),Ga(n,-1)),"float32")))}function xC(t,n){return kc((()=>wa(Sf(Oh(Hl(t,1),Hl(n,1))),"float32")))}function bC(t,n){return kc((()=>wa(Sf(Oh(Hl(t,0),Hl(n,1))),"float32")))}function gC(t,n){return kc((()=>{const e=xC(t,n);const s=bC(t,n);const o=Na(e,s);return wa(ql(Xf(o,0),Ta(e,o),0),"float32")}))}function wC(t,n){return aC(t,n)}function vC(t,n){if(t.rank===n.rank){t=em(t,[t.rank-1])}n=Ga(n,-1);if(n.dtype!==t.dtype){n=wa(n,t.dtype)}return wa(Hl(t,n),"float32")}const $C=Yk;const yC=Yk;const kC=Zk;const CC=Zk;const NC=Qk;const RC=Qk;const SC=rC;const EC=fC;const TC=iC;const IC={binaryAccuracy:pC,categoricalAccuracy:mC,precision:gC,categoricalCrossentropy:SC,sparseCategoricalCrossentropy:TC,mse:$C,MSE:yC,mae:kC,MAE:CC,mape:NC,MAPE:RC,cosine:EC};function AC(t){if(typeof t==="string"&&t in IC){return IC[t]}else if(typeof t!=="string"&&t!=null){return t}else{throw new Qv(`Unknown metric ${t}`)}}function OC(t){o$(t!==null,`Unknown LossOrMetricFn ${t}`);if(typeof t==="string"){return t}else{let n;for(const e of Object.keys(hC)){if(hC[e]===t){n=e;break}}if(n!==undefined){return n}for(const e of Object.keys(IC)){if(IC[e]===t){n=e;break}}if(n!==undefined){return n}return t.name}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FC(t){const n={Adagrad:()=>Tb.adagrad(.01),Adadelta:()=>Tb.adadelta(1,.95,Z$()),Adam:()=>Tb.adam(.001,.9,.999,Z$()),Adamax:()=>Tb.adamax(.002,.9,.999,Z$(),0),RMSProp:()=>Tb.rmsprop(.001,.9,0,Z$()),SGD:()=>Tb.sgd(.01)};n["adagrad"]=n["Adagrad"];n["adadelta"]=n["Adadelta"];n["adam"]=n["Adam"];n["adamax"]=n["Adamax"];n["rmsprop"]=n["RMSProp"];n["sgd"]=n["SGD"];if(t in n){return n[t]()}throw new Qv(`Unknown Optimizer ${t}`)}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const _C=1*1024*1024;function MC(t,n,e=false){if(t==null||typeof t!=="object"||Object.getPrototypeOf(t)!==Object.prototype||!DC(t)){throw new Error("User-defined metadata is expected to be a JSON object, but is not.")}if(e){const e=JSON.stringify(t);if(e.length>_C){console.warn(`User-defined metadata of model "${n}" is too large in `+`size (length=${e.length} when serialized). It is not `+`recommended to store such large objects in user-defined metadata. `+`Please make sure its serialized length is <= `+`${_C}.`)}}}function DC(t){if(t===null){return true}else if(typeof t==="object"){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n){if(typeof e!=="string"){return false}if(!DC(t[e])){return false}}return true}else{if(Array.isArray(t)){for(const n of t){if(!DC(n)){return false}}return true}else{return false}}}else{const n=typeof t;return n==="string"||n==="number"||n==="boolean"}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LC(t,n,e,s=console.log){const o=PC(t);const r=["Layer (type)","Input Shape","Output shape","Param #"];if(o){n=n||90;e=e||[.32,.61,.89,1]}else{n=n||115;e=e||[.24,.48,.7,.8,1]}if(e[e.length-1]<=1){e=e.map((t=>Math.floor(n*t)))}let i;if(!o){r.push("Receives inputs");i=[];for(const n in t.nodesByDepth){i.push(...t.nodesByDepth[n])}}s("_".repeat(n));VC(r,e,s);s("=".repeat(n));const c=t.layers;for(let t=0;t<c.length;++t){if(o){BC(c[t],e,s)}else{WC(c[t],e,i,s)}s((t===c.length-1?"=":"_").repeat(n))}t.checkTrainableWeightsConsistency();const a=zC(t);const u=Yy(t.nonTrainableWeights);s(`Total params: ${a+u}`);s(`Trainable params: ${a}`);s(`Non-trainable params: ${u}`);s("_".repeat(n))}function zC(t){let n;if(t.collectedTrainableWeights!=null){n=Yy(t.collectedTrainableWeights)}else{n=Yy(t.trainableWeights)}return n}function PC(t){let n=true;const e=[];const s=[];for(const n in t.nodesByDepth){e.push(t.nodesByDepth[n])}for(const t of e){if(t.length>1||t.length===1&&t[0].inboundLayers.length>1){n=false;break}s.push(...t)}if(n){for(const e of t.layers){let t=false;for(const o of e.inboundNodes){if(s.indexOf(o)!==-1){if(t){n=false;break}else{t=true}}}if(!n){break}}}return n}function VC(t,n,e=console.log){let s="";for(let e=0;e<t.length;++e){if(e>0){s=s.slice(0,s.length-1)+" "}s+=t[e];s=s.slice(0,n[e]);s+=" ".repeat(n[e]-s.length)}e(s)}function BC(t,n,e){let s;let o;try{o=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){o="multiple"}try{s=JSON.stringify(t.outputShape)}catch(t){s="multiple"}const r=t.name;const i=t.getClassName();const c=[`${r} (${i})`,o,s,t.countParams().toString()];VC(c,n,e)}function WC(t,n,e,s){let o;let r;try{r=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){r="multiple"}try{o=JSON.stringify(t.outputShape)}catch(t){o="multiple"}const i=[];for(const n of t.inboundNodes){if(e!=null&&e.length>0&&e.indexOf(n)===-1){continue}for(let t=0;t<n.inboundLayers.length;++t){const e=n.inboundLayers[t].name;const s=n.nodeIndices[t];const o=n.tensorIndices[t];i.push(`${e}[${s}][${o}]`)}}const c=t.name;const a=t.getClassName();const u=i.length===0?"":i[0];const l=[`${c} (${a})`,r,o,t.countParams().toString(),u];VC(l,n,s);for(let t=1;t<i.length;++t){VC(["","","","",i[t]],n,s)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function GC(t,n,e){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&n===0&&typeof e==="string"}function UC(t,n){if(t===null){return null}else if(typeof t==="string"){return u$(t)}else if(typeof t==="number"||typeof t==="boolean"){return t}else if(t instanceof Array){const e=[];const s=t.length;for(let o=0;o<s;++o){const s=t[o];if(GC(n,o,s)){e.push(s)}else{e.push(UC(s,n))}}return e}else{const n={};for(const e of Object.keys(t)){const s=t[e];if(e==="name"&&typeof s==="string"){n[e]=s}else{const t=u$(e);n[t]=UC(s,t)}}return n}}function HC(t,n){if(t===null||t===undefined){return null}else if(typeof t==="string"){return a$(t)}else if(typeof t==="number"||typeof t==="boolean"){return t}else if(t instanceof Array){const e=[];const s=t.length;for(let o=0;o<s;++o){const s=t[o];if(GC(n,o,s)){e.push(s)}else{e.push(HC(s,n))}}return e}else{const n={};for(const e of Object.keys(t)){const s=t[e];const o=a$(e);if((e==="name"||e==="className")&&typeof s==="string"){n[o]=s}else{n[o]=HC(s,e)}}return n}}
/** @license See the LICENSE file. */const jC="4.22.0";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const qC=t=>{const n=Object.keys(t);if(n.length===0){return false}const e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class XC extends ak{constructor(t){super({});this.containerNodes=new Set;this.name=t.name;if(this.name==null){const t=this.getClassName().toLowerCase();this.name=S$(t)}this.supportsMasking=false;this.trainable_=true;if(Array.isArray(t.inputs)){this.inputs=t.inputs.slice()}else{this.inputs=[t.inputs]}if(Array.isArray(t.outputs)){this.outputs=t.outputs.slice()}else{this.outputs=[t.outputs]}if(x$(this.inputs).length!==this.inputs.length){throw new Qv("The list of inputs passed to the model is "+"redundant. All inputs should only appear once. Found: "+`${this.inputs.map((t=>t.name))}`)}if(x$(this.outputs).length!==this.outputs.length){console.warn("The list of outputs passed to the model is redundant. "+"All outputs should only appear once. Found: "+`${this.outputs.map((t=>t.name))}`)}this.inputLayers=[];this.inputLayersNodeIndices=[];this.inputLayersTensorIndices=[];this.outputLayers=[];this.outputLayersNodeIndices=[];this.outputLayersTensorIndices=[];this.layers=[];this.internalContainerRefs=[];for(const t of this.outputs){const n=t.sourceLayer;const e=t.nodeIndex;const s=t.tensorIndex;this.outputLayers.push(n);this.outputLayersNodeIndices.push(e);this.outputLayersTensorIndices.push(s)}for(const t of this.inputs){const n=t.sourceLayer;const e=t.nodeIndex;const s=t.tensorIndex;o$(e===0,"input layer has >1 nodes");o$(s===0,"input layer has >1 tensors");this.inputLayers.push(n);this.inputLayersNodeIndices.push(e);this.inputLayersTensorIndices.push(s)}this.inputNames=[];this.outputNames=[];this.feedInputShapes=[];this.feedInputNames=[];this.feedOutputNames=[];for(let n=0;n<this.inputLayers.length;n++){const e=this.inputLayers[n];if(!(e instanceof pk)){throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+`Received inputs: ${t.inputs}. `+`Input ${n} (0-based) originates `+`from layer type ${e.getClassName()}.`)}this.inputNames.push(e.name);this.feedInputShapes.push(e.batchInputShape);this.feedInputNames.push(e.name)}for(const t of this.outputLayers){this.outputNames.push(t.name)}this.internalInputShapes=this.inputs.map((t=>t.shape));this.internalOutputShapes=this.outputs.map((t=>t.shape));const n={};const e={};const s={};const o={};const r={};const i=[];const c=(t,n,e,s,o,a)=>{if(s==null||o==null||a==null){s=t.sourceLayer;o=t.nodeIndex;a=t.tensorIndex}const u=s.inboundNodes[o];if(e.indexOf(u)!==-1){throw new Zv(`The tensor ${t.name} at layer "${s.name}" `+"is part of a cycle.")}if(n.indexOf(u)!==-1){return}this.containerNodes.add(XC.nodeKey(s,o));if(!(s.id in r)){r[s.id]=Object.keys(r).length}if(e.indexOf(u)===-1){e.push(u)}const l=u.inboundLayers.length;for(let t=0;t<l;t++){const s=u.inputTensors[t];const o=u.inboundLayers[t];const r=u.nodeIndices[t];const i=u.tensorIndices[t];c(s,n,e,o,r,i)}n.push(u);while(e.indexOf(u)>=0){e.splice(e.indexOf(u),1)}i.push(u)};const a=[];const u=[];for(const t of this.outputs){c(t,a,u)}const l=i.slice().reverse();for(const t of l){e[t.id]=t;if(!(t.id in n)){n[t.id]=0}let r=n[t.id];const i=s[t.outboundLayer.id]==null?0:s[t.outboundLayer.id];r=Math.max(r,i);s[t.outboundLayer.id]=r;o[t.outboundLayer.id]=t.outboundLayer;n[t.id]=r;for(let s=0;s<t.inboundLayers.length;s++){const o=t.inboundLayers[s];const i=t.nodeIndices[s];const c=o.inboundNodes[i];const a=n[c.id]==null?0:n[c.id];n[c.id]=Math.max(r+1,a);e[c.id]=c}}const f={};for(const t in n){const s=n[t];if(!(s in f)){f[s]=[]}f[s].push(e[t])}const h={};for(const t in s){const n=s[t];if(!(n in h)){h[n]=[]}h[n].push(o[t])}let d=Object.keys(h).map((t=>parseInt(t,10))).sort(m$);this.layers=[];for(const t of d){const n=h[t];n.sort(((t,n)=>{const e=r[t.id];const s=r[n.id];if(e<s){return-1}if(e>s){return 1}return 0}));for(const t of n){if(t instanceof XC){this.internalContainerRefs.push(t)}this.layers.push(t)}}this.layersByDepth=h;d=Object.keys(f).map((t=>parseInt(t,10))).sort(m$);const p=this.inputs.slice();const m=[];for(const t of d){for(const n of f[t]){const t=n.outboundLayer;if(t!=null){for(const e of n.inputTensors){if(p.indexOf(e)===-1){throw new Zv(`Graph disconnected: cannot obtain value for tensor ${e}`+` at layer "${t.name}". `+"The following previous layers were accessed without "+`issue: ${m}`)}}for(const t of n.outputTensors){p.push(t)}m.push(t.name)}}}this.nodesByDepth=f;const x=this.layers.map((t=>t.name));for(const t of x){const n=x.filter((n=>n===t)).length;if(n!==1){throw new Zv(`The name "${t}" is used ${n} times `+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(x))}}this.outboundNodes=[];this.inboundNodes=[];new ik({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))});this.built=true;this._refCount=1}assertNotDisposed(){if(this._refCount===0){throw new Error(`Container '${this.name}' is already disposed.`)}}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers){t.numDisposedVariables+=n.dispose().numDisposedVariables}for(const n of this.internalContainerRefs){t.numDisposedVariables+=n.dispose().numDisposedVariables}}t.refCountAfterDispose=this._refCount;return t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((n=>{n._trainableWeights.forEach((n=>n.trainable=t))}));this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0){throw new Qv("Container instance unexpectedly contains _trainableWeights."+"The trainable weights of a Container are a union of the "+"trainable weights of its consituent Layers. Its own "+"_trainableWeights must remain an empty Array.")}if(!this.trainable){return[]}let t=[];for(const n of this.layers){t=t.concat(n.trainableWeights)}return t}get nonTrainableWeights(){const t=[];for(const n of this.layers){t.push(...n.nonTrainableWeights)}if(!this.trainable){const n=[];for(const t of this.layers){n.push(...t.trainableWeights)}return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=true){const e={};let s=0;const o=qC(t);if(o){this.parseWeights(t)}for(const t of this.layers){for(const[n,r]of t.weights.entries()){const t=o?`${r.name.split("/").slice(0,-1).join("/")+"/"}${n}`:r.originalName;if(e[t]!=null){throw new Qv(`Duplicate weight name: ${t}`)}e[t]=r;s++}}const r=[];for(const s in t){let o=s;if(e[s]==null){const t=s.split("/");const n=t.slice(0,-2).concat([t[t.length-1]]);o=n.join("/")}if(e[o]!=null){r.push([e[o],t[s]])}else if(n){throw new Qv(`Provided weight data has no target variable: ${s}`)}delete e[o]}if(n){const t=[];for(const n in e){t.push(n)}if(t.length>0){throw new Qv(`${t.length} of ${s} weights are not set: `+`${t}`)}}ek(r)}parseWeights(t){for(const n in Object.keys(t)){const e=n.split("/");const s=["vars","layer_checkpoint_dependencies"];const o=e.map((t=>{if(t.startsWith("_")){return t.slice(1)}return t})).filter((t=>!s.includes(t))).join("/");if(o!==n){t[o]=t[n];delete t[n]}}}updatedConfig(){const t=this.getConfig();const n={};n["className"]=this.getClassName();n["config"]=t;n["kerasVersion"]=`tfjs-layers ${jC}`;n["backend"]="TensorFlow.js";return n}toJSON(t,n=true){const e=HC(this.updatedConfig());return n?JSON.stringify(e):e}call(t,n){return kc((()=>{t=c$(t);const e=new bk;for(let n=0;n<this.inputs.length;++n){e.add(this.inputs[n],t[n])}return $k(this.outputs,e,n)}))}computeMask(t,n){return kc((()=>{t=c$(t);let e;if(n==null){e=s$(null,t.length)}else{e=c$(n)}return this.runInternalGraph(t,e)[1]}))}computeOutputShape(t){const n=Xy(t);if(n.length!==this.inputLayers.length){throw new Qv(`Invalid inputShape argument ${t}: `+`model has ${this.inputLayers.length} tensor inputs.`)}const e={};for(let t=0;t<n.length;t++){const s=this.inputLayers[t];const o=n[t];const r=s.name+"_0_0";e[r]=o}const s=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(m$);if(s.length>1){for(const t of s){const n=this.nodesByDepth[t];for(const t of n){const n=t.outboundLayer;if(this.inputLayers.map((t=>t.id)).indexOf(n.id)!==-1){continue}const s=[];for(let n=0;n<t.inboundLayers.length;n++){const o=t.inboundLayers[n];const r=t.nodeIndices[n];const i=t.tensorIndices[n];const c=`${o.name}_${r}_${i}`;const a=e[c];s.push(a)}const o=n.computeOutputShape(i$(s));const r=Xy(o);const i=n.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){const s=`${n.name}_${i}_${t}`;e[s]=r[t]}}}}const o=[];const r=[];for(let t=0;t<this.outputLayers.length;t++){const n=this.outputLayers[t];const e=this.outputLayersNodeIndices[t];const s=this.outputLayersTensorIndices[t];const o=`${n.name}_${e}_${s}`;r.push(o)}for(let t=0;t<r.length;t++){const n=r[t];o$(n in e);o.push(e[n])}return i$(o)}runInternalGraph(t,n){if(n==null){n=s$(null,t.length)}const e={};for(let s=0;s<this.inputs.length;++s){const o=this.inputs[s];const r=t[s];const i=n[s];e[o.id]=[r,i]}const s=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(m$);for(const t of s){const n=this.nodesByDepth[t];for(const t of n){const n=t.outboundLayer;const s=t.inputTensors;const o=t.outputTensors;const r=new Array;for(const t of s){if(t.id in e){r.push(e[t.id])}}if(r.length===s.length){let s={};let i;let c;let a;let u;if(t.callArgs!=null){s=t.callArgs}if(r.length===1){const[t,e]=r[0];if(s["mask"]==null){s["mask"]=e}a=c$(n.call(t,s));u=c$(n.computeMask(t,e));i=[t];c=[e]}else{i=r.map((t=>t[0]));c=r.map((t=>t[1]));if(s["mask"]==null){s["mask"]=c}a=c$(n.call(i,s));u=c$(n.computeMask(i,c))}if(n.activityRegularizer){throw new t$("LayersModel invocation with concrete Tensor value(s) in the "+"presence of activity regularizer(s) is not supported yet.")}for(let t=0;t<o.length;++t){const n=o[t];const s=a[t];const r=u[t];e[n.id]=[s,r]}}}}const o=[];const r=[];const i=[];for(const t of this.outputs){o$(t.id in e,`Could not compute output ${t.name} : ${t.id}`);const[n,s]=e[t.id];i.push(n.shape);o.push(n);r.push(s)}return[o,r,i]}buildNodeConversionMap(t){const n={};let e;for(const t of this.layers){e=t instanceof XC?1:0;for(let s=0;s<t.inboundNodes.length;s++){const o=XC.nodeKey(t,s);if(this.containerNodes.has(o)){n[o]=e;e+=1}}}return n}getLayer(t,n){if(n!=null){return this.findLayer(n)}else{if(t==null){throw new Qv("Provide either a layer name or layer index")}if(typeof t==="number"){return this.findLayer(t)}}for(const n of this.layers){if(n.name===t){return n}}throw new Qv(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t){throw new Qv(`Was asked to retrieve layer at index ${t}, but model only `+`has ${this.layers.length} layer(s).`)}else{return this.layers[t]}}calculateLosses(){return kc((()=>{const t=[];for(const n of this.layers){for(let e=0;e<n.inboundNodes.length;++e){const s=XC.nodeKey(n,e);if(this.containerNodes.has(s)){t.push(...n.calculateLosses())}}}return t}))}getConfig(){const t={name:this.name};const n=this.buildNodeConversionMap(this.layers);const e=[];for(const t of this.layers){const s=t.getClassName();const o=t.getConfig();const r=[];for(let e=0;e<t.inboundNodes.length;e++){const s=t.inboundNodes[e];const o=XC.nodeKey(t,e);let i={};if(this.containerNodes.has(o)){if(s.callArgs){try{JSON.stringify(s.callArgs);i=s.callArgs}catch(n){console.warn(`Layer ${t.name} was passed `+`non-serializable keyword arguments: `+`${s.callArgs}. They will not be included `+`in the serialized model (and thus will be `+`missing at deserialization time).`);i={}}}if(s.inboundLayers.length>0){const t=[];for(let e=0;e<s.inboundLayers.length;e++){const o=s.inboundLayers[e];const r=s.nodeIndices[e];const c=s.tensorIndices[e];const a=XC.nodeKey(o,r);let u=n[a];if(u==null){u=0}t.push([o.name,u,c,i])}r.push(t)}}}const i={};i["name"]=t.name;i["className"]=s;i["config"]=o;i["inboundNodes"]=r;e.push(i)}t["layers"]=e;const s=[];for(let t=0;t<this.inputLayers.length;t++){const e=this.inputLayers[t];const o=this.inputLayersNodeIndices[t];const r=XC.nodeKey(e,o);if(!this.containerNodes.has(r)){continue}let i=n[r];if(i===null||i===undefined){i=0}const c=this.inputLayersTensorIndices[t];s.push([e.name,i,c])}t["inputLayers"]=s;const o=[];for(let t=0;t<this.outputLayers.length;t++){const e=this.outputLayers[t];const s=this.outputLayersNodeIndices[t];const r=XC.nodeKey(e,s);if(!this.containerNodes.has(r)){continue}let i=n[r];if(i===null||i===undefined){i=0}const c=this.outputLayersTensorIndices[t];o.push([e.name,i,c])}t["outputLayers"]=o;return t}static fromConfig(t,n,e={},s=false){const o={};const r={};function i(t,n){if(!(t.name in r)){r[t.name]=[n]}else{r[t.name].push(n)}}function c(t,n){const e=[];let s;for(const r of n){const c=r[0];const a=r[1];const u=r[2];s=r[3]==null?{}:r[3];if(!(c in o)){i(t,n);return}const l=o[c];if(l.inboundNodes.length<=a){i(t,n);return}const f=l.inboundNodes[a];e.push(f.outputTensors[u])}if(e.length>0){t.apply(i$(e),s)}}function a(t){const e=t["name"];const r=Kk(t,n["customObjects"]!=null?n["customObjects"]:{});r.setFastWeightInitDuringBuild(s);o[e]=r;const c=t["inboundNodes"];c.forEach((t=>{if(!(t instanceof Array)){throw new Qv(`Corrupted configuration, expected array for nodeData: ${t}`)}i(r,t)}))}const u=n["name"];const l=n["layers"];for(const t of l){a(t)}while(!b$(r)){for(const t of l){const n=o[t["name"]];if(n.name in r){const t=r[n.name];delete r[n.name];for(const e of t){c(n,e)}}}}const f=[];const h=[];const d=n["inputLayers"];for(const t of d){const n=t[0];const e=t[1];const s=t[2];o$(n in o);const r=o[n];const i=r.inboundNodes[e].outputTensors;f.push(i[s])}const p=n["outputLayers"];for(const t of p){const n=t[0];const e=t[1];const s=t[2];o$(n in o);const r=o[n];const i=r.inboundNodes[e].outputTensors;h.push(i[s])}return new t({inputs:f,outputs:h,name:u})}get stateful(){if(this._stateful){throw new Qv("Container instance unexpectedly has _stateful = true. The "+"statefulness of a Container is determined by the Layers it "+"contains. Its _stateful property must remain the default false.")}for(const t of this.layers){if(t.stateful){return true}}return false}resetStates(){kc((()=>{this.layers.forEach((t=>{if(t.stateful){t.resetStates()}}))}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KC(t,n,e){const s=n.length;if(t==null||Array.isArray(t)&&t.length===0){return n.map((t=>null))}if(s===1){if(Array.isArray(t)&&t.length===1){return t}else if(typeof t==="object"&&n[0]in t){return[t[n[0]]]}else{return[t]}}if(Array.isArray(t)){if(t.length!==s){throw new Error(`Provided ${e} is an array of ${t.length} `+`element(s), but the model has ${s} outputs. `+`Make sure a set of weights is provided for each model output.`)}return t}else if(typeof t==="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]==="object"){const e=[];n.forEach((n=>{if(n in t){e.push(t[n])}else{e.push(null)}}));return e}else{throw new Error(`The model has multiple (${s}) outputs, `+`so ${e} must be either an array with `+`${s} elements or an object with ${n} keys. `+`Provided ${e} not understood: ${JSON.stringify(t)}`)}}function JC(t,n){return KC(t,n,"classWeight")}async function YC(t,n,e,s){if(e!=null){const n=kc((()=>{if(t.shape.length===1){return $a(t)}else if(t.shape.length===2){if(t.shape[1]>1){const n=1;return Ga(t,n)}else if(t.shape[1]===1){return yu(t,[t.shape[0]])}else{throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) `+`during handling of class weights. The size is expected to be `+`>= 1.`)}}else{throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during `+`handling of class weights. The rank is expected to be 1 or 2.`)}}));const s=Array.from(await n.data());Cc(n);const o=[];s.forEach((t=>{if(e[t]==null){throw new Error(`classWeight must contain all classes in the training data. `+`The class ${t} exists in the data but not in `+`classWeight`)}else{o.push(e[t])}}));return fm(o,"float32")}else{return null}}function ZC(t,n){return Aa(t,n)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const QC=32;function tN(t,n){let e;let s;const o=n;e=o["xs"];s=o["ys"];x(e!=null&&s!=null,(()=>"A Dataset iterator for fitDataset() is expected to generate "+"objects of the form `{xs: xVal, ys: yVal}`, where the two "+"values may be `tf.Tensor`, an array of Tensors, or a map of "+"string to Tensor.  The provided Dataset instead generates "+`${n}`));const r=nN("input",t.inputNames,e);const i=nN("output",t.outputNames,s);const c=r[0].shape[0];x(r.length===t.inputs.length,(()=>`LayersModel has ${t.inputs.length} inputs, but the dataset `+`provides ${r.length} inputs.  (Expected input keys: `+`${JSON.stringify(t.inputNames)})`));x(i.length===t.outputs.length,(()=>`LayersModel has ${t.outputs.length} outputs, but the dataset `+`provides ${i.length} outputs.  (Expected output keys: `+`${JSON.stringify(t.outputNames)})`));for(let n=0;n<r.length;n++){x(r[n].shape[0]===c,(()=>`Batch size mismatch: input `+`${t.inputNames[n]} has ${r[n].shape[0]}; `+`expected  ${c} based on input ${t.inputNames[0]}.`))}for(let n=0;n<i.length;n++){x(i[n].shape[0]===c,(()=>`Batch size mismatch: output `+`${t.outputNames[n]} has ${i[n].shape[0]}; `+`expected  ${c} based on input ${t.inputNames[0]}.`))}return{xs:r,ys:i}}function nN(t,n,e){if(e instanceof yr){return[e]}else if(Array.isArray(e)){x(e.length===n.length,(()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`));return e}else{const s=[];for(const o of n){if(e[o]==null){throw new Qv(`The feature data generated by the dataset lacks the required `+`${t} key '${o}'.`)}s.push(e[o])}return s}}function eN(t){if(t.length===3){throw new t$("Validation with sample weights is not implemented yet.")}return{xs:t[0],ys:t[1]}}async function sN(t,n,e){const s=e.batchesPerEpoch!=null;x(t.optimizer!=null,(()=>"You must compile a model before training/testing. Use "+"LayersModel.compile(modelCompileConfig)."));x(e!=null,(()=>`For fitDataset(), the 2nd argument (config) is required, `+`but it is not provided in this call.`));x(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive `+`integer, but got ${e.epochs}`));x(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a `+`positive integer if specified, but got ${e.batchesPerEpoch}`));x(e["validationSplit"]==null,(()=>"`validationSplit` is not supported by `fitDataset()`. "+"Use validationData instead."));if(t.isTraining){throw new Error("Cannot start training because another fit() call is ongoing.")}t.isTraining=true;try{const o=e.validationData!=null;let r;let i;if(o){if(rN(e.validationData)){x(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),(()=>`For fitDataset() with dataset-based validation, `+`config.validationBatches is expected not to be provided, `+`or to be a positive integer, `+`but got ${e.validationBatches}`))}else{const t=eN(e.validationData);r=t.xs;i=t.ys}}const c=t.makeTrainFunction();const a=t.getDedupedMetricsNames();let u;if(o){u=a.slice().concat(a.map((t=>"val_"+t)))}else{u=a.slice()}const l=jk(e.callbacks,e.yieldEvery);const f=e.verbose==null?1:e.verbose;const{callbackList:h,history:d}=Xk(l,f,e.epochs,null,null,oN(n,e),null,o,u);h.setModel(t);t.history=d;await h.onTrainBegin();t.stopTraining_=false;let p=e.initialEpoch==null?0:e.initialEpoch;let m=await n.iterator();while(p<e.epochs){const u={};await h.onEpochBegin(p);let l=0;let f=0;if(!s){m=await n.iterator()}while(s?l<e.batchesPerEpoch:true){const n=await m.next();if(s&&n.done){console.warn("You provided `batchesPerEpoch` as "+`${e.batchesPerEpoch}, `+"but your dataset iterator ran out of data after "+`${l} batches; `+"interrupting training. Make sure that your "+"dataset can generate at least `batchesPerEpoch * epochs` "+"batches (in this case, "+`${e.batchesPerEpoch*e.epochs} batches). `+"You may need to use the repeat() function when building "+"your dataset.");break}if(n.value!=null){const{xs:s,ys:o}=tN(t,n.value);const r={};r["batch"]=f;r["size"]=s[0].shape[0];await h.onBatchBegin(f,r);const i=[];if(e.classWeight!=null){const n=JC(e.classWeight,t.outputNames);for(let t=0;t<n.length;++t){i.push(await YC(o[t],null,n[t]))}}const u=s.concat(o).concat(i);const d=c(u);Cc(u);for(let t=0;t<a.length;++t){const n=a[t];const e=d[t];r[n]=e;Nc(e)}await h.onBatchEnd(f,r);zk(r);f++;l++}if(s?l>=e.batchesPerEpoch:n.done){if(o){let n;if(rN(e.validationData)){n=c$(await t.evaluateDataset(e.validationData,{batches:e.validationBatches}))}else{n=c$(t.evaluate(r,i,{batchSize:e.validationBatchSize==null?QC:e.validationBatchSize,verbose:0}))}for(let e=0;e<t.metricsNames.length;++e){u[`val_${t.metricsNames[e]}`]=n[e]}}break}if(t.stopTraining_){break}}await h.onEpochEnd(p,u);p++;if(t.stopTraining_){break}}await h.onTrainEnd();await t.history.syncData();return t.history}finally{t.isTraining=false}}function oN(t,n){let e=null;if(n.batchesPerEpoch!=null){e=n.batchesPerEpoch}else if(Number.isFinite(t.size)){e=t.size}return e}function rN(t){return typeof t.iterator==="function"}function iN(t){return typeof t.next==="function"}async function cN(t,n,e){e=e||{};const s=e.batches!=null;const o=t.testFunction;let r=[];if(e.verbose>0){throw new t$("Verbose mode is not implemented yet.")}x(!s||e.batches>0&&Number.isInteger(e.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+`received ${JSON.stringify(e.batches)}`));const i=iN(n)?n:await n.iterator();let c=0;let a=0;while(s?a<e.batches:true){const n=await i.next();r=kc((()=>{if(n.value){const{xs:e,ys:s}=tN(t,n.value);const i=e.concat(s);const u=kc((()=>o(i)));Cc(i);if(a===0){for(let t=0;t<u.length;++t){r.push($f(0))}}const l=i[0].shape[0];for(let t=0;t<u.length;++t){const n=u[t];const e=r[t];r[t]=kc((()=>Na(r[t],Aa(l,n))));if(a>0){Cc(e)}}Cc(u);c+=l;++a}return r}));if(n.done){if(s){console.warn("Your dataset iterator ran out of data during evaluateDataset(). "+"Interrupting evalution. Make sure that your "+"dataset can generate at least `batches` "+`batches (in this case, ${e.batches} batches). `+"You may need to use the repeat() function when building "+"your dataset.")}break}}for(let t=0;t<r.length;++t){const n=r[t];r[t]=Ta(r[t],c);Cc(n)}return i$(r)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aN(t){x(t>0&&Number.isInteger(t),(()=>`batchSize is required to be a positive integer, but got ${t}`))}function uN(t,n,e){if(t==null){return[null]}else if(Array.isArray(t)){return t.map((t=>ry(t,n,e-n)))}else{return ry(t,n,e-n)}}function lN(t,n){return kc((()=>{if(t==null){return null}else if(Array.isArray(t)){return t.map((t=>lN(t,n)))}else{return dy(t,n.dtype==="int32"?n:wa(n,"int32"))}}))}function fN(t,n){const e=[];let s=0;let o=null;while(s<t){o=s+n;if(o>=t){o=t}e.push([s,o]);s=o}return e}function hN(t){const n=[];if(t instanceof yr){t=[t]}for(let e=0;e<t.length;++e){const s=t[e];if(s.rank===1){n.push(ny(s,1))}else if(s.rank===0){throw new Error("Expected tensor to be at least 1D, but received a 0D tensor "+"(scalar).")}else{n.push(s)}}return n}function dN(t,n){if(t==null){return}const e=[];if(n instanceof yr){e.push(n.id)}else if(Array.isArray(n)){n.forEach((t=>e.push(t.id)))}else if(n!=null){for(const t in n){const s=n[t];e.push(s.id)}}const s=[];if(t instanceof yr){if(e.indexOf(t.id)===-1){s.push(t)}}else if(Array.isArray(t)){t.forEach((t=>{if(e.indexOf(t.id)===-1){s.push(t)}}))}else if(t!=null){for(const n in t){const o=t[n];if(e.indexOf(o.id)===-1){s.push(o)}}}s.forEach((t=>{if(!t.isDisposed){t.dispose()}}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pN(t){return t instanceof yr}function mN(t){return Array.isArray(t)}function xN(t){return!pN(t)&&!mN(t)}function bN(t,n,e,s=true,o=""){if(n==null||n.length===0){if(t!=null){let n=false;if(mN(t)&&t.length>0){n=true}else if(xN(t)){for(const e in t){if(t.hasOwnProperty(e)){n=true;break}}}else{n=true}if(n){throw new Qv(`Error when checking model ${o} expected no data, `+`but got ${t}`)}}return[]}if(t==null){return n.map((t=>null))}let r;if(xN(t)){t=t;r=[];for(const e of n){if(t[e]==null){throw new Qv(`No data provided for "${e}". Need data for each key in: `+`${n}`)}r.push(t[e])}}else if(mN(t)){t=t;if(t.length!==n.length){throw new Qv(`Error when checking model ${o}: the Array of `+`Tensors that you are passing to your model is not the size the `+`model expected. Expected to see ${n.length} Tensor(s), but `+`instead got the following list of Tensor(s): ${t}`)}r=t}else{t=t;if(n.length>1){throw new Qv(`The model ${o} expects ${n.length} Tensor(s), `+`but only received one Tensor. Found: Tensor with shape ${t.shape}`)}r=[t]}r=hN(r);if(e!=null){for(let t=0;t<n.length;++t){if(e[t]==null){continue}const i=r[t];if(i.shape.length!==e[t].length){throw new Qv(`Error when checking ${o}: expected ${n[t]} `+`to have ${e[t].length} dimension(s). but got array with `+`shape ${i.shape}`)}for(let n=0;n<e[t].length;++n){if(n===0&&!s){continue}const r=i.shape[n];const c=e[t][n];if(c!=null&&c>=0&&r!==c){throw new Qv(`${o} expected a batch of elements where each `+`example has shape [${e[t].slice(1,e[t].length)}] `+`(i.e.,tensor shape [*,${e[t].slice(1,e[t].length)}])`+` but the ${o} received an input with ${i.shape[0]}`+` examples, each with shape [${i.shape.slice(1,i.shape.length)}]`+` (tensor shape [${i.shape}])`)}}}}return r}function gN(t,n,e){const s=x$(t.map((t=>t.shape[0])));s.sort();const o=x$(n.map((t=>t.shape[0])));o.sort();if(s.length>1){throw new Qv(`All input Tensors (x) should have the same number of samples. `+`Got array shapes: `+`${JSON.stringify(t.map((t=>t.shape)))}`)}if(o.length>1){throw new Qv(`All target Tensors (y) should have the same number of samples. `+`Got array shapes: `+`${JSON.stringify(n.map((t=>t.shape)))}`)}if(s.length>0&&o.length>0&&!v(s,o)){throw new Qv(`Input Tensors should have the same number of samples as target `+`Tensors. Found ${s[0]} input sample(s) and ${o[0]} target `+`sample(s).`)}}function wN(t,n,e){const s=[Yk,aC,rC];for(let o=0;o<t.length;++o){const r=t[o];const i=n[o];const c=e[o];if(i==null){continue}if(i===rC){if(r.shape[r.shape.length-1]===1){throw new Qv(`You are passing a target array of shape ${r.shape} while using `+`a loss 'categorical_crossentropy'. 'categorical_crossentropy'`+`expects targets to be binary matrices (1s and 0s) of shape `+`[samples, classes].`)}}if(s.indexOf(i)!==-1){const t=r.shape.slice(1);const n=c.slice(1);for(let e=0;e<t.length;++e){const s=t[e];const o=n[e];if(o!=null&&s!==o){throw new Qv(`A target Tensor with shape ${r.shape} was passed for an `+`output of shape ${c}, while using a loss function that `+`expects targets to have the same shape as the output.`)}}}}}function vN(t,n,e,s=true,o=""){let r;if(Array.isArray(t)){if(t.length!==n.length){throw new Qv(`Error when checking model ${o}: the Array of `+`Tensors that you are passing to your model is not the size the `+`the model expected. Expected to see ${n.length} Tensor(s),`+` but instead got ${t.length} Tensors(s).`)}r=t}else{if(n.length>1){throw new Qv(`The model expects ${n.length} ${o} Tensors, `+`but only received one Tensor. Found: array with shape `+`${JSON.stringify(t.shape)}.`)}r=[t]}if(e!=null){for(let t=0;t<n.length;++t){if(e[t]==null){continue}const i=r[t];if(i.shape.length!==e[t].length){throw new Qv(`Error when checking ${o}: expected ${n[t]} `+`to have ${e[t].length} dimension(s), but got array with `+`shape ${JSON.stringify(i.shape)}`)}for(let r=0;r<e[t].length;++r){if(r===0&&!s){continue}const c=i.shape[r];const a=e[t][r];if(a!=null){if(a!==c){throw new Qv(`Error when checking ${o}: expected `+`${n[t]} to have shape ${JSON.stringify(e[t])} but `+`got array with shape ${JSON.stringify(i.shape)}.`)}}}}}}function $N(t,n){if(t==null||Array.isArray(t)&&t.length===0){return n.map((t=>[]))}let e;if(typeof t==="string"||typeof t==="function"){e=[t]}else if(Array.isArray(t)||typeof t==="object"){e=t}else{throw new TypeError("Type of metrics argument not understood. Expected an string,"+`function, Array, or Object, found: ${t}`)}if(Array.isArray(e)){return n.map((t=>e))}else{const t=[];for(const s of n){let n=e.hasOwnProperty(s)?e[s]:[];if(!Array.isArray(n)){n=[n]}t.push(n)}return t}}const yN="layers-model";class kN extends XC{constructor(t){super(t);this.isTraining=false}summary(t,n,e=console.log){if(!this.built){throw new Qv(`This model has never been called, thus its weights have not been `+`created yet. So no summary can be displayed. Build the model `+`first (e.g., by calling it on some test data).`)}LC(this,t,n,e)}compile(t){if(t.loss==null){t.loss=[]}this.loss=t.loss;if(typeof t.optimizer==="string"){this.optimizer_=FC(t.optimizer);this.isOptimizerOwned=true}else{if(!(t.optimizer instanceof Jx)){throw new Qv(`User-defined optimizer must be an instance of tf.Optimizer.`)}this.optimizer_=t.optimizer;this.isOptimizerOwned=false}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!=="string"&&typeof t.loss!=="function"){t.loss=t.loss;for(const n in t.loss){if(this.outputNames.indexOf(n)===-1){throw new Qv(`Unknown entry in loss dictionary: "${n}". `+`Only expected the following keys: ${this.outputNames}`)}}for(const e of this.outputNames){if(t.loss[e]==null){console.warn(`Output "${e}" is missing from loss dictionary. We assume `+`this was done on purpose, and we will not be expecting data `+`to be passed to ${e} during training`)}n.push(dC(t.loss[e]))}}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length){throw new Qv(`When passing an Array as loss, it should have one entry per `+`model output. The model has ${this.outputs.length} output(s), `+`but you passed loss=${t.loss}.`)}const e=t.loss;n=e.map((t=>dC(t)))}else{const e=dC(t.loss);this.outputs.forEach((t=>{n.push(e)}))}this.lossFunctions=n;this.feedOutputNames=[];this.feedOutputShapes=[];this.feedLossFns=[];for(let t=0;t<this.outputs.length;++t){const n=this.internalOutputShapes[t];const e=this.outputNames[t];this.feedOutputNames.push(e);this.feedOutputShapes.push(n);this.feedLossFns.push(this.lossFunctions[t])}const e=[];this.metrics=t.metrics;this.metricsNames=["loss"];this.metricsTensors=[];V$("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(e.indexOf(t)!==-1){continue}const n=this.lossFunctions[t];if(this.outputs.length>1){this.metricsTensors.push([n,t]);this.metricsNames.push(this.outputNames[t]+"_loss")}}}));const s=$N(t.metrics,this.outputNames);const o=(t,n,e)=>{if(this.outputNames.length>1){n=this.outputNames[t]+"_"+n}this.metricsNames.push(n);this.metricsTensors.push([e,t])};V$("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(e.indexOf(t)!==-1){continue}const n=s[t];const r=n=>{const e="";let s;let r;let i;for(const c of n){if(typeof c==="string"&&["accuracy","acc","crossentropy","ce"].indexOf(c)!==-1){const n=this.internalOutputShapes[t];if(n[n.length-1]===1||this.lossFunctions[t]===aC){if(["accuracy","acc"].indexOf(c)!==-1){r=pC}else if(["crossentropy","ce"].indexOf(c)!==-1){r=wC}}else if(this.lossFunctions[t]===iC){if(["accuracy","acc"].indexOf(c)!==-1){r=vC}else if(["crossentropy","ce"].indexOf(c)!==-1){r=TC}}else{if(["accuracy","acc"].indexOf(c)!==-1){r=mC}else if(["crossentropy","ce"].indexOf(c)!==-1){r=SC}}let o;if(["accuracy","acc"].indexOf(c)!==-1){o="acc"}else if(["crossentropy","ce"].indexOf(c)!==-1){o="ce"}i=r;s=e+o}else{const t=AC(c);i=t;s=e+OC(c)}let n;V$(s,(()=>{n=i}));o(t,s,n)}};r(n)}}));this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){if(this.collectedTrainableWeights==null){return}if(this.trainableWeights.length!==this.collectedTrainableWeights.length){console.warn("Discrepancy between trainableweights and collected trainable "+"weights. Did you set `model.trainable` without calling "+"`model.compile()` afterwards?")}}evaluate(t,n,e={}){const s=e.batchSize==null?32:e.batchSize;aN(s);const o=true;const r=this.standardizeUserDataXY(t,n,o,s);try{const t=r[0].concat(r[1]);this.makeTestFunction();const n=this.testFunction;const o=this.testLoop(n,t,s,e.verbose,e.steps);return i$(o)}finally{dN(r[0],t);dN(r[1],n)}}async evaluateDataset(t,n){this.makeTestFunction();return cN(this,t,n)}checkNumSamples(t,n,e,s="steps"){let o;if(e!=null){o=null;if(n!=null){throw new Qv(`If ${s} is set, batchSize must be null or undefined.`+`Got batchSize = ${n}`)}}else if(t!=null){if(Array.isArray(t)){o=t[0].shape[0]}else{o=t.shape[0]}}else{throw new Qv(`Either the input data should have a defined shape, or `+`${s} shoud be specified.`)}return o}execute(t,n){if(Array.isArray(n)&&n.length===0){throw new Qv("`outputs` is an empty Array, which is not allowed.")}const e=Array.isArray(n);const s=e?n:[n];const o=this.retrieveSymbolicTensors(s);const r=new bk;if(t instanceof yr){t=[t]}if(Array.isArray(t)){if(t.length!==this.inputs.length){throw new Qv(`The number of inputs provided (${t.length}) `+`does not match the number of inputs of this model `+`(${this.inputs.length}).`)}for(let n=0;n<this.inputs.length;++n){r.add(this.inputs[n],t[n])}}else{for(const n of this.inputs){const e=t[n.name];if(e==null){throw new Qv(`No value is provided for the model's input ${n.name}`)}r.add(n,e)}}const i=$k(o,r);return e?i:i[0]}retrieveSymbolicTensors(t){const n=s$(null,t.length);let e=t.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output];const r=o.map((t=>t.name));for(let s=0;s<t.length;++s){const i=r.indexOf(t[s]);if(i!==-1){n[s]=o[i];e--}if(e===0){break}}if(e===0){break}}if(e>0){const e=[];n.forEach(((n,s)=>{if(n==null){e.push(t[s])}}));throw new Qv(`Cannot find SymbolicTensors for output name(s): `+`${JSON.stringify(e)}`)}return n}predictLoop(t,n=32,e=false){return kc((()=>{const s=this.checkNumSamples(t);if(e){throw new t$("Verbose predictLoop() is not implemented yet.")}const o=fN(s,n);const r=this.outputs.map((t=>[]));for(let n=0;n<o.length;++n){const e=kc((()=>{const e=o[n][0];const s=o[n][1];const r=uN(t,e,s);const i=[];if(Array.isArray(r)){for(let t=0;t<r.length;++t){i.push({key:this.inputs[t],value:r[t]})}}else{i.push({key:this.inputs[0],value:r})}const c=new bk(i);return $k(this.outputs,c)}));e.forEach(((t,n)=>r[n].push(t)))}return i$(r.map((t=>Eu(t,0))))}))}predict(t,n={}){const e=hN(t);vN(e,this.inputNames,this.feedInputShapes,false);try{const t=n.batchSize==null?32:n.batchSize;aN(t);return this.predictLoop(e,t)}finally{dN(e,t)}}predictOnBatch(t){vN(t,this.inputNames,this.feedInputShapes,true);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,e=true,s){if(this.optimizer_==null){throw new Zv("You must compile a model before training/testing. Use "+"LayersModel.compile(modelCompileArgs).")}const o=[];for(let t=0;t<this.feedOutputShapes.length;++t){const n=this.feedOutputShapes[t];const e=this.feedLossFns[t];if(e===iC){o.push(n.slice(0,n.length-1).concat([1]))}else{o.push(n)}}t=bN(t,this.feedInputNames,this.feedInputShapes,false,"input");n=bN(n,this.feedOutputNames,o,false,"target");gN(t,n);wN(n,this.feedLossFns,this.feedOutputShapes);if(this.stateful&&s!=null&&s>0){if(t[0].shape[0]%s!==0){throw new Qv(`In a stateful network, you should only pass inputs with a `+`number of samples that is divisible by the batch size `+`${s}. Found: ${t[0].shape[0]} sample(s).`)}}return[t,n]}async standardizeUserData(t,n,e,s,o=true,r){const[i,c]=this.standardizeUserDataXY(t,n,o,r);if(e!=null){throw new Error("sample weight is not supported yet.")}let a=null;if(s!=null){const t=JC(s,this.outputNames);a=[];for(let n=0;n<t.length;++n){a.push(await YC(c[n],null,t[n]))}}return[i,c,a]}testLoop(t,n,e,s=0,o){return kc((()=>{const r=this.checkNumSamples(n,e,o,"steps");const i=[];if(s>0){throw new t$("Verbose mode is not implemented yet.")}if(o!=null){throw new t$("steps mode in testLoop() is not implemented yet")}else{const s=fN(r,e);const o=fm(J$(0,r));for(let e=0;e<s.length;++e){const r=s[e][0];const c=s[e][1];const a=ry(o,r,c-r);const u=lN(n,a);const l=t(u);if(e===0){for(let t=0;t<l.length;++t){i.push($f(0))}}for(let t=0;t<l.length;++t){const n=l[t];i[t]=Na(i[t],Aa(c-r,n))}}for(let t=0;t<i.length;++t){i[t]=Ta(i[t],r)}}return i}))}getDedupedMetricsNames(){const t=this.metricsNames;const n=[];for(let e=0;e<t.length;++e){const s=t[e];let o=s;if(r$(t,s)>1){const n=r$(t.slice(0,e),s);o+=`_${n}`}n.push(o)}return n}makeTrainFunction(){return t=>{const n=[];const e=t.slice(0,this.inputs.length);const s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length);const o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2);const r=[];const i=()=>{const t=[];for(let n=0;n<this.inputs.length;++n){t.push({key:this.inputs[n],value:e[n]})}const i=new bk(t);const c=$k(this.outputs,i,{training:true});let a;for(let t=0;t<this.lossFunctions.length;++t){const e=this.lossFunctions[t];let r=e(s[t],c[t]);if(o[t]!=null){r=ZC(r,o[t])}const i=jh(r);n.push(i);if(t===0){a=r}else{a=Na(a,r)}}for(let t=0;t<this.metricsTensors.length;++t){let e;if(this.outputs.length>1&&t<this.outputs.length){e=n[t]}else{const n=this.metricsTensors[t][0];const o=this.metricsTensors[t][1];e=jh(n(s[o],c[o]))}Nc(e);r.push(e)}a=jh(a);this.calculateLosses().forEach((t=>{a=Na(a,t)}));return a};const c=this.collectedTrainableWeights.map((t=>t.read()));const a=true;const u=this.optimizer_.minimize(i,a,c);return[u].concat(r)}}makeTestFunction(){this.testFunction=t=>kc((()=>{const n=[];let e;const s=t.slice(0,this.inputs.length);const o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length);const r=[];for(let t=0;t<this.inputs.length;++t){r.push({key:this.inputs[t],value:s[t]})}const i=new bk(r);const c=$k(this.outputs,i);for(let t=0;t<this.lossFunctions.length;++t){const s=this.lossFunctions[t];const r=jh(s(o[t],c[t]));if(t===0){e=r}else{e=Na(e,r)}n.push(e)}for(let t=0;t<this.metricsTensors.length;++t){const e=this.metricsTensors[t][0];const s=this.metricsTensors[t][1];const r=jh(e(o[s],c[s]));n.push(r)}return n}))}async fit(t,n,e={}){if(this.isTraining){throw new Error("Cannot start training because another fit() call is ongoing.")}this.isTraining=true;let s;let o;let r;let i;let c;let a;let u;let l;let f;try{const h=e.batchSize==null?32:e.batchSize;aN(h);const d=false;const p=await this.standardizeUserData(t,n,e.sampleWeight,e.classWeight,d,h);s=p[0];o=p[1];f=p[2];let m=false;let x;if(e.validationData!=null&&e.validationData.length>0){m=true;if(e.validationData.length===2){c=e.validationData[0];a=e.validationData[1]}else if(e.validationData.length===3){throw new t$("validationData including sample weights is not supported yet.")}else{throw new Qv(`When passing validation data, it must contain 2 (valX, valY) `+`or 3 (valX, valY, valSampleWeight) items; `+`${e.validationData} is invalid.`)}const t=true;const n=await this.standardizeUserData(c,a,null,null,t,h);u=n[0];l=n[1];x=u.concat(l)}else if(e.validationSplit!=null&&e.validationSplit>0&&e.validationSplit<1){m=true;const t=Math.floor(s[0].shape[0]*(1-e.validationSplit));const n=s[0].shape[0];u=uN(s,t,n);r=s;s=uN(s,0,t);l=uN(o,t,n);i=o;o=uN(o,0,t);x=u.concat(l)}else if(e.validationSteps!=null){m=true}const b=s.concat(o).concat(f);this.checkTrainableWeightsConsistency();const g=this.makeTrainFunction();const w=this.getDedupedMetricsNames();let v;let $;if(m){this.makeTestFunction();v=this.testFunction;$=w.slice().concat(w.map((t=>"val_"+t)))}else{v=null;x=[];$=w.slice()}const y=jk(e.callbacks,e.yieldEvery);const k=await this.fitLoop(g,b,w,h,e.epochs,e.verbose,y,v,x,e.shuffle,$,e.initialEpoch,null,null);return k}finally{this.isTraining=false;dN(s,t);dN(o,n);dN(r,t);dN(i,n);dN(u,c);dN(l,a);if(f!=null){Cc(f)}}}async fitLoop(t,n,e,s,o,r,i,c,a,u,l,h,d,p){if(s==null){s=32}if(o==null){o=1}if(u==null){u=true}if(h==null){h=0}let m=false;if(c!=null&&a!=null){m=true}if(p!=null){m=true;if(d==null){throw new Qv("Can only use `validationSteps` when doing step-wise training, "+"i.e., `stepsPerEpoch` must be set.")}}const x=this.checkNumSamples(n,s,d,"steps_per_epoch");let b;if(x!=null){b=J$(0,x)}if(r==null){r=1}const{callbackList:g,history:w}=Xk(i,r,o,h,x,d,s,m,l);g.setModel(this);this.history=w;await g.onTrainBegin();this.stopTraining_=false;for(let r=h;r<o;++r){await g.onEpochBegin(r);const o={};if(d!=null){throw new t$("stepsPerEpoch mode is not implemented yet.")}else{if(u==="batch"){throw new t$("batch shuffling is not implemneted"+" yet")}else if(u){f(b)}const r=fm(b);const i=fN(x,s);for(let u=0;u<i.length;++u){const l={};await g.onBatchBegin(u,l);kc((()=>{const f=i[u][0];const h=i[u][1];const d=ry(r,f,h-f);l["batch"]=u;l["size"]=h-f;const p=lN(n,d);const x=t(p);for(let t=0;t<e.length;++t){const n=e[t];const s=x[t];l[n]=s;Nc(s)}if(u===i.length-1){if(m){const t=this.testLoop(c,a,s);for(let n=0;n<e.length;++n){const s=e[n];const r=t[n];Nc(r);o["val_"+s]=r}}}}));await g.onBatchEnd(u,l);zk(l);if(this.stopTraining_){break}}r.dispose()}await g.onEpochEnd(r,o);if(this.stopTraining_){break}}await g.onTrainEnd();await this.history.syncData();return this.history}async fitDataset(t,n){return sN(this,t,n)}async trainOnBatch(t,n){const e=await this.standardizeUserData(t,n);const s=e[0];const o=e[1];const r=this.makeTrainFunction();const i=r(s.concat(o));const c=[];for(const t of i){const n=await t.data();c.push(n[0])}Cc(i);dN(e[0],t);dN(e[1],n);return i$(c)}getNamedWeights(t){const n=[];const e=t!=null&&t.trainableOnly;const s=e?this.trainableWeights:this.weights;const o=this.getWeights(e);for(let t=0;t<s.length;++t){if(e&&!s[t].trainable){continue}n.push({name:s[t].originalName,tensor:o[t]})}return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){if(this.optimizer_!==t){this.optimizer_=t;this.isOptimizerOwned=false}}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=yc().numTensors;this.optimizer_.dispose();t.numDisposedVariables+=n-yc().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss==="string"){t=a$(this.loss)}else if(Array.isArray(this.loss)){for(const t of this.loss){if(typeof t!=="string"){throw new Error("Serialization of non-string loss is not supported.")}}t=this.loss.map((t=>a$(t)))}else{const n=Object.keys(this.loss);t={};const e=this.loss;for(const s of n){if(typeof e[s]==="string"){t[s]=a$(e[s])}else{throw new Error("Serialization of non-string loss is not supported.")}}}return t}getMetricIdentifiers(){if(typeof this.metrics==="string"||typeof this.metrics==="function"){return[a$(OC(this.metrics))]}else if(Array.isArray(this.metrics)){return this.metrics.map((t=>a$(OC(t))))}else{const t={};for(const n in this.metrics){t[n]=a$(OC(this.metrics[n]))}return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null){throw new Error("Loading weight_metrics is not supported yet.")}if(t.loss_weights!=null){throw new Error("Loading loss_weights is not supported yet.")}if(t.sample_weight_mode!=null){throw new Error("Loading sample_weight_mode is not supported yet.")}const n=UC(t.optimizer_config);const e=Kk(n);let s;if(typeof t.loss==="string"){s=u$(t.loss)}else if(Array.isArray(t.loss)){s=t.loss.map((t=>u$(t)))}else if(t.loss!=null){s={};for(const n in t.loss){s[n]=u$(t.loss[n])}}let o;if(Array.isArray(t.metrics)){o=t.metrics.map((t=>u$(t)))}else if(t.metrics!=null){o={};for(const n in t.metrics){o[n]=u$(t.metrics[n])}}this.compile({loss:s,metrics:o,optimizer:e})}async save(t,n){if(typeof t==="string"){const n=zc(t);if(n.length===0){throw new Qv(`Cannot find any save handlers for URL '${t}'`)}else if(n.length>1){throw new Qv(`Found more than one (${n.length}) save handlers for `+`URL '${t}'`)}t=n[0]}if(t.save==null){throw new Qv("LayersModel.save() cannot proceed because the IOHandler "+"provided does not have the `save` attribute defined.")}const e=await Tc(this.getNamedWeights(n));const s=false;const o=null;const r=this.toJSON(o,s);const i={modelTopology:r,format:yN,generatedBy:`TensorFlow.js tfjs-layers v${jC}`,convertedBy:null};const c=n==null?false:n.includeOptimizer;if(c&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const t="optimizer";const{data:n,specs:s}=await Tc(await this.optimizer.getWeights(),t);e.specs.push(...s);e.data=Mc([e.data,n])}if(this.userDefinedMetadata!=null){const t=true;MC(this.userDefinedMetadata,this.name,t);i.userDefinedMetadata=this.userDefinedMetadata}i.weightData=e.data;i.weightSpecs=e.specs;return t.save(i)}setUserDefinedMetadata(t){MC(t,this.name);this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}kN.className="Model";Kx(kN);class CN extends kN{}CN.className="Functional";Kx(CN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class NN extends kN{constructor(t){super({inputs:[],outputs:[]});t=t||{};this.trainable=true;this.built=false;this.name=t.name!=null?t.name:S$("sequential_");if(t.layers!=null){for(const n of t.layers){this.add(n)}}}checkShape(t){const n=t.inboundNodes[0].outputTensors[0].shape;if(n.some((t=>t<0))){throw new Qv("Negative dimension size caused by adding layer "+`${t.name} with input shape [`+`${t.inboundNodes[0].inputTensors[0].shape}]`)}}add(t){const n=t instanceof NN||t instanceof kN;let e;if(n){e=t;if(e.outputs.length!==1){throw new Qv("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}if(e.inputs.length!==1){throw new Qv("All layers in a Sequential model "+"should have a single input tensor. "+"For multi-input layers, "+"use the functional API.")}}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null){throw new Qv("The first layer in a Sequential model must "+"get an `inputShape` or `batchInputShape` argument.")}const n=mk({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(n)}if(n){this.outputs=e.outputs;this.inputs=e.inputs}else{if(t.inboundNodes.length!==1){throw new Qv("A layer added to a Sequential model must not already be "+`connected somewhere else. LayersModel received layer ${t.name} `+`which has ${t.inboundNodes.length} pre-existing inbound `+"connections.")}if(t.inboundNodes[0].outputTensors.length!==1){throw new Qv("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}this.checkShape(t);this.outputs=[t.inboundNodes[0].outputTensors[0]];this.inputs=fk(this.outputs[0])}this.inboundNodes=[];new ik({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:s$(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const n=t.apply(this.outputs[0]);if(Array.isArray(n)){throw new TypeError("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}this.checkShape(t);this.outputs=[n];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t);this.built=false}pop(){if(this.layers.length===0){throw new TypeError("There are no layers in the model.")}this.layers.pop();if(this.layers.length===0){this.outputs=[];this.inboundNodes=[];this.outboundNodes=[]}else{const t=this.layers.length-1;this.layers[t].outboundNodes=[];this.outputs=[this.layers[t].output];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){if(this.model==null){this.build()}return this.model.call(t,n)}build(t){Jy(t);if(this.inputs.length===0||this.outputs.length===0){throw new TypeError("Sequential model cannot be built: model is empty."+" Add some layers first.")}this.model=new kN({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"});this.model.trainable=this.trainable;this.supportsMasking=this.model.supportsMasking;this.inputLayers=this.model.inputLayers;this.inputLayersNodeIndices=this.model.inputLayersNodeIndices;this.inputLayersTensorIndices=this.model.inputLayersTensorIndices;this.outputLayers=this.model.outputLayers;this.outputLayersNodeIndices=this.model.outputLayersNodeIndices;this.outputLayersTensorIndices=this.model.outputLayersTensorIndices;this.nodesByDepth=this.model.nodesByDepth;this.containerNodes=this.model.containerNodes;this.outputNames=this.model.outputNames;this.inputNames=this.model.inputNames;this.built=true}countParams(){if(!this.built){this.build()}return super.countParams()}summary(t,n,e=console.log){if(!this.built){this.build()}super.summary(t,n,e)}setWeights(t){if(this.model==null){this.build()}this.model.setWeights(t)}evaluate(t,n,e={}){if(!this.built){throw new Zv("The model needs to be compiled before being used.")}return this.model.evaluate(t,n,e)}async evaluateDataset(t,n){if(!this.built){throw new Zv("The model needs to be compiled before being used.")}return this.model.evaluateDataset(t,n)}predict(t,n={}){if(this.model==null){this.build()}return this.model.predict(t,n)}predictOnBatch(t){if(this.model==null){this.build()}return this.model.predictOnBatch(t)}compile(t){this.build();this.model.compile(t);this.optimizer_=this.model.optimizer;this.isOptimizerOwned=this.model.isOptimizerOwned;this.loss=this.model.loss;this.metrics=this.model.metrics;this.metricsTensors=this.model.metricsTensors;this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?undefined:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,e={}){if(!this.built){throw new Zv("The model needs to be compiled before "+"being used.")}return this.model.fit(t,n,e)}async fitDataset(t,n){if(!this.built){throw new Zv("The model needs to be compiled before "+"being used.")}return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,e={},s=false){let o;let r={};if(n instanceof Array){if(!(n[0].className!=null)||n[0]["className"]==="Merge"){throw new Qv("Legacy serialization format not supported yet.")}o=n}else{x(n["layers"]!=null,(()=>`When the config data for a Sequential model is not an Array, `+`it must be an Object that contains the 'layers' field.`));o=n["layers"];delete n["layers"];r=n}const i=new t(r);if(!(i instanceof NN)){throw new t$(`Sequential.fromConfig called on non-Sequential input: ${i}`)}for(const t of o){const n=undefined;const e=Kk(t,n,s);if(s){e.setFastWeightInitDuringBuild(true)}i.add(e)}return i}set stopTraining(t){if(this.model==null){throw new Qv("Cannot set the stopTraining property of a sequential model before "+"it is compiled.")}this.model.stopTraining=t}get stopTraining(){if(this.model==null){throw new Qv("Cannot get the stopTraining property of a sequential model before "+"it is compiled.")}return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const e={};e["className"]=n.getClassName();e["config"]=n.getConfig();t.push(e)}return{name:this.name,layers:t}}}NN.className="Sequential";Kx(NN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let RN=class t extends qx{getConfig(){return{}}};class SN extends RN{apply(t,n=1){return by(t,n)}}SN.className="elu";Kx(SN);class EN extends RN{apply(t){return Cp(t)}}EN.className="selu";Kx(EN);class TN extends RN{apply(t){return pp(t)}}TN.className="relu";Kx(TN);class IN extends RN{apply(t){return kc((()=>Jh(6,pp(t))))}}IN.className="relu6";Kx(IN);class AN extends RN{apply(t){return t}}AN.className="linear";Kx(AN);class ON extends RN{apply(t){return Ou(t)}}ON.className="sigmoid";Kx(ON);class FN extends RN{apply(t){return vy(t)}}FN.className="hardSigmoid";Kx(FN);class _N extends RN{apply(t){return yh(t)}}_N.className="softplus";Kx(_N);class MN extends RN{apply(t){return gy(t)}}MN.className="softsign";Kx(MN);class DN extends RN{apply(t){return Du(t)}}DN.className="tanh";Kx(DN);let LN=class t extends RN{apply(t,n=-1){return Wp(t,n)}};LN.className="softmax";Kx(LN);class zN extends RN{apply(t,n=-1){return Eh(t,n)}}zN.className="logSoftmax";Kx(zN);class PN extends RN{apply(t){return kc((()=>kc((()=>{const n=Math.sqrt(2);const e=Aa(.5,Na(1,rf(Ta(t,n))));return Aa(t,e)}))))}}PN.className="gelu";Kx(PN);class VN extends RN{apply(t){return kc((()=>Aa(.5,Aa(t,Na(1,Du(Aa(kf(Ta(2,Math.PI)),Na(t,Aa(.044715,vf(t,3))))))))))}}VN.className="gelu_new";Kx(VN);class BN extends RN{apply(t){return kc((()=>Aa(t,Du(yh(t)))))}}BN.className="mish";Kx(BN);class WN extends RN{apply(t,n=1){return kc((()=>Aa(Ou(Aa(t,n)),t)))}}WN.className="swish";Kx(WN);function GN(t){return t.getClassName()}function UN(t,n={}){return d$(t,Xx.getMap().classNameMap,n,"activation")}function HN(t){if(t==null){const t={};t["className"]="linear";t["config"]={};return UN(t)}if(typeof t==="string"){const n={};n["className"]=t;n["config"]={};return UN(n)}else if(t instanceof RN){return t}else{return UN(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jN(t){if(t!=null&&typeof t!=="object"){throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an `+`object, but received: ${t}`)}}class qN extends qx{}class XN extends qN{constructor(t){super();jN(t);this.l1=t==null||t.l1==null?.01:t.l1;this.l2=t==null||t.l2==null?.01:t.l2;this.hasL1=this.l1!==0;this.hasL2=this.l2!==0}apply(t){return kc((()=>{let n=qh([1]);if(this.hasL1){n=Na(n,Sf(Aa(this.l1,Fa(t))))}if(this.hasL2){n=Na(n,Sf(Aa(this.l2,py(t))))}return yu(n,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n["l1"],l2:n["l2"]})}}XN.className="L1L2";Kx(XN);const KN={l1l2:"L1L2"};function JN(t){return f$(t)}function YN(t,n={}){return d$(t,Xx.getMap().classNameMap,n,"regularizer")}function ZN(t){if(t==null){return null}if(typeof t==="string"){const n=t in KN?KN[t]:t;const e={className:n,config:{}};return YN(e)}else if(t instanceof qN){return t}else{return YN(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QN extends ak{constructor(t){super(t==null?{}:t);this.supportsMasking=true;if(t!=null){this.maxValue=t.maxValue}}call(t,n){t=Ky(t);let e=pp(t);if(this.maxValue!=null){e=el(e,0,this.maxValue)}return e}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue};const n=super.getConfig();Object.assign(t,n);return t}}QN.className="ReLU";Kx(QN);class tR extends ak{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3;if(t==null){t={}}this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const e=Ky(t);return ih(e,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha};const n=super.getConfig();Object.assign(t,n);return t}}tR.className="LeakyReLU";Kx(tR);class nR extends ak{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA_INITIALIZER="zeros";if(t==null){t={}}this.supportsMasking=true;this.alphaInitializer=jy(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER);this.alphaRegularizer=ZN(t.alphaRegularizer);this.alphaConstraint=Dk(t.alphaConstraint);if(t.sharedAxes==null){this.sharedAxes=null}else if(Array.isArray(t.sharedAxes)){this.sharedAxes=t.sharedAxes}else if(typeof t.sharedAxes==="number"){this.sharedAxes=[t.sharedAxes]}else{throw new Qv(`Expected sharedAxes to be a number or an array of numbers, `+`but got ${t.sharedAxes}`)}}build(t){t=Jy(t);const n=t.slice(1);if(this.sharedAxes!=null){for(const t of this.sharedAxes){n[t-1]=1}}this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,true,this.alphaConstraint);const e={};if(this.sharedAxes!=null){for(let n=1;n<t.length;++n){e[n]=t[n]}}this.inputSpec=[new sk({ndim:t.length,axes:e})];this.built=true}call(t,n){t=Ky(t);return gd(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Hy(this.alphaInitializer),alphaRegularizer:JN(this.alphaRegularizer),alphaConstraint:_k(this.alphaConstraint),sharedAxes:this.sharedAxes};const n=super.getConfig();Object.assign(t,n);return t}}nR.className="PReLU";Kx(nR);let eR=class t extends ak{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=1;if(t==null){t={}}if(t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA){throw new t$(`Non-default alpha value (${t.alpha}) is not supported by the `+`ELU layer yet.`)}this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const e=Ky(t);return sf(e)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha};const n=super.getConfig();Object.assign(t,n);return t}};eR.className="ELU";Kx(eR);class sR extends ak{constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1;if(t==null){t={}}this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const e=Ky(t);return Aa(e,wa(Xf(e,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta};const n=super.getConfig();Object.assign(t,n);return t}}sR.className="ThresholdedReLU";Kx(sR);class oR extends ak{constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1;if(t==null){t={}}this.softmax=(new LN).apply;this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return kc((()=>{let e=Ky(t);const s=n["mask"];if(s!=null){const t=Aa(Rh(Xh(e.shape),wa(s,e.dtype)),$f(-1e9));e=Na(e,t)}if(this.axis instanceof Array){if(this.axis.length>1){return _f(Rh(e,Ih(e,this.axis,true)))}else{return this.softmax(e,this.axis[0])}}return this.softmax(e,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis};const n=super.getConfig();Object.assign(t,n);return t}}oR.className="Softmax";Kx(oR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rR(t,n,e){if(typeof t==="number"){return s$(t,n)}else{if(t.length!==n){throw new Qv(`The ${e} argument must be an integer or tuple of ${n} integers.`+` Received: ${t.length} elements.`)}for(let s=0;s<n;++s){const o=t[s];if(!j$(o)){throw new Qv(`The ${e} argument must be an integer or tuple of ${n}`+` integers. Received: ${JSON.stringify(t)} including a`+` non-integer number ${o}`)}}return t}}function iR(t,n,e,s,o=1){if(t==null){return t}const r=n+(n-1)*(o-1);let i;if(e==="same"){i=t}else{i=t-r+1}return Math.floor((i+s-1)/s)}function cR(t,n,e,s){if(t==null){return null}if(s==="valid"){t=t*n+K$([e-n,0])}else if(s==="same"){t=t*n}else{throw new Qv(`Unsupport padding mode: ${s}.`)}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aR(t,n){return kc((()=>{_$(n);if(n==="channelsFirst"){return Tm(t,[0,2,3,1])}else{return t}}))}function uR(t,n){return kc((()=>{_$(n);if(n==="channelsFirst"){return Tm(t,[0,2,3,4,1])}else{return t}}))}function lR(t,n,e,s=1,o="valid",r,i=1){return kc((()=>{if(r==null){r=Q$()}_$(r);if(t.shape.length!==3){throw new Qv(`The input of a conv1dWithBias operation should be 3, but is `+`${t.shape.length} instead.`)}if(n.shape.length!==3){throw new Qv(`The kernel for a conv1dWithBias operation should be 3, but is `+`${n.shape.length} instead`)}if(e!=null&&e.shape.length!==1){throw new Qv(`The bias for a conv1dWithBias operation should be 1, but is `+`${e.shape.length} instead`)}if(r==="channelsFirst"){t=Tm(t,[0,2,1])}if(o==="causal"){throw new t$("The support for CAUSAL padding mode in conv1dWithBias is not "+"implemented yet.")}let c=pl(t,n,s,o==="same"?"same":"valid","NWC",i);if(e!=null){c=xy(c,e)}return c}))}function fR(t,n,e,s=[1,1],o="valid",r,i,c=null){return kc((()=>{if(r==null){r=Q$()}_$(r);if(t.rank!==3&&t.rank!==4){throw new Qv(`conv2dWithBiasActivation expects input to be of rank 3 or 4, `+`but received ${t.rank}.`)}if(n.rank!==3&&n.rank!==4){throw new Qv(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, `+`but received ${t.rank}.`)}let a=aR(t,r);if(o==="causal"){throw new t$("The support for CAUSAL padding mode in conv1dWithBias is not "+"implemented yet.")}a=Vm({x:a,filter:n,strides:s,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:c});if(r==="channelsFirst"){a=Tm(a,[0,3,1,2])}return a}))}function hR(t,n,e,s=[1,1,1],o="valid",r,i){return kc((()=>{if(r==null){r=Q$()}_$(r);if(t.rank!==4&&t.rank!==5){throw new Qv(`conv3dWithBias expects input to be of rank 4 or 5, but received `+`${t.rank}.`)}if(n.rank!==4&&n.rank!==5){throw new Qv(`conv3dWithBias expects kernel to be of rank 4 or 5, but received `+`${t.rank}.`)}let c=uR(t,r);if(o==="causal"){throw new t$("The support for CAUSAL padding mode in conv3dWithBias is not "+"implemented yet.")}c=vl(c,n,s,o==="same"?"same":"valid","NDHWC",i);if(e!=null){c=xy(c,e)}if(r==="channelsFirst"){c=Tm(c,[0,4,1,2,3])}return c}))}class dR extends ak{constructor(t,n){super(n);this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";dR.verifyArgs(n);this.rank=t;v$(this.rank,"rank");if(this.rank!==1&&this.rank!==2&&this.rank!==3){throw new t$(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is `+`not implemented yet.`)}this.kernelSize=rR(n.kernelSize,t,"kernelSize");this.strides=rR(n.strides==null?1:n.strides,t,"strides");this.padding=n.padding==null?"valid":n.padding;D$(this.padding);this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat;_$(this.dataFormat);this.activation=HN(n.activation);this.useBias=n.useBias==null?true:n.useBias;this.biasInitializer=jy(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.biasConstraint=Dk(n.biasConstraint);this.biasRegularizer=ZN(n.biasRegularizer);this.activityRegularizer=ZN(n.activityRegularizer);this.dilationRate=rR(n.dilationRate==null?1:n.dilationRate,t,"dilationRate");if(this.rank===1&&(Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)){throw new Qv(`dilationRate must be a number or an array of a single number `+`for 1D convolution, but received `+`${JSON.stringify(this.dilationRate)}`)}else if(this.rank===2){if(typeof this.dilationRate==="number"){this.dilationRate=[this.dilationRate,this.dilationRate]}else if(this.dilationRate.length!==2){throw new Qv(`dilationRate must be a number or array of two numbers for 2D `+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}}else if(this.rank===3){if(typeof this.dilationRate==="number"){this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate]}else if(this.dilationRate.length!==3){throw new Qv(`dilationRate must be a number or array of three numbers for 3D `+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}}}static verifyArgs(t){o$("kernelSize"in t,`required key 'kernelSize' not in config`);if(typeof t.kernelSize!=="number"&&!w$(t.kernelSize,"number",1,3)){throw new Qv(`BaseConv expects config.kernelSize to be number or number[] with `+`length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:GN(this.activation),useBias:this.useBias,biasInitializer:Hy(this.biasInitializer),biasRegularizer:JN(this.biasRegularizer),activityRegularizer:JN(this.activityRegularizer),biasConstraint:_k(this.biasConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}class pR extends dR{constructor(t,n){super(t,n);this.kernel=null;pR.verifyArgs(n);this.filters=n.filters;v$(this.filters,"filters");this.kernelInitializer=jy(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.kernelConstraint=Dk(n.kernelConstraint);this.kernelRegularizer=ZN(n.kernelRegularizer)}build(t){t=Jy(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new Qv(`The channel dimension of the input should be defined. `+`Found ${t[n]}`)}const e=t[n];const s=this.kernelSize.concat([e,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[{ndim:this.rank+2,axes:{[n]:e}}];this.built=true}call(t,n){return kc((()=>{t=Ky(t);let n;const e=this.bias==null?null:this.bias.read();const s=k$(this.activation.getClassName());if(s!=null&&this.rank===2){n=fR(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate,s)}else{if(this.rank===1){n=lR(t,this.kernel.read(),e,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0])}else if(this.rank===2){n=fR(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate)}else if(this.rank===3){n=hR(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate)}else{throw new t$("convolutions greater than 3D are not implemented yet.")}if(this.activation!=null){n=this.activation.apply(n)}}return n}))}computeOutputShape(t){t=Jy(t);const n=[];const e=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<e.length;++t){const s=iR(e[t],this.kernelSize[t],this.padding,this.strides[t],typeof this.dilationRate==="number"?this.dilationRate:this.dilationRate[t]);n.push(s)}let s=[t[0]];if(this.dataFormat==="channelsLast"){s=s.concat(n);s.push(this.filters)}else{s.push(this.filters);s=s.concat(n)}return s}getConfig(){const t={filters:this.filters,kernelInitializer:Hy(this.kernelInitializer),kernelRegularizer:JN(this.kernelRegularizer),kernelConstraint:_k(this.kernelConstraint)};const n=super.getConfig();Object.assign(t,n);return t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!=="number"||t.filters<1){throw new Qv(`Convolution layer expected config.filters to be a 'number' > 0 `+`but got ${JSON.stringify(t.filters)}`)}}}class mR extends pR{constructor(t){super(2,t);mR.verifyArgs(t)}getConfig(){const t=super.getConfig();delete t["rank"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"&&!w$(t.kernelSize,"number",1,2)){throw new Qv(`Conv2D expects config.kernelSize to be number or number[] with `+`length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}}mR.className="Conv2D";Kx(mR);class xR extends pR{constructor(t){super(3,t);xR.verifyArgs(t)}getConfig(){const t=super.getConfig();delete t["rank"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"){if(!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3))){throw new Qv(`Conv3D expects config.kernelSize to be number or`+` [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}}}xR.className="Conv3D";Kx(xR);class bR extends mR{constructor(t){super(t);this.inputSpec=[new sk({ndim:4})];if(this.padding!=="same"&&this.padding!=="valid"){throw new Qv(`Conv2DTranspose currently supports only padding modes 'same' `+`and 'valid', but received padding mode ${this.padding}`)}}build(t){t=Jy(t);if(t.length!==4){throw new Qv("Input should have rank 4; Received input shape: "+JSON.stringify(t))}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new Qv("The channel dimension of the inputs should be defined. "+"Found `None`.")}const e=t[n];const s=this.kernelSize.concat([this.filters,e]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[new sk({ndim:4,axes:{[n]:e}})];this.built=true}call(t,n){return kc((()=>{let n=Ky(t);if(n.shape.length!==4){throw new Qv(`Conv2DTranspose.call() expects input tensor to be rank-4, but `+`received a tensor of rank-${n.shape.length}`)}const e=n.shape;const s=e[0];let o;let r;if(this.dataFormat==="channelsFirst"){o=2;r=3}else{o=1;r=2}const i=e[o];const c=e[r];const a=this.kernelSize[0];const u=this.kernelSize[1];const l=this.strides[0];const f=this.strides[1];const h=cR(i,l,a,this.padding);const d=cR(c,f,u,this.padding);const p=[s,h,d,this.filters];if(this.dataFormat!=="channelsLast"){n=Tm(n,[0,2,3,1])}let m=gl(n,this.kernel.read(),p,this.strides,this.padding);if(this.dataFormat!=="channelsLast"){m=Tm(m,[0,3,1,2])}if(this.bias!=null){m=xy(m,this.bias.read(),this.dataFormat)}if(this.activation!=null){m=this.activation.apply(m)}return m}))}computeOutputShape(t){t=Jy(t);const n=t.slice();let e;let s;let o;if(this.dataFormat==="channelsFirst"){e=1;s=2;o=3}else{e=3;s=1;o=2}const r=this.kernelSize[0];const i=this.kernelSize[1];const c=this.strides[0];const a=this.strides[1];n[e]=this.filters;n[s]=cR(n[s],c,r,this.padding);n[o]=cR(n[o],a,i,this.padding);return n}getConfig(){const t=super.getConfig();delete t["dilationRate"];return t}}bR.className="Conv2DTranspose";Kx(bR);class gR extends xR{constructor(t){super(t);this.inputSpec=[new sk({ndim:5})];if(this.padding!=="same"&&this.padding!=="valid"){throw new Qv(`Conv3DTranspose currently supports only padding modes 'same' `+`and 'valid', but received padding mode ${this.padding}`)}}build(t){t=Jy(t);if(t.length!==5){throw new Qv("Input should have rank 5; Received input shape: "+JSON.stringify(t))}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new Qv("The channel dimension of the inputs should be defined. "+"Found `None`.")}const e=t[n];const s=this.kernelSize.concat([this.filters,e]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[new sk({ndim:5,axes:{[n]:e}})];this.built=true}call(t,n){return kc((()=>{let n=Ky(t);if(n.shape.length!==5){throw new Qv(`Conv3DTranspose.call() expects input tensor to be rank-4, but `+`received a tensor of rank-${n.shape.length}`)}const e=n.shape;const s=e[0];let o;let r;let i;if(this.dataFormat==="channelsFirst"){i=2;o=3;r=4}else{i=1;o=2;r=3}const c=e[i];const a=e[o];const u=e[r];const l=this.kernelSize[0];const f=this.kernelSize[1];const h=this.kernelSize[2];const d=this.strides[0];const p=this.strides[1];const m=this.strides[2];const x=cR(c,d,l,this.padding);const b=cR(a,p,f,this.padding);const g=cR(u,m,h,this.padding);const w=[s,x,b,g,this.filters];if(this.dataFormat!=="channelsLast"){n=Tm(n,[0,2,3,4,1])}let v=Cl(n,this.kernel.read(),w,this.strides,this.padding);if(this.dataFormat!=="channelsLast"){v=Tm(v,[0,4,1,2,3])}if(this.bias!==null){v=xy(v,this.bias.read(),this.dataFormat)}if(this.activation!==null){v=this.activation.apply(v)}return v}))}computeOutputShape(t){t=Jy(t);const n=t.slice();let e;let s;let o;let r;if(this.dataFormat==="channelsFirst"){e=1;s=2;o=3;r=4}else{e=4;s=1;o=2;r=3}const i=this.kernelSize[0];const c=this.kernelSize[1];const a=this.kernelSize[2];const u=this.strides[0];const l=this.strides[1];const f=this.strides[2];n[e]=this.filters;n[s]=cR(n[s],u,i,this.padding);n[o]=cR(n[o],l,c,this.padding);n[r]=cR(n[r],f,a,this.padding);return n}getConfig(){const t=super.getConfig();delete t["dilationRate"];return t}}gR.className="Conv3DTranspose";Kx(gR);class wR extends pR{constructor(t,n){super(t,n);this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";this.depthwiseKernel=null;this.pointwiseKernel=null;if(n.filters==null){throw new Qv("The `filters` configuration field is required by SeparableConv, "+"but is unspecified.")}if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null){throw new Qv("Fields kernelInitializer, kernelRegularizer and kernelConstraint "+"are invalid for SeparableConv2D. Use depthwiseInitializer, "+"depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, "+"pointwiseRegularizer and pointwiseConstraint instead.")}if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid"){throw new Qv(`SeparableConv${this.rank}D supports only padding modes: `+`'same' and 'valid', but received ${JSON.stringify(n.padding)}`)}this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier;this.depthwiseInitializer=jy(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER);this.depthwiseRegularizer=ZN(n.depthwiseRegularizer);this.depthwiseConstraint=Dk(n.depthwiseConstraint);this.pointwiseInitializer=jy(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER);this.pointwiseRegularizer=ZN(n.pointwiseRegularizer);this.pointwiseConstraint=Dk(n.pointwiseConstraint)}build(t){t=Jy(t);if(t.length<this.rank+2){throw new Qv(`Inputs to SeparableConv${this.rank}D should have rank `+`${this.rank+2}, but received input shape: `+`${JSON.stringify(t)}`)}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0){throw new Qv(`The channel dimension of the inputs should be defined, `+`but found ${JSON.stringify(t[n])}`)}const e=t[n];const s=this.kernelSize.concat([e,this.depthMultiplier]);const o=[];for(let t=0;t<this.rank;++t){o.push(1)}o.push(e*this.depthMultiplier,this.filters);const r=true;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint);this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint)}else{this.bias=null}this.inputSpec=[new sk({ndim:this.rank+2,axes:{[n]:e}})];this.built=true}call(t,n){return kc((()=>{t=Ky(t);let n;if(this.rank===1){throw new t$("1D separable convolution is not implemented yet.")}else if(this.rank===2){if(this.dataFormat==="channelsFirst"){t=Tm(t,[0,2,3,1])}n=Rp(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")}if(this.useBias){n=xy(n,this.bias.read(),this.dataFormat)}if(this.activation!=null){n=this.activation.apply(n)}if(this.dataFormat==="channelsFirst"){n=Tm(n,[0,3,1,2])}return n}))}getConfig(){const t=super.getConfig();delete t["rank"];delete t["kernelInitializer"];delete t["kernelRegularizer"];delete t["kernelConstraint"];t["depthwiseInitializer"]=Hy(this.depthwiseInitializer);t["pointwiseInitializer"]=Hy(this.pointwiseInitializer);t["depthwiseRegularizer"]=JN(this.depthwiseRegularizer);t["pointwiseRegularizer"]=JN(this.pointwiseRegularizer);t["depthwiseConstraint"]=_k(this.depthwiseConstraint);t["pointwiseConstraint"]=_k(this.pointwiseConstraint);return t}}wR.className="SeparableConv";class vR extends wR{constructor(t){super(2,t)}}vR.className="SeparableConv2D";Kx(vR);class $R extends pR{constructor(t){super(1,t);$R.verifyArgs(t);this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();delete t["rank"];delete t["dataFormat"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"&&!w$(t.kernelSize,"number",1,1)){throw new Qv(`Conv1D expects config.kernelSize to be number or number[] with `+`length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}}$R.className="Conv1D";Kx($R);class yR extends ak{constructor(t){super(t);if(typeof t.cropping==="number"){this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]}else if(typeof t.cropping[0]==="number"){this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]}else{this.cropping=t.cropping}this.dataFormat=t.dataFormat===undefined?"channelsLast":t.dataFormat;this.inputSpec=[{ndim:4}]}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){return[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]}else{return[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}}call(t,n){return kc((()=>{t=Ky(t);if(this.dataFormat==="channelsLast"){const n=cy(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return cy(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const n=cy(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return cy(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}yR.className="Cropping2D";Kx(yR);class kR extends ak{constructor(t){super(t);this.DEFAULT_SIZE=[2,2];this.inputSpec=[{ndim:4}];this.size=t.size==null?this.DEFAULT_SIZE:t.size;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;_$(this.dataFormat);this.interpolation=t.interpolation==null?"nearest":t.interpolation;M$(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2];const e=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,e]}else{const n=t[1]==null?null:this.size[0]*t[1];const e=t[2]==null?null:this.size[1]*t[2];return[t[0],n,e,t[3]]}}call(t,n){return kc((()=>{let n=Ky(t);const e=n.shape;if(this.dataFormat==="channelsFirst"){n=Tm(n,[0,2,3,1]);const t=this.size[0]*e[2];const s=this.size[1]*e[3];const o=this.interpolation==="nearest"?Gx.resizeNearestNeighbor(n,[t,s]):Gx.resizeBilinear(n,[t,s]);return Tm(o,[0,3,1,2])}else{const t=this.size[0]*e[1];const s=this.size[1]*e[2];return this.interpolation==="nearest"?Gx.resizeNearestNeighbor(n,[t,s]):Gx.resizeBilinear(n,[t,s])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation};const n=super.getConfig();Object.assign(t,n);return t}}kR.className="UpSampling2D";Kx(kR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CR(t,n,e=[1,1],s="valid",o,r){return kc((()=>{if(o==null){o=Q$()}_$(o);let i=aR(t,o);if(t.rank!==4){throw new Qv(`Input for depthwiseConv2d is required to be 4-D, but is instead `+`${t.rank}-D`)}if(n.rank!==4){throw new Qv(`depthwiseKernel is required to be 4-D, but is instead `+`${n.rank}-D`)}i=zl(i,n,e,s==="same"?"same":"valid","NHWC",r);if(o==="channelsFirst"){i=Tm(i,[0,3,1,2])}return i}))}class NR extends dR{constructor(t){super(2,t);this.depthwiseKernel=null;this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier;this.depthwiseInitializer=jy(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.depthwiseConstraint=Dk(t.depthwiseConstraint);this.depthwiseRegularizer=ZN(t.depthwiseRegularizer)}build(t){t=Jy(t);if(t.length<4){throw new Qv(`Inputs to DepthwiseConv2D should have rank 4. `+`Received input shape: ${JSON.stringify(t)}.`)}const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0){throw new Qv("The channel dimension of the inputs to DepthwiseConv2D should "+`be defined, but is not (${t[n]}).`)}const e=t[n];const s=[this.kernelSize[0],this.kernelSize[1],e,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,true,this.depthwiseConstraint);if(this.useBias){this.bias=this.addWeight("bias",[e*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return kc((()=>{t=Ky(t);let n=CR(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);if(this.useBias){n=xy(n,this.bias.read(),this.dataFormat)}if(this.activation!=null){n=this.activation.apply(n)}return n}))}computeOutputShape(t){t=Jy(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1];const e=this.dataFormat==="channelsFirst"?t[3]:t[2];const s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier;const o=iR(n,this.kernelSize[0],this.padding,this.strides[0]);const r=iR(e,this.kernelSize[1],this.padding,this.strides[1]);if(this.dataFormat==="channelsFirst"){return[t[0],s,o,r]}else{return[t[0],o,r,s]}}getConfig(){const t=super.getConfig();t["depthMultiplier"]=this.depthMultiplier;t["depthwiseInitializer"]=Hy(this.depthwiseInitializer);t["depthwiseRegularizer"]=JN(this.depthwiseRegularizer);t["depthwiseConstraint"]=_k(this.depthwiseRegularizer);return t}}NR.className="DepthwiseConv2D";Kx(NR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function RR(t,n,e,s){if(Array.isArray(t)){if(n!=null||e!=null){throw new Qv("When inputs is an array, neither initialState or constants "+"should be provided")}if(s!=null){e=t.slice(t.length-s,t.length);t=t.slice(0,t.length-s)}if(t.length>1){n=t.slice(1,t.length)}t=t[0]}function o(t){if(t==null||Array.isArray(t)){return t}else{return[t]}}n=o(n);e=o(e);return{inputs:t,initialState:n,constants:e}}function SR(t,n,e,s=false,o,r,i=false,c=false){return kc((()=>{const r=n.shape.length;if(r<3){throw new Qv(`Input should be at least 3D, but is ${r}D.`)}const a=[1,0].concat(J$(2,r));n=Tm(n,a);if(i){console.warn("Backend rnn(): the unroll = true option is not applicable to the "+"imperative deeplearn.js backend.")}if(o!=null){o=wa(wa(o,"bool"),"float32");if(o.rank===r-1){o=Df(o,-1)}o=Tm(o,a)}if(s){n=gp(n,0);if(o!=null){o=gp(o,0)}}const u=[];let l;let f=e;const h=n.shape[0];const d=Nm(n);let p;if(o!=null){p=Nm(o)}for(let n=0;n<h;++n){const e=d[n];const s=kc((()=>t(e,f)));if(o==null){l=s[0];f=s[1]}else{const t=kc((()=>{const t=p[n];const e=Rh(ad(t),t);const o=Na(Aa(s[0],t),Aa(f[0],e));const r=f.map(((n,o)=>Na(Aa(s[1][o],t),Aa(n,e))));return{output:o,newStates:r}}));l=t.output;f=t.newStates}if(c){u.push(l)}}let m;if(c){const t=1;m=om(u,t)}return[l,m,f]}))}class ER extends ak{constructor(t){super(t);let n;if(t.cell==null){throw new Qv("cell property is missing for the constructor of RNN.")}else if(Array.isArray(t.cell)){n=new DR({cells:t.cell})}else{n=t.cell}if(n.stateSize==null){throw new Qv("The RNN cell should have an attribute `stateSize` (tuple of "+"integers, one integer per RNN state).")}this.cell=n;this.returnSequences=t.returnSequences==null?false:t.returnSequences;this.returnState=t.returnState==null?false:t.returnState;this.goBackwards=t.goBackwards==null?false:t.goBackwards;this._stateful=t.stateful==null?false:t.stateful;this.unroll=t.unroll==null?false:t.unroll;this.supportsMasking=true;this.inputSpec=[new sk({ndim:3})];this.stateSpec=null;this.states_=null;this.numConstants=null;this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return J$(0,t).map((t=>null))}else{return this.states_}}setStates(t){this.states_=t}computeOutputShape(t){if(qy(t)){t=t[0]}t=t;let n=this.cell.stateSize;if(!Array.isArray(n)){n=[n]}const e=n[0];let s;if(this.returnSequences){s=[t[0],t[1],e]}else{s=[t[0],e]}if(this.returnState){const e=[];for(const s of n){e.push([t[0],s])}return[s].concat(e)}else{return s}}computeMask(t,n){return kc((()=>{if(Array.isArray(n)){n=n[0]}const t=this.returnSequences?n:null;if(this.returnState){const n=this.states.map((t=>null));return[t].concat(n)}else{return t}}))}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;const n=[];for(let e=0;e<t;++e){n.push(null)}return n}else{return this.states_}}set states(t){this.states_=t}build(t){if(this.numConstants!=null){throw new t$("Constants support is not implemented in RNN yet.")}if(qy(t)){t=t[0]}t=t;const n=this.stateful?t[0]:null;const e=t.slice(2);this.inputSpec[0]=new sk({shape:[n,null,...e]});const s=[t[0]].concat(t.slice(2));{this.cell.build(s)}let o;if(Array.isArray(this.cell.stateSize)){o=this.cell.stateSize}else{o=[this.cell.stateSize]}if(this.stateSpec!=null){if(!v(this.stateSpec.map((t=>t.shape[t.shape.length-1])),o)){throw new Qv(`An initialState was passed that is not compatible with `+`cell.stateSize. Received stateSpec=${this.stateSpec}; `+`However cell.stateSize is ${this.cell.stateSize}`)}}else{this.stateSpec=o.map((t=>new sk({shape:[null,t]})))}if(this.stateful){this.resetStates()}}resetStates(t,n=false){kc((()=>{if(!this.stateful){throw new Yv("Cannot call resetStates() on an RNN Layer that is not stateful.")}const e=this.inputSpec[0].shape[0];if(e==null){throw new Qv("If an RNN is stateful, it needs to know its batch size. Specify "+"the batch size of your input tensors: \n"+"- If using a Sequential model, specify the batch size by "+"passing a `batchInputShape` option to your first layer.\n"+"- If using the functional API, specify the batch size by "+"passing a `batchShape` option to your Input layer.")}if(this.states_==null){if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((t=>qh([e,t])))}else{this.states_=[qh([e,this.cell.stateSize])]}}else if(t==null){Cc(this.states_);if(this.keptStates!=null){Cc(this.keptStates);this.keptStates=[]}if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((t=>qh([e,t])))}else{this.states_[0]=qh([e,this.cell.stateSize])}}else{if(!Array.isArray(t)){t=[t]}if(t.length!==this.states_.length){throw new Qv(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${t.length} state value(s). Input `+`received: ${t}`)}if(n===true){this.keptStates.push(this.states_.slice())}else{Cc(this.states_)}for(let n=0;n<this.states_.length;++n){const s=t[n];const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[n]:this.cell.stateSize;const r=[e,o];if(!v(s.shape,r)){throw new Qv(`State ${n} is incompatible with layer ${this.name}: `+`expected shape=${r}, received shape=${s.shape}`)}this.states_[n]=s}}this.states_=this.states_.map((t=>Nc(t.clone())))}))}apply(t,n){let e=n==null?null:n["initialState"];let s=n==null?null:n["constants"];if(n==null){n={}}const o=RR(t,e,s,this.numConstants);t=o.inputs;e=o.initialState;s=o.constants;let r=[];let i=[];if(e!=null){n["initialState"]=e;r=r.concat(e);this.stateSpec=[];for(const t of e){this.stateSpec.push(new sk({shape:t.shape}))}i=i.concat(this.stateSpec)}if(s!=null){n["constants"]=s;r=r.concat(s);this.numConstants=s.length}const c=r[0]instanceof ok;if(c){const e=[t].concat(r);const s=this.inputSpec.concat(i);const o=this.inputSpec;this.inputSpec=s;const c=super.apply(e,n);this.inputSpec=o;return c}else{return super.apply(t,n)}}call(t,n){return kc((()=>{const e=n==null?null:n["mask"];const s=n==null?null:n["training"];let o=n==null?null:n["initialState"];t=Ky(t);if(o==null){if(this.stateful){o=this.states_}else{o=this.getInitialState(t)}}const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==r){throw new Qv(`RNN Layer has ${r} state(s) but was passed `+`${o.length} initial state(s).`)}if(this.unroll){console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.")}const i={training:s};const c=(t,n)=>{const e=this.cell.call([t].concat(n),i);return[e[0],e.slice(1)]};const a=SR(c,t,o,this.goBackwards,e,null,this.unroll,this.returnSequences);const u=a[0];const l=a[1];const f=a[2];if(this.stateful){this.resetStates(f,s)}const h=this.returnSequences?l:u;if(this.returnState){return[h].concat(f)}else{return h}}))}getInitialState(t){return kc((()=>{let n=qh(t.shape);n=Sf(n,[1,2]);n=ny(n);if(Array.isArray(this.cell.stateSize)){return this.cell.stateSize.map((t=>t>1?ly(n,[1,t]):n))}else{return this.cell.stateSize>1?[ly(n,[1,this.cell.stateSize])]:[n]}}))}get trainableWeights(){if(!this.trainable){return[]}return this.cell.trainableWeights}get nonTrainableWeights(){if(!this.trainable){return this.cell.weights}return this.cell.nonTrainableWeights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.cell!=null){this.cell.setFastWeightInitDuringBuild(t)}}getConfig(){const t=super.getConfig();const n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};if(this.numConstants!=null){n["numConstants"]=this.numConstants}const e=this.cell.getConfig();if(this.getClassName()===ER.className){n["cell"]={className:this.cell.getClassName(),config:e}}return Object.assign(Object.assign(Object.assign({},e),t),n)}static fromConfig(t,n,e={}){const s=n["cell"];const o=Kk(s,e);return new t(Object.assign(n,{cell:o}))}}ER.className="RNN";Kx(ER);class TR extends ak{}class IR extends TR{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=t.units;v$(this.units,`units`);this.activation=HN(t.activation==null?this.DEFAULT_ACTIVATION:t.activation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=jy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=jy(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=jy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelRegularizer=ZN(t.kernelRegularizer);this.recurrentRegularizer=ZN(t.recurrentRegularizer);this.biasRegularizer=ZN(t.biasRegularizer);this.kernelConstraint=Dk(t.kernelConstraint);this.recurrentConstraint=Dk(t.recurrentConstraint);this.biasConstraint=Dk(t.biasConstraint);this.dropout=X$([1,K$([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=X$([1,K$([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.stateSize=this.units;this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){t=Jy(t);this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return kc((()=>{t=t;if(t.length!==2){throw new Qv(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`)}let e=t[1];t=t[0];const s=n["training"]==null?false:n["training"];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=LR({ones:()=>ad(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=LR({ones:()=>ad(e),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc})}let o;const r=this.dropoutMask;const i=this.recurrentDropoutMask;if(r!=null){o=hy(Aa(t,r),this.kernel.read())}else{o=hy(t,this.kernel.read())}if(this.bias!=null){o=xy(o,this.bias.read())}if(i!=null){e=Aa(e,i)}let c=Na(o,hy(e,this.recurrentKernel.read()));if(this.activation!=null){c=this.activation.apply(c)}return[c,c]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:GN(this.activation),useBias:this.useBias,kernelInitializer:Hy(this.kernelInitializer),recurrentInitializer:Hy(this.recurrentInitializer),biasInitializer:Hy(this.biasInitializer),kernelRegularizer:JN(this.kernelRegularizer),recurrentRegularizer:JN(this.recurrentRegularizer),biasRegularizer:JN(this.biasRegularizer),activityRegularizer:JN(this.activityRegularizer),kernelConstraint:_k(this.kernelConstraint),recurrentConstraint:_k(this.recurrentConstraint),biasConstraint:_k(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}IR.className="SimpleRNNCell";Kx(IR);class AR extends ER{constructor(t){t.cell=new IR(t);super(t)}call(t,n){return kc((()=>{if(this.cell.dropoutMask!=null){Cc(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Cc(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){return new t(n)}}AR.className="SimpleRNN";Kx(AR);class OR extends TR{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(t.resetAfter){throw new Qv(`GRUCell does not support reset_after parameter set to true.`)}this.units=t.units;v$(this.units,"units");this.activation=HN(t.activation===undefined?this.DEFAULT_ACTIVATION:t.activation);this.recurrentActivation=HN(t.recurrentActivation===undefined?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=jy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=jy(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=jy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelRegularizer=ZN(t.kernelRegularizer);this.recurrentRegularizer=ZN(t.recurrentRegularizer);this.biasRegularizer=ZN(t.biasRegularizer);this.kernelConstraint=Dk(t.kernelConstraint);this.recurrentConstraint=Dk(t.recurrentConstraint);this.biasConstraint=Dk(t.biasConstraint);this.dropout=X$([1,K$([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=X$([1,K$([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.implementation=t.implementation;this.stateSize=this.units;this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){t=Jy(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return kc((()=>{t=t;if(t.length!==2){throw new Qv(`GRUCell expects 2 input Tensors (inputs, h, c), got `+`${t.length}.`)}const e=n["training"]==null?false:n["training"];let s=t[1];t=t[0];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=LR({ones:()=>ad(t),rate:this.dropout,training:e,count:3,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=LR({ones:()=>ad(s),rate:this.recurrentDropout,training:e,count:3,dropoutFunc:this.dropoutFunc})}const o=this.dropoutMask;const r=this.recurrentDropoutMask;let i;let c;let a;if(0<this.dropout&&this.dropout<1){t=Aa(t,o[0])}let u=hy(t,this.kernel.read());if(this.useBias){u=xy(u,this.bias.read())}if(0<this.recurrentDropout&&this.recurrentDropout<1){s=Aa(s,r[0])}const l=this.recurrentKernel.read();const[f,h]=Jp(l,[2*this.units,this.units],l.rank-1);const d=hy(s,f);const[p,m,x]=Jp(u,3,u.rank-1);const[b,g]=Jp(d,2,d.rank-1);i=this.recurrentActivation.apply(Na(p,b));c=this.recurrentActivation.apply(Na(m,g));const w=hy(Aa(c,s),h);a=this.activation.apply(Na(x,w));const v=Na(Aa(i,s),Aa(Na(1,vh(i)),a));return[v,v]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:GN(this.activation),recurrentActivation:GN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Hy(this.kernelInitializer),recurrentInitializer:Hy(this.recurrentInitializer),biasInitializer:Hy(this.biasInitializer),kernelRegularizer:JN(this.kernelRegularizer),recurrentRegularizer:JN(this.recurrentRegularizer),biasRegularizer:JN(this.biasRegularizer),activityRegularizer:JN(this.activityRegularizer),kernelConstraint:_k(this.kernelConstraint),recurrentConstraint:_k(this.recurrentConstraint),biasConstraint:_k(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:false};return Object.assign(Object.assign({},t),n)}}OR.className="GRUCell";Kx(OR);class FR extends ER{constructor(t){if(t.implementation===0){console.warn("`implementation=0` has been deprecated, and now defaults to "+"`implementation=1`. Please update your layer call.")}t.cell=new OR(t);super(t)}call(t,n){return kc((()=>{if(this.cell.dropoutMask!=null){Cc(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Cc(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){if(n["implmentation"]===0){n["implementation"]=1}return new t(n)}}FR.className="GRU";Kx(FR);class _R extends TR{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=t.units;v$(this.units,"units");this.activation=HN(t.activation===undefined?this.DEFAULT_ACTIVATION:t.activation);this.recurrentActivation=HN(t.recurrentActivation===undefined?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=jy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=jy(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=jy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.unitForgetBias=t.unitForgetBias;this.kernelRegularizer=ZN(t.kernelRegularizer);this.recurrentRegularizer=ZN(t.recurrentRegularizer);this.biasRegularizer=ZN(t.biasRegularizer);this.kernelConstraint=Dk(t.kernelConstraint);this.recurrentConstraint=Dk(t.recurrentConstraint);this.biasConstraint=Dk(t.biasConstraint);this.dropout=X$([1,K$([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=X$([1,K$([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.implementation=t.implementation;this.stateSize=[this.units,this.units];this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){var n;t=Jy(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const t=this.biasInitializer;const e=this.units;s=new(n=class n extends Ry{apply(n,s){const o=t.apply([e]);const r=(new Ey).apply([e]);const i=t.apply([e*2]);return uy(uy(o,r),i)}},n.className="CustomInit",n)}else{s=this.biasInitializer}this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return kc((()=>{const e=n["training"]==null?false:n["training"];t=t;if(t.length!==3){throw new Qv(`LSTMCell expects 3 input Tensors (inputs, h, c), got `+`${t.length}.`)}let s=t[1];const o=t[2];t=t[0];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=LR({ones:()=>ad(t),rate:this.dropout,training:e,count:4,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=LR({ones:()=>ad(s),rate:this.recurrentDropout,training:e,count:4,dropoutFunc:this.dropoutFunc})}const r=this.dropoutMask;const i=this.recurrentDropoutMask;let c;let a;let u;let l;if(0<this.dropout&&this.dropout<1){t=Aa(t,r[0])}let f=hy(t,this.kernel.read());if(0<this.recurrentDropout&&this.recurrentDropout<1){s=Aa(s,i[0])}f=Na(f,hy(s,this.recurrentKernel.read()));if(this.useBias){f=xy(f,this.bias.read())}const[h,d,p,m]=Jp(f,4,f.rank-1);c=this.recurrentActivation.apply(h);a=this.recurrentActivation.apply(d);u=Na(Aa(a,o),Aa(c,this.activation.apply(p)));l=this.recurrentActivation.apply(m);const x=Aa(l,this.activation.apply(u));return[x,x,u]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:GN(this.activation),recurrentActivation:GN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Hy(this.kernelInitializer),recurrentInitializer:Hy(this.recurrentInitializer),biasInitializer:Hy(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:JN(this.kernelRegularizer),recurrentRegularizer:JN(this.recurrentRegularizer),biasRegularizer:JN(this.biasRegularizer),activityRegularizer:JN(this.activityRegularizer),kernelConstraint:_k(this.kernelConstraint),recurrentConstraint:_k(this.recurrentConstraint),biasConstraint:_k(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}_R.className="LSTMCell";Kx(_R);class MR extends ER{constructor(t){if(t.implementation===0){console.warn("`implementation=0` has been deprecated, and now defaults to "+"`implementation=1`. Please update your layer call.")}t.cell=new _R(t);super(t)}call(t,n){return kc((()=>{if(this.cell.dropoutMask!=null){Cc(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Cc(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){if(n["implmentation"]===0){n["implementation"]=1}return new t(n)}}MR.className="LSTM";Kx(MR);class DR extends TR{constructor(t){super(t);this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse()){if(Array.isArray(n.stateSize)){t.push(...n.stateSize)}else{t.push(n.stateSize)}}return t}call(t,n){return kc((()=>{t=t;let e=t.slice(1);const s=[];for(const t of this.cells.slice().reverse()){if(Array.isArray(t.stateSize)){s.push(e.splice(0,t.stateSize.length))}else{s.push(e.splice(0,1))}}s.reverse();const o=[];let r;for(let i=0;i<this.cells.length;++i){const c=this.cells[i];e=s[i];if(i===0){r=[t[0]].concat(e)}else{r=[r[0]].concat(e)}r=c.call(r,n);o.push(r.slice(1))}e=[];for(const t of o.slice().reverse()){e.push(...t)}return[r[0]].concat(e)}))}build(t){if(qy(t)){t=t[0]}t=t;let n;this.cells.forEach(((e,s)=>{V$(`RNNCell_${s}`,(()=>{e.build(t);if(Array.isArray(e.stateSize)){n=e.stateSize[0]}else{n=e.stateSize}t=[t[0],n]}))}));this.built=true}getConfig(){const t=super.getConfig();const n=t=>({className:t.getClassName(),config:t.getConfig()});const e=this.cells.map(n);const s={cells:e};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,e={}){const s=[];for(const t of n["cells"]){s.push(Kk(t,e))}return new t({cells:s})}get trainableWeights(){if(!this.trainable){return[]}const t=[];for(const n of this.cells){t.push(...n.trainableWeights)}return t}get nonTrainableWeights(){const t=[];for(const n of this.cells){t.push(...n.nonTrainableWeights)}if(!this.trainable){const n=[];for(const t of this.cells){n.push(...t.trainableWeights)}return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells){t.push(...n.weights)}return nk(t)}setWeights(t){const n=[];for(const e of this.cells){const s=e.weights.length;const o=t.splice(s);for(let t=0;t<e.weights.length;++t){n.push([e.weights[t],o[t]])}}ek(n)}}DR.className="StackedRNNCells";Kx(DR);function LR(t){const{ones:n,rate:e,training:s=false,count:o=1,dropoutFunc:r}=t;const i=()=>r!=null?r(n(),e):wy(n(),e);const c=()=>$y(i,n,s);if(!o||o<=1){return Nc(c().clone())}const a=Array(o).fill(undefined).map(c);return a.map((t=>Nc(t.clone())))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var zR=undefined&&undefined.__rest||function(t,n){var e={};for(var s in t)if(Object.prototype.hasOwnProperty.call(t,s)&&n.indexOf(s)<0)e[s]=t[s];if(t!=null&&typeof Object.getOwnPropertySymbols==="function")for(var o=0,s=Object.getOwnPropertySymbols(t);o<s.length;o++){if(n.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(t,s[o]))e[s[o]]=t[s[o]]}return e};class PR extends ER{constructor(t){if(t.unroll){throw new t$("Unrolling is not possible with convolutional RNNs.")}if(Array.isArray(t.cell)){throw new t$("It is not possible at the moment to stack convolutional cells.")}super(t);this.inputSpec=[new sk({ndim:5})]}call(t,n){return kc((()=>{if(this.cell.dropoutMask!=null){Cc(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Cc(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}if(n&&n["constants"]){throw new Qv("ConvRNN2D cell does not support constants")}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}computeOutputShape(t){let n=this.computeSingleOutputShape(t);if(!this.returnSequences){n=[n[0],...n.slice(2)]}if(this.returnState){n=[n,...Array(2).fill([t[0],...n.slice(-3)])]}return n}getInitialState(t){return kc((()=>{const{stateSize:n}=this.cell;const e=t.shape;const s=this.computeSingleOutputShape(e);const o=[s[0],...s.slice(2)];const r=qh(o);if(Array.isArray(n)){return Array(n.length).fill(r)}return[r]}))}resetStates(t,n=false){kc((()=>{if(!this.stateful){throw new Yv("Cannot call resetStates() on an RNN Layer that is not stateful.")}const e=this.inputSpec[0].shape;const s=this.computeSingleOutputShape(e);const o=[s[0],...s.slice(2)];const r=e[0];if(r==null){throw new Qv("If an RNN is stateful, it needs to know its batch size. Specify "+"the batch size of your input tensors: \n"+"- If using a Sequential model, specify the batch size by "+"passing a `batchInputShape` option to your first layer.\n"+"- If using the functional API, specify the batch size by "+"passing a `batchShape` option to your Input layer.")}if(this.getStates()==null){if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((()=>qh(o)))}else{this.states_=[qh(o)]}}else if(t==null){Cc(this.states_);if(this.keptStates!=null){Cc(this.keptStates);this.keptStates=[]}if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((()=>qh(o)))}else{this.states_[0]=qh(o)}}else{if(!Array.isArray(t)){t=[t]}if(t.length!==this.states_.length){throw new Qv(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${t.length} state value(s). Input `+`received: ${t}`)}if(n){this.keptStates.push(this.states_.slice())}else{Cc(this.states_)}for(let n=0;n<this.states_.length;++n){const e=t[n];const s=o;if(!v(e.shape,s)){throw new Qv(`State ${n} is incompatible with layer ${this.name}: `+`expected shape=${s}, received shape=${e.shape}`)}this.states_[n]=e}}this.states_=this.states_.map((t=>Nc(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:n,filters:e,kernelSize:s,padding:o,strides:r,dilationRate:i}=this.cell;const c=n==="channelsFirst";const a=t[c?3:2];const u=t[c?4:3];const l=iR(a,s[0],o,r[0],i[0]);const f=iR(u,s[1],o,r[1],i[1]);const h=[...t.slice(0,2),...c?[e,l,f]:[l,f,e]];return h}}PR.className="ConvRNN2D";class VR extends _R{constructor(t){const{filters:n,kernelSize:e,strides:s,padding:o,dataFormat:r,dilationRate:i}=t;super(Object.assign(Object.assign({},t),{units:n}));this.filters=n;v$(this.filters,"filters");this.kernelSize=rR(e,2,"kernelSize");this.kernelSize.forEach((t=>v$(t,"kernelSize")));this.strides=rR(s||1,2,"strides");this.strides.forEach((t=>v$(t,"strides")));this.padding=o||"valid";D$(this.padding);this.dataFormat=r||"channelsLast";_$(this.dataFormat);this.dilationRate=rR(i||1,2,"dilationRate");this.dilationRate.forEach((t=>v$(t,"dilationRate")))}build(t){var n;t=Jy(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null){throw new Qv(`The channel dimension of the input should be defined. `+`Found ${t[e]}`)}const s=t[e];const o=4;const r=this.kernelSize.concat([s,this.filters*o]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*o]);this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){let t;if(this.unitForgetBias){const e=this.biasInitializer;const s=this.filters;t=new(n=class t extends Ry{apply(t,n){const o=e.apply([s]);const r=Xh([s]);const i=e.apply([s*2]);return ay([o,r,i])}},n.className="CustomInit",n)}else{t=this.biasInitializer}this.bias=this.addWeight("bias",[this.filters*o],null,t,this.biasRegularizer,true,this.biasConstraint)}this.built=true}call(t,n){return kc((()=>{if(t.length!==3){throw new Qv(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got `+`${t.length}.`)}const e=n["training"]||false;const s=t[0];const o=t[1];const r=t[2];const i=4;if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=LR({ones:()=>ad(s),rate:this.dropout,training:e,count:i,dropoutFunc:this.dropoutFunc})}const c=this.dropoutMask;const a=(t,n,e)=>{if(!n||!n[e]){return t}return Aa(n[e],t)};let u=a(s,c,0);let l=a(s,c,1);let f=a(s,c,2);let h=a(s,c,3);if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=LR({ones:()=>ad(o),rate:this.recurrentDropout,training:e,count:i,dropoutFunc:this.dropoutFunc})}const d=this.recurrentDropoutMask;let p=a(o,d,0);let m=a(o,d,1);let x=a(o,d,2);let b=a(o,d,3);const g=3;const[w,v,$,y]=Jp(this.kernel.read(),i,g);const[k,C,N,R]=this.useBias?Jp(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,w,k,this.padding);l=this.inputConv(l,v,C,this.padding);f=this.inputConv(f,$,N,this.padding);h=this.inputConv(h,y,R,this.padding);const[S,E,T,I]=Jp(this.recurrentKernel.read(),i,g);p=this.recurrentConv(p,S);m=this.recurrentConv(m,E);x=this.recurrentConv(x,T);b=this.recurrentConv(b,I);const A=this.recurrentActivation.apply(Na(u,p));const O=this.recurrentActivation.apply(Na(l,m));const F=Na(Aa(O,r),Aa(A,this.activation.apply(Na(f,x))));const _=Aa(this.recurrentActivation.apply(Na(h,b)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),n=zR(t,["units"]);const e={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),e)}inputConv(t,n,e,s){const o=hl(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);if(e){return xy(o,e,this.dataFormat)}return o}recurrentConv(t,n){const e=1;return hl(t,n,e,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}VR.className="ConvLSTM2DCell";Kx(VR);class BR extends PR{constructor(t){const n=new VR(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}BR.className="ConvLSTM2D";Kx(BR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class WR extends ak{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0);this.noiseShape=t.noiseShape;this.seed=t.seed;this.supportsMasking=true}getNoiseShape(t){if(this.noiseShape==null){return this.noiseShape}const n=t.shape;const e=[];for(let t=0;t<this.noiseShape.length;++t){e.push(this.noiseShape[t]==null?n[t]:this.noiseShape[t])}return e}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);if(0<this.rate&&this.rate<1){const t=n["training"]==null?false:n["training"];const s=this.getNoiseShape(e);const o=$y((()=>wy(e,this.rate,s,this.seed)),(()=>e),t);return o}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed};const n=super.getConfig();Object.assign(t,n);return t}dispose(){return super.dispose()}}WR.className="Dropout";Kx(WR);class GR extends WR{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}GR.className="SpatialDropout1D";Kx(GR);class UR extends ak{constructor(t){super(t);this.activation=null;this.useBias=true;this.kernel=null;this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;if(t.batchSize!=null){n=t.batchSize}this.batchInputShape=[n,t.inputDim]}this.units=t.units;v$(this.units,"units");this.activation=HN(t.activation);if(t.useBias!=null){this.useBias=t.useBias}this.kernelInitializer=jy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.biasInitializer=jy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelConstraint=Dk(t.kernelConstraint);this.biasConstraint=Dk(t.biasConstraint);this.kernelRegularizer=ZN(t.kernelRegularizer);this.biasRegularizer=ZN(t.biasRegularizer);this.activityRegularizer=ZN(t.activityRegularizer);this.supportsMasking=true;this.inputSpec=[{minNDim:2}]}build(t){t=Jy(t);const n=t[t.length-1];if(this.kernel==null){this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}}this.inputSpec=[{minNDim:2,axes:{[-1]:n}}];this.built=true}computeOutputShape(t){t=Jy(t);const n=t.slice();n[n.length-1]=this.units;return n}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);const s=k$(this.activation.getClassName());let o;if(s!=null){o=hy(e,this.kernel.read(),s,this.bias?this.bias.read():null)}else{o=hy(e,this.kernel.read());if(this.bias!=null){o=xy(o,this.bias.read())}if(this.activation!=null){o=this.activation.apply(o)}}return o}))}getConfig(){const t={units:this.units,activation:GN(this.activation),useBias:this.useBias,kernelInitializer:Hy(this.kernelInitializer),biasInitializer:Hy(this.biasInitializer),kernelRegularizer:JN(this.kernelRegularizer),biasRegularizer:JN(this.biasRegularizer),activityRegularizer:JN(this.activityRegularizer),kernelConstraint:_k(this.kernelConstraint),biasConstraint:_k(this.biasConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}UR.className="Dense";Kx(UR);class HR extends ak{constructor(t){t=t||{};super(t);this.inputSpec=[{minNDim:3}];this.dataFormat=t.dataFormat}computeOutputShape(t){t=Jy(t);for(const n of t.slice(1)){if(n==null){throw new Qv(`The shape of the input to "Flatten" is not fully defined `+`(got ${t.slice(1)}). Make sure to pass a complete `+`"input_shape" or "batch_input_shape" argument to the first `+`layer in your model.`)}}return[t[0],q$(t,1)]}call(t,n){return kc((()=>{this.invokeCallHook(t,n);let e=Ky(t);if(this.dataFormat==="channelsFirst"&&e.rank>1){const t=[0];for(let n=2;n<e.rank;++n){t.push(n)}t.push(1);e=Tm(e,t)}return oy(e)}))}getConfig(){const t={};if(this.dataFormat!=null){t["dataFormat"]=this.dataFormat}const n=super.getConfig();Object.assign(t,n);return t}}HR.className="Flatten";Kx(HR);class jR extends ak{constructor(t){super(t);this.supportsMasking=true;this.activation=HN(t.activation)}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);return this.activation.apply(e)}))}getConfig(){const t={activation:GN(this.activation)};const n=super.getConfig();Object.assign(t,n);return t}}jR.className="Activation";Kx(jR);class qR extends ak{constructor(t){super(t);this.n=t.n;this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return kc((()=>{t=Ky(t);return ey(t,this.n)}))}getConfig(){const t={n:this.n};const n=super.getConfig();Object.assign(t,n);return t}}qR.className="RepeatVector";Kx(qR);class XR extends ak{constructor(t){super(t);this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t){if(this.isUnknown(this.targetShape[t])){this.targetShape[t]=null}}}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const e="Total size of new array must be unchanged.";const s=n.slice();let o=1;let r=null;for(let t=0;t<s.length;++t){const n=s[t];if(this.isUnknown(n)){if(r===null){r=t}else{throw new Qv("Can only specifiy one unknown dimension.")}}else{o*=n}}const i=q$(t);if(r!==null){if(o===0||i%o!==0){throw new Qv(e)}s[r]=i/o}else if(i!==o){throw new Qv(e)}return s}computeOutputShape(t){let n=false;for(let e=0;e<t.length;++e){if(this.isUnknown(t[e])){n=true;break}}if(n){return t.slice(0,1).concat(this.targetShape)}else{return t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);const s=e.shape;const o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return yu(e,o)}))}getConfig(){const t={targetShape:this.targetShape};const n=super.getConfig();Object.assign(t,n);return t}}XR.className="Reshape";Kx(XR);class KR extends ak{constructor(t){super(t);if(t.dims==null){throw new Error("Required configuration field `dims` is missing during Permute "+"constructor call.")}if(!Array.isArray(t.dims)){throw new Error("Permute constructor requires `dims` to be an Array, but received "+`${t.dims} instead.`)}const n=J$(1,t.dims.length+1);if(!v(t.dims.slice().sort(),n)){throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.")}this.dims=t.dims;this.dimsIncludingBatch=[0].concat(this.dims);this.inputSpec=[new sk({ndim:this.dims.length+1})]}computeOutputShape(t){t=Jy(t);const n=t.slice();this.dims.forEach(((e,s)=>{n[s+1]=t[e]}));return n}call(t,n){return Tm(Ky(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims};const n=super.getConfig();Object.assign(t,n);return t}}KR.className="Permute";Kx(KR);class JR extends ak{constructor(t){super(t==null?{}:t);this.supportsMasking=true;if(t!=null){this.maskValue=t.maskValue==null?0:t.maskValue}else{this.maskValue=0}}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={maskValue:this.maskValue};Object.assign(n,t);return n}computeMask(t,n){const e=Ky(t);const s=-1;return Ba(od(e,this.maskValue),s)}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);const s=-1;const o=true;const r=Ba(od(e,this.maskValue),s,o);const i=Aa(e,wa(r,e.dtype));return i}))}}JR.className="Masking";Kx(JR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class YR extends ak{constructor(t){super(t);this.embeddings=null;this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";if(t.batchInputShape==null&&t.inputShape==null){let n=null;if(t.batchSize!=null){n=t.batchSize}if(t.inputLength==null){this.batchInputShape=[n,null]}else{this.batchInputShape=[n].concat(c$(t.inputLength))}}this.inputDim=t.inputDim;v$(this.inputDim,"inputDim");this.outputDim=t.outputDim;v$(this.outputDim,"outputDim");this.embeddingsInitializer=jy(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER);this.embeddingsRegularizer=ZN(t.embeddingsRegularizer);this.activityRegularizer=ZN(t.activityRegularizer);this.embeddingsConstraint=Dk(t.embeddingsConstraint);this.maskZero=t.maskZero;this.supportsMasking=t.maskZero;this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,true,this.embeddingsConstraint);this.built=true}warnOnIncompatibleInputShape(t){}computeMask(t,n){return kc((()=>{if(!this.maskZero){return null}else{t=Ky(t);return od(t,Kl(t))}}))}computeOutputShape(t){t=Jy(t);if(this.inputLength==null){return[...t,this.outputDim]}const n=c$(this.inputLength);if(n.length!==t.length-1){throw new Qv(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${t}`)}else{let e=0;for(let s=0;s<n.length;++s){const o=n[s];const r=t[s+1];if(o!=null&&r!=null&&o!==r){throw new Qv(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${t}`)}else if(o==null){n[e]=r}e++}}return[t[0],...n,this.outputDim]}call(t,n){return kc((()=>{this.invokeCallHook(t,n);let e=Ky(t);if(e.dtype!=="int32"){e=ty(e,"int32")}const s=dy(this.embeddings.read(),yu(e,[e.size]));return yu(s,Jy(this.computeOutputShape(e.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Hy(this.embeddingsInitializer),embeddingsRegularizer:JN(this.embeddingsRegularizer),activityRegularizer:JN(this.activityRegularizer),embeddingsConstraint:_k(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength};const n=super.getConfig();Object.assign(t,n);return t}}YR.className="Embedding";Kx(YR);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZR extends ak{constructor(t){super(t||{});this.supportsMasking=true}mergeFunction(t){throw new t$}computeElementwiseOpOutputShape(t,n){if(t==null||n==null){return null}else if(t.length<n.length){return this.computeElementwiseOpOutputShape(n,t)}else if(n.length===0){return t}const e=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const o=t[t.length-n.length+s];const r=n[s];if(o==null||r==null||o<0||r<0){e.push(null)}else if(o===1){e.push(r)}else if(r===1){e.push(o)}else{if(o!==r){throw new Qv("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n))}e.push(o)}}return e}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])){t=[Jy(t)]}t=t;if(t.length<2){throw new Qv("A merge layer should be called on an Array of at least 2 inputs."+` Got ${t.length} input(s).`)}let n=[];for(const e of t){if(e!=null&&e[0]!==null){n.push(e[0])}}n=x$(n);if(n.length>1){throw new Qv(`Can not merge tensors with different batch sizes. `+`Got tensors with shapes: ${JSON.stringify(t)}.`)}let e=t[0]==null?null:t[0].slice(1);for(let n=1;n<t.length;++n){const s=t[n]==null?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}const s=t.map((t=>t.length));if(t.indexOf(null)===-1&&x$(s).length===1){this.reshapeRequired=false}else{this.reshapeRequired=true}}call(t,n){return kc((()=>{t=t;if(this.reshapeRequired){const n=[];const e=t.map((t=>t.rank));if(e.indexOf(null)===-1){const s=K$(e);for(let e of t){const t=e.rank;for(let n=0;n<s-t;++n){e=ny(e,1)}n.push(e)}return this.mergeFunction(n)}else{let e=false;for(const s of t){const t=s.rank;if(t==null){const t=s.shape;const o=t[0];const r=t.slice(1).concat([o]);let i=yu(s,[o].concat(q$(t.slice(1))));i=Tm(i,[1,0]);i=yu(i,r);n.push(i);e=true}else if(t>1){const o=J$(1,t).concat([0]);n.push(Tm(s,o));e=true}else{n.push(s)}}let s=this.mergeFunction(n);const o=s.rank;if(e){if(o==null){const t=s.shape;const n=t.length;const e=t[n-1];const o=[e].concat(t.slice(0,t.length-1));s=yu(Tm(yu(s,[-1,e]),[1,0]),o)}else if(o>1){const t=[o-1].concat(J$(0,o-1));s=Tm(s,t)}}return s}}else{return this.mergeFunction(t)}}))}computeOutputShape(t){t=t;let n;if(t[0]==null){n=null}else{n=t[0].slice(1)}for(let e=1;e<t.length;++e){const s=t[e]==null?null:t[e].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let e=[];for(const n of t){if(n!=null&&n[0]!==null){e.push(n[0])}}e=x$(e);if(e.length===1){n=e.concat(n)}else{n=[null].concat(n)}return n}computeMask(t,n){return kc((()=>{if(n==null){return null}if(!Array.isArray(n)){throw new Qv("`mask` should be an Array")}if(!Array.isArray(t)){throw new Qv("`inputs` should be an Array")}if(n.length!==t.length){throw new Qv(`The Array 'inputs' and 'mask' are expected to have the same `+`length, but have different lengths `+`(${t.length} vs ${n.length})`)}if(n.every((t=>t==null))){return null}n=n.map((t=>t==null?t:Df(t,0)));let e=n[0];for(let t=1;t<n.length-1;++t){e=Oh(e,n[t])}return e}))}}class QR extends ZR{constructor(t){super(t)}mergeFunction(t){return kc((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=Na(n,t[e])}return n}))}}QR.className="Add";Kx(QR);class tS extends ZR{constructor(t){super(t)}mergeFunction(t){return kc((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=Aa(n,t[e])}return n}))}}tS.className="Multiply";Kx(tS);class nS extends ZR{constructor(t){super(t)}mergeFunction(t){return kc((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=Na(n,t[e])}return Aa(1/t.length,n)}))}}nS.className="Average";Kx(nS);class eS extends ZR{constructor(t){super(t)}mergeFunction(t){return kc((()=>{let n=t[0];for(let e=1;e<t.length;++e){n=Uh(n,t[e])}return n}))}}eS.className="Maximum";Kx(eS);class sS extends ZR{constructor(t){super(t)}mergeFunction(t){return kc((()=>{let n=t[0];for(let e=1;e<t.length;++e){n=Jh(n,t[e])}return n}))}}sS.className="Minimum";Kx(sS);class oS extends ZR{constructor(t){super(t);this.DEFAULT_AXIS=-1;if(t==null){t={}}this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis;this.supportsMasking=true;this.reshapeRequired=false}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1){throw new Qv("A `Concatenate` layer should be called on a list of at least 2 "+"inputs")}t=t;let n=true;for(const e of t){if(e!=null){n=false;break}}if(n){return}const e=[];for(let n=0;n<t.length;++n){const s=t[n].slice();s.splice(this.axis,1);let o=false;for(const t of e){if(v(t,s)){o=true;break}}if(!o){e.push(s)}}if(e.length>1){throw new Qv("A `Concatenate` layer requires inputs with matching shapes "+"except for the concat axis. Got input shapes: "+JSON.stringify(t))}}mergeFunction(t){return kc((()=>ay(t,this.axis)))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))){throw new Qv("A `Concatenate` layer should be called on a list of inputs.")}const n=t;const e=n[0].slice();const s=this.axis<0?e.length+this.axis:this.axis;for(const t of n.slice(1)){if(e[s]==null||t[s]==null){e[s]=null;break}e[s]+=t[s]}return e}computeMask(t,n){if(n==null){return null}if(!Array.isArray(n)){throw new Qv("`mask` should be an array for Concatenate")}if(!Array.isArray(t)){throw new Qv("`inputs` should be an array for Concatenate")}if(n.length!==t.length){throw new Qv(`Mismatch in the length of mask (${n.length}) `+`and the legnth of inputs (${t.length})`)}return kc((()=>{let e=true;n.forEach((t=>{if(t!=null){e=false;return}}));if(e){return null}const s=[];for(let e=0;e<t.length;++e){if(n[e]==null){s.push(wa(ad(t[e]),"bool"))}else if(n[e].rank<t[e].rank){s.push(Df(n[e],-1))}else{s.push(n[e])}}const o=Eu(s,this.axis);return Pa(o,-1,false)}))}getConfig(){const t={axis:this.axis};const n=super.getConfig();Object.assign(t,n);return t}}oS.className="Concatenate";Kx(oS);function rS(t,n){while(t<0){t+=n}return t}function iS(t,n,e){if(t.shape.length>3||n.shape.length>3){throw new t$("batchDot is not implemented for tensors of 4D or higher rank yet")}x(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, `+`but got ${t.shape.length}`));x(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, `+`but got ${n.shape.length}`));if(typeof e==="number"){e=[e,e]}if(t.dtype==="complex64"||n.dtype==="complex64"){throw new t$("batchDot is not implemented for complex64-type Tensors yet.")}const s=t.shape.length;const o=n.shape.length;if(e==null){e=[s-1,o-2]}const r=e;return kc((()=>{let e;if(s>o){e=s-o;const t=[];for(let n=0;n<e;++n){t.push(1)}n=yu(n,n.shape.concat(t))}else if(o>s){e=o-s;const n=[];for(let t=0;t<e;++t){n.push(1)}t=yu(t,t.shape.concat(n))}else{e=0}let i;if(t.shape.length===2&&n.shape.length===2){if(r[0]===r[1]){i=Sf(Aa(t,n),r[0])}else{i=Sf(Aa(Tm(t,[1,0]),n),r[1])}}else{const e=r[0]!==t.shape.length-1;const s=r[1]===n.shape.length-1;i=Iu(t,n,e,s)}if(e>0){let t;if(s>o){t=s+o-3}else{t=s-1}const n=[];for(let s=t;s<t+e;++s){n.push(s)}i=em(i,n)}if(i.shape.length===1){i=Df(i,1)}return i}))}class cS extends ZR{constructor(t){super(t);this.axes=t.axes;this.normalize=t.normalize==null?false:t.normalize;this.supportsMasking=true;this.reshapeRequired=false}build(t){x(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const n=t[0];const e=t[1];if(n.length>3||e.length>3){throw new t$("Dot layer does not support tensors of 4D or higher rank yet.")}const s=this.interpretAxes(n,e);if(n[s[0]]!==e[s[1]]){throw new Qv(`Dimension incompatibility: `+`${n[s[0]]} !== ${e[s[1]]}`)}}mergeFunction(t){if(t.length!==2){throw new Qv("A `Dot` layer must be called on exactly 2 inputs, "+`but received ${t.length} input(s).`)}let n=t[0];let e=t[1];let s;if(!Array.isArray(this.axes)){s=[rS(this.axes,n.shape.length),rS(this.axes,e.shape.length)]}else{s=this.axes.map(((n,e)=>rS(n,t[e].shape.length)))}if(this.normalize){n=Jk(n,s[0]);e=Jk(e,s[1])}return iS(n,e,s)}interpretAxes(t,n){let e;if(!Array.isArray(this.axes)){e=[rS(this.axes,t.length),rS(this.axes,n.length)]}else{e=this.axes}return e}computeOutputShape(t){x(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const n=t[0].slice();const e=t[1].slice();if(n.length>3||e.length>3){throw new t$("Dot layer does not support tensors of 4D or higher rank yet.")}const s=this.interpretAxes(n,e);n.splice(s[0],1);e.splice(s[1],1);e.splice(0,1);const o=n.concat(e);if(o.length===1){o.push(1)}return o}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize};const n=super.getConfig();Object.assign(t,n);return t}}cS.className="Dot";Kx(cS);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class aS extends ak{constructor(t){super(t);this.supportsMasking=true;this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={stddev:this.stddev};Object.assign(n,t);return n}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);const s=()=>Na(fy(e.shape,0,this.stddev),e);const o=$y(s,(()=>e),n["training"]||false);return o}))}}aS.className="GaussianNoise";Kx(aS);class uS extends ak{constructor(t){super(t);this.supportsMasking=true;this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={rate:this.rate};Object.assign(n,t);return n}call(t,n){return kc((()=>{this.invokeCallHook(t,n);const e=Ky(t);if(this.rate>0&&this.rate<1){const t=()=>{const t=Math.sqrt(this.rate/(1-this.rate));return Aa(e,fy(e.shape,1,t))};return $y(t,(()=>e),n["training"]||false)}return e}))}}uS.className="GaussianDropout";Kx(uS);class lS extends ak{constructor(t){super(t);this.supportsMasking=true;this.rate=t.rate;this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Ky(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={rate:this.rate};Object.assign(n,t);return n}call(t,n){return kc((()=>{if(this.rate<1&&this.rate>0){const e=this._getNoiseShape(t);const s=()=>{const n=Ky(t);const s=1.0507009873554805;const o=-1.6732632423543772*s;let r=Jf(cp(e),this.rate);r=ty(r,"float32");const i=((1-this.rate)*(1+this.rate*o**2))**-.5;const c=-i*o*this.rate;const a=Na(Aa(n,r),Aa(Na(r,-1),o));return Na(Aa(a,i),c)};return $y(s,(()=>Ky(t)),n["training"]||false)}return t}))}}lS.className="AlphaDropout";Kx(lS);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fS(t,n,e,s,o,r=.001){let i;if(t.rank===2){i=Gu(t,n,e,s,o,r)}else if(t.rank===3){i=Hu(t,n,e,s,o,r)}else if(t.rank===4){i=qu(t,n,e,s,o,r)}else{throw new t$(`batchNormalization is not implemented for array of rank ${t.rank} `+`yet`)}return i}function hS(t,n,e,s,o=.001){return kc((()=>{const r=ed(t,s);const i=r.mean;const c=r.variance;const a=fS(t,i,c,e,n,o);return[a,i,c]}))}function dS(t,n,e,s,o=.001){return kc((()=>{const r=ed(t,s);const i=r.mean;const c=r.variance;const a=[];for(const n of J$(0,t.rank)){if(s.indexOf(n)!==-1){a.push(1)}else{a.push(t.shape[n])}}const u=yu(i,a);const l=yu(c,a);const f=n==null?null:yu(n,a);const h=e==null?null:yu(e,a);const d=fS(t,u,l,h,f,o);return[d,i,c]}))}function pS(t,n,e,s,o=.001){if(v(s.slice().sort(),J$(0,t.rank-1))){return hS(t,n,e,s,o)}else{return dS(t,n,e,s,o)}}class mS extends ak{constructor(t){if(t==null){t={}}super(t);this.supportsMasking=true;this.axis=t.axis==null?-1:t.axis;this.momentum=t.momentum==null?.99:t.momentum;this.epsilon=t.epsilon==null?.001:t.epsilon;this.center=t.center==null?true:t.center;this.scale=t.scale==null?true:t.scale;this.betaInitializer=jy(t.betaInitializer||"zeros");this.gammaInitializer=jy(t.gammaInitializer||"ones");this.movingMeanInitializer=jy(t.movingMeanInitializer||"zeros");this.movingVarianceInitializer=jy(t.movingVarianceInitializer||"ones");this.betaConstraint=Dk(t.betaConstraint);this.gammaConstraint=Dk(t.gammaConstraint);this.betaRegularizer=ZN(t.betaRegularizer);this.gammaRegularizer=ZN(t.gammaRegularizer)}build(t){t=Jy(t);const n=this.axis>=0?this.axis:this.axis+t.length;const e=t[n];if(e==null){throw new Qv(`Axis ${n} of input tensor should have a defined dimension but `+`the layer received an input with shape `+`${JSON.stringify(t)}.`)}this.inputSpec=[new sk({ndim:t.length,axes:{[n]:e}})];const s=[e];if(this.scale){this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,true,this.gammaConstraint)}if(this.center){this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,true,this.betaConstraint)}this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,false);this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,false);this.built=true}call(t,n){return kc((()=>{const e=n["training"]==null?false:n["training"];const s=Ky(t);const o=s.shape;const r=o.length;const i=J$(0,r);const c=this.axis>=0?this.axis:this.axis+r;i.splice(c,1);const a=s$(1,r);a[c]=o[c];const u=i.slice();u.sort();const l=!v(u,J$(0,r).slice(0,r-1));const f=()=>{if(l){const t=yu(this.movingMean.read(),a);const n=yu(this.movingVariance.read(),a);const e=this.center?yu(this.beta.read(),a):null;const o=this.scale?yu(this.gamma.read(),a):null;return fS(s,t,n,e,o,this.epsilon)}else{return fS(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)}};if(!e){return f()}const[h,d,p]=pS(s,this.gamma.read(),this.beta.read(),i,this.epsilon);const m=(t,n,e)=>{kc((()=>{const s=1-e;const o=t.read();const r=Aa(Rh(o,n),s);t.write(Rh(o,r))}))};const x=()=>{m(this.movingMean,d,this.momentum);m(this.movingVariance,p,this.momentum)};x();return h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Hy(this.betaInitializer),gammaInitializer:Hy(this.gammaInitializer),movingMeanInitializer:Hy(this.movingMeanInitializer),movingVarianceInitializer:Hy(this.movingVarianceInitializer),betaRegularizer:JN(this.betaRegularizer),gammaRegularizer:JN(this.gammaRegularizer),betaConstraint:_k(this.betaConstraint),gammaConstraint:_k(this.gammaConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}mS.className="BatchNormalization";Kx(mS);class xS extends ak{constructor(t){if(t==null){t={}}super(t);this.axis=t.axis==null?-1:t.axis;if(typeof this.axis==="number"){if(!Number.isInteger(this.axis)){throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}}else if(Array.isArray(this.axis)){for(const t of this.axis){if(!Number.isInteger(t)){throw new Error(`Expected axis to be an array of integers, `+`but received ${JSON.stringify(this.axis)}`)}}}else{throw new Error(`Expected axis to be an integer or an array of integers, `+`but received ${JSON.stringify(this.axis)}`)}this.epsilon=t.epsilon==null?.001:t.epsilon;this.center=t.center==null?true:t.center;this.scale=t.scale==null?true:t.scale;this.betaInitializer=jy(t.betaInitializer||"zeros");this.gammaInitializer=jy(t.gammaInitializer||"ones");this.betaRegularizer=ZN(t.betaRegularizer);this.gammaRegularizer=ZN(t.gammaRegularizer);this.supportsMasking=true}build(t){t=Jy(t);const n=t.length;if(typeof this.axis==="number"){this.axis=[this.axis]}for(let t=0;t<this.axis.length;++t){if(this.axis[t]<0){this.axis[t]+=n}}for(const t of this.axis){if(t<0||t>=n){throw new Error(`Invalid axis: ${t}`)}}if(this.axis.length!==x$(this.axis).length){throw new Error(`Found duplicate axes in: ${this.axis}`)}const e=this.axis.map((n=>t[n]));const s=true;if(this.scale){this.gamma=this.addWeight("gamma",e,"float32",this.gammaInitializer,this.gammaRegularizer,s)}else{this.gamma=null}if(this.center){this.beta=this.addWeight("beta",e,"float32",this.betaInitializer,this.betaRegularizer,s)}else{this.beta=null}this.built=true}call(t,n){const e=Ky(t);const s=e.shape;const o=s.length;return kc((()=>{const t=true;let{mean:n,variance:r}=ed(e,this.axis,t);const i=s$(1,o);for(const t of this.axis){i[t]=s[t]}const c=t=>{if(t!=null&&t.shape.length!==o){return yu(t,i)}else{return t}};let a=this.scale?c(this.gamma.read()):null;let u=this.center?c(this.beta.read()):null;const l=[];const f=[];for(let t=0;t<o;++t){if(this.axis.indexOf(t)!==-1){l.push(s[t]);f.push(1)}else{l.push(1);f.push(s[t])}}n=Vf(n,l);r=Vf(r,l);if(a!=null){a=Vf(a,f)}if(u!=null){u=Vf(u,f)}return fS(e,n,r,u,a,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Hy(this.betaInitializer),gammaInitializer:Hy(this.gammaInitializer),betaRegularizer:JN(this.betaRegularizer),gammaRegularizer:JN(this.gammaRegularizer)};const n=super.getConfig();Object.assign(t,n);return t}}xS.className="LayerNormalization";Kx(xS);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bS(t,n,e){return kc((()=>{if(t.rank!==4){throw new Qv(`temporalPadding expects input tensor to be 4-D, but received a `+`${t.rank}-D tensor.`)}if(n==null){n=[[1,1],[1,1]]}if(n.length!==2||n[0].length!==2||n[1].length!==2){throw new Qv("spatial2dPadding expects `padding` to be an Array of two Arrays, "+"each of which is an Array of two integers.")}if(e==null){e=Q$()}if(e!=="channelsLast"&&e!=="channelsFirst"){throw new Qv(`Unknown data format: ${e}. `+`Supported data formats are 'channelsLast' and 'channelsFirst.`)}let s;if(e==="channelsFirst"){s=[[0,0],[0,0],n[0],n[1]]}else{s=[[0,0],n[0],n[1],[0,0]]}return ld(t,s)}))}class gS extends ak{constructor(t){if(t==null){t={}}super(t);this.dataFormat=t.dataFormat==null?Q$():t.dataFormat;if(t.padding==null){this.padding=[[1,1],[1,1]]}else if(typeof t.padding==="number"){this.padding=[[t.padding,t.padding],[t.padding,t.padding]]}else{t.padding=t.padding;if(t.padding.length!==2){throw new Qv(`ZeroPadding2D expects padding to be a length-2 array, but `+`received a length-${t.padding.length} array.`)}let n;let e;if(typeof t.padding[0]==="number"){n=[t.padding[0],t.padding[0]];e=[t.padding[1],t.padding[1]]}else{t.padding=t.padding;if(t.padding[0].length!==2){throw new Qv(`ZeroPadding2D expects height padding to be a length-2 array, `+`but received a length-${t.padding[0].length} array.`)}n=t.padding[0];if(t.padding[1].length!==2){throw new Qv(`ZeroPadding2D expects width padding to be a length-2 array, `+`but received a length-${t.padding[1].length} array.`)}e=t.padding[1]}this.padding=[n,e]}this.inputSpec=[new sk({ndim:4})]}computeOutputShape(t){t=Jy(t);let n;let e;if(this.dataFormat==="channelsFirst"){if(t[2]!=null&&t[2]>=0){n=t[2]+this.padding[0][0]+this.padding[0][1]}else{n=null}if(t[3]!=null&&t[3]>=0){e=t[3]+this.padding[1][0]+this.padding[1][1]}else{e=null}return[t[0],t[1],n,e]}else{if(t[1]!=null&&t[1]>=0){n=t[1]+this.padding[0][0]+this.padding[0][1]}else{n=null}if(t[2]!=null&&t[2]>=0){e=t[2]+this.padding[1][0]+this.padding[1][1]}else{e=null}return[t[0],n,e,t[3]]}}call(t,n){return kc((()=>bS(Ky(t),this.padding,this.dataFormat)))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}gS.className="ZeroPadding2D";Kx(gS);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wS(t,n,e,s,o,r){return kc((()=>{_$(o);L$(r);D$(s);if(e==null){e=[1,1]}if(s==null){s="valid"}if(o==null){o=Q$()}if(r==null){r="max"}t=aR(t,o);let i;const c=s==="same"?"same":"valid";if(r==="max"){i=Vh(t,n,e,c)}else{i=Cu(t,n,e,c)}if(o==="channelsFirst"){i=Tm(i,[0,3,1,2])}return i}))}function vS(t,n,e,s,o,r){return kc((()=>{_$(o);L$(r);D$(s);if(e==null){e=[1,1,1]}if(s==null){s="valid"}if(o==null){o=Q$()}if(r==null){r="max"}t=uR(t,o);let i;const c=s==="same"?"same":"valid";if(r==="max"){i=Wh(t,n,e,c)}else{i=Ru(t,n,e,c)}if(o==="channelsFirst"){i=Tm(i,[0,4,1,2,3])}return i}))}class $S extends ak{constructor(t){if(t.poolSize==null){t.poolSize=2}super(t);if(typeof t.poolSize==="number"){this.poolSize=[t.poolSize]}else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]==="number"){this.poolSize=t.poolSize}else{throw new Qv(`poolSize for 1D convolutional layer must be a number or an `+`Array of a single number, but received `+`${JSON.stringify(t.poolSize)}`)}v$(this.poolSize,"poolSize");if(t.strides==null){this.strides=this.poolSize}else{if(typeof t.strides==="number"){this.strides=[t.strides]}else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]==="number"){this.strides=t.strides}else{throw new Qv(`strides for 1D convolutional layer must be a number or an `+`Array of a single number, but received `+`${JSON.stringify(t.strides)}`)}}v$(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;D$(this.padding);this.inputSpec=[new sk({ndim:3})]}computeOutputShape(t){t=Jy(t);const n=iR(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return kc((()=>{this.invokeCallHook(t,n);t=ny(Ky(t),2);const e=this.poolingFunction(Ky(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return em(e,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides};const n=super.getConfig();Object.assign(t,n);return t}}class yS extends $S{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return wS(t,n,e,s,o,"max")}}yS.className="MaxPooling1D";Kx(yS);class kS extends $S{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return wS(t,n,e,s,o,"avg")}}kS.className="AveragePooling1D";Kx(kS);class CS extends ak{constructor(t){if(t.poolSize==null){t.poolSize=[2,2]}super(t);this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize];if(t.strides==null){this.strides=this.poolSize}else if(Array.isArray(t.strides)){if(t.strides.length!==2){throw new Qv(`If the strides property of a 2D pooling layer is an Array, `+`it is expected to have a length of 2, but received length `+`${t.strides.length}.`)}this.strides=t.strides}else{this.strides=[t.strides,t.strides]}v$(this.poolSize,"poolSize");v$(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;_$(this.dataFormat);D$(this.padding);this.inputSpec=[new sk({ndim:4})]}computeOutputShape(t){t=Jy(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1];let e=this.dataFormat==="channelsFirst"?t[3]:t[2];n=iR(n,this.poolSize[0],this.padding,this.strides[0]);e=iR(e,this.poolSize[1],this.padding,this.strides[1]);if(this.dataFormat==="channelsFirst"){return[t[0],t[1],n,e]}else{return[t[0],n,e,t[3]]}}call(t,n){return kc((()=>{this.invokeCallHook(t,n);return this.poolingFunction(Ky(t),this.poolSize,this.strides,this.padding,this.dataFormat)}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class NS extends CS{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return wS(t,n,e,s,o,"max")}}NS.className="MaxPooling2D";Kx(NS);class RS extends CS{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return wS(t,n,e,s,o,"avg")}}RS.className="AveragePooling2D";Kx(RS);class SS extends ak{constructor(t){if(t.poolSize==null){t.poolSize=[2,2,2]}super(t);this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize];if(t.strides==null){this.strides=this.poolSize}else if(Array.isArray(t.strides)){if(t.strides.length!==3){throw new Qv(`If the strides property of a 3D pooling layer is an Array, `+`it is expected to have a length of 3, but received length `+`${t.strides.length}.`)}this.strides=t.strides}else{this.strides=[t.strides,t.strides,t.strides]}v$(this.poolSize,"poolSize");v$(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;_$(this.dataFormat);D$(this.padding);this.inputSpec=[new sk({ndim:5})]}computeOutputShape(t){t=Jy(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1];let e=this.dataFormat==="channelsFirst"?t[3]:t[2];let s=this.dataFormat==="channelsFirst"?t[4]:t[3];n=iR(n,this.poolSize[0],this.padding,this.strides[0]);e=iR(e,this.poolSize[1],this.padding,this.strides[1]);s=iR(s,this.poolSize[2],this.padding,this.strides[2]);if(this.dataFormat==="channelsFirst"){return[t[0],t[1],n,e,s]}else{return[t[0],n,e,s,t[4]]}}call(t,n){return kc((()=>{this.invokeCallHook(t,n);return this.poolingFunction(Ky(t),this.poolSize,this.strides,this.padding,this.dataFormat)}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class ES extends SS{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return vS(t,n,e,s,o,"max")}}ES.className="MaxPooling3D";Kx(ES);class TS extends SS{constructor(t){super(t)}poolingFunction(t,n,e,s,o){_$(o);D$(s);return vS(t,n,e,s,o,"avg")}}TS.className="AveragePooling3D";Kx(TS);class IS extends ak{constructor(t){super(t);this.inputSpec=[new sk({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new t$}}class AS extends IS{constructor(t){super(t||{})}call(t,n){return kc((()=>{const n=Ky(t);return jh(n,1)}))}}AS.className="GlobalAveragePooling1D";Kx(AS);class OS extends IS{constructor(t){super(t||{})}call(t,n){return kc((()=>{const n=Ky(t);return xf(n,1)}))}}OS.className="GlobalMaxPooling1D";Kx(OS);class FS extends ak{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;_$(this.dataFormat);this.inputSpec=[new sk({ndim:4})]}computeOutputShape(t){t=t;if(this.dataFormat==="channelsLast"){return[t[0],t[3]]}else{return[t[0],t[1]]}}call(t,n){throw new t$}getConfig(){const t={dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class _S extends FS{call(t,n){return kc((()=>{const n=Ky(t);if(this.dataFormat==="channelsLast"){return jh(n,[1,2])}else{return jh(n,[2,3])}}))}}_S.className="GlobalAveragePooling2D";Kx(_S);class MS extends FS{call(t,n){return kc((()=>{const n=Ky(t);if(this.dataFormat==="channelsLast"){return xf(n,[1,2])}else{return xf(n,[2,3])}}))}}MS.className="GlobalMaxPooling2D";Kx(MS);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class DS extends ak{constructor(t){super(t);this.layer=t.layer}build(t){this.built=true}get trainable(){if(this.layer!=null){return this.layer.trainable}else{return false}}set trainable(t){if(this.layer!=null){this.layer.trainable=t}}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}};const n=super.getConfig();Object.assign(t,n);return t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.layer!=null){this.layer.setFastWeightInitDuringBuild(t)}}static fromConfig(t,n,e={}){const s=n["layer"];const o=Kk(s,e);delete n["layer"];const r={layer:o};Object.assign(r,n);return new t(r)}}class LS extends DS{constructor(t){super(t);this.supportsMasking=true}build(t){t=Jy(t);if(t.length<3){throw new Qv(`TimeDistributed layer expects an input shape >= 3D, but received `+`input shape ${JSON.stringify(t)}`)}this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));if(!this.layer.built){this.layer.build(n);this.layer.built=true}super.build(t)}computeOutputShape(t){t=Jy(t);const n=[t[0]].concat(t.slice(2));const e=this.layer.computeOutputShape(n);const s=t[1];return[e[0],s].concat(e.slice(1))}call(t,n){return kc((()=>{t=Ky(t);const e=(t,e)=>{const s=Ky(this.layer.call(t,n));return[s,[]]};const s=SR(e,t,[],false,null,null,false,true);const o=s[1];return o}))}}LS.className="TimeDistributed";Kx(LS);function zS(t){g$(O$,"BidirectionalMergeMode",t)}const PS="concat";class VS extends DS{constructor(t){super(t);const n=t.layer.getConfig();const e={};e["className"]=t.layer.getClassName();e["config"]=n;this.forwardLayer=Kk(e);n["goBackwards"]=n["goBackwards"]===true?false:true;const s={};s["className"]=t.layer.getClassName();s["config"]=n;this.backwardLayer=Kk(s);this.forwardLayer.name="forward_"+this.forwardLayer.name;this.backwardLayer.name="backward_"+this.backwardLayer.name;this.mergeMode=t.mergeMode===undefined?PS:t.mergeMode;zS(this.mergeMode);if(t.weights){throw new t$("weights support is not implemented for Bidirectional layer yet.")}this._stateful=t.layer.stateful;this.returnSequences=t.layer.returnSequences;this.returnState=t.layer.returnState;this.supportsMasking=true;this._trainable=true;this.inputSpec=t.layer.inputSpec;this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t;if(this.forwardLayer!=null){this.forwardLayer.trainable=t}if(this.backwardLayer!=null){this.backwardLayer.trainable=t}}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length;const e=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,e));this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);if(!(Array.isArray(n)&&Array.isArray(n[0]))){n=[n]}n=n;let e;let s;let o;if(this.returnState){o=n.slice(1);e=n[0]}else{e=n[0]}e=e;if(this.mergeMode==="concat"){e[e.length-1]*=2;s=[e]}else if(this.mergeMode==null){s=[e,e.slice()]}else{s=[e]}if(this.returnState){if(this.mergeMode==null){return s.concat(o).concat(o.slice())}return[e].concat(o).concat(o.slice())}return i$(s)}apply(t,n){let e=n==null?null:n["initialState"];let s=n==null?null:n["constants"];if(n==null){n={}}const o=RR(t,e,s,this.numConstants);t=o.inputs;e=o.initialState;s=o.constants;if(Array.isArray(t)){e=t.slice(1);t=t[0]}if((e==null||e.length===0)&&s==null){return super.apply(t,n)}const r=[];const i=[];if(e!=null){const t=e.length;if(t%2>0){throw new Qv("When passing `initialState` to a Bidrectional RNN, "+"the state should be an Array containing the states of "+"the underlying RNNs.")}n["initialState"]=e;r.push(...e);const s=e.map((t=>new sk({shape:t.shape})));this.forwardLayer.stateSpec=s.slice(0,t/2);this.backwardLayer.stateSpec=s.slice(t/2);i.push(...s)}if(s!=null){throw new t$("Support for constants in Bidirectional layers is not "+"implemented yet.")}const c=r[0]instanceof ok;for(const t of r){if(t instanceof ok!==c){throw new Qv("The initial state of a Bidirectional layer cannot be "+"specified as a mix of symbolic and non-symbolic tensors")}}if(c){const e=[t].concat(r);const s=this.inputSpec.concat(i);const o=this.inputSpec;this.inputSpec=s;const c=super.apply(e,n);this.inputSpec=o;return c}else{return super.apply(t,n)}}call(t,n){return kc((()=>{const e=n["initialState"];let s;let o;if(e==null){s=this.forwardLayer.call(t,n);o=this.backwardLayer.call(t,n)}else{const r=e.slice(0,e.length/2);const i=e.slice(e.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:r}));o=this.backwardLayer.call(t,Object.assign(n,{initialState:i}))}let r;if(this.returnState){if(Array.isArray(s)){r=s.slice(1).concat(o.slice(1))}s=s[0];o=o[0]}if(this.returnSequences){o=gp(o,1)}let i;if(this.mergeMode==="concat"){i=ay([s,o])}else if(this.mergeMode==="sum"){i=Na(s,o)}else if(this.mergeMode==="ave"){i=Aa(.5,Na(s,o))}else if(this.mergeMode==="mul"){i=Aa(s,o)}else if(this.mergeMode==null){i=[s,o]}if(this.returnState){if(this.mergeMode==null){return i.concat(r)}return[i].concat(r)}return i}))}resetStates(t){this.forwardLayer.resetStates();this.backwardLayer.resetStates()}build(t){V$(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)}));V$(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)}));this.built=true}computeMask(t,n){if(Array.isArray(n)){n=n[0]}let e;if(this.returnSequences){if(this.mergeMode==null){e=[n,n]}else{e=n}}else{if(this.mergeMode==null){e=[null,null]}else{e=null}}if(this.returnState){const t=this.forwardLayer.states;const n=t.map((t=>null));if(Array.isArray(e)){return e.concat(n).concat(n)}else{return[e].concat(n).concat(n)}}else{return e}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.forwardLayer!=null){this.forwardLayer.setFastWeightInitDuringBuild(t)}if(this.backwardLayer!=null){this.backwardLayer.setFastWeightInitDuringBuild(t)}}getConfig(){const t={mergeMode:this.mergeMode};const n=super.getConfig();Object.assign(t,n);return t}static fromConfig(t,n){const e=Kk(n["layer"]);delete n["layer"];if(n["numConstants"]!=null){throw new t$(`Deserialization of a Bidirectional layer with numConstants `+`present is not supported yet.`)}const s=n;s["layer"]=e;return new t(s)}}VS.className="Bidirectional";Kx(VS);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class BS extends ak{constructor(t){super(t);this.scale=t.scale;if(t.offset){this.offset=t.offset}else{this.offset=0}}getConfig(){const t={scale:this.scale,offset:this.offset};const n=super.getConfig();Object.assign(t,n);return t}call(t,n){return kc((()=>{t=Ky(t);if(t.dtype!=="float32"){t=ty(t,"float32")}return Na(Aa(t,this.scale),this.offset)}))}}BS.className="Rescaling";Kx(BS);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:WS,cropAndResize:GS}=Gx;class US extends ak{constructor(t){super(t);this.height=t.height;this.width=t.width}centerCrop(t,n,e,s,o,r,i,c){return kc((()=>{let a;let u=false;const l=n/r;const f=e/i;const h=(s+n)/r;const d=(o+e)/i;const p=[l,f,h,d];const m=[];if(t.rank===3){u=true;a=om([t])}else{a=t}for(let t=0;t<a.shape[0];t++){m.push(p)}const x=gc(m,[m.length,4]);const b=ap(0,m.length,1,"int32");const g=[s,o];const w=GS(a,x,b,g,"nearest");if(u){return ty(Ky(Nm(w)),c)}return ty(w,c)}))}upsize(t,n,e,s){return kc((()=>{const o=WS(t,[n,e]);return ty(o,s)}))}call(t,n){return kc((()=>{const n=Ky(t);const e=n.dtype;const s=n.shape;const o=s[s.length-3];const r=s[s.length-2];let i=0;if(o!==this.height){i=Math.floor((o-this.height)/2)}let c=0;if(r!==this.width){c=Math.floor((r-this.width)/2);if(c===0){c=1}}if(i>=0&&c>=0){return this.centerCrop(n,i,c,this.height,this.width,o,r,e)}else{return this.upsize(t,this.height,this.width,e)}}))}getConfig(){const t={height:this.height,width:this.width};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=Jy(t);const n=t.length-3;const e=t.length-2;t[n]=this.height;t[e]=this.width;return t}}US.className="CenterCrop";Kx(US);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HS(t,n,e,s){let o=Ky(t);if(o.dtype!=="int32"){o=ty(o,"int32")}if(n==="int"){return o}const r=o.shape;if(o.rank===0){o=Df(o,-1)}if(n==="oneHot"){if(o.shape[o.shape.length-1]!==1){o=Df(o,-1)}}if(o.rank>2){throw new Qv(`When outputMode is not int, maximum output rank is 2`+` Received outputMode ${n} and input shape ${r}`+` which would result in output rank ${o.rank}.`)}const i=["multiHot","oneHot"].includes(n);const c=o;let a;if(typeof s!=="undefined"&&n==="count"){a=_l(c,s,e,i)}else{a=_l(c,[],e,i)}if(n!=="tfIdf"){return a}if(s){return Aa(a,s)}else{throw new Qv(`When outputMode is 'tfIdf', weights must be provided.`)}}
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jS extends ak{constructor(t){super(t);this.numTokens=t.numTokens;if(t.outputMode){this.outputMode=t.outputMode}else{this.outputMode="multiHot"}}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=Jy(t);if(t==null){return[this.numTokens]}if(this.outputMode==="oneHot"&&t[t.length-1]!==1){t.push(this.numTokens);return t}t[t.length-1]=this.numTokens;return t}call(t,n){return kc((()=>{t=Ky(t);if(t.dtype!=="int32"){t=ty(t,"int32")}let e;if(typeof n["countWeights"]!=="undefined"){if(this.outputMode!=="count"){throw new Qv(`countWeights is not used when outputMode !== count.\n              Received countWeights=${n["countWeights"]}`)}e=Ky(n["countWeights"])}const s=xf(t);const o=gf(t);const r=Xf(this.numTokens,s).bufferSync().get(0);const i=Jf(o,0).bufferSync().get(0);if(!(r&&i)){throw new Qv("Input values must be between 0 < values <="+` numTokens with numTokens=${this.numTokens}`)}return HS(t,this.outputMode,this.numTokens,e)}))}}jS.className="CategoryEncoding";Kx(jS);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const qS=["bilinear","nearest"];const XS=new Set(qS);class KS extends ak{constructor(t){super(t);this.height=t.height;this.width=t.width;if(t.interpolation){if(XS.has(t.interpolation)){this.interpolation=t.interpolation}else{throw new Qv(`Invalid interpolation parameter: ${t.interpolation} is not implemented`)}}else{this.interpolation="bilinear"}this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=Jy(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio};const n=super.getConfig();Object.assign(t,n);return t}call(t,n){return kc((()=>{const n=[this.height,this.width];if(this.interpolation==="bilinear"){return Gx.resizeBilinear(t,n,!this.cropToAspectRatio)}else if(this.interpolation==="nearest"){return Gx.resizeNearestNeighbor(t,n,!this.cropToAspectRatio)}else{throw new Error(`Interpolation is ${this.interpolation} but only ${[...XS]} are supported`)}}))}}KS.className="Resizing";Kx(KS);
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class JS{constructor(t){this.seed=t}next(){if(this.seed===undefined){return undefined}return this.seed++}}JS.className="RandomSeed";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class YS extends ak{constructor(t){super(t);this.randomGenerator=new JS(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed};const n=super.getConfig();Object.assign(t,n);return t}}YS.className="BaseRandomLayer";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ZS=["bilinear","nearest"];const QS=new Set(ZS);class tE extends YS{constructor(t){super(t);const{factor:n,interpolation:e="bilinear"}=t;this.factor=n;if(Array.isArray(this.factor)&&this.factor.length===2){this.widthLower=this.factor[0];this.widthUpper=this.factor[1]}else if(!Array.isArray(this.factor)&&this.factor>0){this.widthLower=-this.factor;this.widthUpper=this.factor}else{throw new Qv(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`)}if(this.widthLower<-1||this.widthUpper<-1){throw new Qv(`factor must have values larger than -1. Got: ${this.factor}`)}if(this.widthUpper<this.widthLower){throw new Qv(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `)}if(e){if(QS.has(e)){this.interpolation=e}else{throw new Qv(`Invalid interpolation parameter: ${e} is not implemented`)}}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=Jy(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return kc((()=>{const n=Ky(t);this.imgHeight=n.shape[n.shape.length-3];const e=n.shape[n.shape.length-2];this.widthFactor=cp([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*e;s=Math.round(s);const o=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Gx.resizeBilinear(t,o);case"nearest":return Gx.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...QS]} are supported`)}}))}}tE.className="RandomWidth";Kx(tE);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nE=st();nE.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>false),(t=>{if(t){console.warn("Keep intermediate tensors is ON. This will print the values of all "+"intermediate tensors during model inference. Not all models "+"support this mode. For details, check e2e/benchmarks/ "+"model_config.js. This significantly impacts performance.")}}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var eE;(function(t){t[t["DT_INVALID"]=0]="DT_INVALID";t[t["DT_FLOAT"]=1]="DT_FLOAT";t[t["DT_DOUBLE"]=2]="DT_DOUBLE";t[t["DT_INT32"]=3]="DT_INT32";t[t["DT_UINT8"]=4]="DT_UINT8";t[t["DT_INT16"]=5]="DT_INT16";t[t["DT_INT8"]=6]="DT_INT8";t[t["DT_STRING"]=7]="DT_STRING";t[t["DT_COMPLEX64"]=8]="DT_COMPLEX64";t[t["DT_INT64"]=9]="DT_INT64";t[t["DT_BOOL"]=10]="DT_BOOL";t[t["DT_QINT8"]=11]="DT_QINT8";t[t["DT_QUINT8"]=12]="DT_QUINT8";t[t["DT_QINT32"]=13]="DT_QINT32";t[t["DT_BFLOAT16"]=14]="DT_BFLOAT16";t[t["DT_QINT16"]=15]="DT_QINT16";t[t["DT_QUINT16"]=16]="DT_QUINT16";t[t["DT_UINT16"]=17]="DT_UINT16";t[t["DT_COMPLEX128"]=18]="DT_COMPLEX128";t[t["DT_HALF"]=19]="DT_HALF";t[t["DT_RESOURCE"]=20]="DT_RESOURCE";t[t["DT_VARIANT"]=21]="DT_VARIANT";t[t["DT_UINT32"]=22]="DT_UINT32";t[t["DT_UINT64"]=23]="DT_UINT64";t[t["DT_FLOAT_REF"]=101]="DT_FLOAT_REF";t[t["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF";t[t["DT_INT32_REF"]=103]="DT_INT32_REF";t[t["DT_UINT8_REF"]=104]="DT_UINT8_REF";t[t["DT_INT16_REF"]=105]="DT_INT16_REF";t[t["DT_INT8_REF"]=106]="DT_INT8_REF";t[t["DT_STRING_REF"]=107]="DT_STRING_REF";t[t["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF";t[t["DT_INT64_REF"]=109]="DT_INT64_REF";t[t["DT_BOOL_REF"]=110]="DT_BOOL_REF";t[t["DT_QINT8_REF"]=111]="DT_QINT8_REF";t[t["DT_QUINT8_REF"]=112]="DT_QUINT8_REF";t[t["DT_QINT32_REF"]=113]="DT_QINT32_REF";t[t["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF";t[t["DT_QINT16_REF"]=115]="DT_QINT16_REF";t[t["DT_QUINT16_REF"]=116]="DT_QUINT16_REF";t[t["DT_UINT16_REF"]=117]="DT_UINT16_REF";t[t["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF";t[t["DT_HALF_REF"]=119]="DT_HALF_REF";t[t["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF";t[t["DT_VARIANT_REF"]=121]="DT_VARIANT_REF";t[t["DT_UINT32_REF"]=122]="DT_UINT32_REF";t[t["DT_UINT64_REF"]=123]="DT_UINT64_REF"})(eE||(eE={}));var sE;(function(t){(function(t){t[t["LEGACY"]=0]="LEGACY";t[t["V1"]=1]="V1";t[t["V2"]=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(sE||(sE={}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var oE;(function(t){t[t["FAIL"]=0]="FAIL";t[t["SHORTEST"]=1]="SHORTEST";t[t["LONGEST"]=2]="LONGEST"})(oE||(oE={}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rE(t,n){if(!Array.isArray(t)){t=[t]}t.forEach((t=>{if(t!=null){x(t.dtype!=="complex64",(()=>`${n} does not support complex64 tensors in the CPU backend.`))}}))}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iE=Sm;class cE extends u{nextDataId(){return cE.nextDataId++}constructor(){super();this.blockSize=48;this.firstUse=true;this.data=new a(this,$c())}write(t,n,e){if(this.firstUse){this.firstUse=false;if(st().get("IS_NODE")){ho("\n============================\n"+"Hi, looks like you are running TensorFlow.js in "+"Node.js. To speed things up dramatically, install our node "+"backend, visit https://github.com/tensorflow/tfjs-node for more details. "+"\n============================")}}const s={id:this.nextDataId()};this.data.set(s,{values:t,dtype:e,refCount:1});return s}makeTensorInfo(t,n,e){let s;if(n==="string"&&e!=null&&e.length>0&&M(e[0])){const o=e.map((t=>Qo(t)));s=this.write(o,t,n)}else{s=this.write(e,t,n)}return{dataId:s,shape:t,dtype:n}}refCount(t){if(this.data.has(t)){const n=this.data.get(t);return n.refCount}return 0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,e,s,o){this.data.set(t,{values:n,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:e}=this.data.get(t);if(n==="complex64"){const t=this.readSync(e.real.dataId);const n=this.readSync(e.imag.dataId);return ng(t,n)}return U(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string"){try{const e=n.map((t=>tr(t)));return ba(t.shape,t.dtype,e)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}}return ba(t.shape,t.dtype,n)}makeOutput(t,n,e){return $c().makeTensorFromTensorInfo(this.makeTensorInfo(n,e,t),this)}disposeData(t,n=false){if(this.data.has(t)){this.data.get(t).refCount--;if(!n&&this.data.get(t).refCount>0){return false}const{complexTensorInfos:e}=this.data.get(t);if(e!=null){this.disposeData(e.real.dataId,true);this.disposeData(e.imag.dataId,true)}this.data.delete(t)}return true}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=Zo();t();const e=Zo()-n;return{kernelMs:e}}memory(){return{unreliable:true,reasons:["The reported memory is an upper bound. Due to automatic garbage "+"collection, the true allocated memory may be less."]}}where(t){rE([t],"where");const n=this.readSync(t.dataId);return iE(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}cE.nextDataId=0;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e){n[e]=Math.abs(t[e])}return n}const uE=t=>{const{x:n}=t.inputs;const e=t.backend;rE(n,"abs");let s=new Float32Array(w(n.shape));const o=e.data.get(n.dataId).values;s=aE(o);return e.makeOutput(s,n.shape,n.dtype)};const lE={kernelName:Zt,backendName:"cpu",kernelFunc:uE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(t){return(n,e,s,o,r)=>{const i=Gl(n,e);const c=i.length;const a=B(i);const u=w(i);const l=E(r,u);const f=n.length;const h=e.length;const d=B(n);const p=B(e);const m=Bl(n,i);const x=Bl(e,i);if(m.length+x.length===0){for(let n=0;n<l.length;++n){l[n]=t(s[n%s.length],o[n%o.length])}}else{for(let n=0;n<l.length;++n){const e=J(n,c,a);const r=e.slice(-f);m.forEach((t=>r[t]=0));const i=K(r,f,d);const u=e.slice(-h);x.forEach((t=>u[t]=0));const b=K(u,h,p);l[n]=t(s[i],o[b])}}return[l,i]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hE(t){const{inputs:n,backend:e}=t;const{real:s,imag:o}=n;const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const c=e.makeTensorInfo(s.shape,"complex64");const a=e.data.get(c.dataId);a.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",r),imag:e.makeTensorInfo(o.shape,"float32",i)};return c}const dE={kernelName:Rn,backendName:"cpu",kernelFunc:hE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pE(t,n,e="float32"){if(e==="complex64"){const e=pE(t,n,"float32");const s=pE(t,n,"float32");return hE({inputs:{real:e,imag:s},backend:t})}const s=j(w(n),e);return t.makeTensorInfo(n,e,s)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mE(t){const{inputs:n,backend:e}=t;const{x:s}=n;e.incRef(s.dataId);return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const xE={kernelName:me,backendName:"cpu",kernelFunc:mE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.data.get(s.dataId).complexTensorInfos.real;const r=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,r)}const gE={kernelName:us,backendName:"cpu",kernelFunc:bE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(t,n,e,s){if(s==="int32"){const e=Int32Array.from(t);return[n,"int32",e]}if(s==="bool"){const s=Yo([0],e);const[o,r]=fE(((t,n)=>t!==n?1:0))(n,[],t,s,"bool");return[r,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function vE(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dtype:r}=s;if(r==="complex64"){if(o.dtype==="complex64"){return mE({inputs:{x:o},backend:e})}const t=pE(e,o.shape,o.dtype);const n=vE({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});const s=hE({inputs:{real:n,imag:t},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);return s}if(o.dtype==="complex64"){const t=bE({inputs:{input:o},backend:e});const n=vE({inputs:{x:t},backend:e,attrs:{dtype:r}});e.disposeIntermediateTensorInfo(t);return n}if(!O(o.dtype,r)){const t=mE({inputs:{x:o},backend:e});return{dataId:t.dataId,shape:t.shape,dtype:r}}const i=e.data.get(o.dataId).values;const[c,a,u]=wE(i,o.shape,o.dtype,r);return e.makeTensorInfo(c,a,u)}const $E={kernelName:kn,backendName:"cpu",kernelFunc:vE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yE(t,n,e,s){if(e==null){return({inputs:e,backend:o})=>{const{a:r,b:i}=e;const c=o;rE([r,i],t);const a=c.data.get(r.dataId).values;const u=c.data.get(i.dataId).values;const l=r.dtype==="string"?Dg(a):a;const f=r.dtype==="string"?Dg(u):u;const h=s||r.dtype;const[d,p]=n(r.shape,i.shape,l,f,h);return c.makeTensorInfo(p,h,d)}}return({inputs:t,backend:o})=>{const{a:r,b:i}=t;const c=o;if(r.dtype==="complex64"||i.dtype==="complex64"){const t=vE({inputs:{x:r},backend:c,attrs:{dtype:"complex64"}});const n=c.data.get(t.dataId);const s=n.complexTensorInfos.real;const o=n.complexTensorInfos.imag;const a=c.data.get(s.dataId).values;const u=c.data.get(o.dataId).values;const l=vE({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}});const f=c.data.get(l.dataId);const h=f.complexTensorInfos.real;const d=f.complexTensorInfos.imag;const p=c.data.get(h.dataId).values;const m=c.data.get(d.dataId).values;const[x,b,g]=e(r.shape,i.shape,a,u,p,m);const w=c.makeTensorInfo(g,"float32",x);const v=c.makeTensorInfo(g,"float32",b);const $=hE({inputs:{real:w,imag:v},backend:c});c.disposeIntermediateTensorInfo(t);c.disposeIntermediateTensorInfo(l);c.disposeIntermediateTensorInfo(w);c.disposeIntermediateTensorInfo(v);return $}else{const t=c.data.get(r.dataId).values;const e=c.data.get(i.dataId).values;const o=s||r.dtype;const[a,u]=n(r.shape,i.shape,t,e,o);return c.makeTensorInfo(u,o,a)}}}function kE(t){return(n,e,s,o,r,i)=>{const c=Gl(n,e);const a=w(c);const u=c.length;const l=B(c);const f=E("float32",a);const h=E("float32",a);const d=Bl(n,c);const p=Bl(e,c);const m=ng(s,o);const x=ng(r,i);const b=n.length;const g=B(n);const v=e.length;const $=B(e);if(d.length+p.length===0){for(let n=0;n<f.length;n++){const e=n%m.length;const s=n%x.length;const o=t(m[e*2],m[e*2+1],x[s*2],x[s*2+1]);f[n]=o.real;h[n]=o.imag}}else{for(let n=0;n<f.length;n++){const e=J(n,u,l);const s=e.slice(-b);d.forEach((t=>s[t]=0));const o=K(s,b,g);const r=e.slice(-v);p.forEach((t=>r[t]=0));const i=K(r,v,$);const c=t(m[o*2],m[o*2+1],x[i*2],x[i*2+1]);f[n]=c.real;h[n]=c.imag}}return[f,h,c]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CE=fE(((t,n)=>t+n));const NE=kE(((t,n,e,s)=>({real:t+e,imag:n+s})));const RE=yE(nn,CE,NE);const SE={kernelName:nn,backendName:"cpu",kernelFunc:RE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(t,n,e,s,o){const r=w(s);const i=j(o,e);for(let e=0;e<t.length;e++){const s=t[e];if(s<0){throw new Error("Input x must be non-negative!")}if(s>=o){continue}if(r>0){i[s]+=n[e]}else{i[s]+=1}}return i}function TE(t,n,e,s=false){const o=t.shape[0];const r=t.shape[1];const i=ba([o,e],n.dtype);for(let c=0;c<o;c++){for(let o=0;o<r;o++){const r=t.get(c,o);if(r<0){throw new Error("Input x must be non-negative!")}if(r>=e){continue}if(s){i.set(1,c,r)}else{if(n.size>0){i.set(i.get(c,r)+n.get(c,o),c,r)}else{i.set(i.get(c,r)+1,c,r)}}}}return i}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IE=fE(((t,n)=>t&n));const AE=yE(vn,IE);const OE={kernelName:vn,backendName:"cpu",kernelFunc:AE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(t){return(n,e,s)=>{const o=T(e,n.length);for(let e=0;e<n.length;++e){o[e]=t(n[e],s)}return o}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(t,n,e){const s=FE(n);return ME(t,s,e)}function ME(t,n,e){return({inputs:s,attrs:o,backend:r})=>{const{x:i}=s;rE(i,t);const c=r;const a=c.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(a)){throw new Error("String tensor's value was not an instance of Array")}u=Dg(a)}else{u=a}const l=e||i.dtype;const f=n(u,l,o);return c.makeTensorInfo(i.shape,l,f)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE=FE((t=>Math.ceil(t)));const LE=ME(Cn,DE);const zE={kernelName:Cn,backendName:"cpu",kernelFunc:LE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PE(t,n,e,s){const o=T(e,w(n));if(s&&e!=="string"){let n=0;t.forEach((t=>{const e=w(t.shape);o.set(t.vals,n);n+=e}))}else{let s=0;t.forEach((t=>{const r=e==="string"?Dg(t.vals):t.vals;let i=0;for(let e=0;e<t.shape[0];++e){const c=e*n[1]+s;for(let n=0;n<t.shape[1];++n){o[c+n]=r[i++]}}s+=t.shape[1]}))}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VE=fE(((t,n)=>t===n?1:0));const BE=yE(ne,VE,null,"bool");const WE={kernelName:ne,backendName:"cpu",kernelFunc:BE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GE=FE((t=>Math.exp(t)));const UE=ME(ee,GE,"float32");const HE={kernelName:ee,backendName:"cpu",kernelFunc:UE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=FE((t=>Math.expm1(t)));const qE=ME(oe,jE);const XE={kernelName:oe,backendName:"cpu",kernelFunc:qE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE=FE((t=>Math.floor(t)));const JE=ME(ae,KE);const YE={kernelName:ae,backendName:"cpu",kernelFunc:JE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZE=fE(((t,n)=>Math.floor(t/n)));const QE=yE(ue,ZE,null,"int32");const tT={kernelName:ue,backendName:"cpu",kernelFunc:QE};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nT(t,n,e,s,o,r,i,c,a){const u=ba([s,r],e);for(let e=0;e<s;e++){const s=[];let l=0;for(let n=0;n<o;n++){const r=t[e*o+n];l+=r*i[n];s.push(r)}if(l<0||l>=a/r){throw new Error(`Invalid indices: ${s} does not index into ${c}`)}for(let t=0;t<r;t++){u.values[e*r+t]=n.get(...n.indexToLoc(l*r+t))}}return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eT(t,n,e){const s=ba(e,t.dtype);for(let e=0;e<s.size;++e){const o=s.indexToLoc(e);const r=o.slice();const i=r[0];const c=r[2];const a=n.locToIndex([i,c]);r[2]=n.values[a];const u=t.locToIndex(r);if(0<=u&&u<t.values.length){s.values[e]=t.values[u]}}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sT=fE(((t,n)=>t>n?1:0));const oT=yE(de,sT,null,"bool");const rT={kernelName:de,backendName:"cpu",kernelFunc:oT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iT=fE(((t,n)=>t>=n?1:0));const cT=yE(pe,iT,null,"bool");const aT={kernelName:pe,backendName:"cpu",kernelFunc:cT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uT=fE(((t,n)=>t<n?1:0));const lT=yE(ye,uT,null,"bool");const fT={kernelName:ye,backendName:"cpu",kernelFunc:lT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=fE(((t,n)=>t<=n?1:0));const dT=yE(ke,hT,null,"bool");const pT={kernelName:ke,backendName:"cpu",kernelFunc:dT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mT(t,n,e){const s=(n-t)/(e-1);const o=j(e,"float32");o[0]=t;for(let t=1;t<o.length;t++){o[t]=o[t-1]+s}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xT=FE((t=>Math.log(t)));const bT=ME(Ne,xT);const gT={kernelName:Ne,backendName:"cpu",kernelFunc:bT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(t,n,e,s){const o=E(s,w(e));for(let e=0;e<o.length;++e){const s=e*n;let r=t[s];for(let e=0;e<n;++e){const n=t[s+e];if(Number.isNaN(n)||n>r){r=n}}o[e]=r}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vT=fE(((t,n)=>Math.max(t,n)));const $T=yE(_e,vT);const yT={kernelName:_e,backendName:"cpu",kernelFunc:$T};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kT=fE(((t,n)=>Math.min(t,n)));const CT=yE(We,kT);const NT={kernelName:We,backendName:"cpu",kernelFunc:CT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RT=fE(((t,n)=>t*n));const ST=kE(((t,n,e,s)=>({real:t*e-n*s,imag:t*s+n*e})));const ET=yE(je,RT,ST);const TT={kernelName:je,backendName:"cpu",kernelFunc:ET};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IT(t,n,e){const s=Ko(-1,e);return RT([],n,s,t,e)}function AT(t){const{inputs:n,backend:e}=t;const{x:s}=n;rE(s,"neg");const o=e.data.get(s.dataId).values;const[r,i]=IT(o,s.shape,s.dtype);return e.makeTensorInfo(i,s.dtype,r)}const OT={kernelName:qe,backendName:"cpu",kernelFunc:AT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FT=fE(((t,n)=>t!==n?1:0));const _T=yE(Xe,FT,null,"bool");const MT={kernelName:Xe,backendName:"cpu",kernelFunc:_T};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(t,n,e,s,o){const r=n.length;const i=w(n);const c=B(n);const a=B(o);const u=E(e,w(o));for(let n=0;n<i;++n){const e=J(n,r,c);const o=new Array(e.length);for(let t=0;t<o.length;t++){o[t]=e[s[t]]}const i=K(o,r,a);u[i]=t[n]}return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LT(t){const{inputs:n,attrs:e,backend:s}=t;const{x:o}=n;const{perm:r}=e;rE(o,"transpose");const i=o.shape.length;const c=new Array(i);for(let t=0;t<c.length;t++){c[t]=o.shape[r[t]]}const a=s.data.get(o.dataId).values;const u=DT(a,o.shape,o.dtype,r,c);const l=s.write(u,c,o.dtype);return{dataId:l,shape:c,dtype:o.dtype}}const zT={kernelName:no,backendName:"cpu",kernelFunc:LT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(t,n,e,s){const[o,r]=uf(t,s);const i=Ar(n,"int32");const c=j(w(o),i);const a=w(r);for(let t=0;t<c.length;++t){const n=t*a;let s=1;for(let t=0;t<a;++t){s*=e[n+t]}c[t]=s}return{outVals:c,outShape:o,outDtype:i}}function VT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;rE(o,"prod");const c=o.shape.length;const a=R(r,o.shape);const u=hf(a,c);let l=a;let f=o;const h=[];if(u!=null){f=LT({inputs:{x:o},backend:e,attrs:{perm:u}});h.push(f);l=pf(l.length,c)}const d=e.data.get(f.dataId).values;const{outVals:p,outShape:m,outDtype:x}=PT(f.shape,f.dtype,d,l);let b=m;if(i){b=lf(m,a)}h.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(b,x,p)}const BT={kernelName:os,backendName:"cpu",kernelFunc:VT};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WT(t,n,e){t.forEach(((t,s)=>{if(t<0||t>=e){const o=J(s,n.length,B(n)).join(",");throw new Error(`indices[${o}] = ${t} is not in [0, ${e})`)}}))}function GT(t,n){for(let e=0;e<t.length;++e){const s=t[e];const o=e===t.length-1?n:t[e+1].length;if(s.length===0){throw new Error("Ragged splits may not be empty")}if(s[0]<0){throw new Error("Ragged splits must be non-negative")}if(s[s.length-1]>o){throw new Error("Ragged splits must not point past values")}for(let t=1;t<s.length;++t){if(s[t-1]>s[t]){throw new Error("Ragged splits must be sorted in ascending order")}}}}function UT(t,n,e,s){const o=[];let r=0;const i=n.length-1+e.length;const c=new Array(i).fill(null).map((()=>[0]));GT(e,s);let a=1;for(let t=0;t<n.length-1;++t){a*=n[t];const e=n[t+1];for(let n=1;n<a+1;++n){c[t].push(n*e)}}for(let s=0;s<t.length;++s){let i=t[s];let a=t[s]+1;for(let t=0;t<e.length;++t){const s=e[t];const o=t+n.length-1;if(o>=0){const t=c[o];const n=t[t.length-1]-s[i];for(let t=i;t<a;++t){c[o].push(s[t+1]+n)}}i=s[i];a=s[a]}if(a!==i){o.push([i,a]);r+=a-i}}return{outSplits:c,valueSlices:o,numValues:r}}function HT(t){const n=[];for(let e=0;e<t.length;++e){const s=t[e].length;const o=T("int32",s);n.push(o);t[e].forEach(((t,n)=>o[n]=t))}return n}function jT(t,n){const e=t.slice(0,n);while(e.length<n){e.push(1)}for(let s=n;s<t.length;s++){e[n-1]*=t[s]}return e}function qT(t,n,e,s,o,r){const i=jT(n,2)[1];const c=jT(r,2)[1];let a=0;for(const n of e){for(let e=n[0];e<n[1];++e){for(let n=0;n<s;++n){o[a*c+n]=t[e*i+n]}++a}}}function XT(t,n,e,s,o){const r=n.slice();r[0]=o;const i=T(e,w(r));const c=t.length;const a=c===0?0:c/n[0];qT(t,n,s,a,i,r);return[i,r]}function KT(t,n,e,s,o,r,i,c){if(t.length===0){throw new Error("paramsNestedSplits must be non empty")}if(n[0].length===0){throw new Error("Split tensors must not be scalars")}const a=n[0][0]-1;WT(r,i,a);if(s.length===0){throw new Error("params.rank must be nonzero")}const u=s[0];const{outSplits:l,valueSlices:f,numValues:h}=UT(r,i,t,u);const d=HT(l);const p=XT(e,s,o,f,h);return[d,p[0],p[1]]}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JT=2147483647;function YT(t,n,e,s,o,r,i){if(n.length>1){throw new Error("starts must be a scalar or vector")}if(o.length>1){throw new Error("limits must be a scalar or vector")}if(i.length>1){throw new Error("deltas must be a scalar or vector")}const c=n.length===0;const a=o.length===0;const u=i.length===0;const l=[];if(!c){l.push(n[0])}if(!a){l.push(o[0])}if(!u){l.push(i[0])}for(let t=1;t<l.length;++t){if(l[t]!==l[t-1]){throw new Error("starts, limits, and deltas must have the same shape")}}const f=l.length===0?1:l[0];const h=T("int32",f+1);h[0]=0;for(let n=0;n<f;++n){const e=c?t[0]:t[n];const o=a?s[0]:s[n];const i=u?r[0]:r[n];if(i===0){throw new Error("Requires delta != 0")}let l;if(i>0&&o<e||i<0&&o>e){l=0}else{l=Math.ceil(Math.abs((o-e)/i));if(l>JT){throw new Error(`Requires ((limit - start) / delta) <= ${JT}`)}}h[n+1]=h[n]+l}const d=h[f];const p=T(e,d);let m=0;for(let n=0;n<f;++n){const e=h[n+1]-h[n];let s=c?t[0]:t[n];const o=u?r[0]:r[n];for(let t=0;t<e;++t){p[m++]=s;s+=o}}return[h,p]}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ZT=_b;class QT{constructor(t,n,e,s,o,r,i,c,a,u){this.shape=t;this.shapeShape=n;this.values=e;this.valuesShape=s;this.valuesDType=o;this.defaultValue=r;this.defaultValueShape=i;this.rowPartitionValues=c;this.rowPartitionValuesShapes=a;this.rowPartitionTypes=Db(u);this.raggedRank=Lb(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){if(this.rowPartitionTypes[0]===ZT.FIRST_DIM_SIZE){return this.rowPartitionTypes[t+1]}else{return this.rowPartitionTypes[t]}}getRowPartitionTensor(t){if(this.rowPartitionTypes[0]===ZT.FIRST_DIM_SIZE){return this.rowPartitionValues[t+1]}else{return this.rowPartitionValues[t]}}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ZT.VALUE_ROWIDS:return QT.getMaxWidthValueRowID(n);case ZT.ROW_SPLITS:return QT.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${ZT[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1){return 0}let e=0;for(let s=0;s<n-1;++s){const n=t[s+1]-t[s];if(n>e){e=n}}return e}static getMaxWidthValueRowID(t){const n=t.length;if(n===0){return 0}let e=0;let s=t[0];let o=0;for(let r=1;r<n;++r){const n=t[r];if(n!==s){s=n;o=Math.max(r-e,o);e=r}}return Math.max(n-e,o)}tensorShapeFromTensor(t,n,e=true){if(n.length===0){if(t[0]===-1){return[]}throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`)}return nI(t,e)}calculateOutputSize(t){const n=this.valuesShape;const e=this.defaultValueShape;zb(e,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape);const o=Mb(this.raggedRank,s,n);const r=o;if(r[0]<0){r[0]=t}for(let t=1;t<=this.raggedRank;++t){if(r[t]<0){r[t]=this.getMaxWidth(t)}}return r}calculateFirstParentOutputIndex(t,n,e){const s=Math.min(t,e);const o=[];let r=0;for(let t=0;t<s;++t,r+=n){o.push(r)}for(let n=s;n<t;++n){o.push(-1)}x(o.length===t,(()=>"Final length of result must be equal to firstDimension."));return o}calculateOutputIndexRowSplit(t,n,e,s){const o=t.length;const r=[];for(let i=0;i<o-1;++i){const o=t[i+1]-t[i];let c=Math.min(s,o);let a=n[i];if(a===-1){c=0}for(let t=0;t<c;++t){r.push(a);a+=e}for(let t=0;t<o-c;++t){r.push(-1)}}if(o>0&&r.length!==t[o-1]){throw new Error("Invalid row split size.")}return r}calculateOutputIndexValueRowID(t,n,e,s){const o=t.length;const r=[];if(o===0){return[]}let i=0;let c=t[0];if(c>=n.length){throw new Error(`Got currentValueRowId=${c}, which is not less than ${n.length}`)}let a=n[c];r.push(a);for(let u=1;u<o;++u){const o=t[u];if(o===c){if(a>=0){++i;if(i<s){a+=e}else{a=-1}}}else{i=0;c=o;if(o>=n.length){throw new Error(`Got nextValueRowId=${o} which is not less than ${n.length}`)}a=n[o]}r.push(a)}if(r.length!==t.length){throw new Error("Invalid row ids.")}return r}calculateOutputIndex(t,n,e,s){const o=this.getRowPartitionTensor(t);const r=this.getRowPartitionTypeByDimension(t);switch(r){case ZT.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,e,s);case ZT.ROW_SPLITS:if(o.length-1>n.length){throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`)}return this.calculateOutputIndexRowSplit(o,n,e,s);default:throw new Error(`Unsupported partition type: ${ZT[r]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0){throw new Error("No row_partition_types given.")}const n=this.rowPartitionTypes[0];switch(n){case ZT.FIRST_DIM_SIZE:return t[0];case ZT.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ZT.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ZT[n]}`)}}compute(){const t=this.rowPartitionValues[0];if(t.length<=0){throw new Error("Invalid first partition input. "+"Tensor requires at least one element.")}const n=this.getFirstDimensionSize();const e=this.calculateOutputSize(n);const s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let t=s.length-2;t>=0;--t){s[t]=s[t+1]*e[t+1]}const o=nI(e,false);const r=T(this.valuesDType,w(o));const i=s[0]*e[0];if(i>0){let t=this.calculateFirstParentOutputIndex(n,s[0],e[0]);for(let n=1;n<=this.raggedRank;++n){const o=this.calculateOutputIndex(n-1,t,s[n],e[n]);t=o}this.setOutput(this.raggedRank,t,r,o)}return[o,r]}setOutput(t,n,e,s){if(e.length===0){return}const o=this.values;const r=e;let i=s.slice();i=i.slice(t+1);const c=w(i);const a=n.length;let u=this.defaultValue;if(u.length!==c&&u.length!==1){const t=this.defaultValueShape;kc((()=>{const n=yu(u,t);const e=Yu(n,i);u=e.dataSync()}))}let l=0;let f=0;let h=0;for(let t=0;t<=a;++t){let s=t<a?n[t]:-1;if(s===h){++h;continue}if(f<h){const t=o.subarray(l*c);const n=r.subarray(f*c);const e=(h-f)*c;tI(n,t,e)}if(t>=a){const t=e.length;s=Math.floor(t/c)}if(s>h){if(this.defaultValue.length===1){r.subarray(h*c,s*c).fill(this.defaultValue[0]);h=s}else{while(s>h){const t=r.slice(h*c);tI(t,u,c);++h}}}if(s<0){l=t+1;f=h}else{l=t;f=h;h=f+1}}}}function tI(t,n,e){for(let s=0;s<e;s++){t[s]=n[s]}}function nI(t,n){const e=[];for(let s of t){if(s<0){if(!n){throw new Error(`Dimension ${s} must be >= 0`)}if(s<-1){throw new Error(`Dimension ${s} must be >= -1`)}s=-1}e.push(s)}return e}function eI(t,n,e,s,o,r,i,c,a,u){return new QT(t,n,e,s,o,r,i,c,a,u).compute()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(t,n,e,s){const o=t===n;const r=t<n&&e<0;const i=n<t&&e>1;if(o||r||i){return j(0,s)}const c=Math.abs(Math.ceil((n-t)/e));const a=j(c,s);if(n<t&&e===1){e=-1}a[0]=t;for(let t=1;t<a.length;t++){a[t]=a[t-1]+e}return a}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI=FE((t=>1/Math.sqrt(t)));const rI=ME(vs,oI);const iI={kernelName:vs,backendName:"cpu",kernelFunc:rI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cI(t,n,e,s,o,r,i,c,a,u){const l=[s/o,o];const f=t.values;const h=n.values;if(s===0){return ba(e,n.dtype)}const d=a instanceof br?a:ba(l,n.dtype);if(typeof a==="string"){d.values.fill(a)}else if(typeof a==="number"){d.values.fill(a)}else if(typeof a==="boolean"){d.values.fill(+a)}for(let t=0;t<r;t++){const r=[];let a=0;for(let n=0;n<i;n++){const e=f[t*i+n];r.push(e);a+=e*c[n]}if(a<0||a>=s/o){throw new Error(`Invalid indices: ${r} does not index into ${e}`)}for(let e=0;e<o;e++){if(u){d.values[a*o+e]+=h[t*o+e]}else{d.values[a*o+e]=n.rank===0?h[0]:h[t*o+e]}}}return d}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI=FE((t=>1/(1+Math.exp(-t))));const uI=_E(Is,(t=>1/(1+Math.exp(-t))));const lI={kernelName:Is,backendName:"cpu",kernelFunc:uI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(t,n,e,s,o){const r=$b(s,n,e);const i=w(e);const c=B(s);if(r){const e=yb(n,c);if(o==="string"){return t.slice(e,e+i)}return t.subarray(e,e+i)}const a=o==="string"?Dg(t):t;const u=ba(s,o,a);const l=ba(e,o);for(let t=0;t<l.size;++t){const e=l.indexToLoc(t);const s=e.map(((t,e)=>t+n[e]));l.set(u.get(...s),...e)}if(o==="string"){return Lg(l.values)}return l.values}function hI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,size:i}=s;rE(o,"slice");const[c,a]=kb(o,r,i);ub(o,c,a);const u=e.data.get(o.dataId).values;const l=fI(u,c,a,o.shape,o.dtype);return e.makeTensorInfo(a,o.dtype,l)}const dI={kernelName:Rs,backendName:"cpu",kernelFunc:hI};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(t,n,e,s,o,r,i){const c=n[0];const a=r[0];const u=new Array(a);const l=new Array(c);const f=n[1];if(a===0){if(c!==0){throw new Error(vg(c))}const t=T(e,0);const n=T(o,0);return[t,[0,f],n,u,l]}let h=true;let d=0;const p=new Array(a).fill(0);for(let n=0;n<c;++n){const e=t[n*f];if(e<0){throw new Error($g(n,e))}if(e>=a){throw new Error(yg(n,e,a))}++p[e];h=h&&e>=d;d=e}let m=true;for(let t=0;t<a;++t){const n=p[t]===0;u[t]=n;m=m&&!n;p[t]=Math.max(p[t],1);if(t>0){p[t]+=p[t-1]}}if(m&&h){const n=t;const e=s;for(let t=0;t<c;++t){l[t]=t}return[n,[c,f],e,u,l]}else{const n=p[a-1];const r=T(e,n*f);const h=T(o,n);const d=new Array(a).fill(0);for(let n=0;n<c;++n){const e=t[n*f];const o=d[e];const i=(e===0?0:p[e-1])+o;d[e]++;for(let e=0;e<f;++e){r[i*f+e]=t[n*f+e]}h[i]=s[n];l[n]=i}for(let t=0;t<a;++t){const n=d[t];if(n===0){const n=t===0?0:p[t-1];r[n*f+0]=t;for(let t=1;t<f;++t){r[n*f+t]=0}h[n]=i}}return[r,[n,f],h,u,l]}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(t,n,e,s,o){const r=w(s);const i=n[0];const c=o.length;const a=[];let u=1;let l=-1;for(let t=0;t<c;++t){const n=o[t];if(n===-1){if(l!==-1){throw new Error(kg(l,t))}l=t;a.push(1)}else{if(n<0){throw new Error(Cg(t,n))}u*=n;a.push(n)}}if(l!==-1){if(u<=0){throw new Error(Ng())}const t=Math.trunc(r/u);if(u*t!==r){throw new Error(Rg(s,a))}a[l]=t}const f=w(a);if(f!==r){throw new Error(Sg(s,a))}const h=s.length;const d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t){d[t]=d[t+1]*s[t+1]}}const p=[];if(c>0){p[c-1]=1;for(let t=c-2;t>=0;--t){p[t]=p[t+1]*a[t+1]}}const m=T(e,i*c);for(let n=0;n<i;++n){let e=0;for(let s=0;s<h;++s){e+=t[n*h+s]*d[s]}for(let t=0;t<c;++t){m[n*c+t]=Math.trunc(e/p[t]);e%=p[t]}}return[m,[i,c],a]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(t,n,e,s,o,r=false,i=0){const c=s.length;const a=[n[0],t.length/n[0]];const u=a[1];const l=c>0?o[c-1]+1:0;const f=l;if(f<0){throw new Error(Eg())}const h=n.slice();h[0]=f;const d=h.reduce(((t,n)=>t*n),1);const p=T(e,d);if(c===0){if(f>0){p.fill(i)}return[p,h]}if(f<=0){throw new Error(Eg())}let m=0,x=1;let b=0;let g=o[m];while(true){let n=0;if(x<c){n=o[x];if(g===n){++x;continue}if(g>=n){throw new Error(Tg())}}if(g<0||g>=f){throw new Error(Ig(g,f))}if(g>b){p.fill(i,b*u,g*u)}for(let n=m;n<x;++n){const e=s[n];if(e<0||e>=a[0]){throw new Error(Ag(n,s[n],a[0]))}for(let n=0;n<u;n++){p[g*u+n]+=t[e*u+n]}}if(r){for(let t=0;t<u;t++){p[g*u+t]/=x-m}}m=x;++x;b=g+1;g=n;if(x>c){break}}if(b<f){p.fill(i,b*u,f*u)}return[p,h]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI=FE((t=>Math.sqrt(t)));const gI=_E(Os,(t=>Math.sqrt(t)));const wI={kernelName:Os,backendName:"cpu",kernelFunc:gI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vI=fE(((t,n)=>{const e=t-n;return e*e}));const $I=yE(Ws,vI);const yI={kernelName:Ws,backendName:"cpu",kernelFunc:$I};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kI=FE(((t,n)=>{const{pattern:e,replaceGlobal:s,rewrite:o}=n;return t.replace(new RegExp(e,s?"g":""),o)}));const CI=ME(Us,kI);const NI={kernelName:Us,backendName:"cpu",kernelFunc:CI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(t,n,e,s){const o=ba(t,n.dtype);for(let t=0;t<o.size;t++){const r=o.indexToLoc(t);const i=new Array(r.length);for(let t=0;t<i.length;t++){i[t]=r[t]*e[t]+s[t]}o.set(n.get(...i),...r)}return o}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SI{constructor(t,n,e,s,o,r){this.separator=Qo(t);this.nGramWidths=n;this.leftPad=Qo(e);this.rightPad=Qo(s);this.padWidth=o;this.preserveShort=r}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const e=this.getPadWidth(n);return Math.max(0,t+2*e-n+1)}createNGrams(t,n,e,s,o,r){for(let i=0;i<o;++i){const c=this.getPadWidth(r);const a=Math.max(0,c-i);const u=Math.max(0,c-(o-(i+1)));const l=r-(a+u);const f=n+(a>0?0:i-c);let h=0;h+=a*this.leftPad.length;for(let n=0;n<l;++n){h+=t[f+n].length}h+=u*this.rightPad.length;const d=a+u+l-1;h+=d*this.separator.length;e[s+i]=new Uint8Array(h);const p=e[s+i];let m=0;const x=t=>t.forEach((t=>p[m++]=t));for(let t=0;t<a;++t){x(this.leftPad);x(this.separator)}for(let n=0;n<l-1;++n){x(t[f+n]);x(this.separator)}if(l>0){x(t[f+l-1]);for(let t=0;t<u;++t){x(this.separator);x(this.rightPad)}}else{for(let t=0;t<u-1;++t){x(this.rightPad);x(this.separator)}x(this.rightPad)}}}compute(t,n){const e=t.length;const s=n.length;if(s>0){let t=n[0];if(t!==0){throw new Error(`First split value must be 0, got ${t}`)}for(let o=1;o<s;++o){let s=n[o]>=t;s=s&&n[o]<=e;if(!s){throw new Error(`Invalid split value ${n[o]}, must be in [${t}, ${e}]`)}t=n[o]}if(t!==e){throw new Error(`Last split value must be data size. Expected ${e}, got ${t}`)}}const o=s-1;const r=T("int32",s);if(e===0||s===0){const t=new Array(e);for(let t=0;t<=o;++t){r[t]=0}return[t,r]}r[0]=0;for(let t=1;t<=o;++t){const e=n[t]-n[t-1];let s=0;this.nGramWidths.forEach((t=>{s+=this.getNumNGrams(e,t)}));if(this.preserveShort&&e>0&&s===0){s=1}r[t]=r[t-1]+s}const i=new Array(r[o]);for(let e=0;e<o;++e){const s=n[e];let o=r[e];this.nGramWidths.forEach((r=>{const c=n[e+1]-n[e];const a=this.getNumNGrams(c,r);this.createNGrams(t,s,i,o,a,r);o+=a}));if(this.preserveShort&&o===r[e]){const r=n[e+1]-n[e];if(r===0){continue}const c=r+2*this.padWidth;const a=1;this.createNGrams(t,s,i,o,a,c)}}return[i,r]}}function EI(t,n,e,s,o,r,i,c){return new SI(e,s,o,r,i,c).compute(t,n)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(t,n,e,s){if(!t.length){return}if(n.length===0){for(let n=0;n<t.length;++n){s.push(t.subarray(n,n+1))}return}if(n.length===1){const o=n[0];let r=t.indexOf(o);while(r!==-1){const n=t.subarray(0,r);if(!e||n.length!==0){s.push(n)}t=t.subarray(r+1);r=t.indexOf(o)}if(!e||t.length!==0){s.push(t)}return}let o=0;for(let r=0;r<t.length+1;r++){if(r===t.length||n.indexOf(t[r])!==-1){const n=t.subarray(o,r);if(!e||n.length!==0){s.push(n)}o=r+1}}}function II(t,n,e){const s=t.length;const o=[];let r=0;let i=0;const c=new Array(s);for(let a=0;a<s;++a){const s=o.length;TI(t[a],n,e,o);const u=o.length-s;c[a]=u;r+=u;i=Math.max(i,u)}const a=T("int32",r*2);const u=new Array(r);const l=[s,i];let f=0;for(let t=0;t<s;++t){for(let n=0;n<c[t];++n){a[f*2]=t;a[f*2+1]=n;u[f]=o[f];++f}}return[a,u,l]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(t,n){const e=T("int32",t.length);for(let s=0;s<t.length;++s){e[s]=Xo(t[s]).modulo(n).getLowBitsUnsigned()}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OI=fE(((t,n)=>t-n));const FI=kE(((t,n,e,s)=>({real:t-e,imag:n-s})));const _I=yE(Ks,OI,FI);const MI={kernelName:Ks,backendName:"cpu",kernelFunc:_I};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++){e[s]=t.shape[s]*n[s]}const s=ba(e,t.dtype);for(let n=0;n<s.values.length;++n){const e=s.indexToLoc(n);const o=new Array(t.rank);for(let n=0;n<o.length;n++){o[n]=e[n]%t.shape[n]}const r=t.locToIndex(o);s.values[n]=t.values[r]}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LI=(t,n)=>{const e=n.value-t.value;return e===0?t.index-n.index:e};function zI(t,n,e=0,s=t.length-1){while(s>e){if(s-e>600){const o=s-e+1;const r=n-e+1;const i=Math.log(o);const c=.5*Math.exp(2*i/3);const a=.5*Math.sqrt(i*c*(o-c)/o)*Math.sign(r-o/2);const u=Math.max(e,Math.floor(n-r*c/o+a));const l=Math.min(s,Math.floor(n+(o-r)*c/o+a));zI(t,n,u,l)}const o=t[n];let r=e;let i=s;p(t,e,n);if(LI(t[s],o)>0){p(t,e,s)}while(r<i){p(t,r,i);r++;i--;while(LI(t[r],o)<0){r=r+1}while(LI(t[i],o)>0){i=i-1}}if(LI(t[e],o)===0){p(t,e,i)}else{i=i+1;p(t,i,s)}if(i<=n){e=i+1}if(n<=i){s=i-1}}}function PI(t,n,e,s,o){const r=n[n.length-1];const[i,c]=[t.length/r,r];const a=E(e,i*s);const u=E("int32",i*s);for(let n=0;n<i;n++){const e=n*c;const r=t.subarray(e,e+c);let i=new Array(r.length);r.forEach(((t,n)=>i[n]={value:t,index:n}));if(s<i.length){zI(i,s);i=i.slice(0,s)}if(o){i.sort(LI)}const l=n*s;const f=a.subarray(l,l+s);const h=u.subarray(l,l+s);for(let t=0;t<s;t++){f[t]=i[t].value;h[t]=i[t].index}}const l=n.slice();l[l.length-1]=s;return[ba(l,e,a),ba(l,"int32",u)]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(t,n,e,s){const o=R(n,e)[0];const r=[1,e[0],1];for(let t=0;t<o;t++){r[0]*=e[t]}r[1]=e[o];for(let t=o+1;t<e.length;t++){r[2]*=e[t]}const i=new Map;const c=new Int32Array(e[o]);const a=new br(r,s,t);const u=[];const l=r[0]===1&&r[2]===1;for(let n=0;n<e[o];n++){let e;if(l){e=t[n].toString()}else{const t=[];for(let e=0;e<r[0];e++){for(let s=0;s<r[2];s++){t.push(a.get(e,n,s))}}e=t.join(",")}const s=i.get(e);if(s!=null){c[n]=s}else{const t=i.size;i.set(e,t);c[n]=t;u.push(n)}}const f=r.slice();f[1]=i.size;const h=new br(f,s);u.forEach(((t,n)=>{for(let e=0;e<r[0];e++){for(let s=0;s<r[2];s++){h.set(a.get(e,t,s),e,n,s)}}}));const d=e.slice();d[o]=f[1];return{outputValues:h.values,outputShape:d,indices:c}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var BI=Object.freeze({__proto__:null,addImpl:CE,bincountImpl:EE,bincountReduceImpl:TE,bitwiseAndImpl:IE,castImpl:wE,ceilImpl:DE,concatImpl:PE,equalImpl:VE,expImpl:GE,expm1Impl:jE,floorDivImpl:ZE,floorImpl:KE,gatherNdImpl:nT,gatherV2Impl:eT,greaterEqualImpl:iT,greaterImpl:sT,lessEqualImpl:hT,lessImpl:uT,linSpaceImpl:mT,logImpl:xT,maxImpl:wT,maximumImpl:vT,minimumImpl:kT,multiplyImpl:RT,negImpl:IT,notEqualImpl:FT,prodImpl:PT,raggedGatherImpl:KT,raggedRangeImpl:YT,raggedTensorToTensorImpl:eI,rangeImpl:sI,rsqrtImpl:oI,scatterImpl:cI,sigmoidImpl:aI,simpleAbsImpl:aE,sliceImpl:fI,sparseFillEmptyRowsImpl:pI,sparseReshapeImpl:mI,sparseSegmentReductionImpl:xI,sqrtImpl:bI,squaredDifferenceImpl:vI,staticRegexReplaceImpl:kI,stridedSliceImpl:RI,stringNGramsImpl:EI,stringSplitImpl:II,stringToHashBucketFastImpl:AI,subImpl:OI,tileImpl:DI,topKImpl:PI,transposeImpl:DT,uniqueImpl:VI});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Rc("cpu",(()=>new cE),1);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WI=_E(Zn,(t=>t>=0?t:Math.exp(t)-1));const GI={kernelName:Zn,backendName:"cpu",kernelFunc:WI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{alpha:r}=s;rE([o],"leakyRelu");const i=w(o.shape);const c=e.data.get(o.dataId).values;const a=E("float32",i);for(let t=0;t<c.length;t++){a[t]=c[t]<0?r*c[t]:c[t]}return e.makeTensorInfo(o.shape,"float32",a)}const HI={kernelName:$e,backendName:"cpu",kernelFunc:UI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jI=fE(((t,n)=>t<0?n*t:t));function qI(t){const{inputs:n,backend:e}=t;const{x:s,alpha:o}=n;rE([s,o],"prelu");const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const[c,a]=jI(s.shape,o.shape,r,i,"float32");return e.makeTensorInfo(a,"float32",c)}const XI={kernelName:ss,backendName:"cpu",kernelFunc:qI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KI=_E(fs,(t=>Math.max(0,t)));const JI={kernelName:fs,backendName:"cpu",kernelFunc:KI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YI=_E(bs,(t=>Math.min(Math.max(0,t),6)));const ZI={kernelName:bs,backendName:"cpu",kernelFunc:YI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(t,n,e,s,o){if(e==="linear"){return mE({inputs:{x:n},backend:t})}else if(e==="relu"){return KI({inputs:{x:n},backend:t})}else if(e==="elu"){return WI({inputs:{x:n},backend:t})}else if(e==="relu6"){return YI({inputs:{x:n},backend:t})}else if(e==="prelu"){return qI({inputs:{x:n,alpha:s},backend:t})}else if(e==="leakyrelu"){return UI({inputs:{x:n},backend:t,attrs:{alpha:o}})}else if(e==="sigmoid"){return uI({inputs:{x:n},backend:t})}throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{shape:r}=s;const i=w(o.shape);const c=N(r,i);const a=w(c);x(i===a,(()=>`The new shape (${c}) has ${a} elements and the old `+`shape (${o.shape}) has ${i} elements. The new shape and old `+`shape must have the same number of elements.`));e.incRef(o.dataId);const u=e.data.get(o.dataId);if(u.complexTensorInfos!=null){const t=u.complexTensorInfos.real;const n=u.complexTensorInfos.imag;t.shape=c;n.shape=c}return{dataId:o.dataId,shape:c,dtype:o.dtype}}const nA={kernelName:hs,backendName:"cpu",kernelFunc:tA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r}=n;const{transposeA:i,transposeB:c}=s;rE([o,r],"matMul");const a=o.shape.length;const u=r.shape.length;const l=i?o.shape[a-2]:o.shape[a-1];const f=c?r.shape[u-1]:r.shape[u-2];const h=i?o.shape[a-1]:o.shape[a-2];const d=c?r.shape[u-2]:r.shape[u-1];const p=o.shape.slice(0,-2);const m=r.shape.slice(0,-2);const b=w(p);const g=w(m);const v=Gl(o.shape.slice(0,-2),r.shape.slice(0,-2));const $=v.concat([h,d]);x(l===f,(()=>`Error in matMul: inner shapes (${l}) and (`+`${f}) of Tensors with shapes ${o.shape} and `+`${r.shape} and transposeA=${i}`+` and transposeB=${c} must match.`));const y=i?[b,l,h]:[b,h,l];const k=c?[g,d,f]:[g,f,d];const C=tA({inputs:{x:o},backend:e,attrs:{shape:y}});const N=tA({inputs:{x:r},backend:e,attrs:{shape:k}});const R=i?C.shape[1]:C.shape[2];const S=i?C.shape[2]:C.shape[1];const E=c?N.shape[1]:N.shape[2];const T=Math.max(b,g);const I=e.data.get(C.dataId).values;const A=e.data.get(N.dataId).values;const O=B(C.shape);const F=B(N.shape);const[_,M,D]=i?[O[0],1,O[1]]:[O[0],O[1],1];const[L,z,P]=c?[1,F[1],F[0]]:[F[1],1,F[0]];const V=S*E;const W=ba([T,S,E],C.dtype);const G=W.values;const U=e.blockSize;for(let t=0;t<T;t++){const n=t%b;const e=t%g;for(let s=0;s<S;s+=U){const o=Math.min(s+U,S);for(let r=0;r<E;r+=U){const i=Math.min(r+U,E);for(let c=0;c<R;c+=U){const a=Math.min(c+U,R);for(let u=s;u<o;u++){for(let s=r;s<i;s++){let o=0;for(let t=c;t<a;t++){const r=I[n*_+u*M+t*D];const i=A[t*L+s*z+e*P];o+=r*i}G[t*V+(u*E+s)]+=o}}}}}}e.disposeIntermediateTensorInfo(C);e.disposeIntermediateTensorInfo(N);return e.makeTensorInfo($,W.dtype,W.values)}const sA={kernelName:bn,backendName:"cpu",kernelFunc:eA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r,bias:i,preluActivationWeights:c}=n;const{transposeA:a,transposeB:u,activation:l,leakyreluAlpha:f}=s;let h;let d;let p;const m=[];const x=eA({inputs:{a:o,b:r},attrs:{transposeA:a,transposeB:u},backend:e});h=x;if(i){d=RE({inputs:{a:h,b:i},backend:e});m.push(h);h=d}if(l){p=QI(e,h,l,c,f);m.push(h);h=p}for(const t of m){e.disposeIntermediateTensorInfo(t)}return h}const rA={kernelName:uo,backendName:"cpu",kernelFunc:oA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iA=_E(Qt,(t=>Math.acos(t)));const cA={kernelName:Qt,backendName:"cpu",kernelFunc:iA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aA=_E(tn,(t=>Math.acosh(t)));const uA={kernelName:tn,backendName:"cpu",kernelFunc:aA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(t){const{inputs:n,backend:e}=t;const s=n;rE(n,"addN");const o=s.map((t=>e.data.get(t.dataId).values));const r=ba(s[0].shape,s[0].dtype);const i=r.values;for(let t=0;t<s.length;t++){const n=o[t];for(let t=0;t<i.length;t++){i[t]+=n[t]}}return e.makeTensorInfo(r.shape,r.dtype,r.values)}const fA={kernelName:en,backendName:"cpu",kernelFunc:lA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;rE(o,"all");const c=R(r,o.shape);let a=c;const u=hf(a,o.shape.length);let l=o;if(u!=null){l=LT({inputs:{x:o},backend:e,attrs:{perm:u}});a=pf(a.length,o.shape.length)}ff("all",a,l.shape.length);const[f,h]=uf(l.shape,a);const d=w(h);const p=j(w(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];e=e&&s}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=lf(f,c);const n=tA({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const dA={kernelName:sn,backendName:"cpu",kernelFunc:hA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;rE(o,"any");const c=R(r,o.shape);let a=c;const u=hf(a,o.shape.length);let l=o;if(u!=null){l=LT({inputs:{x:o},backend:e,attrs:{perm:u}});a=pf(a.length,o.shape.length)}ff("any",a,l.shape.length);const[f,h]=uf(l.shape,a);const d=w(h);const p=j(w(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];e=e||s}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=lf(f,c);const n=tA({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const mA={kernelName:on,backendName:"cpu",kernelFunc:pA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;rE(o,"argMax");let i=R(r,o.shape);const c=hf(i,o.shape.length);let a=o;const u=[];if(c!=null){a=LT({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=pf(i.length,a.shape.length)}i=[i[0]];ff("argMax",i,a.shape.length);const[l,f]=uf(a.shape,i);const h=w(l);const d=j(h,"int32");const p=w(f);const m=e.data.get(a.dataId).values;for(let t=0;t<d.length;++t){const n=t*p;let e=m[n];let s=0;for(let t=0;t<p;++t){const o=m[n+t];if(o>e){e=o;s=t}}d[t]=s}u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(l,"int32",d)}const bA={kernelName:rn,backendName:"cpu",kernelFunc:xA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;rE(o,"argMin");let i=R(r,o.shape);const c=hf(i,o.shape.length);let a=o;const u=[];if(c!=null){a=LT({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=pf(i.length,a.shape.length)}i=[i[0]];ff("argMin",i,a.shape.length);const[l,f]=uf(a.shape,i);const h=w(l);const d=j(h,"int32");const p=w(f);const m=e.data.get(a.dataId).values;for(let t=0;t<d.length;++t){const n=t*p;let e=m[n];let s=0;for(let t=0;t<p;++t){const o=m[n+t];if(o<e){e=o;s=t}}d[t]=s}u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(l,"int32",d)}const wA={kernelName:cn,backendName:"cpu",kernelFunc:gA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vA=_E(an,(t=>Math.asin(t)));const $A={kernelName:an,backendName:"cpu",kernelFunc:vA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yA=_E(un,(t=>Math.asinh(t)));const kA={kernelName:un,backendName:"cpu",kernelFunc:yA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CA=_E(ln,(t=>Math.atan(t)));const NA={kernelName:ln,backendName:"cpu",kernelFunc:CA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RA=fE(((t,n)=>Math.atan2(t,n)));const SA=yE(hn,RA);const EA={kernelName:hn,backendName:"cpu",kernelFunc:SA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TA=_E(fn,(t=>Math.atanh(t)));const IA={kernelName:fn,backendName:"cpu",kernelFunc:TA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(t,n,e,s,o,r){const i=o.strideHeight;const c=o.strideWidth;const a=o.dilationHeight;const u=o.dilationWidth;const l=o.effectiveFilterHeight;const f=o.effectiveFilterWidth;const h=o.padInfo.top;const d=o.padInfo.left;const p=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const m=ba(o.outShape,e);const x=m.values;const b=o.outShape[1]*o.outShape[2]*o.outShape[3];const g=o.outShape[2]*o.outShape[3];const w=o.outShape[3];for(let n=0;n<o.batchSize;++n){const e=n*b;const m=n*s[0];for(let n=0;n<o.inChannels;++n){for(let b=0;b<o.outHeight;++b){const v=b*i-h;const $=Math.max(0,v);const y=Math.min(o.inHeight,l+v);const k=e+b*g;for(let e=0;e<o.outWidth;++e){const i=e*c-d;const l=Math.max(0,i);const h=Math.min(o.inWidth,f+i);let b=p;let g=0;let v=0;for(let e=$;e<y;e+=a){const o=m+e*s[1];for(let e=l;e<h;e+=u){const i=o+e*s[2];const c=t[i+n];if(r==="max"&&c>b){b=c}else if(r==="avg"){g+=c;v++}}if(isNaN(b)){break}}const C=k+e*w+n;x[C]=r==="avg"?g/v:b}}}}return m}function OA(t,n,e,s,o=false,r=false){const i=ba(s.outShape,"int32");const c=s.strideHeight;const a=s.strideWidth;const u=s.dilationHeight;const l=s.dilationWidth;const f=s.effectiveFilterHeight;const h=s.effectiveFilterWidth;const d=s.padInfo.top;const p=s.padInfo.left;const m=ba(n,e,t);for(let t=0;t<s.batchSize;++t){for(let n=0;n<s.inChannels;++n){for(let e=0;e<s.outHeight;++e){const x=e*c-d;let b=x;while(b<0){b+=u}const g=Math.min(s.inHeight,f+x);for(let c=0;c<s.outWidth;++c){const f=c*a-p;let d=f;while(d<0){d+=l}const w=Math.min(s.inWidth,h+f);let v=Number.NEGATIVE_INFINITY;let $=-1;for(let e=b;e<g;e+=u){const i=e-x;for(let c=d;c<w;c+=l){const a=c-f;const u=m.get(t,e,c,n);if(u>v){v=u;if(o){$=r?((t*s.inHeight+e)*s.inWidth+c)*s.inChannels+n:(e*s.inWidth+c)*s.inChannels+n}else{$=i*h+a}}}}i.set($,t,e,c,n)}}}}return i}function FA(t,n,e,s,o,r){const i=o.strideDepth;const c=o.strideHeight;const a=o.strideWidth;const u=o.dilationDepth;const l=o.dilationHeight;const f=o.dilationWidth;const h=o.effectiveFilterDepth;const d=o.effectiveFilterHeight;const p=o.effectiveFilterWidth;const m=o.padInfo.front;const x=o.padInfo.top;const b=o.padInfo.left;const g=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const w=ba(o.outShape,e);const v=w.values;const $=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4];const y=o.outShape[2]*o.outShape[3]*o.outShape[4];const k=o.outShape[3]*o.outShape[4];const C=o.outShape[4];for(let n=0;n<o.batchSize;++n){const e=n*$;const w=n*s[0];for(let n=0;n<o.inChannels;++n){for(let $=0;$<o.outDepth;++$){const N=$*i-m;let R=N;while(R<0){R+=u}const S=Math.min(o.inDepth,h+N);const E=e+$*y;for(let e=0;e<o.outHeight;++e){const i=e*c-x;let h=i;while(h<0){h+=l}const m=Math.min(o.inHeight,d+i);const $=E+e*k;for(let e=0;e<o.outWidth;++e){const i=e*a-b;let c=i;while(c<0){c+=f}const d=Math.min(o.inWidth,p+i);const x=$+e*C;let y=g;let k=0;let N=0;for(let e=R;e<S;e+=u){const o=w+e*s[1];for(let e=h;e<m;e+=l){const i=o+e*s[2];for(let e=c;e<d;e+=f){const o=i+e*s[3];const c=t[o+n];if(r==="max"&&c>y){y=c}else if(r==="avg"){k+=c;N++}if(isNaN(y)){break}}if(isNaN(y)){break}}if(isNaN(y)){break}}const E=x+n;v[E]=r==="avg"?k/Math.max(N,1):y}}}}}return w}function _A(t,n){const e=ba(n.outShape,"int32");const s=n.strideDepth;const o=n.strideHeight;const r=n.strideWidth;const i=n.dilationDepth;const c=n.dilationHeight;const a=n.dilationWidth;const u=n.effectiveFilterDepth;const l=n.effectiveFilterHeight;const f=n.effectiveFilterWidth;const h=n.padInfo.front;const d=n.padInfo.top;const p=n.padInfo.left;for(let m=0;m<n.batchSize;++m){for(let x=0;x<n.inChannels;++x){for(let b=0;b<n.outDepth;++b){const g=b*s-h;let w=g;while(w<0){w+=i}const v=Math.min(n.inDepth,u+g);for(let s=0;s<n.outHeight;++s){const u=s*o-d;let h=u;while(h<0){h+=c}const $=Math.min(n.inHeight,l+u);for(let o=0;o<n.outWidth;++o){const d=o*r-p;let y=d;while(y<0){y+=a}const k=Math.min(n.inWidth,f+d);let C=Number.NEGATIVE_INFINITY;let N=-1;for(let n=w;n<v;n+=i){const e=n-g;for(let s=h;s<$;s+=c){const o=s-u;for(let r=y;r<k;r+=a){const i=r-d;const c=t.get(m,n,s,r,x);if(c>=C){C=c;N=e*l*f+o*l+i}}}}e.set(N,m,b,s,o,x)}}}}}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;rE(o,"avgPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;x(bu(i,u),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=su(o.shape,r,i,u,c,a);let f;if(l.filterWidth===1&&l.filterHeight===1&&v(l.inShape,l.outShape)){f=mE({inputs:{x:o},backend:e})}else{const t=e.data.get(o.dataId).values;const n=B(o.shape);const s=AA(t,o.shape,o.dtype,n,l,"avg");f=e.makeTensorInfo(l.outShape,o.dtype,s.values)}return f}const DA={kernelName:dn,backendName:"cpu",kernelFunc:MA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;rE(o,"avgPool3d");const l=ou(o.shape,r,i,1,c,a,u);const f=e.data.get(o.dataId).values;const h=FA(f,o.shape,o.dtype,B(o.shape),l,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}const zA={kernelName:mn,backendName:"cpu",kernelFunc:LA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const{filterSize:i,strides:c,pad:a,dimRoundingMode:u}=s;rE([o,r],"avgPool3DGrad");const l=ou(r.shape,i,c,1,a,u);const f=l.strideDepth;const h=l.strideHeight;const d=l.strideWidth;const p=l.filterDepth;const m=l.filterHeight;const x=l.filterWidth;const b=l.dilationDepth;const g=l.dilationHeight;const w=l.dilationWidth;const v=l.effectiveFilterDepth;const $=l.effectiveFilterHeight;const y=l.effectiveFilterWidth;const k=v-1-l.padInfo.front;const C=y-1-l.padInfo.left;const N=$-1-l.padInfo.top;const R=ba(r.shape,"float32");const S=1/(p*m*x);const E=e.bufferSync(o);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inDepth;++e){for(let s=0;s<l.inHeight;++s){for(let o=0;o<l.inWidth;++o){const r=e-k;const i=s-N;const c=o-C;let a=0;for(let e=0;e<v;e+=b){const s=(r+e)/f;if(s<0||s>=l.outDepth||Math.floor(s)!==s){continue}for(let e=0;e<$;e+=g){const o=(i+e)/h;if(o<0||o>=l.outHeight||Math.floor(o)!==o){continue}for(let e=0;e<y;e+=w){const r=(c+e)/d;if(r<0||r>=l.outWidth||Math.floor(r)!==r){continue}const i=E.get(t,s,o,r,n);a+=i}}}R.set(a*S,t,e,s,o,n)}}}}}return e.makeTensorInfo(R.shape,R.dtype,R.values)}const VA={kernelName:xn,backendName:"cpu",kernelFunc:PA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;rE([o,r],"avgPoolGrad");const{filterSize:c,strides:a,pad:u}=s;const l=su(i.shape,c,a,1,u);const f=l.strideHeight;const h=l.strideWidth;const d=l.filterHeight;const p=l.filterWidth;const m=l.dilationHeight;const x=l.dilationWidth;const b=l.effectiveFilterHeight;const g=l.effectiveFilterWidth;const w=g-1-l.padInfo.left;const v=b-1-l.padInfo.top;const $=ba(i.shape,"float32");const y=1/(d*p);const k=e.data.get(o.dataId).values;const C=ba(o.shape,"float32",k);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inHeight;++e){for(let s=0;s<l.inWidth;++s){const o=e-v;const r=s-w;let i=0;for(let e=0;e<b;e+=m){const s=(o+e)/f;if(s<0||s>=l.outHeight||Math.floor(s)!==s){continue}for(let e=0;e<g;e+=x){const o=(r+e)/h;if(o<0||o>=l.outWidth||Math.floor(o)!==o){continue}const c=C.get(t,s,o,n);i+=c}}$.set(i*y,t,e,s,n)}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const WA={kernelName:pn,backendName:"cpu",kernelFunc:BA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,scale:r,offset:i,mean:c,variance:a}=n;x(c.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));x(i==null||c.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));x(r==null||c.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));rE([o,c,a,r,i],"batchNorm");let{varianceEpsilon:u}=s;if(u==null){u=.001}const l=e.data.get(o.dataId).values;const f=e.data.get(c.dataId).values;const h=e.data.get(a.dataId).values;const d=r?e.data.get(r.dataId).values:new Float32Array([1]);const p=i?e.data.get(i.dataId).values:new Float32Array([0]);const m=new Float32Array(l.length);const b=p.length;const g=d.length;const w=h.length;const v=f.length;let $=0;let y=0;let k=0;let C=0;for(let t=0;t<l.length;++t){m[t]=p[$++]+(l[t]-f[y++])*d[k++]/Math.sqrt(h[C++]+u);if($>=b){$=0}if(y>=v){y=0}if(k>=g){k=0}if(C>=w){C=0}}return e.makeTensorInfo(o.shape,o.dtype,m)}const UA={kernelName:le,backendName:"cpu",kernelFunc:GA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,crops:i}=s;rE([o],"batchToSpaceND");const c=r.reduce(((t,n)=>t*n));const a=Wb(o.shape,r,c);const u=Gb(a.length,r.length);const l=Ub(o.shape,r,c);const f=Hb(i,r.length);const h=jb(l,i,r.length);const d=tA({inputs:{x:o},backend:e,attrs:{shape:a}});const p=LT({inputs:{x:d},backend:e,attrs:{perm:u}});const m=tA({inputs:{x:p},backend:e,attrs:{shape:l}});const x=hI({inputs:{x:m},backend:e,attrs:{begin:f,size:h}});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);return x}const jA={kernelName:gn,backendName:"cpu",kernelFunc:HA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i}=s;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const u=EE(c,a,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,u)}const XA={kernelName:wn,backendName:"cpu",kernelFunc:qA};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(t){const{inputs:n,backend:e}=t;const{s0:s,s1:o}=n;const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const c=Gl(Array.from(r),Array.from(i));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const JA={kernelName:yn,backendName:"cpu",kernelFunc:KA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YA=_E(Nn,((t,n)=>{const e=n;if(t>e.clipValueMax){return e.clipValueMax}return t<e.clipValueMin?e.clipValueMin:t}));const ZA={kernelName:Nn,backendName:"cpu",kernelFunc:YA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QA=t=>{const{x:n}=t.inputs;const e=t.backend;const s=new Float32Array(w(n.shape));const o=e.data.get(n.dataId);const r=o.complexTensorInfos.real;const i=o.complexTensorInfos.imag;const c=e.data.get(r.dataId).values;const a=e.data.get(i.dataId).values;for(let t=0;t<c.length;t++){const n=c[t];const e=a[t];s[t]=Math.hypot(n,e)}return e.makeOutput(s,n.shape,"float32")};const tO={kernelName:Sn,backendName:"cpu",kernelFunc:QA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.data.get(s.dataId).complexTensorInfos.imag;const r=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,r)}const eO={kernelName:be,backendName:"cpu",kernelFunc:nO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;const r=R(o,n[0].shape)[0];const i=n.map((t=>t.shape));Ob(i,r);let c=Fb(n.map((t=>t.shape)),r);if(w(c)===0){return e.makeTensorInfo(c,n[0].dtype,[])}const a=n.filter((t=>w(t.shape)>0));if(a.length===1){return mE({inputs:{x:a[0]},backend:e})}if(a[0].dtype==="complex64"){const t=a.map((t=>bE({inputs:{input:t},backend:e})));const n=a.map((t=>nO({inputs:{input:t},backend:e})));const s=sO({inputs:t,backend:e,attrs:{axis:r}});const o=sO({inputs:n,backend:e,attrs:{axis:r}});const i=hE({inputs:{real:s,imag:o},backend:e});t.forEach((t=>e.disposeIntermediateTensorInfo(t)));n.forEach((t=>e.disposeIntermediateTensorInfo(t)));e.disposeIntermediateTensorInfo(s);e.disposeIntermediateTensorInfo(o);return i}const u=a.map((t=>{const n=w(t.shape.slice(r));const s=[-1,n];return tA({inputs:{x:t},backend:e,attrs:{shape:s}})}));const l=u.map((t=>({vals:e.data.get(t.dataId).values,shape:t.shape})));c=Fb(u.map((t=>t.shape)),1);const f=u[0].shape[0]===1;const h=PE(l,c,n[0].dtype,f);const d=Fb(a.map((t=>t.shape)),r);const p=e.makeTensorInfo(d,n[0].dtype,h);u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return p}const oO={kernelName:En,backendName:"cpu",kernelFunc:sO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dataFormat:a,dilations:u,dimRoundingMode:l}=s;rE([o,r],"conv2d");const f=wu(a);const h=ru(o.shape,r.shape,i,u,c,l,false,f);const d=h.filterHeight;const p=h.filterWidth;const m=h.dilationHeight;const x=h.dilationWidth;const b=h.padInfo.left;const g=h.padInfo.top;const w=h.dataFormat==="channelsLast";const v=new br(h.outShape,o.dtype);const $=B(o.shape);const y=B(r.shape);const k=$[0];const C=w?$[1]:$[2];const N=w?$[2]:1;const R=w?1:$[1];const S=v.strides[0];const E=w?v.strides[1]:v.strides[2];const T=w?v.strides[2]:1;const I=w?1:v.strides[1];const A=e.data.get(o.dataId).values;const O=e.data.get(r.dataId).values;const F=v.values;for(let t=0;t<h.batchSize;++t){const n=t*k;const e=t*S;for(let t=0;t<h.outHeight;++t){const s=e+t*E;const o=t*h.strideHeight-g;for(let t=0;t<d;++t){const e=o+t*m;if(e<0||e>=h.inHeight){continue}const r=t*y[0];const i=n+e*C;for(let t=0;t<h.outWidth;++t){const n=s+t*T;const e=t*h.strideWidth-b;for(let t=0;t<p;++t){const s=e+t*x;if(s<0||s>=h.inWidth){continue}const o=r+t*y[1];const c=i+s*N;let a=o;for(let t=0;t<h.inChannels;++t){const e=A[c+t*R];for(let t=0;t<h.outChannels;++t){F[n+t*I]+=e*O[a+t]}a+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,F)}const iO={kernelName:Tn,backendName:"cpu",kernelFunc:rO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,dataFormat:a,dimRoundingMode:u,filterShape:l}=s;rE([o,r],"conv2dBackpropFilter");const f=wu(a);const h=ru(o.shape,l,i,1,c,u,false,f);const{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:x}=h;const b=h.dataFormat==="channelsLast";const g=new br(h.filterShape,"float32");const w=h.padInfo.left;const v=h.padInfo.top;const $=e.data.get(o.dataId).values;const y=e.data.get(r.dataId).values;const k=new br(o.shape,o.dtype,$);const C=new br(r.shape,r.dtype,y);for(let t=0;t<m;++t){const n=Math.max(0,Math.ceil((v-t)/d));const e=Math.min(h.outHeight,(h.inHeight+v-t)/d);for(let s=0;s<x;++s){const o=Math.max(0,Math.ceil((w-s)/p));const r=Math.min(h.outWidth,(h.inWidth+w-s)/p);for(let i=0;i<h.inChannels;++i){for(let c=0;c<h.outChannels;++c){let a=0;for(let u=0;u<h.batchSize;++u){for(let l=n;l<e;++l){const n=t+l*d-v;for(let t=o;t<r;++t){const e=s+t*p-w;if(b){a+=k.get(u,n,e,i)*C.get(u,l,t,c)}else{a+=k.get(u,i,n,e)*C.get(u,c,l,t)}}}}g.set(a,t,s,i,c)}}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const aO={kernelName:In,backendName:"cpu",kernelFunc:cO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{inputShape:i,strides:c,pad:a,dataFormat:u,dimRoundingMode:l}=s;rE([o,r],"conv2dBackpropInput");const f=B(r.shape);const h=B(o.shape);let d=wu(u);const p=ru(i,r.shape,c,1,a,l,false,d);const m=new br(p.inShape,"float32");const x=m.values;const b=e.data.get(o.dataId).values;const g=e.data.get(r.dataId).values;const[w,v,$]=f;const{batchSize:y,filterHeight:k,filterWidth:C,inChannels:N,inHeight:R,inWidth:S,outChannels:E,outHeight:T,outWidth:I,strideHeight:A,strideWidth:O}=p;d=p.dataFormat;const F=k-1-p.padInfo.top;const _=C-1-p.padInfo.left;const M=d==="channelsLast";const D=m.strides[0];const L=M?m.strides[1]:m.strides[2];const z=M?m.strides[2]:1;const P=M?1:m.strides[1];const V=h[0];const W=M?h[1]:h[2];const G=M?h[2]:1;const U=M?1:h[1];for(let t=0;t<y;++t){for(let n=0;n<N;++n){for(let e=0;e<R;++e){const s=e-F;const o=Math.max(0,Math.ceil(s/A));const r=Math.min(T,(k+s)/A);for(let i=0;i<S;++i){const c=i-_;const a=Math.max(0,Math.ceil(c/O));const u=Math.min(I,(C+c)/O);let l=0;for(let e=o;e<r;++e){const o=e*A-s;for(let s=a;s<u;++s){const r=s*O-c;const i=V*t+W*e+G*s;const a=w*(k-1-o)+v*(C-1-r)+$*n;for(let t=0;t<E;++t){const n=b[i+U*t];const e=g[a+t];l+=n*e}}}const f=D*t+L*e+z*i+P*n;x[f]=l}}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const lO={kernelName:An,backendName:"cpu",kernelFunc:uO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;rE([o,r],"conv3d");const u=iu(o.shape,r.shape,i,a,c);const{filterDepth:l,filterHeight:f,filterWidth:h,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:x}=u;const b=x.front;const g=x.left;const w=x.top;const v=new br(u.outShape,o.dtype);const $=e.data.get(o.dataId).values;const y=e.data.get(r.dataId).values;const k=v.values;const C=B(o.shape);const N=B(r.shape);for(let t=0;t<u.batchSize;++t){const n=t*C[0];const e=t*v.strides[0];for(let t=0;t<u.outDepth;++t){const s=e+t*v.strides[1];const o=t*u.strideDepth-b;for(let t=0;t<l;++t){const e=o+t*d;if(e<0||e>=u.inDepth){continue}const r=t*N[0];const i=n+e*C[1];for(let t=0;t<u.outHeight;++t){const n=s+t*v.strides[2];const e=t*u.strideHeight-w;for(let t=0;t<f;++t){const s=e+t*p;if(s<0||s>=u.inHeight){continue}const o=r+t*N[1];const c=i+s*C[2];for(let t=0;t<u.outWidth;++t){const e=n+t*u.outChannels;const s=t*u.strideWidth-g;for(let t=0;t<h;++t){const n=s+t*m;if(n<0||n>=u.inWidth){continue}const r=o+t*N[2];const i=c+n*u.inChannels;let a=r;for(let t=0;t<u.inChannels;++t){const n=$[i+t];for(let t=0;t<u.outChannels;++t){k[e+t]+=n*y[a+t]}a+=u.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const hO={kernelName:On,backendName:"cpu",kernelFunc:fO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,filterShape:a}=s;rE([o,r],"conv3dBackpropFilterV2");const u=B(o.shape);const l=B(r.shape);const f=iu(o.shape,a,i,1,c);const h=f.strideDepth;const d=f.strideHeight;const p=f.strideWidth;const m=f.filterDepth;const x=f.filterHeight;const b=f.filterWidth;const g=new br(f.filterShape,"float32");const w=g.values;const[v,$,y,k]=g.strides;const C=e.data.get(r.dataId).values;const[N,R,S,E]=l;const T=e.data.get(o.dataId).values;const[I,A,O,F]=u;const _=f.padInfo.front;const M=f.padInfo.left;const D=f.padInfo.top;for(let t=0;t<m;++t){const n=Math.max(0,Math.ceil((_-t)/h));const e=Math.min(f.outDepth,(f.inDepth+_-t)/h);const s=t*v;for(let o=0;o<x;++o){const r=Math.max(0,Math.ceil((D-o)/d));const i=Math.min(f.outHeight,(f.inHeight+D-o)/d);const c=o*$+s;for(let s=0;s<b;++s){const a=Math.max(0,Math.ceil((M-s)/p));const u=Math.min(f.outWidth,(f.inWidth+M-s)/p);const l=s*y+c;for(let c=0;c<f.inChannels;++c){const m=c*k+l;for(let l=0;l<f.outChannels;++l){let x=0;for(let m=0;m<f.batchSize;++m){const f=m*I;const b=m*N;for(let m=n;m<e;++m){const n=t+m*h-_;const e=n*A+f;const g=m*R+b;for(let t=r;t<i;++t){const n=o+t*d-D;const r=n*O+e;const i=t*S+g;for(let t=a;t<u;++t){const n=s+t*p-M;const e=n*F+r;const o=t*E+i;x+=T[e+c]*C[o+l]}}}}w[m+l]=x}}}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const pO={kernelName:Fn,backendName:"cpu",kernelFunc:dO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{pad:i,strides:c,inputShape:a}=s;rE([o],"conv3dBackpropInputV2");const u=B(o.shape);const l=B(r.shape);const f=iu(a,r.shape,c,1,i);const h=new br(f.inShape,"float32");const d=h.values;const[p,m,x,b]=h.strides;const g=e.data.get(o.dataId).values;const[w,v,$,y]=u;const k=e.data.get(r.dataId).values;const[C,N,R,S]=l;const{batchSize:E,filterDepth:T,filterHeight:I,filterWidth:A,inChannels:O,inDepth:F,inHeight:_,inWidth:M,outChannels:D,outDepth:L,outHeight:z,outWidth:P,strideDepth:V,strideHeight:W,strideWidth:G}=f;const U=T-1-f.padInfo.front;const H=I-1-f.padInfo.top;const j=A-1-f.padInfo.left;for(let t=0;t<E;++t){for(let n=0;n<O;++n){for(let e=0;e<F;++e){const s=e-U;const o=Math.max(0,Math.ceil(s/V));const r=Math.min(L,(T+s)/V);for(let i=0;i<_;++i){const c=i-H;const a=Math.max(0,Math.ceil(c/W));const u=Math.min(z,(I+c)/W);for(let l=0;l<M;++l){const f=l-j;const h=Math.max(0,Math.ceil(f/G));const E=Math.min(P,(A+f)/G);let O=0;for(let e=o;e<r;++e){const o=e*V-s;for(let s=a;s<u;++s){const r=s*W-c;for(let i=h;i<E;++i){const c=i*G-f;const a=w*t+v*e+$*s+y*i;const u=C*(T-1-o)+N*(I-1-r)+R*(A-1-c)+S*n;for(let t=0;t<D;++t){const n=g[a+t];const e=k[u+t];O+=n*e}}}}d[p*t+m*e+x*i+b*l+n]=O}}}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}const xO={kernelName:_n,backendName:"cpu",kernelFunc:mO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bO=_E(Mn,(t=>Math.cos(t)));const gO={kernelName:Mn,backendName:"cpu",kernelFunc:bO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO=_E(Dn,(t=>Math.cosh(t)));const vO={kernelName:Dn,backendName:"cpu",kernelFunc:wO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $O(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o,boxes:r,boxInd:i}=n;const{cropSize:c,method:a,extrapolationValue:u}=s;const[l,f,h,d]=o.shape;const p=r.shape[0];const[m,x]=c;const b=ba([p,m,x,d],"float32");const g=e.data.get(r.dataId).values;const w=e.data.get(i.dataId).values;const v=e.data.get(o.dataId).values;const $=B(o.shape);const y=B(b.shape);for(let t=0;t<p;t++){const n=t*4;const e=g[n];const s=g[n+1];const o=g[n+2];const r=g[n+3];const i=w[t];if(i>=l){continue}const c=m>1?(o-e)*(f-1)/(m-1):0;const p=x>1?(r-s)*(h-1)/(x-1):0;for(let n=0;n<m;n++){const l=m>1?e*(f-1)+n*c:.5*(e+o)*(f-1);if(l<0||l>f-1){for(let e=0;e<x;e++){for(let s=0;s<d;s++){const o=s+e*y[2]+n*y[1]+t*y[0];b.values[o]=u}}continue}if(a==="bilinear"){const e=Math.floor(l);const o=Math.ceil(l);const c=l-e;for(let a=0;a<x;a++){const l=x>1?s*(h-1)+a*p:.5*(s+r)*(h-1);if(l<0||l>h-1){for(let e=0;e<d;e++){const s=e+a*y[2]+n*y[1]+t*y[0];b.values[s]=u}continue}const f=Math.floor(l);const m=Math.ceil(l);const g=l-f;for(let s=0;s<d;s++){let r=s+f*$[2]+e*$[1]+i*$[0];const u=v[r];r=s+m*$[2]+e*$[1]+i*$[0];const l=v[r];r=s+f*$[2]+o*$[1]+i*$[0];const h=v[r];r=s+m*$[2]+o*$[1]+i*$[0];const d=v[r];const p=u+(l-u)*g;const x=h+(d-h)*g;r=s+a*y[2]+n*y[1]+t*y[0];b.values[r]=p+(x-p)*c}}}else{for(let e=0;e<x;++e){const o=x>1?s*(h-1)+e*p:.5*(s+r)*(h-1);if(o<0||o>h-1){for(let s=0;s<d;s++){const o=s+e*y[2]+n*y[1]+t*y[0];b.values[o]=u}continue}const c=Math.round(o);const a=Math.round(l);for(let s=0;s<d;s++){const o=s+c*$[2]+a*$[1]+i*$[0];const r=s+e*y[2]+n*y[1]+t*y[0];b.values[r]=v[o]}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const yO={kernelName:Pn,backendName:"cpu",kernelFunc:$O};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;rE(o,"cumprod");const a=hf([r],o.shape.length);let u=o;if(a!=null){u=LT({inputs:{x:o},backend:e,attrs:{perm:a}})}const l=pf(1,o.shape.length)[0];if(l!==u.shape.length-1){throw new Error(`backend.cumprod in CPU expects an inner-most `+`axis=${u.shape.length-1} but got axis=${l}`)}const f=Ar(u.dtype,"int32");const h=H(w(u.shape),f);const d=e.data.get(u.dataId).values;const p=u.shape[u.shape.length-1];const m=c?(t,n)=>t+p-n-1:(t,n)=>t+n;for(let t=0;t<d.length;t+=p){for(let n=0;n<p;n++){const e=m(t,n);if(n===0){h[e]=i?1:d[e]}else{const s=m(t,n-1);h[e]=i?d[s]*h[s]:d[e]*h[s]}}}const x=e.makeTensorInfo(u.shape,f,h);if(a!=null){const t=df(a);const n=LT({inputs:{x},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(x);e.disposeIntermediateTensorInfo(u);return n}return x}const CO={kernelName:Ln,backendName:"cpu",kernelFunc:kO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;rE(o,"cumsum");const a=hf([r],o.shape.length);let u=o;if(a!=null){u=LT({inputs:{x:o},backend:e,attrs:{perm:a}})}const l=pf(1,o.shape.length)[0];if(l!==u.shape.length-1){throw new Error(`backend.cumsum in CPU expects an inner-most `+`axis=${u.shape.length-1} but got axis=${l}`)}const f=Ar(u.dtype,"int32");const h=j(w(u.shape),f);const d=e.data.get(u.dataId).values;const p=u.shape[u.shape.length-1];const m=c?(t,n)=>t+p-n-1:(t,n)=>t+n;for(let t=0;t<d.length;t+=p){for(let n=0;n<p;n++){const e=m(t,n);if(n===0){h[e]=i?0:d[e]}else{const s=m(t,n-1);h[e]=i?d[s]+h[s]:d[e]+h[s]}}}const x=e.makeTensorInfo(u.shape,f,h);if(a!=null){const t=df(a);const n=LT({inputs:{x},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(x);e.disposeIntermediateTensorInfo(u);return n}return x}const RO={kernelName:zn,backendName:"cpu",kernelFunc:NO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i,binaryOutput:c}=s;if(o.shape.length===1){const t=e.data.get(o.dataId).values;const n=e.data.get(r.dataId).values;const s=EE(t,n,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,s)}else if(o.shape.length===2){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=TE(t,n,i,c);return e.makeTensorInfo(s.shape,r.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank`+`${o.shape.length}.`)}const EO={kernelName:Vn,backendName:"cpu",kernelFunc:SO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockSize:r,dataFormat:i}=s;x(i==="NHWC",(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const c=o.shape[0];const a=o.shape[1];const u=o.shape[2];const l=o.shape[3];const f=a*r;const h=u*r;const d=l/(r*r);const p=e.data.get(o.dataId).values;const m=new Float32Array(c*f*h*d);let b=0;for(let t=0;t<c;++t){for(let n=0;n<f;++n){const e=Math.floor(n/r);const s=n%r;for(let n=0;n<h;++n){const o=Math.floor(n/r);const i=n%r;const c=(s*r+i)*d;for(let n=0;n<d;++n){const s=n+c;const r=s+l*(o+u*(e+a*t));m[b++]=p[r]}}}}return e.makeTensorInfo([c,f,h,d],o.dtype,m)}const IO={kernelName:Bn,backendName:"cpu",kernelFunc:TO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a,dimRoundingMode:u}=s;rE([o,r],"depthwiseConv2DNative");const l=B(o.shape);const f=B(r.shape);let h=a;if(h==null){h=[1,1]}x(bu(i,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${i} and dilations '${h}'`));const d=ru(o.shape,r.shape,i,h,c,u,true);const{filterHeight:p,filterWidth:m,dilationHeight:b,dilationWidth:g,padInfo:w}=d;const v=w.left;const $=w.top;const y=d.outChannels/d.inChannels;const k=new br(d.outShape,o.dtype);const C=e.data.get(o.dataId).values;const N=e.data.get(r.dataId).values;const R=k.values;for(let t=0;t<d.batchSize;++t){const n=t*l[0];const e=t*k.strides[0];for(let t=0;t<d.outHeight;++t){const s=e+t*k.strides[1];const o=t*d.strideHeight-$;for(let t=0;t<p;++t){const e=o+t*b;if(e<0||e>=d.inHeight){continue}const r=t*f[0];const i=n+e*l[1];for(let t=0;t<d.outWidth;++t){const n=s+t*k.strides[2];const e=t*d.strideWidth-v;for(let t=0;t<m;++t){const s=e+t*g;if(s<0||s>=d.inWidth){continue}const o=r+t*f[1];const c=i+s*d.inChannels;let a=n;let u=o;for(let t=0;t<d.inChannels;++t){const n=C[c+t];for(let t=0;t<y;++t){R[a+t]+=n*N[u+t]}a+=y;u+=y}}}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const OO={kernelName:Wn,backendName:"cpu",kernelFunc:AO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,filterShape:l}=s;rE([o,r],"depthwiseConv2dNativeBackpropFilter");const f=ru(o.shape,l,i,c,a,u,true);const{strideHeight:h,strideWidth:d,filterHeight:p,filterWidth:m}=f;const x=new br(f.filterShape,"float32");const b=f.padInfo.left;const g=f.padInfo.top;const w=f.outChannels/f.inChannels;const v=e.data.get(o.dataId).values;const $=new br(o.shape,o.dtype,v);const y=e.data.get(r.dataId).values;const k=new br(r.shape,r.dtype,y);for(let t=0;t<p;++t){const n=Math.max(0,Math.ceil((g-t)/h));const e=Math.min(f.outHeight,(f.inHeight+g-t)/h);for(let s=0;s<m;++s){const o=Math.max(0,Math.ceil((b-s)/d));const r=Math.min(f.outWidth,(f.inWidth+b-s)/d);for(let i=0;i<f.outChannels;++i){const c=Math.trunc(i/w);const a=i%w;let u=0;for(let a=0;a<f.batchSize;++a){for(let l=n;l<e;++l){const n=t+l*h-g;for(let t=o;t<r;++t){const e=s+t*d-b;u+=$.get(a,n,e,c)*k.get(a,l,t,i)}}}x.set(u,t,s,c,a)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const _O={kernelName:Gn,backendName:"cpu",kernelFunc:FO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MO(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,inputShape:l}=s;rE([o,r],"depthwiseConv2DNativeBackpropInput");const f=B(o.shape);const h=B(r.shape);const d=ru(l,r.shape,i,c,a,u,true);const p=new br(d.inShape,"float32");const m=p.values;const[x,b,g]=p.strides;const w=e.data.get(o.dataId).values;const[v,$,y]=f;const k=e.data.get(r.dataId).values;const[C,N,R]=h;const{batchSize:S,filterHeight:E,filterWidth:T,inChannels:I,inHeight:A,inWidth:O,outChannels:F,outHeight:_,outWidth:M,strideHeight:D,strideWidth:L}=d;const z=E-1-d.padInfo.top;const P=T-1-d.padInfo.left;const V=F/I;for(let t=0;t<S;++t){for(let n=0;n<I;++n){for(let e=0;e<A;++e){const s=e-z;const o=Math.max(0,Math.ceil(s/D));const r=Math.min(_,(E+s)/D);for(let i=0;i<O;++i){const c=i-P;const a=Math.max(0,Math.ceil(c/L));const u=Math.min(M,(T+c)/L);let l=0;for(let e=o;e<r;++e){const o=e*D-s;for(let s=a;s<u;++s){const r=s*L-c;const i=v*t+$*e+y*s;const a=C*(E-1-o)+N*(T-1-r)+R*n;for(let t=0;t<V;++t){const e=n*V+t;const s=w[i+e];const o=k[a+t];l+=s*o}}}m[x*t+b*e+g*i+n]=l}}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const DO={kernelName:Un,backendName:"cpu",kernelFunc:MO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LO(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=w(s.shape);const r=e.data.get(s.dataId).values;const i=ba([o,o],s.dtype);const c=i.values;for(let t=0;t<r.length;t++){c[t*o+t]=r[t]}const a=[...s.shape,...s.shape];return e.makeTensorInfo(a,i.dtype,i.values)}const zO={kernelName:Hn,backendName:"cpu",kernelFunc:LO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PO={kernelName:jn,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o}=t;const{strides:r,pad:i,dilations:c}=e;const a=n;const u=a.data.get(s.dataId).values;const l=s.shape.length;const f=a.data.get(o.dataId).values;const h=o.shape.length;const{batchSize:d,inHeight:p,inWidth:m,inChannels:x,outHeight:b,outWidth:g,padInfo:v,strideHeight:$,strideWidth:y,filterHeight:k,filterWidth:C,dilationHeight:N,dilationWidth:R,outShape:S}=eu(s.shape,o.shape,r,i,"NHWC",c);const E=w(S);const I=S.length;const A=T(s.dtype,E);for(let t=0;t<d;++t){for(let n=0;n<b;++n){const e=n*$-v.top;for(let r=0;r<g;++r){const i=r*y-v.left;for(let c=0;c<x;++c){let a=Number.MIN_SAFE_INTEGER;for(let n=0;n<k;++n){const r=e+n*N;if(r>=0&&r<p){for(let e=0;e<C;++e){const d=i+e*R;if(d>=0&&d<m){const i=K([t,r,d,c],l,B(s.shape));const p=K([n,e,c],h,B(o.shape));const m=u[i]+f[p];if(m>a){a=m}}}}}const d=K([t,n,r,c],I,B(S));A[d]=a}}}}const O=a.write(Yo(A,s.dtype),S,s.dtype);return{dataId:O,shape:S,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO={kernelName:Xn,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o,dy:r}=t;const{strides:i,pad:c,dilations:a}=e;const u=n;const l=G(s.shape,u.data.get(s.dataId).values);const f=G(o.shape,u.data.get(o.dataId).values);const{batchSize:h,inHeight:d,inWidth:p,inChannels:m,outHeight:b,outWidth:g,padInfo:w,strideHeight:v,strideWidth:$,filterHeight:y,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:R}=eu(s.shape,o.shape,i,c,"NHWC",a);x(r.rank===R.length,(()=>`Error in ${Xn}, dy `+`must have the same rank as output ${R.length}, but got `+`${r.rank}`));const S=G(R,u.data.get(r.dataId).values);const E=q(o.shape,o.dtype);for(let t=0;t<h;++t){for(let n=0;n<b;++n){const e=n*v-w.top;for(let s=0;s<g;++s){const o=s*$-w.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER;let c=0;let a=0;for(let n=0;n<y;++n){const s=e+n*C;if(s>=0&&s<d){for(let e=0;e<k;++e){const u=o+e*N;if(u>=0&&u<p){const o=l[t][s][u][r]+f[n][e][r];if(o>i){i=o;c=n;a=e}}}}}E[c][a][r]+=S[t][n][s][r]}}}}const T=u.write(Yo(E,s.dtype),o.shape,o.dtype);return{dataId:T,shape:o.shape,dtype:o.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BO={kernelName:qn,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o,dy:r}=t;const{strides:i,pad:c,dilations:a}=e;const u=n;const l=G(s.shape,u.data.get(s.dataId).values);const f=G(o.shape,u.data.get(o.dataId).values);const{batchSize:h,inHeight:d,inWidth:p,inChannels:m,outHeight:b,outWidth:g,padInfo:w,strideHeight:v,strideWidth:$,filterHeight:y,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:R}=eu(s.shape,o.shape,i,c,"NHWC",a);x(r.rank===R.length,(()=>`Error in ${qn}, dy `+`must have the same rank as output ${R.length}, but got `+`${r.rank}`));const S=G(R,u.data.get(r.dataId).values);const E=q(s.shape,s.dtype);for(let t=0;t<h;++t){for(let n=0;n<b;++n){const e=n*v-w.top;for(let s=0;s<g;++s){const o=s*$-w.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER;let c=e<0?0:e;let a=o<0?0:o;for(let n=0;n<y;++n){const s=e+n*C;if(s>=0&&s<d){for(let e=0;e<k;++e){const u=o+e*N;if(u>=0&&u<p){const o=l[t][s][u][r]+f[n][e][r];if(o>i){i=o;c=s;a=u}}}}}E[t][c][a][r]+=S[t][n][s][r]}}}}const T=u.write(Yo(E,s.dtype),s.shape,s.dtype);return{dataId:T,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WO(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o}=n;const{canvas:r,options:i}=s;const{contextOptions:c,imageOptions:a}=i||{};const u=(a===null||a===void 0?void 0:a.alpha)||1;const l=(c===null||c===void 0?void 0:c.contextType)||"2d";if(l!=="2d"){throw new Error(`Context type ${c.contextType} is not supported by the CPU backend.`)}const f=r.getContext(l,(c===null||c===void 0?void 0:c.contextAttributes)||{});if(f==null){throw new Error(`Could not get the context with ${l} type.`)}const[h,d]=o.shape.slice(0,2);const p=o.shape.length===2?1:o.shape[2];const m=e.data.get(o.dataId).values;const x=o.dtype==="float32"?255:1;const b=new Uint8ClampedArray(d*h*4);for(let t=0;t<h*d;++t){const n=[0,0,0,255*u];for(let e=0;e<p;e++){const s=m[t*p+e];if(o.dtype==="float32"){if(s<0||s>1){throw new Error(`Tensor values for a float32 Tensor must be in the `+`range [0 - 1] but encountered ${s}.`)}}else if(o.dtype==="int32"){if(s<0||s>255){throw new Error(`Tensor values for a int32 Tensor must be in the `+`range [0 - 255] but encountered ${s}.`)}}if(p===1){n[0]=s*x;n[1]=s*x;n[2]=s*x}else{n[e]=s*x}}const e=t*4;b[e+0]=Math.round(n[0]);b[e+1]=Math.round(n[1]);b[e+2]=Math.round(n[2]);b[e+3]=Math.round(n[3])}r.width=d;r.height=h;const g=new ImageData(b,d,h);f.putImageData(g,0,0);return o}const GO={kernelName:Kn,backendName:"cpu",kernelFunc:WO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;rE(o,"sum");let c;if(o.dtype==="bool"){c=vE({inputs:{x:o},backend:e,attrs:{dtype:"int32"}})}else{c=mE({inputs:{x:o},backend:e})}const a=c.shape.length;const u=R(r,c.shape);const l=hf(u,a);let f=u;let h=c;if(l!=null){h=LT({inputs:{x:c},backend:e,attrs:{perm:l}});f=pf(f.length,a)}ff("sum",f,h.shape.length);const[d,p]=uf(h.shape,f);const m=Ar(h.dtype,"int32");let x=pE(e,d,m);const b=w(p);const g=e.data.get(x.dataId).values;const v=e.data.get(h.dataId).values;for(let t=0;t<g.length;++t){const n=t*b;let e=0;for(let t=0;t<b;++t){e+=v[n+t]}g[t]=e}if(i){const t=lf(x.shape,u);const n=x;x=tA({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(n)}e.disposeIntermediateTensorInfo(c);if(l!=null){e.disposeIntermediateTensorInfo(h)}return x}const HO={kernelName:Fs,backendName:"cpu",kernelFunc:UO};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(t){const{inputs:n,backend:e,attrs:s}=t;const{equation:o}=s;const r=n;const{allDims:i,summedDims:c,idDims:a}=dg(o,r.length);mg(i.length,a,r);const{path:u,steps:l}=xg(c,a);const f=l.length;let h=null;let d=i.length;const p=[];for(let t=0;t<f;++t){for(const n of l[t]){const{permutationIndices:t,expandDims:s}=pg(d,a[n]);let o;if(bg(t)){o=r[n]}else{o=LT({inputs:{x:r[n]},backend:e,attrs:{perm:t}});p.push(o)}const i=o.shape.slice();for(let t=0;t<s.length;++t){i.splice(s[t],0,1)}if(!v(o.shape,i)){o=tA({inputs:{x:o},backend:e,attrs:{shape:i}});p.push(o)}if(h===null){h=o}else{h=ET({inputs:{a:o,b:h},backend:e});p.push(h)}}if(t<f-1){if(u[t]>=0){h=UO({inputs:{x:h},backend:e,attrs:{axis:u[t]-(i.length-d),keepDims:false}});p.push(h)}d--}}for(const t of p){if(t===h){continue}e.disposeIntermediateTensorInfo(t)}return h}const qO={kernelName:Yn,backendName:"cpu",kernelFunc:jO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XO(t){const{inputs:n,backend:e}=t;const{dy:s,y:o}=n;rE([s,o],"eluGrad");const r=new Float32Array(w(o.shape));const i=e.data.get(o.dataId).values;const c=e.data.get(s.dataId).values;for(let t=0;t<i.length;++t){const n=i[t];if(n>=0){r[t]=c[t]}else{r[t]=c[t]*(n+1)}}return e.makeTensorInfo(o.shape,"float32",r)}const KO={kernelName:Qn,backendName:"cpu",kernelFunc:XO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JO=Kb;const YO=Jb;const ZO=Yb;const QO=Zb;const tF=Qb;const nF=tg;const eF=_E(te,(t=>{const n=Math.sign(t);const e=Math.abs(t);const s=1/(1+JO*e);return n*(1-((((nF*s+tF)*s+QO)*s+ZO)*s+YO)*s*Math.exp(-e*e))}));const sF={kernelName:te,backendName:"cpu",kernelFunc:eF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oF(t){const{inputs:n,backend:e,attrs:s}=t;const{input:o}=n;const{dim:r}=s;const i=o.shape.length;const c=o.shape.slice();let a=r;if(r<0){x(-(i+1)<=r,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`));a=i+r+1}c.splice(a,0,1);return tA({inputs:{x:o},backend:e,attrs:{shape:c}})}const rF={kernelName:se,backendName:"cpu",kernelFunc:oF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iF=fE(((t,n)=>t/n));const cF=yE(Jn,iF);const aF={kernelName:Jn,backendName:"cpu",kernelFunc:cF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(t,n,e){const s=t.shape;const o=s[0];const r=s[1];const i=e.data.get(t.dataId);const c=i.complexTensorInfos.real;const a=i.complexTensorInfos.imag;const u=[o,r];const l=w(u);const f=E("float32",l);const h=E("float32",l);for(let t=0;t<o;t++){const s=hI({inputs:{x:c},backend:e,attrs:{begin:[t,0],size:[1,r]}});const o=hI({inputs:{x:a},backend:e,attrs:{begin:[t,0],size:[1,r]}});const i=hE({inputs:{real:s,imag:o},backend:e});const{real:u,imag:l}=lF(i,n,e);const d=ng(u,l);for(let n=0;n<r;n++){const e=rg(d,n);f[t*r+n]=e.real;h[t*r+n]=e.imag}e.disposeIntermediateTensorInfo(s);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(i)}const d=e.makeTensorInfo(u,"float32",f);const p=e.makeTensorInfo(u,"float32",h);const m=hE({inputs:{real:d,imag:p},backend:e});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);return m}function lF(t,n,e){const s=w(t.shape);const o=e.data.get(t.dataId);const r=e.data.get(o.complexTensorInfos.real.dataId).values;const i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(fF(s)){const o=hF(r,i,s,n,e);const c=[t.shape[0],t.shape[1]];if(n){const t=e.makeTensorInfo(c,"float32",o.real);const n=e.makeTensorInfo(c,"float32",o.imag);const r=e.makeTensorInfo([],"float32",Ko(s,"float32"));const i=mE({inputs:{x:r},backend:e});const a=aF.kernelFunc({inputs:{a:t,b:r},backend:e});const u=aF.kernelFunc({inputs:{a:n,b:i},backend:e});const l=e.data.get(a.dataId).values;const f=e.data.get(u.dataId).values;e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(r);e.disposeIntermediateTensorInfo(i);e.disposeIntermediateTensorInfo(a);e.disposeIntermediateTensorInfo(u);return{real:l,imag:f}}return o}else{const t=ng(r,i);const e=dF(t,s,n);return eg(e)}}function fF(t){return(t&t-1)===0}function hF(t,n,e,s,o){if(e===1){return{real:t,imag:n}}const r=ng(t,n);const i=e/2;const c=sg(r);const a=c.real;const u=c.imag;const l=[a.length];const f=o.makeTensorInfo(l,"float32",a);const h=o.makeTensorInfo(l,"float32",u);const d=hE({inputs:{real:f,imag:h},backend:o});const p=og(r);const m=p.real;const x=p.imag;const b=[m.length];const g=o.makeTensorInfo(b,"float32",m);const w=o.makeTensorInfo(b,"float32",x);const v=hE({inputs:{real:g,imag:w},backend:o});const $=hF(a,u,i,s,o);const y=$.real;const k=$.imag;const C=[y.length];const N=o.makeTensorInfo(C,"float32",y);const R=o.makeTensorInfo(C,"float32",k);const S=hE({inputs:{real:N,imag:R},backend:o});const E=hF(m,x,i,s,o);const T=E.real;const I=E.imag;const A=[T.length];const O=o.makeTensorInfo(A,"float32",T);const F=o.makeTensorInfo(A,"float32",I);const _=hE({inputs:{real:O,imag:F},backend:o});const M=cg(e,s);const D=[M.real.length];const L=o.makeTensorInfo(D,"float32",M.real);const z=o.makeTensorInfo(D,"float32",M.imag);const P=hE({inputs:{real:L,imag:z},backend:o});const V=ET({inputs:{a:P,b:_},backend:o});const B=RE({inputs:{a:S,b:V},backend:o});const W=_I({inputs:{a:S,b:V},backend:o});const G=bE({inputs:{input:B},backend:o});const U=bE({inputs:{input:W},backend:o});const H=nO({inputs:{input:B},backend:o});const j=nO({inputs:{input:W},backend:o});const q=sO({inputs:[G,U],backend:o,attrs:{axis:0}});const X=sO({inputs:[H,j],backend:o,attrs:{axis:0}});const K=o.data.get(q.dataId).values;const J=o.data.get(X.dataId).values;o.disposeIntermediateTensorInfo(f);o.disposeIntermediateTensorInfo(h);o.disposeIntermediateTensorInfo(d);o.disposeIntermediateTensorInfo(g);o.disposeIntermediateTensorInfo(w);o.disposeIntermediateTensorInfo(v);o.disposeIntermediateTensorInfo(N);o.disposeIntermediateTensorInfo(R);o.disposeIntermediateTensorInfo(S);o.disposeIntermediateTensorInfo(O);o.disposeIntermediateTensorInfo(F);o.disposeIntermediateTensorInfo(_);o.disposeIntermediateTensorInfo(L);o.disposeIntermediateTensorInfo(z);o.disposeIntermediateTensorInfo(P);o.disposeIntermediateTensorInfo(V);o.disposeIntermediateTensorInfo(B);o.disposeIntermediateTensorInfo(W);o.disposeIntermediateTensorInfo(G);o.disposeIntermediateTensorInfo(H);o.disposeIntermediateTensorInfo(U);o.disposeIntermediateTensorInfo(j);o.disposeIntermediateTensorInfo(q);o.disposeIntermediateTensorInfo(X);return{real:K,imag:J}}function dF(t,n,e){const s=new Float32Array(n*2);for(let o=0;o<n;o++){let r=0;let i=0;for(let s=0;s<n;s++){const c=ag(o*s,n,e);const a=rg(t,s);r+=a.real*c.real-a.imag*c.imag;i+=a.real*c.imag+a.imag*c.real}if(e){r/=n;i/=n}ig(s,r,i,o)}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=w(s.shape);const r=s.shape[s.shape.length-1];const i=o/r;const c=tA({inputs:{x:s},backend:e,attrs:{shape:[i,r]}});const a=uF(c,false,e);const u=tA({inputs:{x:a},backend:e,attrs:{shape:s.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(a);return u}const mF={kernelName:re,backendName:"cpu",kernelFunc:pF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(t){const{backend:n,attrs:e}=t;const{shape:s,value:o,dtype:r}=e;const i=r||z(o);const c=T(i,w(s));gF(c,o,i);return n.makeTensorInfo(s,i,c)}const bF={kernelName:ie,backendName:"cpu",kernelFunc:xF};function gF(t,n,e){if(e==="string"){t.fill(n)}else{t.fill(n)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF={kernelName:ce,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const o=e;const r=E(s.dtype,w(s.shape));const[i,c,a,u]=s.shape;const l=o.data.get(s.dataId).values;for(let t=0;t<i;t++){const n=t*a*c*u;for(let t=0;t<c;t++){const e=t*(a*u);for(let t=0;t<a;t++){const s=t*u;for(let o=0;o<u;o++){const i=Math.round(a-t-1);const c=n+e+s+o;let f=l[c];if(i>=0&&i<a){const t=i*u;const s=n+e+t+o;f=l[s]}r[c]=f}}}}const f=o.write(r,s.shape,s.dtype);return{dataId:f,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;let m=rO({inputs:{x:o,filter:r},backend:e,attrs:{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h}});if(i){const t=m;if(l==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const t=tA({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});m=RE({inputs:{a:m,b:t},backend:e});e.disposeIntermediateTensorInfo(t)}else{m=RE({inputs:{a:m,b:i},backend:e})}e.disposeIntermediateTensorInfo(t)}if(d){const t=m;if(l==="NCHW"&&d==="prelu"&&c.shape.length===1&&c.shape[0]!==1){const t=tA({inputs:{x:c},backend:e,attrs:{shape:[c.shape[0],1,1]}});m=QI(e,m,d,t,p);e.disposeIntermediateTensorInfo(t)}else{m=QI(e,m,d,c,p)}e.disposeIntermediateTensorInfo(t)}return m}const $F={kernelName:lo,backendName:"cpu",kernelFunc:vF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;let m=AO({inputs:{x:o,filter:r},backend:e,attrs:{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h}});if(i){const t=m;m=RE({inputs:{a:m,b:i},backend:e});e.disposeIntermediateTensorInfo(t)}if(d){const t=m;m=QI(e,m,d,c,p);e.disposeIntermediateTensorInfo(t)}return m}const kF={kernelName:fo,backendName:"cpu",kernelFunc:yF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(t){const{inputs:n,backend:e}=t;const{params:s,indices:o}=n;const r=w(s.shape);const i=o.shape;const c=i[i.length-1];const[a,u,l,f]=ib(s,o);if(u===0){return e.makeTensorInfo(a,s.dtype,[])}const h=e.data.get(o.dataId).values;const d=e.bufferSync(s);const p=nT(h,d,s.dtype,u,c,l,f,s.shape,r);return e.makeTensorInfo(a,s.dtype,p.values)}const NF={kernelName:he,backendName:"cpu",kernelFunc:CF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,indices:r}=n;const{axis:i,batchDims:c}=s;rE([o,r],"gatherV2");const a=R(i,o.shape)[0];const u=e.data.get(r.dataId).values;const l=o.shape[a];for(let t=0;t<u.length;++t){const n=u[t];x(n<=l-1&&n>=0,(()=>`GatherV2: the index value ${n} is not in [0, ${l-1}]`))}let f=c;if(c==null){f=0}const h=w(r.shape);const d=_g(o,r,a,f);const p=tA({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}});const m=tA({inputs:{x:r},backend:e,attrs:{shape:[d.batchSize,h/d.batchSize]}});const b=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];const g=e.bufferSync(m);const v=e.bufferSync(p);const $=eT(v,g,b);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);return e.makeTensorInfo(d.outputShape,$.dtype,$.values)}const SF={kernelName:fe,backendName:"cpu",kernelFunc:RF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EF(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=w(s.shape);const r=s.shape[s.shape.length-1];const i=o/r;const c=tA({inputs:{x:s},backend:e,attrs:{shape:[i,r]}});const a=uF(c,true,e);const u=tA({inputs:{x:a},backend:e,attrs:{shape:s.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(a);return u}const TF={kernelName:xe,backendName:"cpu",kernelFunc:EF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=_E(ge,(t=>Number.isFinite(t)?1:0),"bool");const AF={kernelName:ge,backendName:"cpu",kernelFunc:IF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OF=_E(we,(t=>Math.abs(t)===Infinity?1:0),"bool");const FF={kernelName:we,backendName:"cpu",kernelFunc:OF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _F=_E(ve,(t=>Number.isNaN(t)?1:0),"bool");const MF={kernelName:ve,backendName:"cpu",kernelFunc:_F};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,num:r}=e;const i=mT(s,o,r);return n.makeTensorInfo([i.length],"float32",i)}const LF={kernelName:Ce,backendName:"cpu",kernelFunc:DF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=_E(Re,(t=>Math.log1p(t)));const PF={kernelName:Re,backendName:"cpu",kernelFunc:zF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=fE(((t,n)=>t&&n));const BF=yE(Se,VF,null,"bool");const WF={kernelName:Se,backendName:"cpu",kernelFunc:BF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF=_E(Ee,(t=>t?0:1),"bool");const UF={kernelName:Ee,backendName:"cpu",kernelFunc:GF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=fE(((t,n)=>t||n));const jF=yE(Te,HF,null,"bool");const qF={kernelName:Te,backendName:"cpu",kernelFunc:jF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=s;rE(o,"LRN");const u=o.shape[3];const l=u-1;const f=e.data.get(o.dataId).values;const h=w(o.shape);const d=new Float32Array(h);function p(t){const n=t%u;let e=t-n+Math.max(0,n-r);const s=t-n+Math.min(n+r,l);let o=0;for(;e<=s;e++){const t=f[e];o+=t*t}return o}for(let t=0;t<h;t++){const n=p(t);const e=f[t]*Math.pow(i+c*n,-a);d[t]=e}return e.makeTensorInfo(o.shape,o.dtype,d)}const KF={kernelName:Ae,backendName:"cpu",kernelFunc:XF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,y:r,dy:i}=n;const{depthRadius:c,bias:a,alpha:u,beta:l}=s;rE(i,"LRNGrad");const f=w(i.shape);const h=i.shape[3];const d=e.data.get(i.dataId).values;const p=e.data.get(o.dataId).values;const m=e.data.get(r.dataId).values;const x=new Float32Array(f);const b=f;for(let t=0;t<b;t++){const n=t%h;const e=t-n+Math.max(0,n-c);const s=t-n+Math.min(h,n+c+1);let o=0;for(let t=e;t<s;t++){o+=Math.pow(p[t],2)}o=u*o+a;for(let n=e;n<s;n++){let e=-2*u*l*p[n]*m[t]/o;if(t===n){e+=Math.pow(o,-l)}e*=d[t];x[n]+=e}}return e.makeTensorInfo(i.shape,o.dtype,x)}const YF={kernelName:Oe,backendName:"cpu",kernelFunc:JF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reductionIndices:r,keepDims:i}=s;const c=e;let a=o.shape;const u=a.length;const l=R(r,a);let f=l;const h=hf(f,u);let d=c.data.get(o.dataId).values;if(h!=null){const t=new Array(u);for(let n=0;n<t.length;n++){t[n]=a[h[n]]}d=DT(d,a,o.dtype,h,t);f=pf(f.length,u);a=t}rE(o,"max");ff("max",f,u);const[p,m]=uf(a,f);const x=w(m);const b=wT(d,x,p,o.dtype);const g=c.write(b,p,o.dtype);let v=p;if(i){const t=lf(p,l);v=t}return{dataId:g,shape:v,dtype:o.dtype}}const QF={kernelName:Fe,backendName:"cpu",kernelFunc:ZF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;rE(o,"maxPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;x(bu(i,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=su(o.shape,r,i,u,c,a);let f;if(l.filterWidth===1&&l.filterHeight===1&&v(l.inShape,l.outShape)){f=mE({inputs:{x:o},backend:e})}else{const t=e.data.get(o.dataId).values;const n=B(o.shape);const s=AA(t,o.shape,o.dtype,n,l,"max");f=e.makeTensorInfo(l.outShape,o.dtype,s.values)}return f}const n_={kernelName:Me,backendName:"cpu",kernelFunc:t_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;rE(o,"maxPool3d");const l=ou(o.shape,r,i,1,c,a,u);const f=e.data.get(o.dataId).values;const h=FA(f,o.shape,o.dtype,B(o.shape),l,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}const s_={kernelName:Le,backendName:"cpu",kernelFunc:e_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const{filterSize:i,strides:c,pad:a,dimRoundingMode:u}=s;rE([o,r],"maxPool3DGrad");const l=ou(r.shape,i,c,1,a,u);const f=e.bufferSync(r);const h=_A(f,l);const d=l.strideDepth;const p=l.strideHeight;const m=l.strideWidth;const x=l.dilationDepth;const b=l.dilationHeight;const g=l.dilationWidth;const w=l.effectiveFilterDepth;const v=l.effectiveFilterHeight;const $=l.effectiveFilterWidth;const y=w-1-l.padInfo.front;const k=$-1-l.padInfo.left;const C=v-1-l.padInfo.top;const N=ba(r.shape,"float32");const R=e.bufferSync(o);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inDepth;++e){for(let s=0;s<l.inHeight;++s){for(let o=0;o<l.inWidth;++o){const r=e-y;const i=s-C;const c=o-k;let a=0;for(let e=0;e<w;e+=x){const s=(r+e)/d;if(s<0||s>=l.outDepth||Math.floor(s)!==s){continue}for(let o=0;o<v;o+=b){const r=(i+o)/p;if(r<0||r>=l.outHeight||Math.floor(r)!==r){continue}for(let i=0;i<$;i+=g){const u=(c+i)/m;if(u<0||u>=l.outWidth||Math.floor(u)!==u){continue}const f=w*v*$-1-h.get(t,s,r,u,n);const d=e*v*$+o*$+i;const p=f===d?1:0;if(p===0){continue}const x=R.get(t,s,r,u,n);a+=x*p}}}N.set(a,t,e,s,o,n)}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const r_={kernelName:ze,backendName:"cpu",kernelFunc:o_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r,output:i}=n;const c=r;rE([r,i],"maxPoolGrad");const{filterSize:a,strides:u,pad:l,dimRoundingMode:f}=s;const h=su(c.shape,a,u,1,l,f);const d=e.data.get(c.dataId).values;const p=ba(h.outShape,c.dtype,OA(d,c.shape,c.dtype,h).values);const m=h.strideHeight;const x=h.strideWidth;const b=h.dilationHeight;const g=h.dilationWidth;const w=h.effectiveFilterHeight;const v=h.effectiveFilterWidth;const $=v-1-h.padInfo.left;const y=w-1-h.padInfo.top;const k=ba(c.shape,"float32");const C=e.data.get(o.dataId).values;const N=ba(o.shape,"float32",C);for(let t=0;t<h.batchSize;++t){for(let n=0;n<h.inChannels;++n){for(let e=0;e<h.inHeight;++e){for(let s=0;s<h.inWidth;++s){const o=e-y;const r=s-$;let i=0;for(let e=0;e<w;e+=b){const s=(o+e)/m;if(s<0||s>=h.outHeight||Math.floor(s)!==s){continue}for(let o=0;o<v;o+=g){const c=(r+o)/x;if(c<0||c>=h.outWidth||Math.floor(c)!==c){continue}const a=w*v-1-p.get(t,s,c,n);const u=e*v+o;const l=a===u?1:0;if(l===0){continue}const f=N.get(t,s,c,n);i+=f*l}}k.set(i,t,e,s,n)}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const c_={kernelName:De,backendName:"cpu",kernelFunc:i_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(t,n,e,s,o){const r=B(n);const i=AA(t,n,e,r,o,"max");const c=OA(t,n,e,o,true,s);return[i.values,c.values]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_={kernelName:Pe,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{filterSize:o,strides:r,pad:i,includeBatchInIndex:c}=n;const a=e;rE(s,"MaxPoolWithArgmax");const u=a.data.get(s.dataId).values;const l=su(s.shape,o,r,[1,1],i);const[f,h]=a_(u,s.shape,s.dtype,c,l);const d=a.write(f,l.outShape,s.dtype);const p=a.write(h,l.outShape,s.dtype);return[{dataId:d,shape:l.outShape,dtype:s.dtype},{dataId:p,shape:l.outShape,dtype:"int32"}]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=R(r,o.shape);const a=uf(o.shape,c);const u=a[1];const l=w(u);const f=[];const h=e.makeTensorInfo([],"float32",new Float32Array([l]));f.push(h);const d=vE({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});f.push(d);const p=cF({inputs:{a:d,b:h},backend:e});f.push(p);const m=UO({inputs:{x:p},backend:e,attrs:{axis:r,keepDims:i}});f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return m}const f_={kernelName:Ve,backendName:"cpu",kernelFunc:l_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;rE(o,"min");const c=R(r,o.shape);let a=c;const u=hf(a,o.shape.length);let l=o;if(u!=null){l=LT({inputs:{x:o},backend:e,attrs:{perm:u}});a=pf(a.length,o.shape.length)}ff("min",a,l.shape.length);const[f,h]=uf(l.shape,a);const d=w(h);const p=j(w(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];if(Number.isNaN(s)||s<e){e=s}}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=lf(f,c);const n=tA({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const d_={kernelName:Be,backendName:"cpu",kernelFunc:h_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,mode:i}=s;rE(o,"mirrorPad");const c=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));const a=r.map((t=>t[0]));const u=r.map(((t,n)=>t[0]+o.shape[n]));const l=i==="reflect"?0:1;const f=e.data.get(o.dataId).values;const h=o.shape.length;const d=B(o.shape);const p=w(c);const m=c.length;const x=B(c);const b=E(o.dtype,p);for(let t=0;t<p;t++){let n=J(t,m,x);for(let t=0;t<m;t++){if(n[t]<a[t]){n[t]=a[t]*2-n[t]-l}else if(n[t]>=u[t]){n[t]=(u[t]-1)*2-n[t]+l}}n=n.map(((t,n)=>t-a[n]));const e=K(n,h,d);b[t]=f[e]}const g=e.write(b,c,o.dtype);return{dataId:g,shape:c,dtype:o.dtype}}const m_={kernelName:Ge,backendName:"cpu",kernelFunc:p_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x_=fE(((t,n)=>{const e=t%n;if(t<0&&n<0||t>=0&&n>=0){return e}else{return(e+n)%n}}));const b_=yE(Ue,x_);const g_={kernelName:Ue,backendName:"cpu",kernelFunc:b_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{dim:r}=s;const i=o.shape.length;let c=r;if(c===-1){c=i-1}if(c!==i-1){throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${i} and dim was ${c}`)}const a=R([c],o.shape);const u=ZF({inputs:{x:o},backend:e,attrs:{reductionIndices:a,keepDims:false}});const l=lf(u.shape,a);const f=tA({inputs:{x:u},backend:e,attrs:{shape:l}});const h=_I({inputs:{a:o,b:f},backend:e});const d=UE({inputs:{x:h},backend:e});const p=UO({inputs:{x:d},backend:e,attrs:{axis:a,keepDims:false}});const m=tA({inputs:{x:p},backend:e,attrs:{shape:l}});const x=cF({inputs:{a:d,b:m},backend:e});e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);return x}const v_={kernelName:Ds,backendName:"cpu",kernelFunc:w_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{numSamples:r,seed:i,normalized:c}=s;rE(o,"multinomial");const a=c?o:w_({inputs:{logits:o},backend:e,attrs:{dim:-1}});const u=a.shape[0];const l=a.shape[1];const f=e.data.get(a.dataId).values;const h=[u,r];const d=j(w(h),"int32");for(let t=0;t<u;++t){const n=t*l;const e=new Float32Array(l-1);e[0]=f[n];for(let t=1;t<e.length;++t){e[t]=e[t-1]+f[n+t]}const s=np.alea(i.toString());const o=t*r;for(let t=0;t<r;++t){const n=s();d[o+t]=e.length;for(let s=0;s<e.length;s++){if(n<e[s]){d[o+t]=s;break}}}}if(!c){e.disposeIntermediateTensorInfo(a)}return e.makeTensorInfo(h,"int32",d)}const y_={kernelName:He,backendName:"cpu",kernelFunc:$_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_=lx;function C_(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a}=s;rE(o,"NonMaxSuppression");const u=e.data.get(o.dataId).values;const l=e.data.get(r.dataId).values;const{selectedIndices:f}=k_(u,l,i,c,a);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const N_={kernelName:Ke,backendName:"cpu",kernelFunc:C_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R_=fx;function S_(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,padToMaxOutputSize:u}=s;rE(o,"NonMaxSuppressionPadded");const l=e.data.get(o.dataId).values;const f=e.data.get(r.dataId).values;const{selectedIndices:h,validOutputs:d}=R_(l,f,i,c,a,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}const E_={kernelName:Je,backendName:"cpu",kernelFunc:S_};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T_=hx;function I_(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,softNmsSigma:u}=s;rE(o,"NonMaxSuppressionWithScore");const l=e.data.get(o.dataId).values;const f=e.data.get(r.dataId).values;const h=i;const d=c;const p=a;const m=u;const{selectedIndices:x,selectedScores:b}=T_(l,f,h,d,p,m);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const A_={kernelName:Ye,backendName:"cpu",kernelFunc:I_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o}=n;const{dtype:r,depth:i,onValue:c,offValue:a}=s;rE(o,"oneHot");const u=w(o.shape);const l=new Float32Array(u*i);l.fill(a);const f=e.data.get(o.dataId).values;for(let t=0;t<u;++t){if(f[t]>=0&&f[t]<i){l[t*i+f[t]]=c}}return e.makeTensorInfo([...o.shape,i],r,l)}const F_={kernelName:Qe,backendName:"cpu",kernelFunc:O_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("zerosLike is not supported for string tensors")}else if(s.dtype==="complex64"){const t=bE({inputs:{input:s},backend:e});const n=__({inputs:{x:t},backend:e});const o=nO({inputs:{input:s},backend:e});const r=__({inputs:{x:o},backend:e});const i=hE({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return xF({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}}const M_={kernelName:ro,backendName:"cpu",kernelFunc:__};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D_(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("onesLike is not supported for string tensors")}else if(s.dtype==="complex64"){const t=bE({inputs:{input:s},backend:e});const n=D_({inputs:{x:t},backend:e});const o=nO({inputs:{input:s},backend:e});const r=__({inputs:{x:o},backend:e});const i=hE({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return xF({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}}const L_={kernelName:Ze,backendName:"cpu",kernelFunc:D_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z_(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;if(n.length===1){return oF({inputs:{input:n[0]},backend:e,attrs:{dim:o}})}const r=n[0].shape;const i=n[0].dtype;n.forEach((t=>{b(r,t.shape,"All tensors passed to stack must have matching shapes");x(i===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=[];const a=n.map((t=>{const n=oF({inputs:{input:t},backend:e,attrs:{dim:o}});c.push(n);return n}));const u=sO({inputs:a,backend:e,attrs:{axis:o}});c.forEach((t=>e.disposeIntermediateTensorInfo(t)));return u}const P_={kernelName:ts,backendName:"cpu",kernelFunc:z_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,constantValue:i}=s;rE(o,"pad");const c=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));const a=r.map((t=>t[0]));const u=e.data.get(o.dataId).values;const l=w(o.shape);const f=o.shape.length;const h=B(o.shape);const d=w(c);const p=c.length;const m=B(c);const x=E(o.dtype,d);if(i!==0){x.fill(i)}for(let t=0;t<l;t++){const n=J(t,f,h);const e=n.map(((t,n)=>t+a[n]));const s=K(e,p,m);x[s]=u[t]}const b=e.write(x,c,o.dtype);return{dataId:b,shape:c,dtype:o.dtype}}const B_={kernelName:ns,backendName:"cpu",kernelFunc:V_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_=fE(((t,n)=>Math.pow(t,n)));const G_=yE(es,W_);const U_={kernelName:es,backendName:"cpu",kernelFunc:G_};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(t){const{inputs:n,backend:e}=t;const{paramsNestedSplits:s,paramsDenseValues:o,indices:r}=n;const i=s.map((t=>e.data.get(t.dataId).values));const c=s.map((t=>t.shape));const a=e.data.get(o.dataId).values;const u=e.data.get(r.dataId).values;const[l,f,h]=KT(i,c,a,o.shape,o.dtype,u,r.shape);const d=l.map((t=>e.makeTensorInfo([t.length],"int32",t)));const p=e.makeTensorInfo(h,o.dtype,f);return d.concat([p])}const j_={kernelName:rs,backendName:"cpu",kernelFunc:H_};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(t){const{inputs:n,backend:e}=t;const{starts:s,limits:o,deltas:r}=n;const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=YT(i,s.shape,s.dtype,c,o.shape,a,r.shape);const f=e.makeTensorInfo([u.length],"int32",u);const h=e.makeTensorInfo([l.length],s.dtype,l);return[f,h]}const X_={kernelName:is,backendName:"cpu",kernelFunc:q_};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K_(t){const{inputs:n,backend:e,attrs:s}=t;const{shape:o,values:r,defaultValue:i,rowPartitionTensors:c}=n;const{rowPartitionTypes:a}=s;const u=e.data.get(o.dataId).values;const l=e.data.get(r.dataId).values;const f=e.data.get(i.dataId).values;const h=c.map((t=>e.data.get(t.dataId).values));const d=c.map((t=>t.shape));const[p,m]=eI(u,o.shape,l,r.shape,r.dtype,f,i.shape,h,d,a);return e.makeTensorInfo(p,r.dtype,m)}const J_={kernelName:cs,backendName:"cpu",kernelFunc:K_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,dtype:r,step:i}=e;const c=sI(s,o,i,r);return n.makeTensorInfo([c.length],r,c)}const Z_={kernelName:as,backendName:"cpu",kernelFunc:Y_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q_=_E(ls,(t=>1/t));const tM={kernelName:ls,backendName:"cpu",kernelFunc:Q_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nM(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;rE(o,"resizeBilinear");const a=B(o.shape);const[u,l]=c;const[f,h,d,p]=o.shape;const m=e.data.get(o.dataId).values;const x=new Float32Array(w([f,u,l,p]));const b=[r&&u>1?h-1:h,r&&l>1?d-1:d];const g=[r&&u>1?u-1:u,r&&l>1?l-1:l];let v=0;const $=b[0]/g[0];const y=b[1]/g[1];for(let t=0;t<f;t++){for(let n=0;n<u;n++){let e;if(i){e=$*(n+.5)-.5}else{e=$*n}const s=Math.max(0,Math.floor(e));const o=e-s;const r=Math.min(h-1,Math.ceil(e));const c=t*a[0]+s*a[1];const u=t*a[0]+r*a[1];for(let t=0;t<l;t++){let n;if(i){n=y*(t+.5)-.5}else{n=y*t}const e=Math.max(0,Math.floor(n));const s=n-e;const r=Math.min(d-1,Math.ceil(n));const l=c+e*a[2];const f=u+e*a[2];const h=c+r*a[2];const b=u+r*a[2];for(let t=0;t<p;t++){const n=m[l+t];const e=m[f+t];const r=m[h+t];const i=m[b+t];const c=n+(r-n)*s;const a=e+(i-e)*s;const u=c+(a-c)*o;x[v++]=u}}}}return e.makeTensorInfo([f,u,l,p],"float32",x)}const eM={kernelName:ms,backendName:"cpu",kernelFunc:nM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;rE([r,o],"resizeBilinearGrad");const c=B(o.shape);const[a,u,l,f]=o.shape;const[,h,d]=r.shape;const p=new Float32Array(a*u*l*f);const m=[i&&h>1?u-1:u,i&&d>1?l-1:l];const x=[i&&h>1?h-1:h,i&&d>1?d-1:d];const b=m[0]/x[0];const g=m[1]/x[1];const w=e.data.get(r.dataId).values;let v=0;for(let t=0;t<a;t++){const n=t*c[0];for(let t=0;t<h;t++){const e=t*b;const s=Math.floor(e);const o=Math.min(Math.ceil(e),u-1);const r=n+s*c[1];const i=n+o*c[1];const a=e-s;const h=1-a;for(let t=0;t<d;t++){const n=t*g;const e=Math.floor(n);const s=Math.min(Math.ceil(n),l-1);const o=n-e;const u=1-o;const d=r+e*c[2];const m=r+s*c[2];const x=i+e*c[2];const b=i+s*c[2];const $=h*u;const y=h*o;const k=a*u;const C=a*o;for(let t=0;t<f;t++){const n=w[v++];p[d+t]+=n*$;p[m+t]+=n*y;p[x+t]+=n*k;p[b+t]+=n*C}}}}return e.makeTensorInfo([a,l,u,f],"float32",p)}const oM={kernelName:xs,backendName:"cpu",kernelFunc:sM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rM(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;rE(o,"resizeNearestNeighbor");const a=B(o.shape);const[u,l]=c;const[f,h,d,p]=o.shape;const m=e.data.get(o.dataId).values;const x=new Float32Array(f*u*l*p);const b=[r&&u>1?h-1:h,r&&l>1?d-1:d];const g=[r&&u>1?u-1:u,r&&l>1?l-1:l];const w=b[0]/g[0];const v=b[1]/g[1];let $=0;for(let t=0;t<f;t++){const n=t*a[0];for(let t=0;t<u;t++){const e=i?w*(t+.5):w*t;let s=Math.min(h-1,r?Math.round(e):Math.floor(e));if(i){s=Math.max(0,s)}const o=n+s*a[1];for(let t=0;t<l;t++){const n=i?v*(t+.5):v*t;let e=Math.min(d-1,r?Math.round(n):Math.floor(n));if(i){e=Math.max(0,e)}const s=o+e*a[2];for(let t=0;t<p;t++){const n=m[s+t];x[$++]=n}}}}return e.makeTensorInfo([f,u,l,p],o.dtype,x)}const iM={kernelName:ds,backendName:"cpu",kernelFunc:rM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cM(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;rE([r,o],"resizeNearestNeighborGrad");const c=B(o.shape);const a=B(r.shape);const[u,l,f,h]=o.shape;const[,d,p]=r.shape;const m=new Float32Array(u*l*f*h);const x=e.data.get(r.dataId).values;const b=[i&&d>1?l-1:l,i&&p>1?f-1:f];const g=[i&&d>1?d-1:d,i&&p>1?p-1:p];const w=b[0]/g[0];const v=b[1]/g[1];const $=1/w;const y=1/v;const k=Math.ceil($)*2+2;const C=Math.ceil(y)*2+2;for(let t=0;t<u;t++){const n=t*c[0];for(let t=0;t<l;t++){const e=n+t*c[1];const s=Math.floor(t*$);const o=Math.floor(s-k/2);for(let s=0;s<f;s++){const r=e+s*c[2];const u=Math.floor(s*y);const b=Math.floor(u-C/2);for(let e=0;e<h;e++){let c=0;for(let r=0;r<k;r++){const u=r+o;if(u<0||u>=d){continue}const h=n+u*a[1];const m=u*w;const g=Math.min(l-1,i?Math.round(m):Math.floor(m));if(t!==g){continue}for(let t=0;t<C;t++){const n=t+b;if(n<0||n>=p){continue}const o=h+n*a[2];const r=n*v;const u=Math.min(f-1,i?Math.round(r):Math.floor(r));if(s===u){c+=x[o+e]}}}m[r+e]=c}}}}return e.makeTensorInfo(o.shape,o.dtype,m)}const aM={kernelName:ps,backendName:"cpu",kernelFunc:cM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dims:r}=s;rE(o,"reverse");const i=o.shape.length;const c=R(r,o.shape);if(i===0){return mE({inputs:{x:o},backend:e})}const a=new br(o.shape,o.dtype);const u=e.bufferSync(o);for(let t=0;t<a.size;t++){const n=a.indexToLoc(t);const e=n.slice();c.forEach((t=>e[t]=o.shape[t]-1-e[t]));a.set(u.get(...e),...n)}return e.makeTensorInfo(a.shape,a.dtype,a.values)}const lM={kernelName:gs,backendName:"cpu",kernelFunc:uM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fM={kernelName:ao,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const{radians:o,fillValue:r,center:i}=n;const c=e;const a=E(s.dtype,w(s.shape));const[u,l,f,h]=s.shape;const[d,p]=Bb(i,l,f);const m=255;const x=Math.sin(o);const b=Math.cos(o);const g=c.data.get(s.dataId).values;for(let t=0;t<u;t++){const n=t*f*l*h;for(let t=0;t<l;t++){const e=t*(f*h);for(let s=0;s<f;s++){const o=s*h;for(let i=0;i<h;i++){const c=[u,t,s,i];const w=c[2];const v=c[1];let $=(w-d)*b-(v-p)*x;let y=(w-d)*x+(v-p)*b;$=Math.round($+d);y=Math.round(y+p);let k=r;if(typeof r!=="number"){if(i===3){k=m}else{k=r[i]}}if($>=0&&$<f&&y>=0&&y<l){const t=y*(f*h);const e=$*h;const s=n+t+e+i;k=g[s]}const C=n+e+o+i;a[C]=k}}}}const v=c.write(a,s.shape,s.dtype);return{dataId:v,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hM=_E(ws,(t=>{const n=Math.floor(t);if(t-n<.5){return Math.floor(t)}else if(t-n>.5){return Math.ceil(t)}else{if(n%2===0){return n}else{return n+1}}}));const dM={kernelName:ws,backendName:"cpu",kernelFunc:hM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o,updates:r}=n;const{shape:i}=s;const{sliceRank:c,numUpdates:a,sliceSize:u,strides:l,outputSize:f}=mm(r,o,i);const h=true;const d=e.bufferSync(o);const p=e.bufferSync(r);const m=cI(d,p,i,f,u,a,c,l,0,h);return e.makeTensorInfo(i,m.dtype,m.values)}const mM={kernelName:$s,backendName:"cpu",kernelFunc:pM};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(t,n){let e=0;let s=t.length;let o=0;while(e<s){o=Math.floor((e+s)/2);if(t[o]<n){e=o+1}else{s=o}}return s}function bM(t,n){let e=0;let s=t.length;let o=0;while(e<s){o=Math.floor((e+s)/2);if(t[o]<=n){e=o+1}else{s=o}}return s}function gM(t,n,e,s,o,r){const i=T("int32",e*o);for(let c=0;c<e;++c){const e=t.slice(c*s,(c+1)*s);const a=c*o;for(let t=0;t<o;++t){i[a+t]=r==="left"?xM(e,n[t+a]):bM(e,n[t+a])}}return i}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wM(t){const{inputs:n,backend:e,attrs:s}=t;const{sortedSequence:o,values:r}=n;const{side:i}=s;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const u=gM(c,a,o.shape[0],o.shape[1],r.shape[1],i);return e.makeTensorInfo(r.shape,"int32",u)}const vM={kernelName:ks,backendName:"cpu",kernelFunc:wM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(t){const{inputs:n,backend:e}=t;const{condition:s,t:o,e:r}=n;rE([s,o,r],"select");const i=s.shape.length;const c=e.data.get(s.dataId).values;const a=e.data.get(o.dataId).values;const u=e.data.get(r.dataId).values;const l=Ar(o.dtype,r.dtype);const f=j(w(o.shape),l);let h=0;const d=i===0||i>1||o.shape.length===1?1:w(o.shape.slice(1));for(let t=0;t<c.length;t++){for(let n=0;n<d;n++){if(c[t]===1){f[h++]=a[t]}else{f[h++]=u[t]}}}return e.makeTensorInfo(o.shape,l,f)}const yM={kernelName:Cs,backendName:"cpu",kernelFunc:$M};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kM=qb;const CM=Xb;const NM=_E(Ns,(t=>{if(t>=0){return CM*t}else{return kM*(Math.exp(t)-1)}}));const RM={kernelName:Ns,backendName:"cpu",kernelFunc:NM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM=_E(Ts,(t=>{if(t<0){return-1}else if(t>0){return 1}else{return 0}}));const EM={kernelName:Ts,backendName:"cpu",kernelFunc:SM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM=_E(Ss,(t=>Math.sin(t)));const IM={kernelName:Ss,backendName:"cpu",kernelFunc:TM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM=_E(Es,(t=>Math.sinh(t)));const OM={kernelName:Es,backendName:"cpu",kernelFunc:AM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM=1.1920928955078125e-7;const _M=Math.log(FM)+2;const MM=_E(As,(t=>{const n=t>-_M;const e=t<_M;const s=Math.exp(t);let o;if(e){o=s}else if(n){o=t}else{o=Math.log(1+s)}return o}));const DM={kernelName:As,backendName:"cpu",kernelFunc:MM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LM(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,paddings:i}=s;rE([o],"spaceToBatchND");const c=w(r);const a=[[0,0]];a.push(...i);for(let t=1+r.length;t<o.shape.length;++t){a.push([0,0])}const u=B_.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:a,constantValue:0}});const l=Wb(u.shape,r,c,false);const f=Gb(l.length,r.length,false);const h=Ub(u.shape,r,c,false);const d={x:u};const p={shape:l};const m=tA({inputs:d,backend:e,attrs:p});const x={x:m};const b={perm:f};const g=LT({inputs:x,backend:e,attrs:b});const v={x:g};const $={shape:h};const y=tA({inputs:v,backend:e,attrs:$});e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(g);return y}const zM={kernelName:_s,backendName:"cpu",kernelFunc:LM};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PM(t){const{inputs:n,backend:e}=t;const{indices:s,values:o,denseShape:r,defaultValue:i}=n;if(r.shape.length!==1){throw new Error(`Dense shape must be a vector, saw:\n        ${r.shape}`)}if(s.shape.length!==2){throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Values must be a vector, saw:\n        ${o.shape}`)}if(i.shape.length!==0){throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`)}const c=e.data.get(s.dataId).values;const a=e.data.get(o.dataId).values;const u=e.data.get(r.dataId).values;const l=e.data.get(i.dataId).values[0];const[f,h,d,p,m]=pI(c,s.shape,s.dtype,a,o.dtype,u,l);return[e.makeTensorInfo(h,s.dtype,f),e.makeTensorInfo([h[0]],o.dtype,d),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map((t=>Number(t))))),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const VM={kernelName:Ls,backendName:"cpu",kernelFunc:PM};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BM(t){const{inputs:n,backend:e}=t;const{inputIndices:s,inputShape:o,newShape:r}=n;if(s.shape.length!==2){throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Input shape should be a vector but received shape\n        ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Target shape should be a vector but received shape ${r.shape}`)}const i=Array.from(e.data.get(o.dataId).values);const c=e.data.get(s.dataId).values;const a=Array.from(e.data.get(r.dataId).values);const[u,l,f]=mI(c,s.shape,s.dtype,i,a);return[e.makeTensorInfo(l,s.dtype,u),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const WM={kernelName:zs,backendName:"cpu",kernelFunc:BM};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n          ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n          ${r.shape}`)}if(o.shape[0]!==r.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=xI(i,s.shape,s.dtype,c,a,true);return e.makeTensorInfo(l,s.dtype,u)}const UM={kernelName:Ps,backendName:"cpu",kernelFunc:GM};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HM(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n         ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n         ${r.shape}`)}if(o.shape[0]!==r.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=xI(i,s.shape,s.dtype,c,a);return e.makeTensorInfo(l,s.dtype,u)}const jM={kernelName:Vs,backendName:"cpu",kernelFunc:HM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qM(t){const{inputs:n,backend:e,attrs:s}=t;const{sparseIndices:o,sparseValues:r,defaultValue:i}=n;const{outputShape:c}=s;const{sliceRank:a,numUpdates:u,sliceSize:l,strides:f,outputSize:h}=mm(r,o,c);const d=false;const p=e.bufferSync(o);let m;switch(r.dtype){case"bool":{const t=e.bufferSync(r);const n=Boolean(e.data.get(i.dataId).values[0]);m=cI(p,t,c,h,l,u,a,f,n,d);break}case"float32":{const t=e.bufferSync(r);const n=e.data.get(i.dataId).values[0];m=cI(p,t,c,h,l,u,a,f,n,d);break}case"int32":{const t=e.bufferSync(r);const n=e.data.get(i.dataId).values[0];m=cI(p,t,c,h,l,u,a,f,n,d);break}case"string":{const t=e.bufferSync(r);const n=tr(e.data.get(i.dataId).values[0]);m=cI(p,t,c,h,l,u,a,f,n,d);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return e.makeTensorInfo(c,m.dtype,m.values)}const XM={kernelName:Bs,backendName:"cpu",kernelFunc:qM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KM(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{numOrSizeSplits:r,axis:i}=s;const c=R(i,o.shape)[0];const a=wg(o,r,c);const u=new Array(o.shape.length).fill(0);const l=o.shape.slice();return a.map((t=>{const n=[...l];n[c]=t;const s=hI({inputs:{x:o},backend:e,attrs:{begin:u,size:n}});u[c]+=t;return s}))}const JM={kernelName:Ms,backendName:"cpu",kernelFunc:KM};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YM={kernelName:Gs,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t;const s=n;rE(e,"square");const o=s.data.get(e.dataId).values;const r=new Float32Array(o.length);for(let t=0;t<o.length;++t){const n=o[t];r[t]=n*n}const i=s.write(r,e.shape,e.dtype);return{dataId:i,shape:e.shape,dtype:e.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM=_E(io,((t,n)=>{const e=n;if(isNaN(t)){return NaN}else{return t>0?1:e.alpha}}));const QM={kernelName:io,backendName:"cpu",kernelFunc:ZM};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tD(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,end:i,strides:c,beginMask:a,endMask:u,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:h}=s;rE(o,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:b,isSimpleSlice:g,begin:w,end:v,strides:$}=Cb(o.shape,r,i,c,a,u,l,f,h);let y;if(m){y=tA({inputs:{x:o},backend:e,attrs:{shape:p}})}else if(b||g){x(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const t=fb(w,v,$);const n=hI({inputs:{x:o},backend:e,attrs:{begin:w,size:t}});y=tA({inputs:{x:n},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(n)}else{const t=e.bufferSync(o);const n=RI(d,t,$,w);y=e.makeTensorInfo(p,n.dtype,n.values)}return y}const nD={kernelName:Hs,backendName:"cpu",kernelFunc:tD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(t){const{inputs:n,backend:e,attrs:s}=t;const{separator:o,nGramWidths:r,leftPad:i,rightPad:c,padWidth:a,preserveShortSequences:u}=s;const{data:l,dataSplits:f}=n;const h=e.data.get(l.dataId).values;const d=e.data.get(f.dataId).values;const[p,m]=EI(h,d,o,r,i,c,a,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(f.shape,"int32",m)]}const sD={kernelName:js,backendName:"cpu",kernelFunc:eD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(t){const{inputs:n,backend:e,attrs:s}=t;const{skipEmpty:o}=s;const{input:r,delimiter:i}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(r.shape.length!==1){throw new Error(`Input must be a vector, got shape: ${r.shape}`)}if(i.shape.length!==0){throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`)}const c=e.data.get(r.dataId).values;const a=e.data.get(i.dataId).values[0];const[u,l,f]=II(c,a,o);const h=l.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const rD={kernelName:qs,backendName:"cpu",kernelFunc:oD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(t){const{inputs:n,backend:e,attrs:s}=t;const{numBuckets:o}=s;const{input:r}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(o<=0){throw new Error(`Number of buckets must be at least 1`)}const i=e.data.get(r.dataId).values;const c=AI(i,o);return e.makeTensorInfo(r.shape,"int32",c)}const cD={kernelName:Xs,backendName:"cpu",kernelFunc:iD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD=_E(Js,(t=>Math.tan(t)));const uD={kernelName:Js,backendName:"cpu",kernelFunc:aD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lD=_E(Ys,(t=>Math.tanh(t)));const fD={kernelName:Ys,backendName:"cpu",kernelFunc:lD};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(t){const{inputs:n,backend:e}=t;const{tensor:s,indices:o,updates:r}=n;const{sliceRank:i,numUpdates:c,sliceSize:a,strides:u,outputSize:l}=mm(r,o,s.shape);const f=false;const h=e.bufferSync(o);const d=e.bufferSync(r);const p=e.bufferSync(s);const m=cI(h,d,s.shape,l,a,c,i,u,p,f);return e.makeTensorInfo(s.shape,m.dtype,m.values)}const dD={kernelName:ys,backendName:"cpu",kernelFunc:hD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reps:r}=s;rE(o,"tile");const i=DI(e.bufferSync(o),r);return e.makeTensorInfo(i.shape,i.dtype,i.values)}const mD={kernelName:Zs,backendName:"cpu",kernelFunc:pD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xD(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{k:r,sorted:i}=s;rE(o,"topk");const c=e.data.get(o.dataId).values;const[a,u]=PI(c,o.shape,o.dtype,r,i);return[e.makeTensorInfo(a.shape,a.dtype,a.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}const bD={kernelName:Qs,backendName:"cpu",kernelFunc:xD};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gD(t){const{inputs:n,attrs:e,backend:s}=t;const{image:o,transforms:r}=n;const{interpolation:i,fillMode:c,fillValue:a,outputShape:u}=e;const[l,f,h,d]=o.shape;const[p,m]=u!=null?u:[f,h];const x=[l,p,m,d];const b=B(o.shape);const g=b[0];const v=b[1];const $=b[2];const y=B(x);const k=y[0];const C=y[1];const N=y[2];const R=E(o.dtype,w(x));R.fill(a);const S=s.data.get(o.dataId).values;const T=s.data.get(r.dataId).values;for(let t=0;t<l;++t){const n=r.shape[0]===1?T:T.subarray(t*8,t*8+8);for(let e=0;e<p;++e){for(let s=0;s<m;++s){for(let o=0;o<d;++o){let r;const u=n[6]*s+n[7]*e+1;if(u===0){continue}const l=(n[0]*s+n[1]*e+n[2])/u;const d=(n[3]*s+n[4]*e+n[5])/u;const p=vD(l,h,c);const m=vD(d,f,c);switch(i){case"nearest":r=RD(S,f,h,g,v,$,t,m,p,o,a);break;case"bilinear":r=SD(S,f,h,g,v,$,t,m,p,o,a);break;default:throw new Error(`Error in Transform: Expect 'nearest' or `+`'bilinear', but got ${i}`)}const x=t*k+e*C+s*N+o;R[x]=r}}}return s.makeTensorInfo(x,o.dtype,R)}const I=s.write(R,x,o.dtype);return{dataId:I,shape:o.shape,dtype:o.dtype}}const wD={kernelName:to,backendName:"cpu",kernelFunc:gD};function vD(t,n,e){switch(e){case"reflect":return $D(t,n);case"wrap":return yD(t,n);case"nearest":return CD(t,n);case"constant":default:return kD(t)}}function $D(t,n){let e=t;if(e<0){if(n<=1){e=0}else{const t=2*n;if(e<t){e=t*Math.trunc(-e/t)+e}e=e<-n?e+t:-e-1}}else if(e>n-1){if(n<=1){e=0}else{const t=2*n;e-=t*Math.trunc(e/t);if(e>=n){e=t-e-1}}}return h(0,e,n-1)}function yD(t,n){let e=t;if(e<0){if(n<=1){e=0}else{const t=n-1;e+=n*(Math.trunc(-e/t)+1)}}else if(e>n-1){if(n<=1){e=0}else{const t=n-1;e-=n*Math.trunc(e/t)}}return h(0,e,n-1)}function kD(t,n){return t}function CD(t,n){return h(0,t,n-1)}function ND(t,n,e,s,o,r,i,c,a,u,l){const f=i*s+c*o+a*r+u;if(0<=c&&c<n&&0<=a&&a<e){return t[f]}else{return l}}function RD(t,n,e,s,o,r,i,c,a,u,l){const f=Math.round(c);const h=Math.round(a);return ND(t,n,e,s,o,r,i,f,h,u,l)}function SD(t,n,e,s,o,r,i,c,a,u,l){const f=Math.floor(c);const h=Math.floor(a);const d=f+1;const p=h+1;const m=(p-a)*ND(t,n,e,s,o,r,i,f,h,u,l)+(a-h)*ND(t,n,e,s,o,r,i,f,p,u,l);const x=(p-a)*ND(t,n,e,s,o,r,i,d,h,u,l)+(a-h)*ND(t,n,e,s,o,r,i,d,p,u,l);return(d-c)*m+(c-f)*x}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(t){const{inputs:n,attrs:e,backend:s}=t;const{axis:o}=e;const{x:r}=n;rE(r,"unique");const i=s.data.get(r.dataId).values;const{outputValues:c,outputShape:a,indices:u}=VI(i,o,r.shape,r.dtype);return[s.makeTensorInfo(a,r.dtype,c),s.makeTensorInfo([u.length],"int32",u)]}const TD={kernelName:eo,backendName:"cpu",kernelFunc:ED};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(t){const{inputs:n,backend:e,attrs:s}=t;const{value:o}=n;let{axis:r}=s;if(r<0){r+=o.shape.length}const i=o.shape.length;const c=o.shape[r];const a=new Array(i-1);let u=0;for(let t=0;t<i;t++){if(t!==r){a[u++]=o.shape[t]}}const l=new Array(i).fill(0);const f=o.shape.slice();f[r]=1;const h=new Array(c);for(let t=0;t<h.length;t++){l[r]=t;const n=hI({inputs:{x:o},backend:e,attrs:{begin:l,size:f}});h[t]=tA({inputs:{x:n},backend:e,attrs:{shape:a}});e.disposeIntermediateTensorInfo(n)}return h}const AD={kernelName:so,backendName:"cpu",kernelFunc:ID};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,segmentIds:r}=n;const{numSegments:i}=s;rE(o,"unsortedSegmentSum");const c=o.shape.length;const a=r.shape.length;const u=[];const l=[];const f=c-a;let h=r;for(let t=0;t<f;++t){const n=oF({inputs:{input:h},backend:e,attrs:{dim:t+1}});h=n;l.push(n)}for(let t=0;t<i;++t){const n=Ko(t,"int32");const s=e.makeTensorInfo([],"int32",n);const r=BE({inputs:{a:s,b:h},backend:e});const i=vE({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});const c=ET({inputs:{a:i,b:o},backend:e});const a=UO({inputs:{x:c},backend:e,attrs:{axis:0,keepDims:false}});u.push(a);l.push(s);l.push(r);l.push(i);l.push(c);l.push(a)}const d=z_({inputs:u,backend:e,attrs:{axis:0}});l.forEach((t=>e.disposeIntermediateTensorInfo(t)));return d}const FD={kernelName:oo,backendName:"cpu",kernelFunc:OD};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _D=[rA,lE,cA,uA,SE,fA,dA,mA,bA,wA,$A,kA,NA,EA,IA,DA,zA,VA,WA,sA,UA,jA,XA,OE,JA,$E,zE,ZA,dE,tO,oO,iO,aO,lO,hO,pO,xO,gO,vO,yO,CO,RO,EO,IO,OO,_O,DO,zO,PO,VO,BO,GO,qO,GI,KO,WE,sF,HE,rF,XE,mF,bF,wF,YE,tT,$F,kF,NF,SF,rT,aT,xE,TF,eO,AF,FF,MF,HI,fT,pT,LF,gT,PF,WF,UF,qF,KF,YF,QF,yT,n_,s_,r_,c_,u_,f_,d_,NT,m_,g_,y_,TT,OT,N_,E_,A_,MT,F_,L_,P_,B_,U_,XI,BT,j_,X_,J_,Z_,gE,aF,tM,JI,ZI,nA,eM,oM,iM,aM,lM,fM,dM,iI,mM,vM,yM,RM,lI,EM,IM,OM,dI,v_,DM,zM,VM,WM,UM,jM,XM,JM,wI,YM,yI,NI,QM,nD,sD,rD,cD,MI,HO,uD,fD,dD,mD,bD,wD,zT,TD,AD,FD,M_];for(const t of _D){vo(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MD={};const DD={alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true};function LD(t,n){MD[t]=n}function zD(t,n){if(!(t in MD)||n!=null){const e=VD(t,n);if(e!==null){MD[t]=e}else{console.log("Could not get context for WebGL version",t);return null}}const e=MD[t];if(e==null||e.isContextLost()){delete MD[t];return zD(t)}e.disable(e.DEPTH_TEST);e.disable(e.STENCIL_TEST);e.disable(e.BLEND);e.disable(e.DITHER);e.disable(e.POLYGON_OFFSET_FILL);e.disable(e.SAMPLE_COVERAGE);e.enable(e.SCISSOR_TEST);e.enable(e.CULL_FACE);e.cullFace(e.BACK);return MD[t]}function PD(t){if(!st().getBool("IS_SAFARI")&&typeof OffscreenCanvas!=="undefined"&&t===2){return new OffscreenCanvas(300,150)}else if(typeof document!=="undefined"){return document.createElement("canvas")}else{throw new Error("Cannot create a canvas in this context")}}function VD(t,n){if(t!==1&&t!==2){throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")}const e=n==null?PD(t):n;e.addEventListener("webglcontextlost",(n=>{n.preventDefault();delete MD[t]}),false);if(st().getBool("SOFTWARE_WEBGL_ENABLED")){DD.failIfMajorPerformanceCaveat=false}if(t===1){return e.getContext("webgl",DD)||e.getContext("experimental-webgl",DD)}return e.getContext("webgl2",DD)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var BD;(function(t){t[t["DENSE"]=0]="DENSE";t[t["SHARED_BATCH"]=1]="SHARED_BATCH"})(BD||(BD={}));var WD;(function(t){t[t["RENDER"]=0]="RENDER";t[t["UPLOAD"]=1]="UPLOAD";t[t["PIXELS"]=2]="PIXELS";t[t["DOWNLOAD"]=3]="DOWNLOAD"})(WD||(WD={}));var GD;(function(t){t[t["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16";t[t["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32";t[t["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE";t[t["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32";t[t["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"})(GD||(GD={}));function UD(t,n){return[n,t]}function HD(t,n){return t*n}function jD(t){const n=w(t);const e=Math.ceil(n/4);return y(e)}function qD(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function XD(t,n){const[e,s]=qD(t,n);return e*s*4}function KD(t,n){const e=t;let s;let o;let r;let i;let c;let a;let u;let l;let f;let h;if(st().getNumber("WEBGL_VERSION")===2){s=e.R32F;o=e.R16F;r=e.RGBA16F;i=e.RGBA32F;c=e.RED;u=4;l=1;f=e.HALF_FLOAT;h=e.FLOAT;a=e.RGBA8}else{s=t.RGBA;o=t.RGBA;r=t.RGBA;i=e.RGBA;c=t.RGBA;u=4;l=4;f=n!=null?n.HALF_FLOAT_OES:null;h=t.FLOAT;a=t.RGBA}return{internalFormatFloat:s,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:i,textureFormatFloat:c,downloadTextureFormat:a,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:f,textureTypeFloat:h}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(t,n){const e=n();if(st().getBool("DEBUG")){YD(t)}return e}function YD(t){const n=t.getError();if(n!==t.NO_ERROR){throw new Error("WebGL Error: "+nL(t,n))}}const ZD=5.96e-8;const QD=65504;function tL(t){if(st().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||ZD<Math.abs(t)&&Math.abs(t)<QD){return true}return false}function nL(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function eL(t,n){return CL(t,(()=>t.getExtension(n)),'Extension "'+n+'" not supported on this browser.')}function sL(t,n){const e=CL(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");JD(t,(()=>t.shaderSource(e,n)));JD(t,(()=>t.compileShader(e)));if(t.getShaderParameter(e,t.COMPILE_STATUS)===false){console.log(t.getShaderInfoLog(e));throw new Error("Failed to compile vertex shader.")}return e}function oL(t,n){const e=CL(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");JD(t,(()=>t.shaderSource(e,n)));JD(t,(()=>t.compileShader(e)));if(st().get("ENGINE_COMPILE_ONLY")){return e}if(t.getShaderParameter(e,t.COMPILE_STATUS)===false){iL(n,t.getShaderInfoLog(e));throw new Error("Failed to compile fragment shader.")}return e}const rL=/ERROR: [0-9]+:([0-9]+):/g;function iL(t,n){const e=rL.exec(n);if(e==null){console.log(`Couldn't parse line number in error: ${n}`);console.log(t);return}const s=+e[1];const o=t.split("\n");const r=o.length.toString().length+2;const i=o.map(((t,n)=>k((n+1).toString(),r)+t));let c=0;for(let t=0;t<i.length;t++){c=Math.max(i[t].length,c)}const a=i.slice(0,s-1);const u=i.slice(s-1,s);const l=i.slice(s);console.log(a.join("\n"));console.log(n.split("\n")[0]);console.log(`%c ${k(u[0],c)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717");console.log(l.join("\n"))}function cL(t){return CL(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}function aL(t,n){JD(t,(()=>t.linkProgram(n)));if(st().get("ENGINE_COMPILE_ONLY")){return}if(t.getProgramParameter(n,t.LINK_STATUS)===false){console.log(t.getProgramInfoLog(n));throw new Error("Failed to link vertex and fragment shaders.")}}function uL(t,n){JD(t,(()=>t.validateProgram(n)));if(t.getProgramParameter(n,t.VALIDATE_STATUS)===false){console.log(t.getProgramInfoLog(n));throw new Error("Shader program validation failed.")}}function lL(t,n){const e=CL(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");JD(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,e)));JD(t,(()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)));return e}function fL(t,n){const e=CL(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");JD(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)));JD(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)));return e}function hL(t){return CL(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}function dL(t,n){const e=st().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0){const e=`[${t}x${n}]`;throw new Error("Requested texture size "+e+" is invalid.")}if(t>e||n>e){const s=`[${t}x${n}]`;const o=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+o+".")}}function pL(t){return CL(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function mL(t,n,e,s,o,r,i){const c=t.getAttribLocation(n,e);if(c===-1){return false}JD(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,s)));JD(t,(()=>t.vertexAttribPointer(c,o,t.FLOAT,false,r,i)));JD(t,(()=>t.enableVertexAttribArray(c)));return true}function xL(t,n,e){NL(t,e);JD(t,(()=>t.activeTexture(t.TEXTURE0+e)));JD(t,(()=>t.bindTexture(t.TEXTURE_2D,n)))}function bL(t,n,e){return CL(t,(()=>t.getUniformLocation(n,e)),'uniform "'+e+'" not present in program.')}function gL(t,n,e){return t.getUniformLocation(n,e)}function wL(t,n,e,s){JD(t,(()=>xL(t,n,s)));JD(t,(()=>t.uniform1i(e,s)))}function vL(t,n,e){JD(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e)));JD(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)))}function $L(t,n){JD(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n)));JD(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function yL(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE){throw new Error("Error binding framebuffer: "+kL(t,n))}}function kL(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function CL(t,n,e){const s=JD(t,(()=>n()));if(s==null){throw new Error(e)}return s}function NL(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;const s=n+t.TEXTURE0;if(s<t.TEXTURE0||s>e){const t=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${t}.`)}}function RL(t,n=2){return w(t.slice(0,t.length-n))}function SL(t){if(t.length===0){throw Error("Cannot get rows and columns of an empty shape array.")}return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function EL(t){let n=[1,1,1];const e=t.length===0||t.length===1&&t[0]===1;if(!e){n=[RL(t),...SL(t)]}return n}function TL(t,n=false){let e=st().getNumber("WEBGL_MAX_TEXTURE_SIZE");let s=st().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(s===Infinity&&st().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")){s=e/2}if(n){e=e*2;s=s*2;t=t.map(((n,e)=>e>=t.length-2?d(t[e]):t[e]));if(t.length===1){t=[2,t[0]]}}if(t.length!==2){const n=S(t);t=n.newShape}let o=w(t);let r=null;if(t.length<=1&&o<=e){r=[1,o]}else if(t.length===2&&t[0]<=e&&t[1]<=e){r=t}else if(t.length===3&&t[0]*t[1]<=e&&t[2]<=e){r=[t[0]*t[1],t[2]]}else if(t.length===3&&t[0]<=e&&t[1]*t[2]<=e){r=[t[0],t[1]*t[2]]}else if(t.length===4&&t[0]*t[1]*t[2]<=e&&t[3]<=e){r=[t[0]*t[1]*t[2],t[3]]}else if(t.length===4&&t[0]<=e&&t[1]*t[2]*t[3]<=e){r=[t[0],t[1]*t[2]*t[3]]}const i=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(n?2:1)&&Math.min(...r)>0;if(r==null||i){if(n){const n=RL(t);let e=2,s=2;if(t.length){[e,s]=SL(t)}o=n*(e/2)*(s/2);r=y(o).map((t=>t*2))}else{r=y(o)}}return r}function IL(t){return t%2===0}function AL(t,n){t=t.slice(-2);n=n.slice(-2);if(v(t,n)){return true}if(!t.length||!n.length){return true}if(t[0]===0||t[1]===0||n[0]===0||n[1]===0){return true}if(t.length!==n.length){const e=t[t.length-1];const s=n[n.length-1];if(e===s){return true}if(IL(e)&&IL(s)&&(t[0]===1||n[0]===1)){return true}}return t[1]===n[1]&&IL(t[0])&&IL(n[0])}let OL;let FL;function _L(t){if(OL==null){const n=zD(t);OL=n.getParameter(n.MAX_TEXTURE_SIZE)}return OL}function ML(t){if(FL==null){const n=zD(t);FL=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,FL)}function DL(t){if(t===0){return 0}let n;const e=zD(t);if(LL(e,"EXT_disjoint_timer_query_webgl2")&&t===2){n=2}else if(LL(e,"EXT_disjoint_timer_query")){n=1}else{n=0}return n}function LL(t,n){const e=t.getExtension(n);return e!=null}function zL(t){try{const n=zD(t);if(n!=null){return true}}catch(t){console.log("Error when getting WebGL context: ",t);return false}return false}function PL(t){if(t===0){return false}const n=zD(t);if(t===1){if(!LL(n,"OES_texture_float")){return false}}else{if(!LL(n,"EXT_color_buffer_float")){return false}}const e=BL(n);return e}function VL(t){if(t===0){return false}const n=zD(t);if(t===1){if(!LL(n,"OES_texture_float")){return false}if(!LL(n,"WEBGL_color_buffer_float")){return false}}else{if(LL(n,"EXT_color_buffer_float")){return BL(n)}const t="EXT_color_buffer_half_float";if(LL(n,t)){const e=n.getExtension(t);return WL(n,e)}return false}const e=BL(n);return e}function BL(t){const n=KD(t);const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const s=1;const o=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,s,o,0,n.textureFormatFloat,n.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.bindTexture(t.TEXTURE_2D,null);t.bindFramebuffer(t.FRAMEBUFFER,null);t.deleteTexture(e);t.deleteFramebuffer(r);return i}function WL(t,n){const e=KD(t,n);const s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s);const o=1;const r=1;t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,o,r,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const c=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.bindTexture(t.TEXTURE_2D,null);t.bindFramebuffer(t.FRAMEBUFFER,null);t.deleteTexture(s);t.deleteFramebuffer(i);return c}function GL(t){if(t!==2){return false}const n=zD(t);const e=n.fenceSync!=null;return e}function UL(t,n){if(!Array.isArray(t)){t=[t]}t.forEach((t=>{if(t!=null){x(t.dtype!=="complex64",(()=>`${n} does not support complex64 tensors `+"in the WebGL backend."))}}))}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HL=st();HL.registerFlag("HAS_WEBGL",(()=>HL.getNumber("WEBGL_VERSION")>0));HL.registerFlag("WEBGL_VERSION",(()=>{if(zL(2)){return 2}else if(zL(1)){return 1}return 0}));HL.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>false));HL.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>HL.get("WEBGL_VERSION")===2));HL.registerFlag("WEBGL_CPU_FORWARD",(()=>true));HL.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>false));HL.registerFlag("WEBGL_PACK",(()=>HL.getBool("HAS_WEBGL")));HL.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_CLIP",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_REDUCE",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_LAZILY_UNPACK",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_CONV_IM2COL",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>HL.getBool("WEBGL_PACK")));HL.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>_L(HL.getNumber("WEBGL_VERSION"))));HL.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>ML(HL.getNumber("WEBGL_VERSION"))));HL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=HL.getNumber("WEBGL_VERSION");if(t===0){return 0}return DL(t)}));HL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>HL.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!qr()));HL.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>PL(HL.getNumber("WEBGL_VERSION"))));HL.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>HL.getBool("WEBGL_FORCE_F16_TEXTURES")?false:HL.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")));HL.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>VL(HL.getNumber("WEBGL_VERSION"))));HL.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>GL(HL.getNumber("WEBGL_VERSION"))));HL.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>{const t=HL.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return t?4:0}));HL.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(!(typeof t==="number")){throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+`got ${t}.`)}if(t<0&&t!==-1){throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never `+`delete) or at least 0, but got ${t}.`)}}));HL.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>qr()?1:-1),(t=>{if(!(typeof t==="number")){throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+`${t}.`)}if(t<0&&t!==-1){throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never `+`manual flush) or at least 0, but got ${t}.`)}}));HL.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128));HL.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>false));HL.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5));HL.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));HL.registerFlag("WEBGL_EXP_CONV",(()=>false));HL.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>HL.getBool("IS_TEST")));HL.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>Infinity));HL.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>false));HL.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>false));HL.registerFlag("ENGINE_COMPILE_ONLY",(()=>false));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jL(){let t;let n;let e;let s;let o;let r;let i;let c;let a;let u;if(st().getNumber("WEBGL_VERSION")===2){t="#version 300 es";n="in";e="out";s="in";o="texture";r="outputColor";i="out vec4 outputColor;";c=st().getBool("WEBGL2_ISNAN_CUSTOM")?`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `:"";a=``;u=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}else{t="";n="attribute";e="varying";s="varying";o="texture2D";r="gl_FragColor";i="";c=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;a=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;u=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}return{version:t,attribute:n,varyingVs:e,varyingFs:s,texture2D:o,output:r,defineOutput:i,defineSpecialNaN:c,defineSpecialInf:a,defineRound:u}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(t,n,e="index"){const s=B(n);return s.map(((n,o)=>{const r=`int ${t[o]} = ${e} / ${n}`;const i=o===s.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${n}`:`index -= ${t[o]} * ${n}`;return`${r}; ${i};`})).join("")}function XL(t,n,e="index"){const s=B(n);return s.map(((n,o)=>{const r=`int ${t[o]} = ${e} / outShapeStrides[${o}]`;const i=o===s.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${r}; ${i};`})).join("")}function KL(t,n){const e=t.length;const s=t.map((t=>`${n}[${t}]`));const o=new Array(e-1);o[e-2]=s[e-1];for(let t=e-3;t>=0;--t){o[t]=`(${o[t+1]} * ${s[t+1]})`}return o}function JL(t,n,e="index"){const s=t.map(((t,n)=>n));const o=KL(s,n);return o.map(((n,s)=>{const r=`int ${t[s]} = ${e} / ${o[s]}`;const i=s===o.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${o[s]}`:`index -= ${t[s]} * ${o[s]}`;return`${r}; ${i};`})).join("")}function YL(t){const n=B(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function ZL(){return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}const QL=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:tz}=zg;function nz(t,n,e){const s=[];t.forEach((t=>{const n=w(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform){s.push(`uniform float ${t.name}${n>1?`[${n}]`:""};`)}else{s.push(`uniform sampler2D ${t.name};`);s.push(`uniform int offset${t.name};`)}if(e.enableShapeUniforms){const{uniformShape:n}=Gz(e.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(n.length){case 1:s.push(`uniform int ${t.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${t.name}Shape;`);break}s.push(`uniform ivec2 ${t.name}TexShape;`)}}));if(e.enableShapeUniforms){switch(n.logicalShape.length){case 1:s.push(`uniform int outShape;`);break;case 2:s.push(`uniform ivec2 outShape;`);s.push(`uniform int outShapeStrides;`);break;case 3:s.push(`uniform ivec3 outShape;`);s.push(`uniform ivec2 outShapeStrides;`);break;case 4:s.push(`uniform ivec4 outShape;`);s.push(`uniform ivec3 outShapeStrides;`);break}s.push(`uniform ivec2 outTexShape;`)}if(e.customUniforms){e.customUniforms.forEach((t=>{s.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)}))}const o=s.join("\n");const r=t.map((t=>oz(t,n,e.packedInputs,e.enableShapeUniforms))).join("\n");const i=n.texShape;const c=jL();const a=cz(c);let u;let l;let f=lz(c);if(n.isPacked){u=rz(n.logicalShape,i,e.enableShapeUniforms);l=uz(c)}else{u=iz(n.logicalShape,i,e.enableShapeUniforms);l=az(c)}if(e.packedInputs){f+=pz}const h=[f,a,l,o,u,r,e.userCode].join("\n");return h}function ez(t,n=false){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return Ez(t,n);case 1:return Iz(t,n);case 2:return Oz(t,n);case 3:return _z(t,n);case 4:return Dz(t,n);case 5:return Lz(t);case 6:return zz(t);default:throw new Error(`${e.length}-D input sampling`+` is not yet supported`)}}function sz(t,n){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return Sz(t);case 1:return Tz(t,n);case 2:return Az(t,n);case 3:return Fz(t,n);default:return Mz(t,n)}}function oz(t,n,e=false,s){let o="";if(e){o+=sz(t,s)}else{o+=ez(t,s)}const r=t.shapeInfo.logicalShape;const i=n.logicalShape;if(r.length<=i.length){if(e){o+=Vz(t,n)}else{o+=Bz(t,n)}}return o}function rz(t,n,e){switch(t.length){case 0:return mz();case 1:return xz(t,n,e);case 2:return Cz(t,n,e);case 3:return gz(t,n,e);default:return vz(t,n,e)}}function iz(t,n,e){switch(t.length){case 0:return mz();case 1:return bz(t,n,e);case 2:return Nz(t,n,e);case 3:return wz(t,n,e);case 4:return $z(t,n,e);case 5:return yz(t,n);case 6:return kz(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function cz(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}function az(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}function uz(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}function lz(t){const n=`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${fz}\n    ${hz}\n    ${dz}\n  `;return n}const fz=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const hz=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const dz=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const pz=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function mz(){return`\n    int getOutputCoords() {\n      return 0;\n    }\n  `}function xz(t,n,e){const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(s[0]===1){if(e){return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    `}return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `}if(s[1]===1){if(e){return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    `}return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `}if(e){return`\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  `}return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}function bz(t,n,e){if(n[0]===1){if(e){return`\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    `}return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `}if(n[1]===1){if(e){return`\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    `}return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `}if(e){return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  `}return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}function gz(t,n,e){if(e){return`\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];const o=Math.ceil(t[2]/2);const r=o*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function wz(t,n,e){if(e){const n=XL(["r","c","d"],t);return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${n}\n    return ivec3(r, c, d);\n  }\n`}const s=qL(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}function vz(t,n,e){if(e){return`\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `}const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];const o=Math.ceil(t[t.length-1]/2);const r=o*Math.ceil(t[t.length-2]/2);let i=r;let c=``;let a="b, r, c";for(let n=2;n<t.length-1;n++){i*=t[t.length-n-1];c=`\n      int b${n} = index / ${i};\n      index -= b${n} * ${i};\n    `+c;a=`b${n}, `+a}return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${c}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}function $z(t,n,e){if(e){const n=XL(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}const s=qL(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}function yz(t,n){const e=qL(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function kz(t,n){const e=qL(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function Cz(t,n,e){const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(v(t,n)){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `}const o=Math.ceil(t[1]/2);if(e){return`\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function Nz(t,n,e){if(v(t,n)){if(e){return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `}if(t[1]===1){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}if(t[0]===1){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}if(e){return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}function Rz(t){return`offset${t}`}function Sz(t){const n=t.name;const e="get"+n.charAt(0).toUpperCase()+n.slice(1);const s=jL();return`\n    vec4 ${e}() {\n      return ${s.texture2D}(${n}, halfCR);\n    }\n  `}function Ez(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform){return`float ${s}() {return ${e};}`}const[o,r]=t.shapeInfo.texShape;if(o===1&&r===1){return`\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `}const i=Rz(e);if(n){return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}const[c,a]=t.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${c}, ${a}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}function Tz(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=t.shapeInfo.texShape;const r=jL();if(n){return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}const i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}function Iz(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform){return`\n      float ${s}(int index) {\n        ${Pz(t)}\n      }\n    `}const o=t.shapeInfo.texShape;const r=o[0];const i=o[1];if(i===1&&r===1){return`\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `}const c=Rz(e);if(i===1){if(n){return`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `}return`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(r===1){if(n){return`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `}return`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(n){return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${c});\n      return sampleTexture(${e}, uv);\n    }\n  `}return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${c});\n      return sampleTexture(${e}, uv);\n    }\n  `}function Az(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;const i=r[0];const c=r[1];const a=jL();if(r!=null&&v(e,r)){if(n){return`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${a.texture2D}(${s}, uv);\n      }\n    `}return`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${i}.0);\n\n        return ${a.texture2D}(${s}, uv);\n      }\n    `}if(n){return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `}const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];const l=Math.ceil(e[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `}function Oz(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;if(r!=null&&v(e,r)){if(n){return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}const t=r[0];const e=r[1];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${e}.0, ${t}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}const{newShape:i,keptDims:c}=S(e);const a=i;if(a.length<e.length){const e=Uz(t,a);const s=["row","col"];return`\n      ${ez(e,n)}\n      float ${o}(int row, int col) {\n        return ${o}(${Hz(s,c)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Pz(t)}\n      }\n    `}const u=r[0];const l=r[1];const f=Rz(s);if(l===1){if(n){return`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}if(u===1){if(n){return`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `}if(n){return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${f};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${f};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}function Fz(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(e[0]===1){const s=e.slice(1);const r=[1,2];const i=Uz(t,s);const c=["b","row","col"];return`\n        ${sz(i,n)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${Hz(c,r)});\n        }\n      `}const c=jL();if(n){return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `}const a=i[0];const u=i[1];const l=Math.ceil(e[2]/2);const f=l*Math.ceil(e[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${u}, ${f}, ${l}, b, row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `}function _z(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=e[1]*e[2];const i=e[2];const{newShape:c,keptDims:a}=S(e);const u=c;if(u.length<e.length){const e=Uz(t,u);const s=["row","col","depth"];return`\n        ${ez(e,n)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${Hz(s,a)});\n        }\n      `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${i}, 1)));\n        ${Pz(t)}\n      }\n    `}const l=t.shapeInfo.texShape;const f=l[0];const h=l[1];const d=t.shapeInfo.flatOffset;if(h===r&&d==null){if(n){return`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${f}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `}if(h===i&&d==null){if(n){return`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${f}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}const p=Rz(s);if(n){return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `}return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${i} + depth + ${p};\n        vec2 uv = uvFromFlat(${f}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}function Mz(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=jL();if(n){return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);\n    }\n  `}const r=t.shapeInfo.logicalShape;const i=r.length;const c=t.shapeInfo.texShape;const a=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];const u=a[0];const l=a[1];const f=Math.ceil(r[i-1]/2);let h=f*Math.ceil(r[i-2]/2);let d=`int b, int row, int col`;let p=`b * ${h} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<i-1;t++){d=`int b${t}, `+d;h*=r[i-t-1];p=`b${t} * ${h} + `+p}return`\n    vec4 ${s}(${d}) {\n      int index = ${p};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}function Dz(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=e[3];const i=e[2]*r;const c=e[1]*i;const{newShape:a,keptDims:u}=S(e);if(a.length<e.length){const e=Uz(t,a);const s=["row","col","depth","depth2"];return`\n      ${ez(e,n)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${Hz(s,u)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${c}, ${i}, ${r}, 1)));\n        ${Pz(t)}\n      }\n    `}const l=t.shapeInfo.flatOffset;const f=t.shapeInfo.texShape;const h=f[0];const d=f[1];const p=`int stride2 = ${s}Shape[3];`;const m=`int stride1 = ${s}Shape[2] * stride2;`;const x=`int stride0 = ${s}Shape[1] * stride1;`;if(d===c&&l==null){if(n){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `}if(d===r&&l==null){if(n){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `}const b=Rz(s);if(n){return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${x}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `}return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${i} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `}function Lz(t){const n=t.shapeInfo.logicalShape;const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=n[4];const r=n[3]*o;const i=n[2]*r;const c=n[1]*i;const{newShape:a,keptDims:u}=S(n);if(a.length<n.length){const n=Uz(t,a);const e=["row","col","depth","depth2","depth3"];return`\n      ${ez(n)}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${Hz(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${i}, ${r}, ${o})) +\n          depth3;\n        ${Pz(t)}\n      }\n    `}const l=t.shapeInfo.flatOffset;const f=t.shapeInfo.texShape;const h=f[0];const d=f[1];if(d===c&&l==null){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${r}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(d===o&&l==null){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}const p=Rz(e);return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${i} + depth * ${r} +\n          depth2 * ${o} + depth3 + ${p};\n      vec2 uv = uvFromFlat(${h}, ${d}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}function zz(t){const n=t.shapeInfo.logicalShape;const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const{newShape:o,keptDims:r}=S(n);if(o.length<n.length){const n=Uz(t,o);const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ez(n)}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${Hz(e,r)});\n      }\n    `}const i=n[5];const c=n[4]*i;const a=n[3]*c;const u=n[2]*a;const l=n[1]*u;if(t.shapeInfo.isUniform){return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${u}, ${a}, ${c})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Pz(t)}\n      }\n    `}const f=t.shapeInfo.flatOffset;const h=t.shapeInfo.texShape;const d=h[0];const p=h[1];if(p===l&&f==null){return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${a}, ${c}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(p===i&&f==null){return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}const m=Rz(e);return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${u} + depth * ${a} +\n          depth2 * ${c} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}function Pz(t){const n=t.name;const e=w(t.shapeInfo.logicalShape);if(e<2){return`return ${n};`}return`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Vz(t,n){const e=t.name;const s=e.charAt(0).toUpperCase()+e.slice(1);const o="get"+s+"AtOutCoords";const r=t.shapeInfo.logicalShape.length;const i=n.logicalShape.length;const c=tz(t.shapeInfo.logicalShape,n.logicalShape);const a=Wz(i);const u=i-r;let l;const f=["x","y","z","w","u","v"];if(r===0){l=""}else if(i<2&&c.length>=1){l="coords = 0;"}else{l=c.map((t=>`coords.${f[t+u]} = 0;`)).join("\n")}let h="";if(i<2&&r>0){h="coords"}else{h=t.shapeInfo.logicalShape.map(((t,n)=>`coords.${f[n+u]}`)).join(", ")}let d=`return outputValue;`;const p=w(t.shapeInfo.logicalShape);const m=p===1;const x=w(n.logicalShape);const b=x===1;if(r===1&&!m&&!b){d=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `}else if(m&&!b){if(i===1){d=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `}else{d=`\n        return vec4(outputValue.x);\n      `}}else if(c.length){const t=r-2;const n=r-1;if(c.indexOf(t)>-1&&c.indexOf(n)>-1){d=`return vec4(outputValue.x);`}else if(c.indexOf(t)>-1){d=`return vec4(outputValue.x, outputValue.y, `+`outputValue.x, outputValue.y);`}else if(c.indexOf(n)>-1){d=`return vec4(outputValue.xx, outputValue.zz);`}}return`\n    vec4 ${o}() {\n      ${a} coords = getOutputCoords();\n      ${l}\n      vec4 outputValue = get${s}(${h});\n      ${d}\n    }\n  `}function Bz(t,n){const e=t.name;const s=e.charAt(0).toUpperCase()+e.slice(1);const o="get"+s+"AtOutCoords";const r=n.texShape;const i=t.shapeInfo.texShape;const c=t.shapeInfo.logicalShape.length;const a=n.logicalShape.length;if(!t.shapeInfo.isUniform&&c===a&&t.shapeInfo.flatOffset==null&&v(i,r)){return`\n      float ${o}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `}const u=Wz(a);const l=tz(t.shapeInfo.logicalShape,n.logicalShape);const f=a-c;let h;const d=["x","y","z","w","u","v"];if(c===0){h=""}else if(a<2&&l.length>=1){h="coords = 0;"}else{h=l.map((t=>`coords.${d[t+f]} = 0;`)).join("\n")}let p="";if(a<2&&c>0){p="coords"}else{p=t.shapeInfo.logicalShape.map(((t,n)=>`coords.${d[n+f]}`)).join(", ")}return`\n    float ${o}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${s}(${p});\n    }\n  `}function Wz(t){if(t<=1){return"int"}else if(t===2){return"ivec2"}else if(t===3){return"ivec3"}else if(t===4){return"ivec4"}else if(t===5){return"ivec5"}else if(t===6){return"ivec6"}else{throw Error(`GPU for rank ${t} is not yet supported`)}}function Gz(t,n,e){const{newShape:s,keptDims:o}=S(n);const r=n.length;const i=t&&r===3&&n[0]===1;const c=i?n.slice(1):s;const a=!t&&r>1&&!v(n,e)&&s.length<r||i;const u=a?c:n;return{useSqueezeShape:a,uniformShape:u,keptDims:o}}function Uz(t,n){const e=JSON.parse(JSON.stringify(t));e.shapeInfo.logicalShape=n;return e}function Hz(t,n){return n.map((n=>t[n])).join(", ")}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jz(t,n,e,s){const o=e.map(((t,e)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:t.isUniform?false:t.texData.isPacked,flatOffset:null};if(t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0){s.flatOffset=t.texData.slice.flatOffset}return{name:n.variableNames[e],shapeInfo:s}}));const r=o.map((t=>t.shapeInfo));const i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:false,isPacked:s.texData.isPacked,flatOffset:null};const c=nz(o,i,n);const a=oL(t.gl,c);const u=t.createProgram(a);if(!st().get("ENGINE_COMPILE_ONLY")){t.buildVao(u);return Object.assign({program:n,fragmentShader:a,source:c,webGLProgram:u,inShapeInfos:r,outShapeInfo:i},qz(t,n,u))}else{return{program:n,fragmentShader:a,source:c,webGLProgram:u,inShapeInfos:r,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}}}function qz(t,n,e){const s=[];const o=[];let r;let i;let c;let a=null;let u=null;u=t.getUniformLocation(e,"NAN",false);if(st().getNumber("WEBGL_VERSION")===1){a=t.getUniformLocation(e,"INFINITY",false)}const l=false;for(const o of n.variableNames){const r={name:o,uniform:t.getUniformLocation(e,o,l),offset:t.getUniformLocation(e,`offset${o}`,l)};if(n.enableShapeUniforms){r.shape=t.getUniformLocation(e,`${o}Shape`,l);r.texShape=t.getUniformLocation(e,`${o}TexShape`,l)}s.push(r)}if(n.enableShapeUniforms){r=t.getUniformLocation(e,"outShape",l);c=t.getUniformLocation(e,"outShapeStrides",l);i=t.getUniformLocation(e,"outTexShape",l)}if(n.customUniforms){for(const s of n.customUniforms){o.push(t.getUniformLocation(e,s.name,l))}}return{variablesLocations:s,customUniformLocations:o,infLoc:a,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:c,outTexShapeLocation:i}}function Xz(t,n){if(t.length!==n.length){throw Error(`Binary was compiled with ${t.length} inputs, but `+`was executed with ${n.length} inputs`)}t.forEach(((t,e)=>{const s=t.logicalShape;const o=n[e];const r=o.shape;if(!v(s,r)){throw Error(`Binary was compiled with different shapes than `+`the current args. Shapes ${s} and ${r} must match`)}if(t.isUniform&&o.isUniform){return}const i=t.texShape;const c=o.isUniform?null:o.texData.texShape;if(!v(i,c)){throw Error(`Binary was compiled with different texture shapes than the`+` current args. Shape ${i} and ${c} must match`)}}))}function Kz(t,n,e,s,o){if(!n.program.enableShapeUniforms){Xz(n.inShapeInfos,e);Xz([n.outShapeInfo],[s])}const r=s.texData.texture;const i=s.texData.texShape;if(s.texData.isPacked){t.setOutputPackedMatrixTexture(r.texture,i[0],i[1])}else{t.setOutputMatrixTexture(r.texture,i[0],i[1])}t.setProgram(n.webGLProgram);t.bindVertexArray(n.webGLProgram.vao);if(st().getNumber("WEBGL_VERSION")===1){if(n.infLoc!==null){t.gl.uniform1f(n.infLoc,Infinity)}}if(n.nanLoc!==null){t.gl.uniform1f(n.nanLoc,NaN)}for(let s=0;s<e.length;++s){const o=e[s];const{uniform:r,offset:i,shape:c,texShape:a}=n.variablesLocations[s];if(c){const{uniformShape:e}=Gz(n.program.packedInputs,o.shape,o.texData.texShape);switch(e.length){case 1:t.gl.uniform1iv(c,new Int32Array(e));break;case 2:t.gl.uniform2iv(c,new Int32Array(e));break;case 3:t.gl.uniform3iv(c,new Int32Array(e));break;case 4:t.gl.uniform4iv(c,new Int32Array(e));break}}if(a){t.gl.uniform2i(a,o.texData.texShape[0],o.texData.texShape[1])}if(r==null){continue}if(o.isUniform){if(w(o.shape)<2){t.gl.uniform1f(r,o.uniformValues[0])}else{let n=o.uniformValues;if(!(n instanceof Float32Array)){n=new Float32Array(n)}t.gl.uniform1fv(r,n)}continue}if(o.texData.slice!=null&&i!=null){t.gl.uniform1i(i,o.texData.slice.flatOffset)}t.setInputMatrixTexture(o.texData.texture.texture,r,s)}const c=n.outShapeLocation;if(c){switch(s.shape.length){case 1:t.gl.uniform1iv(c,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(c,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(c,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(c,new Int32Array(s.shape));break}}if(n.outShapeStridesLocation){const e=B(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(e));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(e));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(e));break}}if(n.outTexShapeLocation){t.gl.uniform2i(n.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1])}if(n.program.customUniforms&&o){for(let e=0;e<n.program.customUniforms.length;++e){const s=n.program.customUniforms[e];const r=n.customUniformLocations[e];const i=o[e];if(s.type==="float"){t.gl.uniform1fv(r,i)}else if(s.type==="vec2"){t.gl.uniform2fv(r,i)}else if(s.type==="vec3"){t.gl.uniform3fv(r,i)}else if(s.type==="vec4"){t.gl.uniform4fv(r,i)}else if(s.type==="int"){t.gl.uniform1iv(r,i)}else if(s.type==="ivec2"){t.gl.uniform2iv(r,i)}else if(s.type==="ivec3"){t.gl.uniform3iv(r,i)}else if(s.type==="ivec4"){t.gl.uniform4iv(r,i)}else{throw Error(`uniform type ${s.type} is not supported yet.`)}}}t.executeProgram()}function Jz(t,n,e){let s="";n.concat(e).forEach((n=>{const o=n.texData!=null&&n.texData.slice!=null&&n.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!n.isUniform){const r=n.texData.texShape;const{useSqueezeShape:i,uniformShape:c,keptDims:a}=Gz(t.packedInputs,n.shape,r);let u="",l="",f="";if(c.length===1&&t.packedInputs){const t=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];u=`${t[0]>1}_${t[1]>1}`}else if(c.length===2&&!t.packedInputs){l=`${c[0]>1}_${c[1]>1}`}else if(c.length>2&&!t.packedInputs){const t=B(c);f=`${t[0]===r[1]}_${t[t.length-1]===r[1]}`}const h=n.shape.length;const d=c.length===2&&v(n.shape,r);const p=w(n.shape)===1;const m=Bl(n.shape,e.shape);const x=!t.packedInputs&&h===e.shape.length&&v(r,e.texData.texShape);const b=t.packedInputs||c.length>2?"":`${r[0]>1}_${r[1]>1}`;s+=`${h}_${x}_${i?a:""}_${c.length}_${p}_${m}_${d}_${u}_${l}_${f}_${b}_${o}`}else{const t=n.isUniform?"uniform":n.texData.texShape;s+=`${n.shape}_${t}_${o}`}}));const o=t.userCode;let r=t.constructor.name;r+="_"+s+"_"+o+`${st().getNumber("WEBGL_VERSION")}`;return r}function Yz(t){return st().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zz{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outPackingScheme=BD.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=jL();this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?XL(["r","c","d"],t):qL(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qz{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outPackingScheme=BD.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=jL();this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?XL(["r","c","d"],t):qL(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tP{constructor(t){this.variableNames=["A"];this.outTexUsage=WD.DOWNLOAD;const n=jL();this.outputShape=t;this.userCode=`\n      ${QL}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${n.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nP{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outTexUsage=WD.DOWNLOAD;const n=jL();this.outputShape=t;this.userCode=`\n      ${QL}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${n.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eP={R:0,G:1,B:2,A:3};class sP{constructor(t,n=false,e="RGBA"){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=jL();this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);let o=`result`;if(n){o=`floor(result * 255. + 0.5)`}let r="";for(let t=0;t<e.length;t++){const n=e[t];r+=`\n          if(offset == ${t}) {\n            result = values[${eP[n]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?ZL():YL(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${e.length});\n\n        flatIndex = idiv(flatIndex, ${e.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${r}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oP{constructor(t,n=false){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=jL();this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);let s="";let o="result";if(n){o="floor(result * 255. + 0.5)"}for(let n=0;n<=1;n++){for(let o=0;o<=1;o++){const r=n*2+o;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${o};\n          if (localCoords[1] + ${n} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${n};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${e.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${r}] = values[0];\n            } else if (offset == 1) {\n              result[${r}] = values[1];\n            } else if (offset == 2) {\n              result[${r}] = values[2];\n            } else {\n              result[${r}] = values[3];\n            }\n          }\n        }\n        `}}this.userCode=`\n        ${this.enableShapeUniforms?ZL():YL(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${e.output} = ${o};\n        }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rP(t){const n=jL();const e=`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return sL(t,e)}function iP(t){const n=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return lL(t,n)}function cP(t){const n=new Uint16Array([0,1,2,2,1,3]);return fL(t,n)}function aP(t,n,e,s,o,r){dL(n,e);const i=hL(t);const c=t.TEXTURE_2D;JD(t,(()=>t.bindTexture(c,i)));JD(t,(()=>t.texParameteri(c,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)));JD(t,(()=>t.texParameteri(c,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)));JD(t,(()=>t.texParameteri(c,t.TEXTURE_MIN_FILTER,t.NEAREST)));JD(t,(()=>t.texParameteri(c,t.TEXTURE_MAG_FILTER,t.NEAREST)));if(st().getNumber("WEBGL_VERSION")===1){JD(t,(()=>t.texImage2D(c,0,s,n,e,0,o,r,null)))}else{JD(t,(()=>t.texStorage2D(c,1,s,n,e)))}JD(t,(()=>t.bindTexture(t.TEXTURE_2D,null)));return{texture:i,texShape:[e,n]}}function uP(t){return t.internalFormatFloat}function lP(t,n,e,s){const[o,r]=UD(n,e);return aP(t,o,r,uP(s),s.textureFormatFloat,t.FLOAT)}function fP(t){return t.internalFormatHalfFloat}function hP(t,n,e,s){const[o,r]=UD(n,e);return aP(t,o,r,fP(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function dP(t){return t.downloadTextureFormat}function pP(t,n,e,s){const[o,r]=UD(n,e);return aP(t,o,r,dP(s),t.RGBA,t.UNSIGNED_BYTE)}function mP(t){return t.internalFormatPackedFloat}function xP(t,n,e,s){const[o,r]=qD(n,e);return aP(t,o,r,mP(s),t.RGBA,t.FLOAT)}function bP(t){return t.internalFormatPackedHalfFloat}function gP(t,n,e,s){const[o,r]=qD(n,e);return aP(t,o,r,bP(s),t.RGBA,s.textureTypeHalfFloat)}function wP(t,n,e){const s=0;const o=3*4;const r=3*4+2*4;JD(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,e)));const i=mL(t,n,"clipSpacePos",e,3,r,s);return i&&mL(t,n,"uv",e,2,r,o)}function vP(t,n,e,s,o,r){JD(t,(()=>t.bindTexture(t.TEXTURE_2D,n)));let i,c,a;if(o instanceof Uint8Array){i=new Uint8Array(e*s*4);c=t.UNSIGNED_BYTE;a=t.RGBA}else{i=new Float32Array(e*s*4);c=t.FLOAT;a=r.internalFormatPackedFloat}i.set(o);if(st().getNumber("WEBGL_VERSION")===2){JD(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,s,t.RGBA,c,i)))}else{JD(t,(()=>t.texImage2D(t.TEXTURE_2D,0,a,e,s,0,t.RGBA,c,i)))}JD(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function $P(t,n,e){JD(t,(()=>t.bindTexture(t.TEXTURE_2D,n)));if(e.data instanceof Uint8Array){if(st().getNumber("WEBGL_VERSION")===2){JD(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)))}else{JD(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)))}}else{if(st().getNumber("WEBGL_VERSION")===2){JD(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)))}else{JD(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)))}}JD(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function yP(t,n,e,s){const o=t.createBuffer();JD(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o)));const r=4;const i=4;const c=r*i*n*e;JD(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,c,t.STREAM_READ)));JD(t,(()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)));JD(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)));return o}function kP(t,n,e){const s=t;const o=new Float32Array(e);s.bindBuffer(s.PIXEL_PACK_BUFFER,n);s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,o);s.bindBuffer(s.PIXEL_PACK_BUFFER,null);return o}function CP(t,n,e,s){const[o,r]=UD(n,e);const i=4;const c=new Uint8Array(HD(n*e,i));JD(t,(()=>t.readPixels(0,0,o,r,s.downloadTextureFormat,t.UNSIGNED_BYTE,c)));return new Float32Array(c.buffer)}function NP(t,n,e,s,o,r,i,c){const a=t;const u=new Float32Array(XD(r,i));a.bindBuffer(a.PIXEL_PACK_BUFFER,n);a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,u);a.bindBuffer(a.PIXEL_PACK_BUFFER,null);return u}function RP(t,n,e){const s=new Float32Array(n*e*4);JD(t,(()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,s)));return s}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SP{constructor(t){this.outputTexture=null;this.program=null;this.disposed=false;this.itemsToPoll=[];const n=st().getNumber("WEBGL_VERSION");if(t!=null){this.gl=t;LD(n,t)}else{this.gl=zD(n)}t=this.gl;if(st().getNumber("WEBGL_VERSION")===2){const n=t;this.createVertexArray=()=>JD(n,(()=>n.createVertexArray()));this.bindVertexArray=t=>JD(n,(()=>n.bindVertexArray(t)));this.deleteVertexArray=t=>JD(n,(()=>n.deleteVertexArray(t)));this.getVertexArray=()=>JD(n,(()=>n.getParameter(n.VERTEX_ARRAY_BINDING)))}else if(t!=null){const n=t.getExtension("OES_vertex_array_object");if(n==null){throw new Error("All WebGL1 implementations are expected to offer"+" OES_vertex_array_object.")}this.createVertexArray=()=>JD(t,(()=>n.createVertexArrayOES()));this.bindVertexArray=e=>JD(t,(()=>n.bindVertexArrayOES(e)));this.deleteVertexArray=e=>JD(t,(()=>n.deleteVertexArrayOES(e)));this.getVertexArray=()=>JD(t,(()=>t.getParameter(n.VERTEX_ARRAY_BINDING_OES)))}let e="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile");if(st().getNumber("WEBGL_VERSION")===1){const t="OES_texture_float";const n="OES_texture_half_float";this.textureFloatExtension=eL(this.gl,t);if(LL(this.gl,n)){this.textureHalfFloatExtension=eL(this.gl,n)}else if(st().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support half float textures, yet the "+"environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}this.colorBufferFloatExtension=this.gl.getExtension(e);if(LL(this.gl,s)){this.colorBufferHalfFloatExtension=eL(this.gl,s)}else if(st().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support color renderable half floats, yet "+"the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}}else{e="EXT_color_buffer_float";if(LL(this.gl,e)){this.colorBufferFloatExtension=this.gl.getExtension(e)}else if(LL(this.gl,s)){this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}else{throw new Error("GL context does not support color renderable floats")}}this.vertexBuffer=iP(this.gl);this.indexBuffer=cP(this.gl);this.framebuffer=pL(this.gl);this.textureConfig=KD(this.gl,this.textureHalfFloatExtension)}get debug(){return st().getBool("DEBUG")}dispose(){if(this.disposed){return}if(this.program!=null){console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram."+" This is probably a resource leak, delete the program with "+"GPGPUContext.deleteProgram before disposing.")}if(this.outputTexture!=null){console.warn("Disposing a GPGPUContext that still has a bound output matrix "+"texture.  This is probably a resource leak, delete the output "+"matrix texture with GPGPUContext.deleteMatrixTexture before "+"disposing.")}const t=this.gl;JD(t,(()=>t.finish()));JD(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null)));JD(t,(()=>t.deleteFramebuffer(this.framebuffer)));JD(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null)));JD(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)));JD(t,(()=>t.deleteBuffer(this.indexBuffer)));this.disposed=true}createFloat32MatrixTexture(t,n){this.throwIfDisposed();return lP(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){this.throwIfDisposed();return hP(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){this.throwIfDisposed();return pP(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed();$P(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,e,s){this.throwIfDisposed();vP(this.gl,t,n,e,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){this.throwIfDisposed();return gP(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){this.throwIfDisposed();return xP(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed();if(this.outputTexture===t){$L(this.gl,this.framebuffer);this.outputTexture=null}JD(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,e){return this.downloadMatrixDriver(t,(()=>CP(this.gl,n,e,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,n,e,s,o,r){return NP(this.gl,t,n,e,s,o,r)}downloadFloat32MatrixFromBuffer(t,n){return kP(this.gl,t,n)}createBufferFromTexture(t,n,e){this.bindTextureToFrameBuffer(t);const s=yP(this.gl,n,e);this.unbindTextureToFrameBuffer();return s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n;let e;if(st().getBool("WEBGL_FENCE_API_ENABLED")){const s=t;const o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush();e=()=>{const t=s.clientWaitSync(o,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED};n=o}else if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){n=this.beginQuery();this.endQuery();e=()=>this.isQueryAvailable(n,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}else{e=()=>true}return{query:n,isFencePassed:e}}downloadMatrixFromPackedTexture(t,n,e){return this.downloadMatrixDriver(t,(()=>RP(this.gl,n,e)))}createProgram(t){this.throwIfDisposed();const n=this.gl;if(this.vertexShader==null){this.vertexShader=rP(n)}const e=cL(n);JD(n,(()=>n.attachShader(e,this.vertexShader)));JD(n,(()=>n.attachShader(e,t)));aL(n,e);const s=Object.assign(e,{vao:this.createVertexArray()});if(this.debug){uL(n,s)}return s}buildVao(t){this.setProgram(t);this.bindVertexArray(t.vao);const n=this.gl;JD(n,(()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)));wP(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed();if(t===this.program){this.program=null}if(t!=null){JD(this.gl,(()=>this.gl.deleteProgram(t)));this.deleteVertexArray(t.vao)}}setProgram(t){this.throwIfDisposed();this.program=t;if(this.program!=null){if(this.debug){uL(this.gl,this.program)}}JD(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,n,e=true){this.throwIfDisposed();if(e){return bL(this.gl,t,n)}else{return gL(this.gl,t,n)}}getAttributeLocation(t,n){this.throwIfDisposed();return JD(this.gl,(()=>this.gl.getAttribLocation(t,n)))}getUniformLocationNoThrow(t,n){this.throwIfDisposed();return this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,e){this.throwIfDisposed();this.throwIfNoProgram();wL(this.gl,t,n,e)}setOutputMatrixTexture(t,n,e){this.setOutputMatrixTextureDriver(t,e,n)}setOutputPackedMatrixTexture(t,n,e){this.throwIfDisposed();const[s,o]=qD(n,e);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,n,e,s){this.setOutputMatrixWriteRegionDriver(e,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,e,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){if(this.program!=null){uL(this.gl,this.program)}yL(this.gl)}executeProgram(){this.throwIfDisposed();this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!");this.debugValidate()}JD(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed();JD(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){if(this.disjointQueryTimerExtension==null){this.disjointQueryTimerExtension=eL(this.gl,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")}return this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();const e=t.createQuery();t.beginQuery(n.TIME_ELAPSED_EXT,e);return e}const t=this.getQueryTimerExtensionWebGL1();const n=t.createQueryEXT();t.beginQueryEXT(t.TIME_ELAPSED_EXT,n);return n}endQuery(){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){await C((()=>this.disposed||this.isQueryAvailable(t,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))));return this.getQueryTime(t,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0){return null}if(n===2){const n=this.gl;const e=n.getQueryParameter(t,n.QUERY_RESULT);return e/1e6}else{const n=this.getQueryTimerExtensionWebGL1();const e=n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT);return e/1e6}}isQueryAvailable(t,n){if(n===0){return true}if(n===2){const n=this.gl;const e=this.getQueryTimerExtensionWebGL2();const s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);if(this.disjoint==null){this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)}return s&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1();const e=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);if(this.disjoint==null){this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)}return e&&!this.disjoint}}pollFence(t){return new Promise((n=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>n()))}))}pollItems(){const t=EP(this.itemsToPoll.map((t=>t.isDoneFn)));for(let n=0;n<=t;++n){const{resolveFn:t}=this.itemsToPoll[n];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){this.itemsToPoll.push({isDoneFn:t,resolveFn:n});if(this.itemsToPoll.length>1){return}let e=undefined;if("setTimeoutCustom"in st().platform){e=st().platform.setTimeoutCustom.bind(st().platform)}C((()=>{this.pollItems();return this.itemsToPoll.length===0}),(()=>0),null,e)}bindTextureToFrameBuffer(t){this.throwIfDisposed();vL(this.gl,t,this.framebuffer);if(this.debug){yL(this.gl)}}unbindTextureToFrameBuffer(){if(this.outputTexture!=null){vL(this.gl,this.outputTexture,this.framebuffer);if(this.debug){yL(this.gl)}}else{$L(this.gl,this.framebuffer)}}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const e=n();this.unbindTextureToFrameBuffer();return e}setOutputMatrixTextureDriver(t,n,e){this.throwIfDisposed();const s=this.gl;vL(s,t,this.framebuffer);if(this.debug){yL(s)}this.outputTexture=t;JD(s,(()=>s.viewport(0,0,n,e)));JD(s,(()=>s.scissor(0,0,n,e)))}setOutputMatrixWriteRegionDriver(t,n,e,s){this.throwIfDisposed();JD(this.gl,(()=>this.gl.scissor(t,n,e,s)))}throwIfDisposed(){if(this.disposed){throw new Error("Attempted to use disposed GPGPUContext.")}}throwIfNoProgram(){if(this.program==null){throw new Error("No GPU program is currently set.")}}}function EP(t){let n=0;for(;n<t.length;++n){const e=t[n]();if(!e){break}}return n-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:TP,bincountImpl:IP,bincountReduceImpl:AP,bitwiseAndImpl:OP,castImpl:FP,ceilImpl:_P,concatImpl:MP,equalImpl:DP,expImpl:LP,expm1Impl:zP,floorImpl:PP,gatherNdImpl:VP,gatherV2Impl:BP,greaterImpl:WP,greaterEqualImpl:GP,lessImpl:UP,lessEqualImpl:HP,linSpaceImpl:jP,logImpl:qP,maxImpl:XP,maximumImpl:KP,minimumImpl:JP,multiplyImpl:YP,negImpl:ZP,notEqualImpl:QP,prodImpl:tV,raggedGatherImpl:nV,raggedRangeImpl:eV,raggedTensorToTensorImpl:sV,rangeImpl:oV,rsqrtImpl:rV,scatterImpl:iV,sigmoidImpl:cV,simpleAbsImpl:aV,sliceImpl:uV,sparseFillEmptyRowsImpl:lV,sparseReshapeImpl:fV,sparseSegmentReductionImpl:hV,sqrtImpl:dV,staticRegexReplaceImpl:pV,stridedSliceImpl:mV,stringNGramsImpl:xV,stringSplitImpl:bV,stringToHashBucketFastImpl:gV,subImpl:wV,tileImpl:vV,topKImpl:$V,transposeImpl:yV,uniqueImpl:kV}=BI;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV(t,n){return["x","y","z","w","u","v"].slice(0,n).map((n=>`${t}.${n}`))}function NV(t,n){if(n===1){return[t]}return CV(t,n)}function RV(t,n){if(t===1){return"rc"}let e="";for(let s=0;s<t;s++){e+=n[s];if(s<t-1){e+=","}}return e}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SV{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outputShape=t;this.rank=t.length;this.enableShapeUniforms=Yz(this.outputShape.length);if(this.rank===0){this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `}else{const t=NV("rc",this.rank);const n=Wz(this.rank);const e=this.getOutOfBoundsCondition(t);const s=this.getSetup(t);const o=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${e}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const n=[];for(let e=0;e<=1;e++){for(let s=0;s<=1;s++){let o=`${e===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let n=2;n<this.rank;n++){o=`${t[t.length-1-n]},`+o}n.push(o)}}return n}getOutOfBoundsCondition(t){if(this.rank===1){return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`}let n="";for(let e=this.rank-2;e<this.rank;e++){n+=`${t[e]} >= ${this.enableShapeUniforms?`outShape[${e}]`:this.outputShape[e]}`;if(e<this.rank-1){n+="||"}}return n}getSetup(t){if(this.rank===1){return""}const n=t.slice(-2);const e=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1];const s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${n[0]};\n      int c = ${n[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${e};\n      bool rEdge = rp1 >= ${s};\n    `}getOutput(t){const n=this.getSourceCoordsArr(t);if(this.rank===1){const t=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${t} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${n[0]}),\n            cEdge ? 0. : getA(${n[1]}),\n            rEdge ? 0. : getA(${n[2]}),\n            rEdge || cEdge ? 0. : getA(${n[3]})`}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EV{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);let e=``;for(let t=0;t<4;t++){let n=`thisRC = rc;`;if(t%2===1){n+=`thisRC.z += 1;`}if(t>1){n+=`thisRC.y += 1;`}e+=`\n        ${n}\n        ${t>0?`if(thisRC.y < rows && thisRC.z < cols){`:""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}this.userCode=`\n      ${TV(n,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?ZL():YL(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${e}\n\n        setOutput(result);\n      }\n    `}}function TV(t,n){const e=n?JL(["r","c","d"],"inputShape"):qL(["r","c","d"],t);return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e}\n      return ivec3(r, c, d);\n    }\n  `}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IV{constructor(t){this.gpgpu=t;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.usedTextures={};this.logEnabled=false}acquireTexture(t,n,e){const s=MV(n,e);const o=DV(t,s,e);if(!(o in this.freeTextures)){this.freeTextures[o]=[]}if(!(o in this.usedTextures)){this.usedTextures[o]=[]}const r=OV(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,e);if(this.freeTextures[o].length>0){this.numFreeTextures--;this.numUsedTextures++;this._numBytesFree-=r;this.log();const t=this.freeTextures[o].pop();this.usedTextures[o].push(t);return t}let i;if(s===GD.PACKED_2X2_FLOAT32){i=this.gpgpu.createPackedMatrixTexture(t[0],t[1])}else if(s===GD.PACKED_2X2_FLOAT16){i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1])}else if(s===GD.UNPACKED_FLOAT32){i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1])}else if(s===GD.UNPACKED_FLOAT16){i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1])}else if(s===GD.PACKED_4X1_UNSIGNED_BYTE){i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])}this.usedTextures[o].push(i);this.numUsedTextures++;this._numBytesAllocated+=r;this.log();return i}releaseTexture(t,n,e,s){if(this.freeTextures==null){return}const o=MV(e,s);const r=DV(n,o,s);if(!(r in this.freeTextures)){this.freeTextures[r]=[]}const i=OV(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s);const c=st().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");if(c!==-1&&this._numBytesAllocated>c){this.gpgpu.deleteMatrixTexture(t.texture);this._numBytesAllocated-=i}else{this.freeTextures[r].push(t);this.numFreeTextures++;this._numBytesFree+=i}this.numUsedTextures--;const a=this.usedTextures[r];const u=a&&a.indexOf(t);if(u==null||u<0){throw new Error("Cannot release a texture that was never provided by this "+"texture manager")}a[u]=a[a.length-1];a.pop();this.log()}log(){if(!this.logEnabled){return}const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`);console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null){return}for(const t in this.freeTextures){this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}))}for(const t in this.usedTextures){this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}))}this.freeTextures=null;this.usedTextures=null;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0}}function AV(t,n){const e=t;if(n===e.R32F){return 4}else if(n===e.R16F){return 2}else if(n===e.RGBA32F){return 16}else if(n===t.RGBA){return 16}else if(n===e.RGBA16F){return 8}else if(n===e.RGBA8){return 4}throw new Error(`Unknown internal format ${n}`)}function OV(t,n,e,s,o){const r=FV(n,s);let i;if(o){const[n,e]=qD(t[0],t[1]);i=n*e}else{const[n,e]=UD(t[0],t[1]);i=n*e}const c=AV(e,r);return i*c}function FV(t,n){switch(t){case GD.PACKED_2X2_FLOAT32:return mP(n);case GD.PACKED_2X2_FLOAT16:return bP(n);case GD.UNPACKED_FLOAT32:return uP(n);case GD.UNPACKED_FLOAT16:return fP(n);case GD.PACKED_4X1_UNSIGNED_BYTE:return dP(n);default:throw new Error(`Unknown physical texture type ${t}`)}}function _V(t){if(st().getBool("WEBGL_RENDER_FLOAT32_ENABLED")){if(t){return GD.PACKED_2X2_FLOAT32}return GD.UNPACKED_FLOAT32}if(t){return GD.PACKED_2X2_FLOAT16}return GD.UNPACKED_FLOAT16}function MV(t,n){if(t===WD.UPLOAD){return GD.PACKED_2X2_FLOAT32}else if(t===WD.RENDER||t==null){return _V(n)}else if(t===WD.DOWNLOAD||t===WD.PIXELS){return GD.PACKED_4X1_UNSIGNED_BYTE}throw new Error(`Unknown logical texture type ${t}`)}function DV(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LV{constructor(t,n){this.variableNames=["A"];this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);this.userCode=`\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const zV=`if (isnan(x)) return x;`;const PV=`return x;`;const VV=`return abs(x);`;const BV=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const WV=zV+`\n  return (x < 0.0) ? 0.0 : x;\n`;const GV=zV+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const UV="return x;";const HV=`return 1.0 / (1.0 + exp(-1.0 * x));`
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const jV=`return x;`;const qV=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const XV=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const KV=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const JV=`return 1.0 / (1.0 + exp(-1.0 * x));`;class YV{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZV{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);const n=t.length;const e=NV("rc",n);const s=Wz(n);const o=RV(n,e);const r=e.slice(-2);const i=n<=1?"rc":`vec2(${r.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QV=Sm;const tB=1e-7;const nB=1e-4;const eB={};function sB(t){if(t in eB){return eB[t]}eB[t]={};return eB[t]}const oB=st().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");const rB=600;function iB(){if(st().global.screen==null){return 1024}return st().global.screen.height*st().global.screen.width*window.devicePixelRatio*rB/1024/1024}class cB extends u{nextDataId(){return cB.nextDataId++}constructor(t){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=false;this.pendingDeletes=0;this.disposed=false;if(!st().getBool("HAS_WEBGL")){throw new Error("WebGL is not supported on this device")}let n;if(t!=null){if(t instanceof SP){n=t}else{const e=zD(st().getNumber("WEBGL_VERSION"),t);n=new SP(e)}this.binaryCache={};this.gpgpuCreatedLocally=false}else{const t=zD(st().getNumber("WEBGL_VERSION"));n=new SP(t);this.binaryCache=sB(st().getNumber("WEBGL_VERSION"));this.gpgpuCreatedLocally=true}this.gpgpu=n;this.canvas=this.gpgpu.gl.canvas;this.textureManager=new IV(this.gpgpu);this.numMBBeforeWarning=iB();this.texData=new a(this,$c())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,e,s,o,r){const i=this.makeTensorInfo(n,e);const c=this.texData.get(i.dataId);c.isPacked=false;c.texture={texture:t,texShape:[s,o]};c.texShape=[s,o];const a=EL(n);const u=new sP(a,false,r);const l=this.runWebGLProgram(u,[i],e,[[s,o]]);l.shape=n;c.texture=null;this.disposeIntermediateTensorInfo(i);return l.dataId}write(t,n,e){if(st().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||st().getBool("DEBUG")){this.checkNumericalProblems(t)}if(e==="complex64"&&t!=null){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}const s={id:this.nextDataId()};this.texData.set(s,{shape:n,dtype:e,values:t,usage:WD.UPLOAD,refCount:1});return s}refCount(t){if(this.texData.has(t)){const n=this.texData.get(t);return n.refCount}return 0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,e,s,o){if(st().getBool("DEBUG")){this.checkNumericalProblems(n)}if(s==="complex64"){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}this.texData.set(t,{shape:e,dtype:s,values:n,usage:WD.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t);const{values:e,dtype:s,complexTensorInfos:o,slice:r,shape:i,isPacked:c}=n;if(r!=null){let n;if(c){n=new YV(i,UV)}else{n=new LV(i,UV)}const e=this.runWebGLProgram(n,[{dataId:t,shape:i,dtype:s}],s);const o=this.readSync(e.dataId);this.disposeIntermediateTensorInfo(e);return o}if(e!=null){return this.convertAndCacheOnCPU(t)}if(s==="string"){return e}const a=this.activeTimers!=null;let u;if(a){u=Zo()}let l;if(s==="complex64"){const t=this.readSync(o.real.dataId);const n=this.readSync(o.imag.dataId);l=ng(t,n)}else{l=this.getValuesFromTexture(t)}if(a){this.downloadWaitMs+=Zo()-u}return this.convertAndCacheOnCPU(t,l)}async read(t){if(this.pendingRead.has(t)){const n=this.pendingRead.get(t);return new Promise((t=>n.push(t)))}const n=this.texData.get(t);const{values:e,shape:s,slice:o,dtype:r,complexTensorInfos:i,isPacked:c}=n;if(o!=null){let n;if(c){n=new YV(s,UV)}else{n=new LV(s,UV)}const e=this.runWebGLProgram(n,[{dataId:t,shape:s,dtype:r}],r);const o=this.read(e.dataId);this.disposeIntermediateTensorInfo(e);return o}if(e!=null){return this.convertAndCacheOnCPU(t)}if(st().getBool("DEBUG")){if(!st().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&st().getNumber("WEBGL_VERSION")===2){throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and `+`WEBGL_VERSION=2 not yet supported.`)}}let a=null;let u;if(r!=="complex64"&&st().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const n=this.texData.get(u.dataId);a=this.gpgpu.createBufferFromTexture(n.texture.texture,...jD(s))}this.pendingRead.set(t,[]);if(r!=="complex64"){await this.gpgpu.createAndWaitForFence()}let l;if(r==="complex64"){const t=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);const n=t[0];const e=t[1];l=ng(n,e)}else if(a==null){l=this.getValuesFromTexture(t)}else{const t=w(s);l=this.gpgpu.downloadFloat32MatrixFromBuffer(a,t)}if(u!=null){this.disposeIntermediateTensorInfo(u)}if(a!=null){const t=this.gpgpu.gl;JD(t,(()=>t.deleteBuffer(a)))}const f=this.convertAndCacheOnCPU(t,l);const h=this.pendingRead.get(t);this.pendingRead.delete(t);h.forEach((t=>t(f)));if(this.pendingDisposal.has(t)){this.pendingDisposal.delete(t);if(this.disposeData(t)){$c().removeDataId(t,this)}this.pendingDeletes--}return f}readToGPU(t,n={}){const e=this.texData.get(t);const{values:s,shape:o,slice:r,dtype:i,isPacked:c,texture:a}=e;if(i==="complex64"){throw new Error("Does not support reading texture for complex64 dtype.")}if(r!=null){let e;if(c){e=new YV(o,UV)}else{e=new LV(o,UV)}const s=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:i}],i);const r=this.readToGPU(s,n);this.disposeIntermediateTensorInfo(s);return r}if(a==null){if(s!=null){throw new Error("Data is not on GPU but on CPU.")}else{throw new Error("There is no data on GPU or CPU.")}}const u=this.decode(t,n.customTexShape);const l=$c().makeTensorFromTensorInfo(u);const f=this.texData.get(u.dataId);return Object.assign({tensorRef:l},f.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string"){try{const e=n.map((t=>tr(t)));return ba(t.shape,t.dtype,e)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}}return ba(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t==null){return}for(let n=0;n<t.length;n++){const e=t[n];if(!tL(e)){if(st().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")){throw Error(`The value ${e} cannot be represented with your `+`current settings. Consider enabling float32 rendering: `+`'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`)}throw Error(`The value ${e} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:n,dtype:e,isPacked:s}=this.texData.get(t);const o=w(n);if(st().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const e=this.decode(t);const s=this.texData.get(e.dataId);const r=this.gpgpu.downloadMatrixFromPackedTexture(s.texture.texture,...jD(n)).subarray(0,o);this.disposeIntermediateTensorInfo(e);return r}const r=st().getBool("WEBGL_PACK")&&s===true;const i=r?EL(n):n;const c=r?new nP(i):new tP(i);const a=this.runWebGLProgram(c,[{shape:i,dtype:e,dataId:t}],"float32");const u=this.texData.get(a.dataId);const l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,o);this.disposeIntermediateTensorInfo(a);return l}timerAvailable(){return st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers;const e=[];let s=false;if(this.programTimersStack==null){this.programTimersStack=e;s=true}else{this.activeTimers.push(e)}this.activeTimers=e;t();const o=er(this.activeTimers.map((t=>t.query))).filter((t=>t!=null));const r=er(this.activeTimers.map((t=>t.name))).filter((t=>t!=null));this.activeTimers=n;if(s){this.programTimersStack=null}const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(o);i["kernelMs"]=m(t);i["getExtraProfileInfo"]=()=>t.map(((t,n)=>({name:r[n],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else{i["kernelMs"]={error:"WebGL query timers are not supported in this environment."}}this.uploadWaitMs=0;this.downloadWaitMs=0;return i})()}memory(){return{unreliable:false,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.beginQuery()}return{startMs:Zo(),endMs:null}}endTimer(t){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){this.gpgpu.endQuery();return t}t.endMs=Zo();return t}async getQueryTime(t){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.waitForQueryAndGetTime(t)}const n=t;return n.endMs-n.startMs}disposeData(t,n=false){if(this.pendingDisposal.has(t)){return false}if(!this.texData.has(t)){return true}if(n){this.texData.get(t).refCount=0}else{this.texData.get(t).refCount--}if(!n&&this.texData.get(t).refCount>0){return false}if(this.pendingRead.has(t)){this.pendingDisposal.add(t);this.pendingDeletes++;return false}this.releaseGPUData(t);const{complexTensorInfos:e}=this.texData.get(t);if(e!=null){this.disposeData(e.real.dataId,n);this.disposeData(e.imag.dataId,n)}this.texData.delete(t);return true}releaseGPUData(t){const{texture:n,dtype:e,texShape:s,usage:o,isPacked:r,slice:i}=this.texData.get(t);const c=i&&i.origDataId||t;const a=this.dataRefCount.get(c);if(a>1){this.dataRefCount.set(c,a-1)}else{this.dataRefCount.delete(c);if(n!=null){this.numBytesInGPU-=this.computeBytes(s,e);this.textureManager.releaseTexture(n,s,o,r)}}const u=this.texData.get(t);u.texture=null;u.texShape=null;u.isPacked=false;u.slice=null}getTexture(t){this.uploadToGPU(t);return this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=oB){return st().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>this.texData.get(t.dataId).texture==null&&w(t.shape)<n))}getGPGPUContext(){return this.gpgpu}where(t){ho("tf.where() in webgl locks the UI thread. "+"Call tf.whereAsync() instead");const n=t.dataSync();return QV(t.shape,n)}packedUnaryOp(t,n,e){const s=new YV(t.shape,n);const o=this.compileAndRun(s,[t],e);return $c().makeTensorFromTensorInfo(o)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const n=aV(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,n)}if(st().getBool("WEBGL_PACK_UNARY_OPERATIONS")){return this.packedUnaryOp(t,VV,t.dtype)}const n=new LV(t.shape,VV);const e=this.compileAndRun(n,[t]);return $c().makeTensorFromTensorInfo(e)}makeTensorInfo(t,n,e){let s;if(n==="string"&&e!=null&&e.length>0&&M(e[0])){const o=e.map((t=>Qo(t)));s=this.write(o,t,n)}else{s=this.write(e,t,n)}this.texData.get(s).usage=null;return{dataId:s,shape:t,dtype:n}}makeOutput(t,n,e){return $c().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}unpackTensor(t){const n=new ZV(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new SV(t.shape);const e=true;return this.runWebGLProgram(n,[t],t.dtype,null,e)}packedReshape(t,n){const e=[RL(t.shape),...SL(t.shape)];const s={dtype:t.dtype,shape:e,dataId:t.dataId};const o=[RL(n),...SL(n)];const r=new EV(o,e);const i=true;const c=[e];const a=this.runWebGLProgram(r,[s],t.dtype,c,i);return{dataId:a.dataId,shape:n,dtype:a.dtype}}decode(t,n){const e=this.texData.get(t);const{isPacked:s,shape:o,dtype:r}=e;if(n!=null){const t=w(o);const e=n[0]*n[1]*4;x(t<=e,(()=>"customTexShape is too small. "+"Row * Column * 4 should be equal or larger than the "+"size of the tensor data."))}const i=EL(o);let c;if(s){c=new Qz(i)}else{c=new Zz(i)}const a=true;const u=[n!=null?n:jD(i)];const l=this.runWebGLProgram(c,[{shape:i,dtype:r,dataId:t}],r,u,a,n);return{dtype:r,shape:o,dataId:l.dataId}}runWebGLProgram(t,n,e,s,o=false,r){const i=this.makeTensorInfo(t.outputShape,e);const c=this.texData.get(i.dataId);if(t.packedOutput){c.isPacked=true}if(t.outPackingScheme===BD.DENSE){const n=r!=null?r:jD(t.outputShape);c.texShape=n.map((t=>t*2))}if(t.outTexUsage!=null){c.usage=t.outTexUsage}if(w(i.shape)===0){c.values=E(i.dtype,0);return i}const a=[];const u=n.map((n=>{if(n.dtype==="complex64"){throw new Error(`GPGPUProgram does not support complex64 input. For complex64 `+`dtypes, please separate the program into real and imaginary `+`parts.`)}let e=this.texData.get(n.dataId);if(e.texture==null){if(!t.packedInputs&&w(n.shape)<=st().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")){return{shape:n.shape,texData:null,isUniform:true,uniformValues:e.values}}if(t.packedInputs){e.isPacked=true;e.shape=n.shape}}this.uploadToGPU(n.dataId);if(!!e.isPacked!==!!t.packedInputs){n=e.isPacked?this.unpackTensor(n):this.packTensor(n);a.push(n);e=this.texData.get(n.dataId)}else if(e.isPacked&&!AL(e.shape,n.shape)){const t=n;const s=n.shape;n.shape=e.shape;n=this.packedReshape(n,s);a.push(n);e=this.texData.get(n.dataId);t.shape=s}return{shape:n.shape,texData:e,isUniform:false}}));this.uploadToGPU(i.dataId);const l={shape:i.shape,texData:c,isUniform:false};const f=Jz(t,u,l);const h=this.getAndSaveBinary(f,(()=>jz(this.gpgpu,t,u,l)));const d=this.activeTimers!=null;let p;if(d){p=this.startTimer()}if(!st().get("ENGINE_COMPILE_ONLY")){Kz(this.gpgpu,h,u,l,s)}a.forEach((t=>this.disposeIntermediateTensorInfo(t)));if(d){p=this.endTimer(p);this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(p)})}const m=st().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=Zo();if(t-this.lastGlFlushTime>m){this.gpgpu.gl.flush();this.lastGlFlushTime=t}}if(!st().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&o===false){const t=this.unpackTensor(i);this.disposeIntermediateTensorInfo(i);return t}return i}compileAndRun(t,n,e,s,o=false){e=e||n[0].dtype;const r=this.runWebGLProgram(t,n,e,s,o);return r}getAndSaveBinary(t,n){if(!(t in this.binaryCache)){this.binaryCache[t]=n()}return this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed){return}if(!st().getBool("IS_TEST")){const t=Object.keys(this.binaryCache);t.forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram);delete this.binaryCache[t]}))}this.textureManager.dispose();if(this.canvas!=null&&(typeof HTMLCanvasElement!=="undefined"&&this.canvas instanceof HTMLCanvasElement)){this.canvas.remove()}else{this.canvas=null}if(this.gpgpuCreatedLocally){this.gpgpu.program=null;this.gpgpu.dispose()}this.disposed=true}floatPrecision(){if(this.floatPrecisionValue==null){this.floatPrecisionValue=kc((()=>{if(!st().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=st().getBool("DEBUG");st().set("DEBUG",false);const n=this.abs($f(1e-8)).dataSync()[0];st().set("DEBUG",t);if(n>0){return 32}}return 16}))}return this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?tB:nB}uploadToGPU(t){const n=this.texData.get(t);const{shape:e,dtype:s,values:o,texture:r,usage:i,isPacked:c}=n;if(r!=null){return}const a=this.activeTimers!=null;let u;if(a){u=Zo()}let l=n.texShape;if(l==null){l=TL(e,c);n.texShape=l}if(o!=null){const t=EL(e);let r;let i=l[1],f=l[0];const h=o instanceof Uint8Array||o instanceof Uint8ClampedArray;if(c||!h){[i,f]=qD(l[0],l[1])}if(c){r=new oP(t,h)}else{r=new sP(t,h)}const d=h?[f,i]:l;const p=this.makeTensorInfo(d,s);const m=this.texData.get(p.dataId);if(h){m.usage=WD.PIXELS}else{m.usage=WD.UPLOAD}m.texShape=d;this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,f,o);const x=[[f,i]];const b=true;const g=this.runWebGLProgram(r,[p],s,x,b);const w=this.texData.get(g.dataId);n.texShape=w.texShape;n.isPacked=w.isPacked;n.usage=w.usage;if(!st().get("ENGINE_COMPILE_ONLY")){n.texture=w.texture;n.values=null;this.texData.delete(g.dataId)}else{this.disposeData(g.dataId)}this.disposeIntermediateTensorInfo(p);if(a){this.uploadWaitMs+=Zo()-u}}else{const t=this.acquireTexture(l,i,s,c);n.texture=t}}convertAndCacheOnCPU(t,n){const e=this.texData.get(t);const{dtype:s}=e;if(n!=null){e.values=aB(n,s)}return e.values}acquireTexture(t,n,e,s){this.numBytesInGPU+=this.computeBytes(t,e);if(!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=true;console.warn(`High memory usage in GPU: ${t} MB, `+`most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*F(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache)){this.checkCompletion_(t)}}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache)){t.push(this.checkCompletionAsync_(n))}return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const e=new Promise((t=>{try{this.checkCompletion_(n);t(true)}catch(t){throw t}}));t.push(e)}return Promise.all(t)}}async checkCompletionAsync_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)){return this.checkCompletion_(t)}else{await Ab();return this.checkCompletionAsync_(t)}}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===false){console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram));if(this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===false){iL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader));throw new Error("Failed to compile fragment shader.")}throw new Error("Failed to link vertex and fragment shaders.")}return true}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:e,infLoc:s,nanLoc:o,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:c}=qz(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n;t.customUniformLocations=e;t.infLoc=s;t.nanLoc=o;t.outShapeLocation=r;t.outShapeStridesLocation=i;t.outTexShapeLocation=c}}createTensorFromGPUData(t,n,e){t.channels=t.channels||"RGBA";const{texture:s,height:o,width:r,channels:i}=t;const c=$c().backend;if(!c.gpgpu.gl.isTexture(s)){throw new Error(`The texture is invalid. Also, please make sure the texture and `+`the TFJS WebGL backend are using the same canvas. If you want to `+`use your own custom canvas, you have to create and use the custom `+`TFJS WebGL backend created from the canvas through `+`'new tf.MathBackendWebGL(customCanvas)'.`)}const a=c.writeTexture(s,n,e,o,r,i);return $c().makeTensorFromDataId(a,n,e,c)}}cB.nextDataId=0;function aB(t,n){if(n==="float32"||n==="complex64"){return t}else if(n==="int32"||n==="bool"){const e=n==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let n=0;n<e.length;++n){e[n]=Math.round(t[n])}return e}else{throw new Error(`Unknown dtype ${n}`)}}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */if(Xr()){Rc("webgl",(()=>new cB),2)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uB=`\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;class lB{constructor(t,n,e){this.variableNames=["A","B"];this.outputShape=Gl(n,e);this.enableShapeUniforms=Yz(this.outputShape.length);this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fB=`\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`;class hB{constructor(t,n,e,s=false){this.variableNames=["A","B"];this.supportsBroadcasting=true;this.packedInputs=true;this.packedOutput=true;this.outputShape=Gl(n,e);const o=this.outputShape.length;this.enableShapeUniforms=Yz(o);let r="";if(s){if(o===0||w(this.outputShape)===1){r=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `}else{const t=Wz(o);r=`\n          ${t} coords = getOutputCoords();\n        `;if(o===1){if(this.enableShapeUniforms){r+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}else{r+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}}else{const t=NV("coords",o);if(this.enableShapeUniforms){r+=`\n            bool nextRowOutOfBounds =\n              (${t[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${t[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}else{r+=`\n            bool nextRowOutOfBounds =\n              (${t[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${t[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${r}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(t){const{inputs:n,backend:e}=t;const{x:s}=n;e.incRef(s.dataId);return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const pB={kernelName:me,backendName:"webgl",kernelFunc:dB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(t){const{inputs:n,backend:e}=t;const{real:s,imag:o}=n;const r=e.makeTensorInfo(s.shape,"complex64");const i=e.texData.get(r.dataId);const c=dB({inputs:{x:s},backend:e});const a=dB({inputs:{x:o},backend:e});i.complexTensorInfos={real:c,imag:a};return r}const xB={kernelName:Rn,backendName:"webgl",kernelFunc:mB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bB=`return (a < 0.) ? b * a : a;`;const gB=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function wB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{alpha:r}=s;const i=e.makeTensorInfo([],"float32",Ko(r,"float32"));const c=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hB(gB,o.shape,i.shape):new lB(bB,o.shape,i.shape);const a=e.runWebGLProgram(c,[o,i],"float32");e.disposeIntermediateTensorInfo(i);return a}const vB={kernelName:$e,backendName:"webgl",kernelFunc:wB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $B=`return (a < 0.) ? b * a : a;`;const yB=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function kB(t){const{inputs:n,backend:e}=t;const{x:s,alpha:o}=n;const r=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hB(yB,s.shape,o.shape):new lB($B,s.shape,o.shape);return e.runWebGLProgram(r,[s,o],"float32")}const CB={kernelName:ss,backendName:"webgl",kernelFunc:kB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NB=`if (isnan(x)) return x;`;function RB({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:s}){return({inputs:o,backend:r})=>{const{x:i}=o;const c=r;const a=s||i.dtype;if(c.shouldExecuteOnCPU([i])&&e!=null){const t=c.texData.get(i.dataId);const n=e(t.values,a);return c.makeTensorInfo(i.shape,a,n)}const u=st().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&n!=null;let l;if(u){l=new YV(i.shape,n)}else{l=new LV(i.shape,t)}return c.runWebGLProgram(l,[i],a)}}function SB({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=false,supportsComplex:s=false,cpuKernelImpl:o,dtype:r}){return({inputs:i,backend:c})=>{const{a,b:u}=i;const l=c;if(s&&a.dtype==="complex64"){const n=l.texData.get(a.dataId);const e=l.texData.get(u.dataId);const[s,o]=[[n.complexTensorInfos.real,e.complexTensorInfos.real],[n.complexTensorInfos.imag,e.complexTensorInfos.imag]].map((n=>{const[e,s]=n;const o={dataId:e.dataId,dtype:e.dtype,shape:a.shape};const r={dataId:s.dataId,dtype:s.dtype,shape:u.shape};const i=new lB(t,a.shape,u.shape);return l.runWebGLProgram(i,[o,r],Ar(e.dtype,s.dtype))}));const r=mB({inputs:{real:s,imag:o},backend:l});l.disposeIntermediateTensorInfo(s);l.disposeIntermediateTensorInfo(o);return r}const f=r||Ar(a.dtype,u.dtype);if((a.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([a,u]))&&o!=null){const t=l.texData.get(a.dataId).values;const n=l.texData.get(u.dataId).values;const e=a.dtype==="string"?Dg(t):t;const s=a.dtype==="string"?Dg(n):n;const[r,i]=o(a.shape,u.shape,e,s,f);const c=l.makeTensorInfo(i,f);const h=l.texData.get(c.dataId);h.values=r;return c}const h=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&n!=null;let d;if(h){d=new hB(n,a.shape,u.shape,e)}else{d=new lB(t,a.shape,u.shape)}return l.runWebGLProgram(d,[a,u],f)}}function EB(t,n=false){if(t==="linear"){if(n){return jV}return PV}else if(t==="relu"){if(n){return XV}return WV}else if(t==="elu"){if(n){return qV}return BV}else if(t==="relu6"){if(n){return KV}return GV}else if(t==="prelu"){if(n){return yB}return $B}else if(t==="leakyrelu"){if(n){return gB}return bB}else if(t==="sigmoid"){if(n){return JV}return HV}throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TB{constructor(t,n,e,s=false,o=false,r=false,i=null,c=false,a=false){this.variableNames=["matrixA","matrixB"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.enableShapeUniforms=Yz(this.outputShape.length);const u=s?t[1]:t[2];const l=Math.ceil(u/2);const f=s?"i * 2, rc.y":"rc.y, i * 2";const h=o?"rc.z, i * 2":"i * 2, rc.z";const d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];const p=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",x="";if(i){if(c){m=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`}else if(a){m=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`}else{m=`vec4 activation(vec4 x) {\n          ${i}\n        }`}x=`result = activation(result);`}const b=r?"result += getBiasAtOutCoords();":"";if(r){this.variableNames.push("bias")}if(c){this.variableNames.push("preluActivationWeights")}if(a){this.variableNames.push("leakyreluAlpha")}let g="rc.x";let w="rc.x";if(t[0]<n[0]){g=`imod(rc.x, ${t[0]})`}else if(n[0]<t[0]){w=`imod(rc.x, ${n[0]})`}this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${g};\n        int batchB = ${w};\n        for (int i = 0; i < ${l}; i++) {\n          vec4 a = getMatrixA(batchA, ${f});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${x}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IB={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class AB{constructor(t,n,e){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=Gl(n,e);this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OB="return a * b;";function FB(t){const{inputs:n,backend:e}=t;const{a:s,b:o}=n;const r=Ar(s.dtype,o.dtype);if(s.dtype==="complex64"){const t=e.texData.get(s.dataId);const n=e.texData.get(o.dataId);const r=new AB(IB.REAL,s.shape,o.shape);const i=new AB(IB.IMAG,s.shape,o.shape);const c=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:o.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:o.shape}];const a=e.runWebGLProgram(r,c,"float32");const u=e.runWebGLProgram(i,c,"float32");const l=mB({inputs:{real:a,imag:u},backend:e});e.disposeIntermediateTensorInfo(a);e.disposeIntermediateTensorInfo(u);return l}if(e.shouldExecuteOnCPU([s,o])){const t=e.texData.get(s.dataId);const n=e.texData.get(o.dataId);const[i,c]=YP(s.shape,o.shape,t.values,n.values,r);const a=e.makeTensorInfo(c,r);const u=e.texData.get(a.dataId);u.values=i;return a}let i;if(st().getBool("WEBGL_PACK_BINARY_OPERATIONS")){i=new hB(OB,s.shape,o.shape)}else{i=new lB(OB,s.shape,o.shape)}return e.runWebGLProgram(i,[s,o],r)}const _B={kernelName:je,backendName:"webgl",kernelFunc:FB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(t,n,e){const s=[RL(t.shape),...SL(t.shape)];const o={dtype:t.dtype,shape:s,dataId:t.dataId};const r=[RL(n),...SL(n)];const i=new EV(r,s);const c=true;const a=[s];const u=e.runWebGLProgram(i,[o],t.dtype,a,c);return{dataId:u.dataId,shape:n,dtype:u.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{shape:r}=s;const i=e;const c=w(o.shape);const a=N(r,c);const u=w(a);x(c===u,(()=>`The new shape (${a}) has ${u} elements and the old `+`shape (${o.shape}) has ${c} elements. The new shape and old `+`shape must have the same number of elements.`));const l=i.texData.get(o.dataId);if(l.isPacked&&!AL(o.shape,a)&&!(l.texture!==null&&AL(l.shape,a))){return MB(o,a,i)}i.incRef(o.dataId);return{dataId:o.dataId,shape:a,dtype:o.dtype}}const LB={kernelName:hs,backendName:"webgl",kernelFunc:DB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zB{constructor(t,n){this.variableNames=["x"];const{windowSize:e,batchSize:s,inSize:o,outSize:r}=t;this.outputShape=[s,r];const i=Math.floor(e/4)*4;const c=e%4;let a=`sumValue += dot(values, ones);`;if(n!=null){const t=1/n;a=`sumValue += dot(values * ${$(t)?t.toPrecision(2):t}, ones);`}let u="";if(o%e>0){u=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `}this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${a}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${c===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${a}\n        } else if (${c===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${a}\n        } else if (${c===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${a}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PB{constructor(t,n){this.variableNames=["x"];const{windowSize:e,batchSize:s,inSize:o,outSize:r}=t;this.outputShape=[s,r];let i="0.0";let c=``;if(n==="prod"){i="1.0"}else if(n==="min"){i="1.0 / 1e-20";c=`min`}else if(n==="max"){i="-1.0 / 1e-20";c=`max`}let a=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="sum"){a=`sumValue`}else if(n==="prod"){a=`prodValue`}else if(n==="all"){a=`allValue`}else if(n==="any"){a=`anyValue`}const u=Math.floor(e/4)*4;const l=e%4;let f=`\n      if (${n==="sum"}) {\n        sumValue += dot(values, ones);\n      } else if (${n==="prod"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${c}(values, minMaxValue);\n        if (${n==="min"} || ${n==="max"}) {\n          minMaxValue = ${c}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;let h=`vec4`;if(n==="all"){i="1.0";f=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;h=`bvec4`}else if(n==="any"){i="0.0";f=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;h=`bvec4`}let d="";if(o%e>0){d=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `}this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${l===1}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${l===2}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${l===3}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${f}\n        }\n        setOutput(${a});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(t){const n=[];while(n.length===0||n[n.length-1].outSize!==1){const e=n.length?n[n.length-1].outSize:t[1];const s=Vb(e);n.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return n}function BB(t,n,e,s){const o=VB(t.shape);let r=t;for(let i=0;i<o.length;i++){const{inSize:c,windowSize:a,outSize:u}=o[i];let l;let f;if(e==="mean"){l=i===0?new zB({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u},c):new zB({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u})}else{l=new PB({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u},e)}f=r;r=s.runWebGLProgram(l,[r],n);if(f.dataId!==t.dataId){s.disposeIntermediateTensorInfo(f)}}return r}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WB{constructor(t,n){this.variableNames=["A"];const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[n[s]]}this.outputShape=e;this.rank=e.length;const s=Wz(this.rank);const o=GB(n);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}function GB(t){const n=t.length;if(n>6){throw Error(`Transpose for rank ${n} is not yet supported`)}const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"];const s=new Array(n);for(let n=0;n<t.length;n++){s[t[n]]=e[n]}return s.join()}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UB{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[n[s]]}this.outputShape=e;this.rank=e.length;if(this.rank>6){throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`)}const s=Wz(this.rank);const o=CV("rc",this.rank);const r=new Array(this.rank);for(let t=0;t<n.length;t++){r[n[t]]=o[t]}const i=`vec2(${r.slice(-2).join()})`;const c=`++${o[this.rank-1]} < ${e[this.rank-1]}`;const a=`getChannel(getA(${r.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${a};\n      if(${c}) {\n        result[1] = ${a};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${e[this.rank-2]}) {\n        result[2] = ${a};\n        if(${c}) {\n          result[3] = ${a};\n        }\n      }\n      setOutput(result);\n    }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(t,n,e){const s=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UB(t.shape,n):new WB(t.shape,n);return e.runWebGLProgram(s,[t],t.dtype)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(t,n,e,s){const o=n;const r=t.shape.length;const i=R(o,t.shape);let c=i;const a=hf(c,r);const u=a!=null;let l=t;if(u){l=HB(t,a,s);c=pf(c.length,r)}ff("sum",c,r);const[f,h]=uf(l.shape,c);let d=f;if(e){d=lf(f,i)}const p=w(h);const m=w(t.shape);const x=m/p;const b=DB({inputs:{x:l},attrs:{shape:[x,p]},backend:s});const g=Or(t.dtype);const v=BB(b,g,"sum",s);const $=DB({inputs:{x:v},attrs:{shape:d},backend:s});s.disposeIntermediateTensorInfo(b);s.disposeIntermediateTensorInfo(v);if(u){s.disposeIntermediateTensorInfo(l)}return $}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;return jB(o,r,i,e)}const XB={kernelName:Fs,backendName:"webgl",kernelFunc:qB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{perm:r}=s;const i=e;const c=o.shape.length;const a=new Array(c);for(let t=0;t<a.length;t++){a[t]=o.shape[r[t]]}let u;if(i.shouldExecuteOnCPU([o])){const t=i.texData.get(o.dataId);const n=t.values;const e=yV(n,o.shape,o.dtype,r,a);u=i.makeTensorInfo(a,o.dtype);const s=i.texData.get(u.dataId);s.values=e}else{u=HB(o,r,i)}return u}const JB={kernelName:no,backendName:"webgl",kernelFunc:KB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YB=1e3;function ZB({a:t,b:n,transposeA:e,transposeB:s,backend:o,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:a=null}){const u=t.shape.length;const l=n.shape.length;const f=e?t.shape[u-2]:t.shape[u-1];const h=s?n.shape[l-1]:n.shape[l-2];const d=e?t.shape[u-1]:t.shape[u-2];const p=s?n.shape[l-2]:n.shape[l-1];const m=t.shape.slice(0,-2);const b=n.shape.slice(0,-2);const g=w(m);const v=w(b);const $=Gl(t.shape.slice(0,-2),n.shape.slice(0,-2));const y=$.concat([d,p]);x(f===h,(()=>`Error in matMul: inner shapes (${f}) and (`+`${h}) of Tensors with shapes ${t.shape} and `+`${n.shape} and transposeA=${e}`+` and transposeB=${s} must match.`));const k=e?[g,f,d]:[g,d,f];const C=s?[v,p,h]:[v,h,p];const N=DB({inputs:{x:t},backend:o,attrs:{shape:k}});const R=DB({inputs:{x:n},backend:o,attrs:{shape:C}});const S=[N,R];const E=Math.max(g,v);const T=e?N.shape[1]:N.shape[2];const I=r!=null;const A=i!=null;const O=a==="leakyrelu";const F=a!=null?EB(a,true):null;const _=I||A||O||F!=null;let M;if((d===1||p===1)&&T>YB&&_===false){let t=N;let n=R;if(e){t=KB({inputs:{x:N},backend:o,attrs:{perm:[0,2,1]}});S.push(t)}if(s){n=KB({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}});S.push(n)}const r=p!==1;const i=p===1;let c=t;if(r){c=DB({inputs:{x:t},backend:o,attrs:{shape:[E,T,1]}});S.push(c)}const a=p===1?2:1;let u=n;if(i){u=DB({inputs:{x:n},backend:o,attrs:{shape:[E,1,T]}});S.push(u)}const l=FB({inputs:{a:c,b:u},backend:o});M=qB({inputs:{x:l},backend:o,attrs:{axis:a,keepDims:true}});S.push(l)}else{const a=Ar(t.dtype,n.dtype);const u=new TB(k,C,[E,d,p],e,s,I,F,A,O);const l=[N,R];if(r!=null){l.push(r)}if(A){l.push(i)}if(O){const t=o.makeTensorInfo([],"float32",Ko(c,"float32"));l.push(t);S.push(t)}M=o.runWebGLProgram(u,l,a)}const D=DB({inputs:{x:M},backend:o,attrs:{shape:y}});S.push(M);for(const t of S){o.disposeIntermediateTensorInfo(t)}return D}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r,bias:i,preluActivationWeights:c}=n;const{transposeA:a,transposeB:u,activation:l,leakyreluAlpha:f}=s;return ZB({a:o,b:r,transposeA:a,transposeB:u,backend:e,bias:i,preluActivationWeights:c,leakyreluAlpha:f,activation:l})}const tW={kernelName:uo,backendName:"webgl",kernelFunc:QB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nW=`return abs(x);`;function eW(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const t=e.texData.get(s.dataId);const n=aV(t.values);return e.makeTensorInfo(s.shape,s.dtype,n)}let o;if(st().getBool("WEBGL_PACK_UNARY_OPERATIONS")){o=new YV(s.shape,nW)}else{o=new LV(s.shape,nW)}return e.runWebGLProgram(o,[s],s.dtype)}const sW={kernelName:Zt,backendName:"webgl",kernelFunc:eW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oW=zV+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;const rW=RB({opSnippet:oW});const iW={kernelName:Qt,backendName:"webgl",kernelFunc:rW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cW=zV+`\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`;const aW=RB({opSnippet:cW});const uW={kernelName:tn,backendName:"webgl",kernelFunc:aW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lW="return a + b;";const fW=SB({opSnippet:lW,packedOpSnippet:lW,supportsComplex:true,cpuKernelImpl:TP});const hW={kernelName:nn,backendName:"webgl",kernelFunc:fW};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dW{constructor(t,n){this.outputShape=[];this.outputShape=t;this.variableNames=n.map(((t,n)=>`T${n}`));const e=[];this.variableNames.forEach((t=>{e.push(`float v${t} = get${t}AtOutCoords();`)}));const s=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${e.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pW{constructor(t,n){this.outputShape=[];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.variableNames=n.map(((t,n)=>`T${n}`));const e=[];this.variableNames.forEach((t=>{e.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const s=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${e.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(t){const{inputs:n,backend:e}=t;const s=n;if(s.length===1){return dB({inputs:{x:s[0]},backend:e})}if(s.length>st().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2);const n=mW({inputs:s.slice(0,t),backend:e});const o=mW({inputs:s.slice(t),backend:e});return mW({inputs:[n,o],backend:e})}const o=s.map((t=>t.dtype)).reduce(((t,n)=>Ar(t,n)));const r=s.map((t=>t.shape));const i=st().getBool("WEBGL_PACK");const c=i?new pW(s[0].shape,r):new dW(s[0].shape,r);return e.runWebGLProgram(c,s,o)}const xW={kernelName:en,backendName:"webgl",kernelFunc:mW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=R(r,o.shape);let u=a;const l=hf(u,c);let f=o;if(l!=null){f=KB({inputs:{x:o},backend:e,attrs:{perm:l}});u=pf(u.length,c)}ff("all",u,c);const[h,d]=uf(f.shape,u);const p=w(d);const m=DB({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=BB(m,m.dtype,"all",e);let b;if(i){const t=lf(h,a);b=DB({inputs:{x},backend:e,attrs:{shape:t}})}else{b=DB({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const gW={kernelName:sn,backendName:"webgl",kernelFunc:bW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=R(r,o.shape);let u=a;const l=hf(u,c);let f=o;if(l!=null){f=KB({inputs:{x:o},backend:e,attrs:{perm:l}});u=pf(u.length,c)}ff("any",u,c);const[h,d]=uf(f.shape,u);const p=w(d);const m=DB({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=BB(m,m.dtype,"any",e);let b;if(i){const t=lf(h,a);b=DB({inputs:{x},backend:e,attrs:{shape:t}})}else{b=DB({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const vW={kernelName:on,backendName:"webgl",kernelFunc:wW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $W{constructor(t,n,e){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:r}=t;if(!e){this.variableNames.push("bestIndicesA")}this.outputShape=[o,r];const i=n==="max"?">":"<";const c=e?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${c};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yW{constructor(t,n,e,s){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;x(t.length>2,(()=>`Packed arg${e.charAt(0).toUpperCase()+e.slice(1)} supports only inputs with rank above 2.`));const o=t[t.length-1];const r=Math.ceil(o/n);this.outputShape=t.slice(0,-1);if(r>1){this.outputShape.push(r)}if(!s){this.variableNames.push("bestIndicesA")}const i=this.outputShape;const c=i.length;const a=Wz(c);const u=NV("coords",c);let l;let f;if(r===1){f=c+1;const t=Wz(f);l=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[c-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[c-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[c-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[c-2]};`}else{f=c;l=`\n        ${a} sourceLocR = coords;\n        ++${u[c-1]};\n        ${a} sourceLocG = coords;\n        ++${u[c-2]};\n        ${a} sourceLocA = coords;\n        --${u[c-1]};\n        ${a} sourceLocB = coords;\n        --${u[c-2]};`}const h=["x","y","z","w","u","v"].slice(0,f);const d="."+h[f-1];const p=h.map((t=>"int "+t));const m=NV("sourceLocR",f-1).concat("inIdx.r");const b=NV("sourceLocG",f-1).concat("inIdx.g");const g=NV("sourceLocB",f-1).concat("inIdx.b");const w=NV("sourceLocA",f-1).concat("inIdx.a");const v=e==="max"?"greaterThan":"lessThan";const $=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${w.join()})));`;const y=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${b.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`;const k=s?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${a} coords = getOutputCoords();\n        bool hasNextCol = ${u[c-1]} < ${i[c-1]-1};\n        bool hasNextRow = ${u[c-2]} < ${i[c-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${n};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${y};\n\n        for (int i = 0; i < ${n}; i++) {\n          inIdx = srcIdx;\n          ${$}\n          vec4 candidate = ${y};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(t,n,e,s=null){let o=n.shape[0];let r=n.shape[1];if(s!=null){o=s.shape[0];r=s.shape[1]}const i=Vb(r);const c={windowSize:i,inSize:r,batchSize:o,outSize:Math.ceil(r/i)};const a=new $W(c,e,s==null);const u=[n];if(s!=null){u.push(s)}const l=t.runWebGLProgram(a,u,"int32");if(l.shape[1]===1){return l}const f=kW(t,n,e,l);t.disposeIntermediateTensorInfo(l);return f}function CW(t,n,e,s=null){const o=s!=null?s.shape:n.shape;const r=o[o.length-1];const i=Vb(r);const c=new yW(o,i,e,s==null);const a=s==null?[n]:[n,s];const u=t.runWebGLProgram(c,a,"int32");if(u.shape.length===n.shape.length){const s=CW(t,n,e,u);t.disposeIntermediateTensorInfo(u);return s}return u}function NW(t,n,e,s){const o=[e];ff("arg"+s.charAt(0).toUpperCase()+s.slice(1),o,n.shape.length);if(!st().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const e=[];const r=t.texData.get(n.dataId);const i=r!==null&&r.isPacked;let c=n;if(i){c=t.unpackTensor(n);e.push(c)}const[a,u]=uf(c.shape,o);const l=w(u);const f=DB({inputs:{x:c},backend:t,attrs:{shape:[-1,l]}});e.push(f);const h=kW(t,f,s);e.push(h);const d=DB({inputs:{x:h},backend:t,attrs:{shape:a}});e.forEach((n=>t.disposeIntermediateTensorInfo(n)));return d}return CW(t,n,s)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;let i=R(r,o.shape);const c=hf(i,o.shape.length);let a=o;const u=[];if(c!=null){a=KB({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=pf(i.length,a.shape.length)}ff("argMax",[i[0]],a.shape.length);const l=NW(e,a,i[0],"max");u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const SW={kernelName:rn,backendName:"webgl",kernelFunc:RW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;let i=R(r,o.shape);const c=hf(i,o.shape.length);let a=o;const u=[];if(c!=null){a=KB({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=pf(i.length,a.shape.length)}ff("argMin",[i[0]],a.shape.length);const l=NW(e,a,i[0],"min");u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const TW={kernelName:cn,backendName:"webgl",kernelFunc:EW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW=zV+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;const AW=RB({opSnippet:IW});const OW={kernelName:an,backendName:"webgl",kernelFunc:AW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FW=zV+`return log(x + sqrt(x * x + 1.0));`;const _W=RB({opSnippet:FW});const MW={kernelName:un,backendName:"webgl",kernelFunc:_W};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW=zV+`\n  return atan(x);\n`;const LW=RB({opSnippet:DW});const zW={kernelName:ln,backendName:"webgl",kernelFunc:LW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=uB+`\n  return atan(a, b);\n`;const VW=`\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+fB+`\n  return result;\n`;const BW=SB({opSnippet:PW,packedOpSnippet:VW});const WW={kernelName:hn,backendName:"webgl",kernelFunc:BW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=zV+`\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`;const UW=RB({opSnippet:GW});const HW={kernelName:fn,backendName:"webgl",kernelFunc:UW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jW{constructor(t,n,e,s=false,o=false){this.variableNames=["x"];if(n==="avg"&&e){throw new Error("Cannot compute positions for average pool.")}const r=t.filterWidth;const i=t.strideHeight;const c=t.strideWidth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.effectiveFilterHeight;const f=t.effectiveFilterWidth;const h=t.padInfo.top;const d=t.padInfo.left;this.outputShape=t.outShape;const p=n==="avg";const m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`;const x=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let b="0.0";if(!p){b="-1.0 / 1e-20"}if(e){const n=">=";this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${c});\n        const ivec2 pads = ivec2(${h}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${n} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?m:x:`wR * ${f} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}const g="max";let w=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="avg"){w=`avgValue / max(count, 1.0)`}const v=Math.floor(r/4)*4;const $=r%4;const y=`\n      if (${p}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${g}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${c});\n      const ivec2 pads = ivec2(${h}, ${d});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${a}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${y}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${$===1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${y}\n          } else if (${$===2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${y}\n          } else if (${$===3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${y}\n          }\n        }\n        setOutput(${w});\n      }\n    `}}class qW{constructor(t,n,e,s=false,o=false){this.variableNames=["x"];if(n==="avg"&&e){throw new Error("Cannot compute positions for average pool.")}const r=t.filterWidth;const i=t.strideDepth;const c=t.strideHeight;const a=t.strideWidth;const u=t.dilationDepth;const l=t.dilationHeight;const f=t.dilationWidth;const h=t.effectiveFilterDepth;const d=t.effectiveFilterHeight;const p=t.effectiveFilterWidth;const m=t.padInfo.front;const x=t.padInfo.top;const b=t.padInfo.left;this.outputShape=t.outShape;const g=n==="avg";let w="0.0";if(!g){w="-1.0 / 1e-20"}if(e){const n=">=";this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${c}, ${a});\n        const ivec3 pads = ivec3(${m}, ${x}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${p};\n                  wC += ${f}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${n} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${p} +\n                      wR * ${p} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}const v="max";let $=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="avg"){$=`avgValue / max(count, 1.0)`}const y=Math.floor(r/4)*4;const k=r%4;const C=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${v}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${c}, ${a});\n      const ivec3 pads = ivec3(${m}, ${x}, ${b});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y}; wC += 4) {\n              int xC = xCCorner + wC * ${f};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${f}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${y};\n            if (${k===1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${k===2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${k===3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n        }\n        setOutput(${$});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;UL(o,"avgPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;x(bu(i,u),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=su(o.shape,r,i,u,c,a);if(l.filterWidth===1&&l.filterHeight===1&&v(l.inShape,l.outShape)){return dB({inputs:{x:o},backend:e})}const f=new jW(l,"avg",false);return e.runWebGLProgram(f,[o],"float32")}const KW={kernelName:dn,backendName:"webgl",kernelFunc:XW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;const l=[1,1,1];const f=ou(o.shape,r,i,l,c,a,u);const h=new qW(f,"avg",false);return e.runWebGLProgram(h,[o],"float32")}const YW={kernelName:mn,backendName:"webgl",kernelFunc:JW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZW{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=t.dilationHeight;const i=t.dilationWidth;const c=t.effectiveFilterHeight;const a=t.effectiveFilterWidth;const u=c-1-t.padInfo.top;const l=a-1-t.padInfo.left;const f=1/(n*e);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${l});\n      const float avgMultiplier = float(${f});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c};\n            wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QW{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;const n=t.filterDepth;const e=t.filterHeight;const s=t.filterWidth;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=t.dilationDepth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.effectiveFilterDepth;const f=t.effectiveFilterHeight;const h=t.effectiveFilterWidth;const d=l-1-t.padInfo.front;const p=f-1-t.padInfo.top;const m=h-1-t.padInfo.left;const x=1/(n*e*s);this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${p}, ${m});\n      const float avgMultiplier = float(${x});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n            wD += ${c}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${f};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tG(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;const{filterSize:c,strides:a,pad:u,dimRoundingMode:l}=s;const f=[1,1,1];const h=ou(i.shape,c,a,f,u,l);const d=new QW(h);return e.runWebGLProgram(d,[o],i.dtype)}const nG={kernelName:xn,backendName:"webgl",kernelFunc:tG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eG(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;UL([o,r],"avgPoolGrad");const{filterSize:c,strides:a,pad:u}=s;const l=su(i.shape,c,a,1,u);const f=new ZW(l);return e.runWebGLProgram(f,[o],i.dtype)}const sG={kernelName:pn,backendName:"webgl",kernelFunc:eG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oG(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r}=n;const{transposeA:i,transposeB:c}=s;return ZB({a:o,b:r,transposeA:i,transposeB:c,backend:e})}const rG={kernelName:bn,backendName:"webgl",kernelFunc:oG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iG{constructor(t,n,e,s,o,r){this.outputShape=[];this.variableNames=["x","mean","variance"];Gl(t,n);Gl(t,e);let i="0.0";if(s!=null){Gl(t,s);this.variableNames.push("offset");i="getOffsetAtOutCoords()"}let c="1.0";if(o!=null){Gl(t,o);this.variableNames.push("scale");c="getScaleAtOutCoords()"}this.outputShape=t;this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${c};\n        float inv = scale * inversesqrt(variance + float(${r}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cG{constructor(t,n,e,s,o,r){this.packedInputs=true;this.packedOutput=true;this.variableNames=["x","mean","variance"];Gl(t,n);Gl(t,e);let i="vec4(0.0)";if(s!=null){Gl(t,s);this.variableNames.push("offset");i="getOffsetAtOutCoords()"}let c="vec4(1.0)";if(o!=null){Gl(t,o);this.variableNames.push("scale");c="getScaleAtOutCoords()"}this.outputShape=t;this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${c};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${r}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aG=({inputs:t,backend:n,attrs:e})=>{const{x:s,mean:o,variance:r,offset:i,scale:c}=t;x(o.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));x(i==null||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));x(c==null||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));let{varianceEpsilon:a}=e;if(a==null){a=.001}const u=[s,o,r];let l=null;if(i!=null){l=i.shape;u.push(i)}let f=null;if(c!=null){f=c.shape;u.push(c)}const h=st().getBool("WEBGL_PACK_NORMALIZATION")?new cG(s.shape,o.shape,r.shape,l,f,a):new iG(s.shape,o.shape,r.shape,l,f,a);const d=n.runWebGLProgram(h,u,u[0].dtype);return d};const uG={kernelName:le,backendName:"webgl",kernelFunc:aG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lG{constructor(t){this.variableNames=["source"];this.outputShape=t;this.rank=t.length;const n=Wz(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=hG(this.rank);let s;const o=t.map(((t,n)=>`sourceLoc.${fG[n]} = start[${n}] + coords.${fG[n]};`));s=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${o.join("\n")}\n      `;this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${e}));\n      }\n    `}}const fG=["x","y","z","w","u","v"];function hG(t){if(t===1){return"sourceLoc"}else if(t<=6){return fG.slice(0,t).map((t=>"sourceLoc."+t)).join(",")}else{throw Error(`Slicing for rank ${t} is not yet supported`)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dG{constructor(t){this.variableNames=["source"];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.rank=t.length;this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Wz(this.rank);const e=NV("coords",this.rank);const s=NV("sourceLoc",this.rank);const o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`;const r=`getChannel(getSource(${s.join()}), ${o})`;const i=`\n      result.x = ${r};\n      if (++${e[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${r};\n        --${s[this.rank-1]};\n      }\n    `;const c=this.rank===1?"":`\n      --${e[this.rank-1]};\n      if (++${e[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${r};\n        if (++${e[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${r};\n        }\n      }\n    `;const a=this.rank<=4?`sourceLoc = coords +\n            ${n}(${t.map(((t,n)=>`start[${n}]`)).join()});`:t.map(((t,n)=>`${s[n]} = ${e[n]} + start[${n}];`)).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${a}\n        vec4 result = vec4(0.);\n        ${i}\n        ${c}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pG(t,n,e,s){const o=s.texData.get(t.dataId);const r=s.makeTensorInfo(e,t.dtype);const i=s.texData.get(r.dataId);Object.assign(i,o);i.refCount=1;i.shape=e;i.dtype=t.dtype;let c=yb(n,B(t.shape));if(o.slice){c+=o.slice.flatOffset}i.slice={flatOffset:c,origDataId:o.slice&&o.slice.origDataId||t.dataId};const a=s.dataRefCount.get(i.slice.origDataId)||1;s.dataRefCount.set(i.slice.origDataId,a+1);return r}function mG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,size:i}=s;const[c,a]=kb(o,r,i);ub(o,c,a);if(w(a)===0){return e.makeTensorInfo(a,o.dtype,[])}if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){const t=e.texData.get(o.dataId);const n=uV(t.values,c,a,o.shape,o.dtype);return e.makeTensorInfo(a,o.dtype,n)}const{isPacked:u}=e.texData.get(o.dataId);const l=$b(o.shape,c,a);if(u||!l){const t=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dG(a):new lG(a);const n=[c];return e.runWebGLProgram(t,[o],o.dtype,n)}e.uploadToGPU(o.dataId);return pG(o,c,a,e)}const xG={kernelName:Rs,backendName:"webgl",kernelFunc:mG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bG=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,crops:i}=s;x(o.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not "+"implemented yet"));const c=r.reduce(((t,n)=>t*n));const a=Wb(o.shape,r,c);const u=Gb(a.length,r.length);const l=Ub(o.shape,r,c);const f=Hb(i,r.length);const h=jb(l,i,r.length);const d=[];const p=DB({inputs:{x:o},backend:e,attrs:{shape:a}});const m=KB({inputs:{x:p},backend:e,attrs:{perm:u}});const b=DB({inputs:{x:m},backend:e,attrs:{shape:l}});const g=mG({inputs:{x:b},backend:e,attrs:{begin:f,size:h}});d.push(p);d.push(m);d.push(b);d.forEach((t=>e.disposeIntermediateTensorInfo(t)));return g};const gG={kernelName:gn,backendName:"webgl",kernelFunc:bG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i}=s;const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const u=IP(c,a,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,u)}const vG={kernelName:wn,backendName:"webgl",kernelFunc:wG};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $G=`\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n`;const yG=`\n  return float(int(a.r) & int(b.r));\n`;function kG(t){const{inputs:n,backend:e}=t;const{a:s,b:o}=n;const r=st().getBool("WEBGL_PACK_BINARY_OPERATIONS");const i=st().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,o])||i===1){const t=e.texData.get(s.dataId).values;const n=e.texData.get(o.dataId).values;const[r,i]=OP(s.shape,o.shape,t,n,s.dtype);const c=e.makeTensorInfo(i,s.dtype);const a=e.texData.get(c.dataId);a.values=r;return c}let c;if(r){c=new hB($G,s.shape,o.shape,false)}else{c=new lB(yG,s.shape,o.shape)}return e.runWebGLProgram(c,[s,o],s.dtype)}const CG={kernelName:vn,backendName:"webgl",kernelFunc:kG};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NG(t){const{inputs:n,backend:e}=t;const{s0:s,s1:o}=n;const r=e.readSync(s.dataId);const i=e.readSync(o.dataId);const c=Gl(Array.from(r),Array.from(i));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const RG={kernelName:yn,backendName:"webgl",kernelFunc:NG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=`return float(a != b);`;const EG=SB({opSnippet:SG,cpuKernelImpl:QP,dtype:"bool"});const TG={kernelName:Xe,backendName:"webgl",kernelFunc:EG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IG(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.texData.get(s.dataId);return dB({inputs:{x:o.complexTensorInfos.real},backend:e})}const AG={kernelName:us,backendName:"webgl",kernelFunc:IG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG=`return float(int(x));`;function FG(t,n){const e=new LV(t.shape,OG);const s=n.runWebGLProgram(e,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _G(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dtype:r}=s;if(r==="complex64"){if(o.dtype==="complex64"){return dB({inputs:{x:o},backend:e})}const t=qh(o.shape);const n=_G({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});const s=mB({inputs:{real:n,imag:t},backend:e});t.dispose();e.disposeIntermediateTensorInfo(n);return s}if(o.dtype==="complex64"){const t=IG({inputs:{input:o},backend:e});const n=_G({inputs:{x:t},backend:e,attrs:{dtype:r}});e.disposeIntermediateTensorInfo(t);return n}if(!O(o.dtype,r)){const t=dB({inputs:{x:o},backend:e});return{dataId:t.dataId,shape:t.shape,dtype:r}}if(e.shouldExecuteOnCPU([o])){const t=e.texData.get(o.dataId).values;const[n,s,i]=FP(t,o.shape,o.dtype,r);return e.makeTensorInfo(n,s,i)}if(r==="int32"){return FG(o,e)}if(r==="bool"){const t=e.makeTensorInfo([],"bool",E("bool",1));const n={a:o,b:t};const s=EG({inputs:n,backend:e});e.disposeIntermediateTensorInfo(t);return s}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${r}`)}const MG={kernelName:kn,backendName:"webgl",kernelFunc:_G};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG=`return ceil(x);`;const LG=RB({opSnippet:DG,packedOpSnippet:DG,cpuKernelImpl:_P});const zG={kernelName:Cn,backendName:"webgl",kernelFunc:LG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PG{constructor(t){this.variableNames=["A"];this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t;this.userCode=`\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VG{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t;this.userCode=`\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{clipValueMin:r,clipValueMax:i}=s;let c;if(st().getBool("WEBGL_PACK_CLIP")){c=new VG(o.shape)}else{c=new PG(o.shape)}const a=[[r],[i]];return e.runWebGLProgram(c,[o],o.dtype,a)}const WG={kernelName:Nn,backendName:"webgl",kernelFunc:BG};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GG{constructor(t){this.variableNames=["real","imag"];this.outputShape=t;this.userCode=`\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UG(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}function HG(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=e.texData.get(s.dataId);const r=new GG(s.shape);const i=[UG(s,o.complexTensorInfos.real),UG(s,o.complexTensorInfos.imag)];return e.runWebGLProgram(r,i,i[0].dtype)}const jG={kernelName:Sn,backendName:"webgl",kernelFunc:HG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qG{constructor(t){this.outputShape=[];this.outputShape=Fb(t,1);this.variableNames=t.map(((t,n)=>`T${n}`));const n=new Array(t.length-1);n[0]=t[0][1];for(let e=1;e<n.length;e++){n[e]=n[e-1]+t[e][1]}const e=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<n.length;t++){const s=n[t-1];e.push(`else if (yC < ${n[t]}) `+`setOutput(getT${t}(yR, yC-${s}));`)}const s=n.length;const o=n[n.length-1];e.push(`else setOutput(getT${s}(yR, yC-${o}));`);this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${e.join("\n        ")}\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XG{constructor(t,n){this.packedInputs=true;this.packedOutput=true;this.outputShape=[];this.outputShape=Fb(t,n);const e=this.outputShape;const s=e.length;const o=Wz(s);const r=NV("coords",s);const i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map(((t,n)=>`T${n}`));const c=new Array(t.length-1);c[0]=t[0][n];for(let e=1;e<c.length;e++){c[e]=c[e-1]+t[e][n]}const a=i[n];const u=i.slice(-2);const l=i.join();let f=`if (${a} < ${c[0]}) {\n        return getChannel(\n            getT0(${l}), vec2(${u.join()}));\n        }`;for(let t=1;t<c.length;t++){const n=c[t-1];f+=`\n        if (${a} < ${c[t]}  && ${a} >= ${c[t-1]}) {\n          return getChannel(\n            getT${t}(${KG(i,a,n)}),\n            vec2(${KG(u,a,n)}));\n        }`}const h=c.length;const d=c[c.length-1];f+=`\n        return getChannel(\n          getT${h}(${KG(i,a,d)}),\n          vec2(${KG(u,a,d)}));`;this.userCode=`\n      float getValue(${i.map((t=>"int "+t))}) {\n        ${f}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${r}), 0., 0., 0.);\n\n        ${r[s-1]} = ${r[s-1]} + 1;\n        if (${r[s-1]} < ${e[s-1]}) {\n          result.g = getValue(${r});\n        }\n\n        ${r[s-2]} = ${r[s-2]} + 1;\n        if (${r[s-2]} < ${e[s-2]}) {\n          result.a = getValue(${r});\n        }\n\n        ${r[s-1]} = ${r[s-1]} - 1;\n        if (${r[s-2]} < ${e[s-2]} &&\n            ${r[s-1]} < ${e[s-1]}) {\n          result.b = getValue(${r});\n        }\n        setOutput(result);\n      }\n    `}}function KG(t,n,e){const s=t.indexOf(n);const o=t.map(((t,n)=>{if(n===s){return`${t} - ${e}`}else{return t}}));return o.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.texData.get(s.dataId);return dB({inputs:{x:o.complexTensorInfos.imag},backend:e})}const YG={kernelName:be,backendName:"webgl",kernelFunc:JG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(t,n,e){const s=t[0].dtype;if(s==="complex64"){const s=t.map((t=>IG({inputs:{input:t},backend:e})));const o=t.map((t=>JG({inputs:{input:t},backend:e})));const r=ZG(s,n,e);const i=ZG(o,n,e);const c=mB({inputs:{real:r,imag:i},backend:e});s.forEach((t=>e.disposeIntermediateTensorInfo(t)));o.forEach((t=>e.disposeIntermediateTensorInfo(t)));e.disposeIntermediateTensorInfo(r);e.disposeIntermediateTensorInfo(i);return c}let o=e.shouldExecuteOnCPU(t);if(s==="string"){o=true}if(o){const o=t.map((t=>{const s=w(t.shape.slice(n));const o=[-1,s];return DB({inputs:{x:t},backend:e,attrs:{shape:o}})}));const r=o.map((t=>({vals:e.readSync(t.dataId),shape:t.shape})));const i=Fb(o.map((t=>t.shape)),1);const c=o[0].shape[0]===1;const a=MP(r,i,s,c);const u=Fb(t.map((t=>t.shape)),n);const l=e.makeTensorInfo(u,s,a);o.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const r=t.filter((t=>w(t.shape)>0));const i=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const n=i?new LV(t[0].shape,UV):new YV(t[0].shape,UV);return e.runWebGLProgram(n,t,s)}const c=st().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>c){const t=[];for(let s=0;s<r.length;s+=c){const o=r.slice(s,s+c);t.push(ZG(o,n,e))}const s=ZG(t,n,e);for(const n of t){e.disposeIntermediateTensorInfo(n)}return s}if(i){const t=new XG(r.map((t=>t.shape)),n);return e.runWebGLProgram(t,r,s)}const{tensors2D:a,outShape:u}=QG(r,n,e);const l=new qG(a.map((t=>t.shape)));const f=e.runWebGLProgram(l,a,s);a.forEach((t=>e.disposeIntermediateTensorInfo(t)));const h=DB({inputs:{x:f},attrs:{shape:u},backend:e});e.disposeIntermediateTensorInfo(f);return h}function QG(t,n,e){const s=Fb(t.map((t=>t.shape)),n);const o=t.map((t=>DB({inputs:{x:t},attrs:{shape:[-1,w(t.shape.slice(n))]},backend:e})));return{tensors2D:o,outShape:s}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;const r=R(o,n[0].shape)[0];const i=n.map((t=>t.shape));Ob(i,r);const c=Fb(n.map((t=>t.shape)),r);if(w(c)===0){return e.makeTensorInfo(c,n[0].dtype,[])}const a=n.filter((t=>w(t.shape)>0));if(a.length===1){return dB({inputs:{x:a[0]},backend:e})}return ZG(a,r,e)}const nU={kernelName:En,backendName:"webgl",kernelFunc:tU};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eU{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.outputShape=t.outShape;const r=t.padInfo.top;const i=t.padInfo.left;const c=t.strideHeight;const a=t.strideWidth;const u=t.dilationHeight;const l=t.dilationWidth;const f=t.filterHeight;const h=t.filterWidth;const d=Math.floor(t.inChannels/4)*4;const p=t.inChannels%4;const m=t.dataFormat==="channelsLast";const x=m?1:2;const b=m?2:3;const g=m?3:1;let w="",v="";if(e){if(s){w=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){w=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{w=`\n          float activation(float x) {\n            ${e}\n          }\n        `}v=`result = activation(result);`}const $=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${c}, ${a});\n      const ivec2 pads = ivec2(${r}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${g}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${x}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${f}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${p===1}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${p===2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${p===3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${v}\n        setOutput(result);\n      }\n    `}}class sU{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;const n=t.padInfo.front;const e=t.padInfo.top;const s=t.padInfo.left;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=t.dilationDepth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.filterDepth;const f=t.filterHeight;const h=t.filterWidth;const d=Math.floor(t.inChannels/4)*4;const p=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${r}, ${i});\n      const ivec3 pads = ivec3(${n}, ${e}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${l}; wF++) {\n          int xF = xFCorner + wF * ${c};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f}; wR++) {\n            int xR = xRCorner + wR * ${a};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${d}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${p===1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${d}) *\n                  getW(wF, wR, wC, ${d}, d2);\n              } else if (${p===2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${p===3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1),\n                  getX(batch, xF, xR, xC, ${d} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2),\n                  getW(wF, wR, wC, ${d} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oU{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=Yz(this.outputShape.length);const r=t.padInfo.left;const i=t.strideWidth;const c=t.dilationWidth;const a=t.filterHeight;const u=t.filterWidth;const l=u;let f=`\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;for(let t=0;t<u;t++){f+=`\n           vec4 xTexelC${t*2};\n           int xTexelC${t*2}Ready;\n           vec4 xTexelC${t*2+1};\n           int xTexelC${t*2+1}Ready;\n           vec4 xC${t};`}f+=`\n     for (int r = 0; r < ${a}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let t=0;t<u;t++){f+=`\n           xTexelC${t*2} = vec4(0.0);\n           xTexelC${t*2}Ready = 0;\n           xTexelC${t*2+1} = vec4(0.0);\n           xTexelC${t*2+1}Ready = 0;\n           xC${t} = vec4(0.0);`}f+=`\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;for(let n=0;n<(l+1)/2;n++){const e=n*2;f+=`\n           xC = xCCorner + ${e*c};\n           `;if(i===1){if(e<u){if(r%2===1){f+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n               `;if(c===1&&e>0){f+=`\n                 xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                 `}else{f+=`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                   } else {\n                     xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                   }\n                   `}}else{f+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 xC${e} = xTexelC${e};\n                 `}if(e+1<u){const t=r%2===0?d(c):c;if(c%2===0&&r%2===1||c%2!==0&&r%2!==1){f+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                     xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${e+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${e+1}Ready = 1;\n                   }\n                   `;if(c>1){f+=`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                     } else {\n                      xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                     }\n                     `}else{f+=`\n                     xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                     `}}else{if(t===1){f+=`\n                     xC${e+1} = xTexelC${e};\n                     `}else{f+=`\n                     xCOffset = xC + ${t};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                       xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${e+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${e+1}Ready = 1;\n                     }\n\n                     xC${e+1} = xTexelC${e+1};\n                     `}}}}}else{if(e<u){if(r%2===1){f+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                   xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${e+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${e+1}Ready = 1;\n                 }\n\n                 xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n               `;if(e+1<u){f+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                 `}}else{f+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                   xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e+1}.zw = vec2(0.);\n                   }\n                   xTexelC${e+1}Ready = 1;\n                 }\n\n                 xC${e} = vec4(\n                   xTexelC${e}.xy, xTexelC${e+1}.xy);\n               `;if(e+1<u){f+=`\n                   xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                 `}}}}if(e<u){f+=`\n             wTexel = getW(r, ${e}, d1, d2);\n             dotProd += xC${e}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${e}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `;if(e+1<u){f+=`\n               wTexel = getW(r, ${e+1}, d1, d2);\n               dotProd += xC${e+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${e+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `}}}f+=`\n     }\n   `;f+=`\n     }\n   `;f+=`\n     }\n   `;let h="",p="";if(e){if(s){h=`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${e}\n         }`}else if(o){h=`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${e}\n         }`}else{h=`vec4 activation(vec4 x) {\n           ${e}\n         }`}p=`result = activation(result);`}const m=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${f}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rU{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];this.outputShape=t;this.enableShapeUniforms=Yz(this.outputShape.length);const{dataFormat:e}=n;const s=jL();const o=e==="channelsLast";const r=o?1:2;const i=o?2:3;const c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let a=``;for(let t=0;t<=1;t++){for(let n=0;n<=1;n++){a+=`\n          blockIndex = rc.z + ${n};\n          pos = rc.y + ${t};\n\n          ${c}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${r}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${t*2+n}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${t*2+n}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `}}this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${a}\n\n        ${s.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(t,n){const e=t.length;if(e>=3){return n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]}else if(!n&&e===1&&t[0]>1){return[t[0],1]}else{return null}}function cU({x:t,filter:n,convInfo:e,backend:s,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:i=0,activation:c=null}){const a=t.shape;const u=s.texData.get(t.dataId);const l=e.inChannels;const f=a[0]*a[1]*a[2];const h=e.outChannels;const d=e.dataFormat==="channelsLast";const p=false;const m=false;let b;const g=[];if(r!=null){const t=iU(r.shape,d);if(t!=null){r=DB({inputs:{x:r},backend:s,attrs:{shape:t}});g.push(r)}}if(o!=null){const t=iU(o.shape,d);if(t!=null){o=DB({inputs:{x:o},backend:s,attrs:{shape:t}});g.push(o)}}const w=(f===1||h===1)&&l>YB;const $=!w&&u.isPacked&&d&&u.texture!=null&&a[2]%2!==0&&v(u.shape.slice(-3),a.slice(-3));if($){const l=a[0]*a[1]*(a[2]+1);const f={dataId:t.dataId,shape:[1,l,e.inChannels],dtype:t.dtype};const h=u.shape;u.shape=u.shape.slice();u.shape[u.shape.length-2]++;x(AL(u.shape,f.shape),(()=>`packed reshape ${u.shape} to ${f.shape} isn't free`));const d=DB({inputs:{x:n},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});g.push(d);const w=ZB({a:f,b:d,backend:s,transposeA:p,transposeB:m,bias:o,activation:c,preluActivationWeights:r,leakyreluAlpha:i});const v=s.texData.get(w.dataId);x(v.isPacked,(()=>"batchMatMul result is expected to be packed"));u.shape=h;v.shape=e.outShape;b=dB({inputs:{x:w},backend:s});b.shape=e.outShape;g.push(w)}else{const a=e.outHeight*e.outWidth;const u=DB({inputs:{x:t},backend:s,attrs:{shape:d?[e.batchSize,a,e.inChannels]:[e.batchSize,e.inChannels,a]}});const l=DB({inputs:{x:n},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});const f=ZB({a:d?u:l,b:d?l:u,transposeA:!d,transposeB:m,backend:s,bias:o,activation:c,preluActivationWeights:r,leakyreluAlpha:i});b=DB({inputs:{x:f},backend:s,attrs:{shape:e.outShape}});g.push(u);g.push(l);g.push(f)}for(const t of g){s.disposeIntermediateTensorInfo(t)}return b}function aU({x:t,filter:n,convInfo:e,backend:s,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:i=0,activation:c=null}){const{filterWidth:a,filterHeight:u,inChannels:l,outWidth:f,outHeight:h,dataFormat:d}=e;const p=d==="channelsLast";const m=a*u*l;const x=h*f;const b=[e.batchSize,m,x];const g=true;const v=false;const $=[];if(r!=null){const t=iU(r.shape,p);if(t!=null){r=DB({inputs:{x:r},backend:s,attrs:{shape:t}});$.push(r)}}if(o!=null){const t=iU(o.shape,p);if(t!=null){o=DB({inputs:{x:o},backend:s,attrs:{shape:t}});$.push(o)}}const y=DB({inputs:{x:n},backend:s,attrs:{shape:[1,m,w(n.shape)/m]}});$.push(y);const k=new rU(b,e);const C=[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]];const N=s.runWebGLProgram(k,[t],"float32",C);const R=DB({inputs:{x:N},backend:s,attrs:{shape:b}});$.push(N);$.push(R);const S=o!=null;const E=r!=null;const T=c==="leakyrelu";const I=c?EB(c,true):null;const A=new TB(p?R.shape:y.shape,p?y.shape:R.shape,p?[e.batchSize,x,e.outChannels]:[e.batchSize,e.outChannels,x],g,v,S,I,E,T);const O=p?[R,y]:[y,R];if(o){O.push(o)}if(E){O.push(r)}if(T){const t=s.makeTensorInfo([],"float32",Ko(i,"float32"));O.push(t);$.push(t)}const F=s.runWebGLProgram(A,O,"float32");const _=DB({inputs:{x:F},backend:s,attrs:{shape:e.outShape}});$.push(F);for(const t of $){s.disposeIntermediateTensorInfo(t)}return _}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dataFormat:a,dilations:u,dimRoundingMode:l}=s;const f=wu(a);const h=ru(o.shape,r.shape,i,u,c,l,false,f);let d;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID")){d=cU({x:o,filter:r,convInfo:h,backend:e})}else if(h.strideWidth<=2&&f==="channelsLast"&&st().getBool("WEBGL_EXP_CONV")){const t=new oU(h);const n=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];d=e.runWebGLProgram(t,[o,r],"float32",n)}else if(st().getBool("WEBGL_CONV_IM2COL")){d=aU({x:o,filter:r,convInfo:h,backend:e})}else{const t=new eU(h);d=e.runWebGLProgram(t,[o,r],"float32")}const p=DB({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});e.disposeIntermediateTensorInfo(d);return p}const lU={kernelName:Tn,backendName:"webgl",kernelFunc:uU};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fU{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.padInfo.top;const o=t.padInfo.left;const r=t.dataFormat==="channelsLast";this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${s};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${e} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${r?`float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hU{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=t.dataFormat==="channelsLast";const i=n-1-t.padInfo.top;const c=e-1-t.padInfo.left;const a=r?1:2;const u=r?2:3;const l=r?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l}];\n\n        ivec2 dyCorner = ivec2(coords[${a}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${e} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dU{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideDepth;const e=t.strideHeight;const s=t.strideWidth;const o=t.padInfo.front;const r=t.padInfo.top;const i=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${n} - ${o};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${e} - ${r};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${s} - ${i};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class pU{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterDepth;const e=t.filterHeight;const s=t.filterWidth;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=n-1-t.padInfo.front;const a=e-1-t.padInfo.top;const u=s-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${a}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${n}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${n} - 1 - wF;\n\n          for (int wR = 0; wR < ${e}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${e} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,dataFormat:a,dimRoundingMode:u,filterShape:l}=s;const f=wu(a);const h=ru(o.shape,l,i,1,c,u,false,f);const d=new fU(h);return e.runWebGLProgram(d,[o,r],"float32")}const xU={kernelName:In,backendName:"webgl",kernelFunc:mU};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bU{constructor(t){this.variableNames=["dy","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"strides",type:"vec2"}];this.outputShape=t.inShape;this.enableShapeUniforms=Yz(this.outputShape.length);const n=t.filterHeight;const e=t.filterWidth;const s=n-1-t.padInfo.top;const o=e-1-t.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            int wCPerm = ${e} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{inputShape:i,strides:c,pad:a,dataFormat:u,dimRoundingMode:l}=s;const f=wu(u);const h=ru(i,r.shape,c,1,a,l,false,f);if(st().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const t=[[h.strideHeight,h.strideWidth]];const n=new bU(h);return e.runWebGLProgram(n,[o,r],"float32",t)}else{const t=new hU(h);return e.runWebGLProgram(t,[o,r],"float32")}}const wU={kernelName:An,backendName:"webgl",kernelFunc:gU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;const u=iu(o.shape,r.shape,i,a,c);const l=new sU(u);return e.runWebGLProgram(l,[o,r],"float32")}const $U={kernelName:On,backendName:"webgl",kernelFunc:vU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,filterShape:a}=s;const u=iu(o.shape,a,i,1,c);const l=new dU(u);return e.runWebGLProgram(l,[o,r],"float32")}const kU={kernelName:Fn,backendName:"webgl",kernelFunc:yU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{pad:i,strides:c,inputShape:a}=s;const u=iu(a,r.shape,c,1,i);const l=new pU(u);return e.runWebGLProgram(l,[o,r],"float32")}const NU={kernelName:_n,backendName:"webgl",kernelFunc:CU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RU=NB+`\n  return cos(x);\n`;const SU=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${fB}\n  return result;\n`;const EU=RB({opSnippet:RU,packedOpSnippet:SU});const TU={kernelName:Mn,backendName:"webgl",kernelFunc:EU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IU=`\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;const AU=RB({opSnippet:IU});const OU={kernelName:Dn,backendName:"webgl",kernelFunc:AU};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FU{constructor(t,n,e,s,o){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];const[r,i,c,a]=t;const[u]=n;const[l,f]=e;this.outputShape=[u,l,f,a];const h=s==="bilinear"?1:0;const[d,p]=[`${i-1}.0`,`${c-1}.0`];const[m,x,b]=l>1?[`${(i-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`];const[g,w,v]=f>1?[`${(c-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${p} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${p}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${g});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${r}) {\n          return;\n        }\n\n        float height_scale = ${x};\n        float width_scale = ${w};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _U=t=>{const{inputs:n,backend:e,attrs:s}=t;const{image:o,boxes:r,boxInd:i}=n;const{cropSize:c,method:a,extrapolationValue:u}=s;const l=new FU(o.shape,r.shape,c,a,u);return e.runWebGLProgram(l,[o,r,i],"float32")};const MU={kernelName:Pn,backendName:"webgl",kernelFunc:_U};var DU;(function(t){t["Prod"]="*";t["Sum"]="+"})(DU||(DU={}));class LU{constructor(t,n,e,s){this.op=t;this.outputShape=n;this.variableNames=["x"];this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length;const r=this.op===DU.Prod?"1.0":"0.0";const i=e?r:`getX(${zU(o,"coords",this.op)})`;const c=this.outputShape[this.outputShape.length-1];let a="";let u="";if(e){a=s?`end != ${c-1}`:"end != 0";u=s?"end + 1":"end - 1"}else{a=s?`end + pow2 < ${c}`:"end >= pow2";u=s?"end + pow2":"end - pow2"}this.userCode=`\n      void main() {\n        ${Wz(o)} coords = getOutputCoords();\n        int end = ${PU(o,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${u};\n          ${PU(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${zU(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function zU(t,n,e){if(t===1){return`${n}`}else if(t===2){return`${n}.x, ${n}.y`}else if(t===3){return`${n}.x, ${n}.y, ${n}.z`}else if(t===4){return`${n}.x, ${n}.y, ${n}.z, ${n}.w`}else{throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}}function PU(t,n,e){if(t===1){return`${n}`}else if(t===2){return`${n}.y`}else if(t===3){return`${n}.z`}else if(t===4){return`${n}.w`}else{throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VU(t,n,e,s,o,r){const i=n.shape.length;const c=hf([s],i);let a=n;if(c!=null){a=KB({inputs:{x:n},backend:e,attrs:{perm:c}})}const u=pf(1,i)[0];if(u!==i-1){throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} `+`but got axis=${s}`)}const l=a.shape[u];let f=dB({inputs:{x:a},backend:e});for(let n=0;n<=Math.ceil(Math.log2(l))-1;n++){const s=new LU(t,a.shape,false,r);const o=[[n]];const i=f;f=e.runWebGLProgram(s,[f],f.dtype,o);e.disposeIntermediateTensorInfo(i)}if(o){const n=new LU(t,a.shape,o,r);const s=f;f=e.runWebGLProgram(n,[f],f.dtype);e.disposeIntermediateTensorInfo(s)}if(c!=null){const t=df(c);const n=KB({inputs:{x:f},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(a);return n}return f}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;return VU(DU.Prod,o,e,r,i,c)}const WU={kernelName:Ln,backendName:"webgl",kernelFunc:BU};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;return VU(DU.Sum,o,e,r,i,c)}const UU={kernelName:zn,backendName:"webgl",kernelFunc:GU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i,binaryOutput:c}=s;if(o.shape.length===1){const t=e.readSync(o.dataId);const n=e.readSync(r.dataId);const s=IP(t,n,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,s)}else if(o.shape.length===2){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=AP(t,n,i,c);return e.makeTensorInfo(s.shape,r.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank`+`${o.shape.length}.`)}const jU={kernelName:Vn,backendName:"webgl",kernelFunc:HU};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qU{constructor(t,n,e){this.variableNames=["x"];this.outputShape=[];this.outputShape=t;this.blockSize=n;this.dataFormat=e;this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${n};\n      int offset_h = imod(h, ${n});\n      int in_w = w / ${n};\n      int offset_w = imod(w, ${n});\n      int offset_d = (offset_h * ${n} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){if(this.dataFormat==="NHWC"){return`coords[1]`}else{return`coords[2]`}}getWidthCoordString(){if(this.dataFormat==="NHWC"){return`coords[2]`}else{return`coords[3]`}}getDepthCoordString(){if(this.dataFormat==="NHWC"){return`coords[3]`}else{return`coords[1]`}}getOutputDepthSize(){if(this.dataFormat==="NHWC"){return this.outputShape[3]}else{return this.outputShape[1]}}getInputSamplingString(){if(this.dataFormat==="NHWC"){return`getX(b, in_h, in_w, in_d)`}else{return`getX(b, in_d, in_h, in_w)`}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockSize:r,dataFormat:i}=s;const c=o.shape[0];const a=i==="NHWC"?o.shape[1]:o.shape[2];const u=i==="NHWC"?o.shape[2]:o.shape[3];const l=i==="NHWC"?o.shape[3]:o.shape[1];const f=a*r;const h=u*r;const d=l/(r*r);const p=i==="NHWC"?[c,f,h,d]:[c,d,f,h];const m=new qU(p,r,i);return e.runWebGLProgram(m,[o],o.dtype)}const KU={kernelName:Bn,backendName:"webgl",kernelFunc:XU};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JU{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=Yz(this.outputShape.length);const r=t.filterHeight;const i=t.filterWidth;const c=t.outChannels/t.inChannels;let a="",u="";if(e){if(s){a=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){a=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{a=`\n          float activation(float x) {\n            ${e}\n          }\n        `}u=`result = activation(result);`}const l=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${a}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${c};\n        int q = d2 - d1 * ${c};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${r}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${l}\n        ${u}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YU{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=Yz(this.outputShape.length);const r=t.outChannels/t.inChannels;const i=t.padInfo.left;const c=t.strideWidth;const a=t.dilationWidth;const u=t.filterHeight;const l=t.filterWidth;const f=l;let h=`\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;for(let t=0;t<l;t++){h+=`\n          vec4 xTexelC${t*2};\n          int xTexelC${t*2}Ready;\n          vec4 xTexelC${t*2+1};\n          int xTexelC${t*2+1}Ready;\n          vec4 xC${t};`}h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let t=0;t<l;t++){h+=`\n          xTexelC${t*2} = vec4(0.0);\n          xTexelC${t*2}Ready = 0;\n          xTexelC${t*2+1} = vec4(0.0);\n          xTexelC${t*2+1}Ready = 0;\n          xC${t} = vec4(0.0);`}h+=`\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;for(let t=0;t<(f+1)/2;t++){const n=t*2;h+=`\n          xC = xCCorner + ${n*a};\n          `;if(c===1){if(n<l){if(i%2===1){h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `;if(a===1&&n>0){h+=`\n                xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `}else{h+=`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `}}else{h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${n} = xTexelC${n};\n                `}if(n+1<l){const t=i%2===0?d(a):a;if(a%2===0&&i%2===1||a%2!==0&&i%2!==1){h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                    xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${n+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+1}Ready = 1;\n                  }\n                  `;if(a>1){h+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                    } else {\n                     xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                    }\n                    `}else{h+=`\n                    xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                    `}}else{if(t===1){h+=`\n                    xC${n+1} = xTexelC${n};\n                    `}else{h+=`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                      xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${n+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+1}Ready = 1;\n                    }\n\n                    xC${n+1} = xTexelC${n+1};\n                    `}}}}}else{if(n<l){if(i%2===1){h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n              `;if(n+1<l){h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                `}}else{h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+1}.xy);\n              `;if(n+1<l){h+=`\n                  xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                `}}}}if(n<l){h+=`\n            wTexel = getW(r, ${n}, d1, q);\n            dotProd += xC${n} * vec4(wTexel.xz, wTexel.xz);\n          `;if(n+1<l){h+=`\n              wTexel = getW(r, ${n+1}, d1, q);\n              dotProd += xC${n+1} * vec4(wTexel.xz, wTexel.xz);\n            `}}}h+=`\n    }\n  `;h+=`\n      }\n    `;let p="",m="";if(e){if(s){p=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){p=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{p=`vec4 activation(vec4 x) {\n          ${e}\n        }`}m=`result = activation(result);`}const x=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${r};\n        int q = d2 - d1 * ${r};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${x}\n        ${m}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a,dimRoundingMode:u}=s;let l=a;if(l==null){l=[1,1]}x(bu(i,l),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${i} and dilations '${l}'`));const f=ru(o.shape,r.shape,i,l,c,u,true);let h;if(st().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1){h=new YU(f)}else{h=new JU(f)}const d=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return e.runWebGLProgram(h,[o,r],"float32",d)}const QU={kernelName:Wn,backendName:"webgl",kernelFunc:ZU};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tH{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.padInfo.top;const o=t.padInfo.left;const r=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${r} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${s};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${e} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nH{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=n-1-t.padInfo.top;const i=e-1-t.padInfo.left;const c=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${e} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${c}; dm++) {\n              int d2 = d1 * ${c} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eH(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,filterShape:l}=s;const f=ru(o.shape,l,i,c,a,u,true);const h=new tH(f);return e.runWebGLProgram(h,[o,r],"float32")}const sH={kernelName:Gn,backendName:"webgl",kernelFunc:eH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oH(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,inputShape:l}=s;const f=ru(l,r.shape,i,c,a,u,true);const h=new nH(f);return e.runWebGLProgram(h,[o,r],"float32")}const rH={kernelName:Un,backendName:"webgl",kernelFunc:oH};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iH{constructor(t){this.variableNames=["X"];this.outputShape=[t,t];this.userCode=`\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=[...s.shape,...s.shape];const r=w(s.shape);const i=DB({inputs:{x:s},backend:e,attrs:{shape:[r]}});const c=new iH(r);const a=e.runWebGLProgram(c,[i],i.dtype);const u=DB({inputs:{x:a},backend:e,attrs:{shape:o}});e.disposeIntermediateTensorInfo(i);e.disposeIntermediateTensorInfo(a);return u}const aH={kernelName:Hn,backendName:"webgl",kernelFunc:cH};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uH{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;const{inHeight:n,inWidth:e,padInfo:s,strideHeight:o,strideWidth:r,filterHeight:i,filterWidth:c,dilationHeight:a,dilationWidth:u}=t;const{top:l,left:f}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${r});\n      const ivec2 pads = ivec2(${l}, ${f});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${a};\n\n          if (hIn >= 0 && hIn < ${n}) {\n            for (int w = 0; w < ${c}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${e}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lH(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;const u=eu(o.shape,r.shape,i,c,"NHWC",a);let l;const f=new uH(u);l=e.runWebGLProgram(f,[o,r],"float32");const h=DB({inputs:{x:l},backend:e,attrs:{shape:u.outShape}});e.disposeIntermediateTensorInfo(l);return h}const fH={kernelName:jn,backendName:"webgl",kernelFunc:lH};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hH(t){const{inputs:n,backend:e,attrs:s}=t;const{equation:o}=s;const r=n;const{allDims:i,summedDims:c,idDims:a}=dg(o,r.length);mg(i.length,a,r);const{path:u,steps:l}=xg(c,a);const f=l.length;let h=null;let d=i.length;const p=[];for(let t=0;t<f;++t){for(const n of l[t]){const{permutationIndices:t,expandDims:s}=pg(d,a[n]);let o;if(bg(t)){o=r[n]}else{o=KB({inputs:{x:r[n]},backend:e,attrs:{perm:t}});p.push(o)}const i=o.shape.slice();for(let t=0;t<s.length;++t){i.splice(s[t],0,1)}if(!v(o.shape,i)){o=DB({inputs:{x:o},backend:e,attrs:{shape:i}});p.push(o)}if(h===null){h=o}else{h=FB({inputs:{a:o,b:h},backend:e});p.push(h)}}if(t<f-1){if(u[t]>=0){h=qB({inputs:{x:h},backend:e,attrs:{axis:u[t]-(i.length-d),keepDims:false}});p.push(h)}d--}}for(const t of p){if(t===h){continue}e.disposeIntermediateTensorInfo(t)}return h}const dH={kernelName:Yn,backendName:"webgl",kernelFunc:hH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pH=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const mH=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const xH=RB({opSnippet:pH,packedOpSnippet:mH});const bH={kernelName:Zn,backendName:"webgl",kernelFunc:xH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gH=`return (b >= 0.0) ? a : a * (b + 1.0);`;const wH=`\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;const vH=t=>{const{inputs:n,backend:e}=t;const{dy:s,y:o}=n;const r=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hB(wH,s.shape,o.shape):new lB(gH,s.shape,o.shape);return e.runWebGLProgram(r,[s,o],s.dtype)};const $H={kernelName:Qn,backendName:"webgl",kernelFunc:vH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yH=`\n  return vec4(equal(a, b));\n`;const kH=`return float(a == b);`;const CH=SB({opSnippet:kH,packedOpSnippet:yH,dtype:"bool",cpuKernelImpl:DP});const NH={kernelName:ne,backendName:"webgl",kernelFunc:CH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RH=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Kb};\n  float a1 = ${Jb};\n  float a2 = ${Yb};\n  float a3 = ${Zb};\n  float a4 = ${Qb};\n  float a5 = ${tg};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;const SH=RB({opSnippet:RH});const EH={kernelName:te,backendName:"webgl",kernelFunc:SH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TH=NB+`\n  return exp(x);\n`;const IH=`\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const AH=RB({opSnippet:TH,packedOpSnippet:IH,cpuKernelImpl:LP,dtype:"float32"});const OH={kernelName:ee,backendName:"webgl",kernelFunc:AH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(t){const{inputs:n,attrs:e,backend:s}=t;const{dim:o}=e;const{input:r}=n;const i=r.shape.length;const c=r.shape.slice();let a=o;if(o<0){x(-(i+1)<=o,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`));a=i+o+1}c.splice(a,0,1);return DB({inputs:{x:r},backend:s,attrs:{shape:c}})}const _H={kernelName:se,backendName:"webgl",kernelFunc:FH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH=`return exp(x) - 1.0;`;const DH=RB({opSnippet:MH,packedOpSnippet:MH,cpuKernelImpl:zP});const LH={kernelName:oe,backendName:"webgl",kernelFunc:DH};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zH{constructor(t,n,e){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=e?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`;const r=e?`${s}.0`:"1.0";let i;if(t==="real"){i="return real * expR - imag * expI;"}else if(t==="imag"){i="return real * expI + imag * expR;"}else{throw new Error(`FFT component must be either "real" or "imag", got ${t}.`)}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${r};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(t,n,e){const s=e.texData.get(t.dataId);const o=w(t.shape);const r=t.shape[t.shape.length-1];const i=o/r;const c=DB({inputs:{x:t},backend:e,attrs:{shape:[i,r]}});const a=c.shape;const u=new zH("real",a,n);const l=new zH("imag",a,n);const f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:a},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:a}];const h=e.runWebGLProgram(u,f,"float32");const d=e.runWebGLProgram(l,f,"float32");const p=mB({inputs:{real:h,imag:d},backend:e});e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);const m=DB({inputs:{x:p},backend:e,attrs:{shape:t.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(p);return m}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(t){const{inputs:n,backend:e}=t;const{input:s}=n;return PH(s,false,e)}const BH={kernelName:re,backendName:"webgl",kernelFunc:VH};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WH{constructor(t,n){this.outputShape=[];this.customUniforms=[{name:"value",type:"float"}];this.variableNames=["x"];this.outputShape=t;this.userCode=`\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(t){const{backend:n,attrs:e}=t;const{shape:s,value:o}=e;let{dtype:r}=e;r=r||z(o);if(r==="string"){const t=T(r,w(s));t.fill(o);return n.makeTensorInfo(s,r,t)}else{const t=new WH(s,o);const e=[[o]];return n.runWebGLProgram(t,[],r,e)}}const UH={kernelName:ie,backendName:"webgl",kernelFunc:GH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HH{constructor(t){this.variableNames=["Image"];this.outputShape=[];const n=t[2];this.outputShape=t;this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${n} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${n}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jH={kernelName:ce,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t;const s=n;const o=new HH(e.shape);const r=s.runWebGLProgram(o,[e],e.dtype);return r}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=`return floor(x);`;const XH=RB({opSnippet:qH,packedOpSnippet:qH,cpuKernelImpl:PP});const KH={kernelName:ae,backendName:"webgl",kernelFunc:XH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JH=`\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;const YH=`\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;const ZH=SB({opSnippet:JH,packedOpSnippet:YH,dtype:"int32"});const QH={kernelName:ue,backendName:"webgl",kernelFunc:ZH};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tj{constructor(t){this.variableNames=["A"];const n=jL();const[e,s]=t;this.outputShape=t;this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${e}.0);\n\n        vec4 values = ${n.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nj{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;const n=jL();const[e,s]=t;this.outputShape=t;this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${e}.0);\n            vec4 values = ${n.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ej={kernelName:co,backendName:"webgl",kernelFunc:rj};let sj;let oj=st().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function rj(t){const{inputs:n,backend:e,attrs:s}=t;let{pixels:o}=n;const{numChannels:r}=s;const i=typeof HTMLVideoElement!=="undefined"&&o instanceof HTMLVideoElement;const c=typeof HTMLImageElement!=="undefined"&&o instanceof HTMLImageElement;const[a,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height];const l=[u,a];const f=[u,a,r];if(c||i){const t=st().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");if(sj==null||t!==oj){oj=t;sj=document.createElement("canvas").getContext("2d",{willReadFrequently:oj})}sj.canvas.width=a;sj.canvas.height=u;sj.drawImage(o,0,0,a,u);o=sj.canvas}const h=e.makeTensorInfo(l,"int32");e.texData.get(h.dataId).usage=WD.PIXELS;e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),o);const d=st().getBool("WEBGL_PACK")?new nj(f):new tj(f);const p=e.runWebGLProgram(d,[h],"int32");e.disposeData(h.dataId);return p}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ij(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;const m=wu(l);const x=ru(o.shape,r.shape,a,f,u,h,false,m);let b;const g=[];const w=i!=null;const v=c!=null;const $=d==="leakyrelu";const y=()=>{const t=[o,r];const n=(t,n)=>{if(n==="NCHW"&&t.shape.length===1&&t.shape[0]!==1){const n=DB({inputs:{x:t},backend:e,attrs:{shape:[t.shape[0],1,1]}});g.push(n);return n}return t};if(w){t.push(n(i,l))}if(v){t.push(n(c,l))}if($){const n=e.makeTensorInfo([],"float32",Ko(p,"float32"));t.push(n);g.push(n)}return t};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID")){b=cU({x:o,filter:r,convInfo:x,backend:e,bias:i,activation:d,preluActivationWeights:c,leakyreluAlpha:p})}else if(x.strideWidth<=2&&m==="channelsLast"&&st().getBool("WEBGL_EXP_CONV")){const t=d?EB(d,true):null;const n=new oU(x,w,t,v,$);const s=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]];const o=y();b=e.runWebGLProgram(n,o,"float32",s)}else if(st().getBool("WEBGL_CONV_IM2COL")){b=aU({x:o,filter:r,convInfo:x,backend:e,bias:i,activation:d,preluActivationWeights:c,leakyreluAlpha:p})}else{const t=d?EB(d,false):null;const n=new eU(x,w,t,v,$);const s=y();b=e.runWebGLProgram(n,s,"float32")}const k=DB({inputs:{x:b},backend:e,attrs:{shape:x.outShape}});g.push(b);g.forEach((t=>e.disposeIntermediateTensorInfo(t)));return k}const cj={kernelName:lo,backendName:"webgl",kernelFunc:ij};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dilations:l,dimRoundingMode:f,activation:h,leakyreluAlpha:d}=s;const p=[];let m=l;if(m==null){m=[1,1]}x(bu(a,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${a} and dilations '${m}'`));const b=ru(o.shape,r.shape,a,m,u,f,true);const g=st().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1;const w=h?EB(h,g):null;const v=[o,r];const $=i!=null;const y=c!=null;const k=h==="leakyrelu";if($){v.push(i)}if(y){v.push(c)}if(k){const t=e.makeTensorInfo([],"float32",Ko(d,"float32"));v.push(t);p.push(t)}let C;if(g){C=new YU(b,$,w,y,k)}else{C=new JU(b,$,w,y,k)}const N=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]];const R=e.runWebGLProgram(C,v,"float32",N);p.forEach((t=>e.disposeIntermediateTensorInfo(t)));return R}const uj={kernelName:fo,backendName:"webgl",kernelFunc:aj};class lj{constructor(t,n,e,s){this.sliceDim=t;this.strides=n;this.paramsShape=s;this.variableNames=["x","indices"];this.outputShape=e;const o=Wz(e.length);let r=`\n    int index;`;for(let t=0;t<this.sliceDim;t++){r+=`\n          index = round(getIndices(coords[0], ${t}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[t]};\n          flattenIndex += index * ${this.strides[t]};`}this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${r}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(t){const{inputs:n,backend:e}=t;const{params:s,indices:o}=n;const r=o.shape;const i=r[r.length-1];const c=w(s.shape);const[a,u,l,f]=ib(s,o);const h=DB({inputs:{x:o},backend:e,attrs:{shape:[u,i]}});const d=DB({inputs:{x:s},backend:e,attrs:{shape:[w(s.shape)/l,l]}});if(e.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const t=e.readSync(o.dataId);const n=e.bufferSync(s);const r=VP(t,n,s.dtype,u,i,l,f,s.shape,c);return e.makeTensorInfo(a,s.dtype,r.values)}const p=new lj(i,f,[u,l],s.shape);const m=e.runWebGLProgram(p,[d,h],d.dtype);const x=DB({inputs:{x:m},backend:e,attrs:{shape:a}});e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(m);return x}const hj={kernelName:he,backendName:"webgl",kernelFunc:fj};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dj{constructor(t,n){this.variableNames=["A","indices"];this.outputShape=n;this.rank=n.length;const e=Wz(this.rank);const s=pj(t);this.userCode=`\n      void main() {\n        ${e} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function pj(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"];const s=[];for(let n=0;n<t.length;n++){if(n===2){s.push("index")}else{s.push(`${e[n]}`)}}return s.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mj(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,indices:r}=n;const{axis:i,batchDims:c}=s;const a=R(i,o.shape)[0];if(st().get("DEBUG")){const t=e.readSync(r.dataId);const n=o.shape[a];for(let e=0;e<t.length;++e){const s=t[e];x(s<=n-1&&s>=0,(()=>`GatherV2: the index value ${s} is not in [0, ${n-1}]`))}}const u=_g(o,r,a,c);const l=w(r.shape);const f=[];const h=DB({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}});const d=DB({inputs:{x:r},backend:e,attrs:{shape:[u.batchSize,l/u.batchSize]}});f.push(h);f.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([o,r])||o.dtype==="string"){const t=e.bufferSync(d);const n=e.bufferSync(h);const s=BP(n,t,p);f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(u.outputShape,s.dtype,s.values)}const m=new dj(h.shape,p);const b=e.runWebGLProgram(m,[h,d],h.dtype);f.push(b);const g=DB({inputs:{x:b},backend:e,attrs:{shape:u.outputShape}});f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return g}const xj={kernelName:fe,backendName:"webgl",kernelFunc:mj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bj=`return float(a > b);`;const gj=`\n  return vec4(greaterThan(a, b));\n`;const wj=SB({opSnippet:bj,packedOpSnippet:gj,cpuKernelImpl:WP,dtype:"bool"});const vj={kernelName:de,backendName:"webgl",kernelFunc:wj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $j=`return float(a >= b);`;const yj=`\n  return vec4(greaterThanEqual(a, b));\n`;const kj=SB({opSnippet:$j,packedOpSnippet:yj,dtype:"bool",cpuKernelImpl:GP});const Cj={kernelName:pe,backendName:"webgl",kernelFunc:kj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(t){const{inputs:n,backend:e}=t;const{input:s}=n;return PH(s,true,e)}const Rj={kernelName:xe,backendName:"webgl",kernelFunc:Nj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sj=`return float(!isnan(x) && !isinf(x));`;const Ej=RB({opSnippet:Sj,dtype:"bool"});const Tj={kernelName:ge,backendName:"webgl",kernelFunc:Ej};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ij=`return float(isinf(x));`;const Aj=RB({opSnippet:Ij,dtype:"bool"});const Oj={kernelName:we,backendName:"webgl",kernelFunc:Aj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fj=`return float(isnan(x));`;const _j=RB({opSnippet:Fj,dtype:"bool"});const Mj={kernelName:ve,backendName:"webgl",kernelFunc:_j};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dj=`return float(a < b);`;const Lj=`\n  return vec4(lessThan(a, b));\n`;const zj=SB({opSnippet:Dj,packedOpSnippet:Lj,cpuKernelImpl:UP,dtype:"bool"});const Pj={kernelName:ye,backendName:"webgl",kernelFunc:zj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vj=`return float(a <= b);`;const Bj=`\n  return vec4(lessThanEqual(a, b));\n`;const Wj=SB({opSnippet:Vj,packedOpSnippet:Bj,cpuKernelImpl:HP,dtype:"bool"});const Gj={kernelName:ke,backendName:"webgl",kernelFunc:Wj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uj(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,num:r}=e;const i=jP(s,o,r);return n.makeTensorInfo([i.length],"float32",i)}const Hj={kernelName:Ce,backendName:"webgl",kernelFunc:Uj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jj=NB+`\n  return x < 0.0 ? 0./0. : log(x);\n`;const qj=`\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n`;const Xj=RB({opSnippet:jj,packedOpSnippet:qj,cpuKernelImpl:qP});const Kj={kernelName:Ne,backendName:"webgl",kernelFunc:Xj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jj=NB+`\n  return log(1.0 + x);\n`;const Yj=RB({opSnippet:Jj});const Zj={kernelName:Re,backendName:"webgl",kernelFunc:Yj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qj=`return float(a >= 1.0 && b >= 1.0);`;const tq=`\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;const nq=SB({opSnippet:Qj,packedOpSnippet:tq,dtype:"bool"});const eq={kernelName:Se,backendName:"webgl",kernelFunc:nq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sq=`return float(!(x >= 1.0));`;const oq=RB({opSnippet:sq});const rq={kernelName:Ee,backendName:"webgl",kernelFunc:oq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq=`return float(a >= 1.0 || b >= 1.0);`;const cq=`\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;const aq=SB({opSnippet:iq,packedOpSnippet:cq,dtype:"bool"});const uq={kernelName:Te,backendName:"webgl",kernelFunc:aq};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lq{constructor(t,n,e,s,o){this.variableNames=["x"];this.outputShape=[];const r=n;const i=t[3]-1;this.outputShape=t;let c;const a=`float(${e}) + float(${s}) * sum`;if(o===.5){c=`inversesqrt(${a})`}else if(o===1){c=`1.0/(${a})`}else{c=`exp(log(${a}) * float(-${o}));`}this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${r}; j <= ${r}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${c};\n        setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fq{constructor(t,n,e,s,o){this.variableNames=["x"];this.outputShape=[];this.packedInputs=true;this.packedOutput=true;const r=n;const i=t[3]-1;this.outputShape=t;let c;const a=`float(${e}) + float(${s}) * sum`;if(o===.5){c=`inversesqrt(${a})`}else if(o===1){c=`1.0/(${a})`}else{c=`exp(log(${a}) * float(-${o}));`}this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${r};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${r}; j <= ${r}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${c};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hq=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=s;const u=st().getBool("WEBGL_PACK_NORMALIZATION")?new fq(o.shape,r,i,c,a):new lq(o.shape,r,i,c,a);return e.runWebGLProgram(u,[o],o.dtype)};const dq={kernelName:Ae,backendName:"webgl",kernelFunc:hq};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pq{constructor(t,n,e,s,o){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=t;this.depth=t[3];this.depthRadius=n;this.bias=e;this.alpha=s;this.beta=o;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${e});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o,y:r,dy:i}=n;const{depthRadius:c,bias:a,alpha:u,beta:l}=s;const f=new pq(o.shape,c,a,u,l);return e.runWebGLProgram(f,[o,r,i],o.dtype)};const xq={kernelName:Oe,backendName:"webgl",kernelFunc:mq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bq(t,n,e,s){const o=w(n);const r=w(t.shape);const i=r/o;const c=DB({inputs:{x:t},attrs:{shape:[i,o]},backend:s});const a=BB(c,t.dtype,"max",s);const u=DB({inputs:{x:a},attrs:{shape:e},backend:s});s.disposeIntermediateTensorInfo(c);s.disposeIntermediateTensorInfo(a);return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reductionIndices:r,keepDims:i}=s;const c=o.shape.length;const a=R(r,o.shape);let u=a;const l=hf(u,c);const f=l!=null;const h=e.shouldExecuteOnCPU([o]);let d=o;if(f){if(h){const t=e.texData.get(d.dataId);const n=t.values;const s=new Array(c);for(let t=0;t<s.length;t++){s[t]=o.shape[l[t]]}const r=yV(n,o.shape,o.dtype,l,s);d=e.makeTensorInfo(s,o.dtype);const i=e.texData.get(d.dataId);i.values=r}else{d=HB(o,l,e)}u=pf(u.length,c)}ff("max",u,c);const[p,m]=uf(d.shape,u);let x=p;if(i){x=lf(p,a)}let b;if(h){const t=e.texData.get(d.dataId);const n=t.values;const s=XP(n,w(m),x,o.dtype);b=e.makeTensorInfo(x,o.dtype);const r=e.texData.get(b.dataId);r.values=s}else{b=bq(d,m,x,e)}if(f){e.disposeIntermediateTensorInfo(d)}return b}const wq={kernelName:Fe,backendName:"webgl",kernelFunc:gq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq=uB+`\n  return max(a, b);\n`;const $q=`\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+fB+`\n  return result;\n`;const yq=SB({opSnippet:vq,packedOpSnippet:$q,cpuKernelImpl:KP});const kq={kernelName:_e,backendName:"webgl",kernelFunc:yq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;UL(o,"maxPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;x(bu(i,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=su(o.shape,r,i,u,c,a);if(l.filterWidth===1&&l.filterHeight===1&&v(l.inShape,l.outShape)){return dB({inputs:{x:o},backend:e})}const f=new jW(l,"max",false);return e.runWebGLProgram(f,[o],o.dtype)}const Nq={kernelName:Me,backendName:"webgl",kernelFunc:Cq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dataFormat:a,dimRoundingMode:u}=s;const l=[1,1,1];const f=ou(o.shape,r,i,l,c,u,a);const h=new qW(f,"max",false);return e.runWebGLProgram(h,[o],o.dtype)}const Sq={kernelName:Le,backendName:"webgl",kernelFunc:Rq};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eq{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.dilationHeight;const o=t.effectiveFilterHeight;const r=t.effectiveFilterWidth;const i=o-1-t.padInfo.top;const c=r-1-t.padInfo.left;const a=o*r-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${n}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${r} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Tq{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;const n=t.strideDepth;const e=t.strideHeight;const s=t.strideWidth;const o=t.dilationDepth;const r=t.dilationHeight;const i=t.dilationWidth;const c=t.effectiveFilterDepth;const a=t.effectiveFilterHeight;const u=t.effectiveFilterWidth;const l=c-1-t.padInfo.front;const f=a-1-t.padInfo.top;const h=u-1-t.padInfo.left;const d=c*a*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${f}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${n}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${a};\n              wR += ${r}) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${a} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iq(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;const{filterSize:c,strides:a,pad:u,dimRoundingMode:l}=s;const f=[1,1,1];const h=ou(i.shape,c,a,f,u,l);const d=new qW(h,"max",true);const p=e.runWebGLProgram(d,[i],i.dtype);const m=new Tq(h);const x=e.runWebGLProgram(m,[o,p],i.dtype);e.disposeIntermediateTensorInfo(p);return x}const Aq={kernelName:ze,backendName:"webgl",kernelFunc:Iq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oq(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r,output:i}=n;const c=r;UL([r,i],"maxPoolGrad");const{filterSize:a,strides:u,pad:l,dimRoundingMode:f}=s;const h=su(c.shape,a,u,1,l,f);const d=true;const p=new jW(h,"max",d);const m=e.runWebGLProgram(p,[c],c.dtype);const x=new Eq(h);const b=e.runWebGLProgram(x,[o,m],c.dtype);e.disposeIntermediateTensorInfo(m);return b}const Fq={kernelName:De,backendName:"webgl",kernelFunc:Oq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _q(t,n,e,s){let o=new jW(e,"max",false);const r=s.runWebGLProgram(o,[t],"float32");o=new jW(e,"max",true,true,n);const i=s.runWebGLProgram(o,[t],"float32");return[r,i]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq={kernelName:Pe,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{filterSize:o,strides:r,pad:i,includeBatchInIndex:c}=n;const a=e;x(s.shape.length===4,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));const u=[1,1];x(bu(r,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${r} and dilations '${u}'`));const l=su(s.shape,o,r,u,i);const[f,h]=_q(s,c,l,a);return[f,h]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(t,n,e,s){const o=w(n);const r=w(t.shape);const i=r/o;const c=DB({inputs:{x:t},attrs:{shape:[i,o]},backend:s});const a=BB(c,"float32","mean",s);const u=DB({inputs:{x:a},attrs:{shape:e},backend:s});s.disposeIntermediateTensorInfo(c);s.disposeIntermediateTensorInfo(a);return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lq={kernelName:Ve,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{keepDims:o,axis:r}=n;const i=e;const c=s.shape.length;const a=R(r,s.shape);let u=a;const l=hf(u,c);const f=l!=null;const h=i.shouldExecuteOnCPU([s]);const d=[];let p=s;if(f){if(h){const t=i.texData.get(p.dataId);const n=t.values;const e=new Array(c);for(let t=0;t<e.length;t++){e[t]=s.shape[l[t]]}const o=yV(n,s.shape,s.dtype,l,e);p=i.makeTensorInfo(e,s.dtype);const r=i.texData.get(p.dataId);r.values=o}else{p=HB(s,l,i)}d.push(p);u=pf(u.length,c)}ff("sum",u,c);const[m,x]=uf(p.shape,u);let b=m;if(o){b=lf(m,a)}const g=Dq(p,x,b,i);for(const t of d){i.disposeIntermediateTensorInfo(t)}return g}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=R(r,o.shape);let u=a;const l=hf(u,c);let f=o;if(l!=null){f=KB({inputs:{x:o},backend:e,attrs:{perm:l}});u=pf(u.length,o.shape.length)}ff("min",u,c);const[h,d]=uf(f.shape,u);const p=w(d);const m=DB({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=BB(m,m.dtype,"min",e);let b;if(i){const t=lf(h,a);b=DB({inputs:{x},backend:e,attrs:{shape:t}})}else{b=DB({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const Pq={kernelName:Be,backendName:"webgl",kernelFunc:zq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vq=uB+`\n  return min(a, b);\n`;const Bq=`\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+fB+`\n  return result;\n`;const Wq=SB({opSnippet:Vq,packedOpSnippet:Bq,cpuKernelImpl:JP});const Gq={kernelName:We,backendName:"webgl",kernelFunc:Wq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uq{constructor(t,n,e){this.variableNames=["x"];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=Wz(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);const a=e==="reflect"?0:1;if(s===1){this.userCode=`\n        int start = ${r};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${a};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${a};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;return}this.userCode=`\n      ${o} start = ${o}(${r});\n      ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${a};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${a};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${c}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hq{constructor(t,n,e){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=Wz(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=NV("rc",s);const a=NV("source",s);const u=`${c[s-1]} < ${this.outputShape[s-1]}`;const l=s===1?"source":`vec2(${a.slice(-2).join()})`;const f=e==="reflect"?0:1;let h="";if(s===1){const t=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${f};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${f};\n        }\n        source -= start;\n      `;h=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${a.join()}), ${l});\n        ${c[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${a.join()}), ${l});\n        }\n      `}else{const t=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${f}) +\n                gte * ((end - 1) * 2 - source + ${f});\n        source -= start;\n      `;h=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${a.join()}), ${l});\n        ${c[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${a.join()}), ${l});\n        }\n        rc = outputLoc;\n        ${c[s-2]} += 1;\n        if(${c[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${a.join()}), ${l});\n          ${c[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${a.join()}), ${l});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${r});\n      const ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jq=({inputs:t,backend:n,attrs:e})=>{const{x:s}=t;const{paddings:o,mode:r}=e;const i=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hq(s.shape,o,r):new Uq(s.shape,o,r);const c=n.runWebGLProgram(i,[s],s.dtype);return c};const qq={kernelName:Ge,backendName:"webgl",kernelFunc:jq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xq=`if (b == 0.0) return NAN;\n  return mod(a, b);`;const Kq=`\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  `+fB+`\n  return result;\n`;const Jq=SB({opSnippet:Xq,packedOpSnippet:Kq});const Yq={kernelName:Ue,backendName:"webgl",kernelFunc:Jq};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zq{constructor(t,n,e){this.variableNames=["probs"];this.customUniforms=[{name:"seed",type:"float"}];this.outputShape=[t,e];this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${n-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${n-1}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qq=`\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;const tX=`\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;const nX=SB({opSnippet:Qq,packedOpSnippet:tX,checkOutOfBounds:true});const eX={kernelName:Jn,backendName:"webgl",kernelFunc:nX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sX="return a - b;";const oX=SB({opSnippet:sX,packedOpSnippet:sX,supportsComplex:true,cpuKernelImpl:wV});const rX={kernelName:Ks,backendName:"webgl",kernelFunc:oX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{dim:r}=s;const i=R([r],o.shape);const c=gq({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:false}});const a=lf(c.shape,i);const u=DB({inputs:{x:c},backend:e,attrs:{shape:a}});const l=oX({inputs:{a:o,b:u},backend:e});const f=AH({inputs:{x:l},backend:e});const h=qB({inputs:{x:f},backend:e,attrs:{axis:i,keepDims:false}});const d=DB({inputs:{x:h},backend:e,attrs:{shape:a}});const p=nX({inputs:{a:f,b:d},backend:e});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(l);e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);return p}const cX={kernelName:Ds,backendName:"webgl",kernelFunc:iX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{numSamples:r,seed:i,normalized:c}=s;const a=c?o:iX({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}});const u=a.shape[0];const l=a.shape[1];const f=new Zq(u,l,r);const h=[[i]];const d=e.runWebGLProgram(f,[a],"int32",h);if(!c){e.disposeIntermediateTensorInfo(a)}return d}const uX={kernelName:He,backendName:"webgl",kernelFunc:aX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lX=zV+`\n  return -x;\n`;const fX=`\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;function hX(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(e.shouldExecuteOnCPU([s])){const t=e.texData.get(s.dataId);const[n,o]=ZP(t.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,n)}let o;if(st().getBool("WEBGL_PACK_UNARY_OPERATIONS")){o=new YV(s.shape,fX)}else{o=new LV(s.shape,lX)}return e.runWebGLProgram(o,[s],s.dtype)}const dX={kernelName:qe,backendName:"webgl",kernelFunc:hX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pX=lx;function mX(t){ho("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a}=s;const u=e.readSync(o.dataId);const l=e.readSync(r.dataId);const{selectedIndices:f}=pX(u,l,i,c,a);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const xX={kernelName:Ke,backendName:"webgl",kernelFunc:mX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bX=fx;function gX(t){ho("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,padToMaxOutputSize:u}=s;const l=e.readSync(o.dataId);const f=e.readSync(r.dataId);const{selectedIndices:h,validOutputs:d}=bX(l,f,i,c,a,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}const wX={kernelName:Je,backendName:"webgl",kernelFunc:gX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX=hx;function $X(t){ho("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,softNmsSigma:u}=s;const l=e.readSync(o.dataId);const f=e.readSync(r.dataId);const h=i;const d=c;const p=a;const m=u;const{selectedIndices:x,selectedScores:b}=vX(l,f,h,d,p,m);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const yX={kernelName:Ye,backendName:"webgl",kernelFunc:$X};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kX{constructor(t,n,e,s){this.variableNames=["indices"];this.outputShape=[t,n];this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${e}),\n                      float(index == coords.y)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CX=t=>{const{inputs:n,backend:e,attrs:s}=t;const{indices:o}=n;const{dtype:r,depth:i,onValue:c,offValue:a}=s;const u=w(o.shape);const l=new kX(u,i,c,a);const f=DB({inputs:{x:o},backend:e,attrs:{shape:[u]}});const h=e.runWebGLProgram(l,[f],r);e.disposeIntermediateTensorInfo(f);const d=[...o.shape,i];const p=DB({inputs:{x:h},backend:e,attrs:{shape:d}});e.disposeIntermediateTensorInfo(h);return p};const NX={kernelName:Qe,backendName:"webgl",kernelFunc:CX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RX(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="complex64"){const t=IG({inputs:{input:s},backend:e});const n=RX({inputs:{x:t},backend:e});const o=JG({inputs:{input:s},backend:e});const r=RX({inputs:{x:o},backend:e});const i=mB({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return GH({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}}const SX={kernelName:ro,backendName:"webgl",kernelFunc:RX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("onesLike is not supported under string dtype")}else if(s.dtype==="complex64"){const t=IG({inputs:{input:s},backend:e});const n=EX({inputs:{x:t},backend:e});const o=JG({inputs:{input:s},backend:e});const r=RX({inputs:{x:o},backend:e});const i=mB({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return GH({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}}const TX={kernelName:Ze,backendName:"webgl",kernelFunc:EX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IX(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;if(n.length===1){return FH({inputs:{input:n[0]},backend:e,attrs:{dim:o}})}const r=n[0].shape;const i=n[0].dtype;n.forEach((t=>{b(r,t.shape,"All tensors passed to stack must have matching shapes");x(i===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=[];const a=n.map((t=>{const n=FH({inputs:{input:t},backend:e,attrs:{dim:o}});c.push(n);return n}));const u=tU({inputs:a,backend:e,attrs:{axis:o}});c.forEach((t=>e.disposeIntermediateTensorInfo(t)));return u}const AX={kernelName:ts,backendName:"webgl",kernelFunc:IX};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OX{constructor(t,n,e){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=Wz(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`\n        int start = ${r};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${o} start = ${o}(${r});\n      ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${c}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FX{constructor(t,n,e){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=Wz(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=NV("rc",s);const a=NV("source",s);const u=`${c[s-1]} < ${this.outputShape[s-1]}`;const l=s===1?"source":`vec2(${a.slice(-2).join()})`;const f=[`${o} rc = outputLoc;`,`${c[s-1]} += 1;\n       if(${u}) {\n      `,s===1?"":`}\n       rc = outputLoc;\n       ${c[s-2]} += 1;\n       if(${c[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${c[s-1]} += 1;\n         if(${u}) {`];const h=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let d="";for(let t=0,n=s===1?2:4;t<n;t++){d+=`\n        ${f[t]}\n        if (${h}) {\n          result[${t}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${t}] = getChannel(getX(${a.join()}), ${l});\n        }\n      `}d+=s===1?`} `:`}}`;this.userCode=`\n      const ${o} start = ${o}(${r});\n      const ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _X=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,constantValue:i}=s;if(w(o.shape)===0){const t=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));return GH({backend:e,attrs:{shape:t,value:i,dtype:o.dtype}})}const c=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new FX(o.shape,r,i):new OX(o.shape,r,i);const a=[[i]];return e.runWebGLProgram(c,[o],o.dtype,a)};const MX={kernelName:ns,backendName:"webgl",kernelFunc:_X};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DX=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;const LX=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  `+fB+`\n  return result;\n`;const zX=SB({opSnippet:DX,packedOpSnippet:LX});const PX={kernelName:es,backendName:"webgl",kernelFunc:zX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=[];const u=R(r,o.shape);let l=u;const f=hf(l,c);let h=o;if(f!=null){h=KB({inputs:{x:o},backend:e,attrs:{perm:f}});l=pf(l.length,c);a.push(h)}ff("prod",l,c);let d;if(e.shouldExecuteOnCPU([h])){const t=e.texData.get(h.dataId).values;const{outVals:n,outShape:s,outDtype:o}=tV(h.shape,h.dtype,t,l);d=e.makeTensorInfo(s,o,n)}else{const[t,n]=uf(h.shape,l);const s=w(n);const r=DB({inputs:{x:h},backend:e,attrs:{shape:[-1,s]}});const i=Or(o.dtype);const c=BB(r,i,"prod",e);d=DB({inputs:{x:c},backend:e,attrs:{shape:t}});a.push(r);a.push(c)}if(i){a.push(d);const t=lf(d.shape,u);d=DB({inputs:{x:d},backend:e,attrs:{shape:t}})}a.forEach((t=>e.disposeIntermediateTensorInfo(t)));return d}const BX={kernelName:os,backendName:"webgl",kernelFunc:VX};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WX(t){const{inputs:n,backend:e,attrs:s}=t;const{paramsNestedSplits:o,paramsDenseValues:r,indices:i}=n;const{outputRaggedRank:c}=s;const a=o.map((t=>e.readSync(t.dataId)));const u=o.map((t=>t.shape));const l=e.readSync(r.dataId);const f=e.readSync(i.dataId);const[h,d,p]=nV(a,u,l,r.shape,r.dtype,f,i.shape,c);const m=h.map((t=>e.makeTensorInfo([t.length],"int32",t)));const x=e.makeTensorInfo(p,r.dtype,d);return m.concat([x])}const GX={kernelName:rs,backendName:"webgl",kernelFunc:WX};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UX(t){const{inputs:n,backend:e}=t;const{starts:s,limits:o,deltas:r}=n;const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=eV(i,s.shape,s.dtype,c,o.shape,a,r.shape);const f=e.makeTensorInfo([u.length],"int32",u);const h=e.makeTensorInfo([l.length],s.dtype,l);return[f,h]}const HX={kernelName:is,backendName:"webgl",kernelFunc:UX};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jX(t){const{inputs:n,backend:e,attrs:s}=t;const{shape:o,values:r,defaultValue:i,rowPartitionTensors:c}=n;const{rowPartitionTypes:a}=s;const u=e.readSync(o.dataId);const l=e.readSync(r.dataId);const f=e.readSync(i.dataId);const h=c.map((t=>e.readSync(t.dataId)));const d=c.map((t=>t.shape));const[p,m]=sV(u,o.shape,l,r.shape,r.dtype,f,i.shape,h,d,a);return e.makeTensorInfo(p,r.dtype,m)}const qX={kernelName:cs,backendName:"webgl",kernelFunc:jX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XX=t=>{const{backend:n,attrs:e}=t;const{start:s,stop:o,step:r,dtype:i}=e;const c=oV(s,o,r,i);return n.makeTensorInfo([c.length],i,c)};const KX={kernelName:as,backendName:"webgl",kernelFunc:XX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JX=`return 1.0 / x;`;const YX=RB({opSnippet:JX});const ZX={kernelName:ls,backendName:"webgl",kernelFunc:YX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QX=zV+`\n  return (x < 0.0) ? 0.0 : x;\n`;const tK=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const nK=RB({opSnippet:QX,packedOpSnippet:tK});const eK={kernelName:fs,backendName:"webgl",kernelFunc:nK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sK=zV+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const oK=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const rK=RB({opSnippet:sK,packedOpSnippet:oK});const iK={kernelName:bs,backendName:"webgl",kernelFunc:rK};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cK{constructor(t,n,e,s,o){this.variableNames=["A"];this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];let f;if(o){f=`(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC`+` - vec2(0.5)`}else{f=`vec2(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aK{constructor(t,n,e,s,o){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];let f;if(o){f=`(vec3(yRC) + vec3(0.5)) * `+`effectiveInputOverOutputRatioRC - vec3(0.5)`}else{f=`vec3(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uK(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;const[a,u]=c;const l=st().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new aK(o.shape,a,u,r,i):new cK(o.shape,a,u,r,i);return e.runWebGLProgram(l,[o],"float32")}const lK={kernelName:ms,backendName:"webgl",kernelFunc:uK};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fK{constructor(t,n,e){this.variableNames=["dy"];this.outputShape=[];this.outputShape=n;const[,s,o]=n;const[,r,i]=t;const c=[e&&r>1?s-1:s,e&&i>1?o-1:o];const a=[e&&r>1?r-1:r,e&&i>1?i-1:i];const u=c[0]/a[0];const l=c[1]/a[1];const f=1/u;const h=1/l;const d=Math.ceil(f)*2+2;const p=Math.ceil(h)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hK(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;const c=new fK(r.shape,o.shape,i);return e.runWebGLProgram(c,[r],r.dtype)}const dK={kernelName:xs,backendName:"webgl",kernelFunc:hK};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pK{constructor(t,n,e,s,o){this.variableNames=["A"];this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];const f=s?"0.5":"0.0";let h;if(o){h=`max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC`+`, vec2(0.0))`}else{h=`vec2(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mK{constructor(t,n,e,s,o){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];const f=s?"0.5":"0.0";let h;if(o){h=`max((vec3(yRC) + vec3(0.5)) * `+`effectiveInputOverOutputRatioRC, vec3(0.0))`}else{h=`vec3(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;const[a,u]=c;const l=st().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mK(o.shape,a,u,r,i):new pK(o.shape,a,u,r,i);return e.runWebGLProgram(l,[o],o.dtype)}const bK={kernelName:ds,backendName:"webgl",kernelFunc:xK};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gK{constructor(t,n,e){this.variableNames=["dy"];this.outputShape=[];this.outputShape=n;const[,s,o]=n;const[,r,i]=t;const c=[e&&r>1?s-1:s,e&&i>1?o-1:o];const a=[e&&r>1?r-1:r,e&&i>1?i-1:i];const u=c[0]/a[0];const l=c[1]/a[1];const f=1/u;const h=1/l;const d=Math.ceil(f)*2+2;const p=Math.ceil(h)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${c[0]}) *\n                (float(dyR) / float(${a[0]}));\n\n            float sourceFracCol =\n                float(${c[1]}) *\n                  (float(dyC) / float(${a[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${e} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${e} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wK(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;const c=new gK(r.shape,o.shape,i);return e.runWebGLProgram(c,[r],r.dtype)}const vK={kernelName:ps,backendName:"webgl",kernelFunc:wK};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $K{constructor(t,n){this.variableNames=["x"];const e=t.length;if(e>4){throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`)}this.outputShape=t;if(e===1){this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `;return}const s=e=>{if(n.indexOf(e)!==-1&&t[e]!==1){return`${t[e]} - coords[${e}] - 1`}return`coords[${e}]`};const o=t.map(((t,n)=>s(n))).join(",");const r=Wz(e);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yK{constructor(t,n){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;const e=t.length;if(e>4){throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`)}this.outputShape=t;const s=NV("rc",e);const o=`${s[e-1]} + 1 < ${this.outputShape[e-1]}`;const r=`${s[e-2]} + 1 < ${this.outputShape[e-2]}`;const i=Wz(e);if(e===1){this.userCode=`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `}else{this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${c(s.slice())};\n          if(${o}){\n            result.g = ${a(s.slice())};\n          }\n          if(${r}) {\n            result.b = ${u(s.slice())};\n            if(${o}) {\n              result.a = ${l(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}function c(t){return f(t)}function a(t){t[e-1]="("+t[e-1]+` + 1)`;return f(t)}function u(t){t[e-2]="("+t[e-2]+` + 1)`;return f(t)}function l(t){t[e-1]="("+t[e-1]+` + 1)`;t[e-2]="("+t[e-2]+` + 1)`;return f(t)}function f(n){const e=t.map(((t,e)=>h(e,n)));const s=e.join(",");const o=e.slice(-2).join(",");return`getChannel(getX(${s}), vec2(${o}))`}function h(e,s){if(n.indexOf(e)!==-1&&t[e]!==1){return`${t[e]} - ${s[e]} - 1`}else{return`${s[e]}`}}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kK(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dims:r}=s;const i=o.shape.length;const c=R(r,o.shape);if(i===0){return dB({inputs:{x:o},backend:e})}const a=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yK(o.shape,c):new $K(o.shape,c);return e.runWebGLProgram(a,[o],o.dtype)}const CK={kernelName:gs,backendName:"webgl",kernelFunc:kK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NK{constructor(t,n){this.variableNames=["Image"];this.outputShape=[];this.customUniforms=[{name:"params",type:"vec4"}];const e=t[1];const s=t[2];this.outputShape=t;let o="";if(typeof n==="number"){o=`float outputValue = ${n.toFixed(2)};`}else{o=`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`}this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${e}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RK={kernelName:ao,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const{radians:o,fillValue:r,center:i}=n;const c=e;const a=new NK(s.shape,r);const[u,l]=Bb(i,s.shape[1],s.shape[2]);const f=[[u,l,Math.sin(o),Math.cos(o)]];const h=c.runWebGLProgram(a,[s],s.dtype,f);return h}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SK=`\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;const EK=RB({opSnippet:SK});const TK={kernelName:ws,backendName:"webgl",kernelFunc:EK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK=`return inversesqrt(x);`;const AK=RB({opSnippet:IK,cpuKernelImpl:rV});const OK={kernelName:vs,backendName:"webgl",kernelFunc:AK};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FK{constructor(t,n,e,s,o,r,i=true,c=false){this.variableNames=["updates","indices","defaultValue"];this.outputShape=r;const a=Wz(o.length);const u=Wz(r.length);let l="";if(e===1){l="i"}else if(e===2){l="i, j"}const f=`getIndices(${l})`;let h="";if(s===1){h="i"}else if(s===2){h="i, coords[1]"}const d=`getUpdates(${h})`;let p="";if(c){p="coords[0], coords[1]"}const m=`getDefaultValue(${p})`;const x=n>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${f});\n              flattenedIndex += index * ${x};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _K{constructor(t,n,e,s,o,r,i=true,c=false){this.variableNames=["updates","indices","defaultValue"];this.packedInputs=true;this.packedOutput=true;this.outputShape=r;const a=Wz(o.length);const u=Wz(r.length);let l="";if(e===1){l="i"}else if(e===2){l="i, j"}const f=`getIndices(${l})`;let h="";if(s===1){h="i"}else if(s===2){h="i, coords[1]"}const d=`getUpdates(${h})`;let p="";if(c){p="coords[0], coords[1]"}const m=`getDefaultValue(${p})`;const x=n>1?"strides[j]":"strides";const b=n>1?"strides[j + 1]":"strides";this.userCode=`\n        ${a} strides = ${a}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${n}; j+=2) {\n              ivec4 index = round(${f});\n              flattenedIndex += index.xz * ${x};\n              if (j + 1 < ${n}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MK(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o,updates:r}=n;const{shape:i}=s;const{sliceRank:c,numUpdates:a,sliceSize:u,strides:l,outputSize:f}=mm(r,o,i);const h=[f/u,u];if(f===0){return e.makeTensorInfo(i,o.dtype)}const d=DB({inputs:{x:o},backend:e,attrs:{shape:[a,c]}});const p=DB({inputs:{x:r},backend:e,attrs:{shape:[a,u]}});const m=e.makeTensorInfo([],"float32",new Float32Array([0]));let x;if(st().getBool("WEBGL_PACK")){x=new _K(a,c,d.shape.length,p.shape.length,l,h)}else{x=new FK(a,c,d.shape.length,p.shape.length,l,h)}const b=e.runWebGLProgram(x,[p,d,m],p.dtype);const g=DB({inputs:{x:b},backend:e,attrs:{shape:i}});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(b);e.disposeIntermediateTensorInfo(m);return g}const DK={kernelName:$s,backendName:"webgl",kernelFunc:MK};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LK{constructor(t,n,e,s){this.variableNames=["sortedSequence","values"];this.customUniforms=[{name:"numInputs",type:"int"}];this.outputShape=[t,e];const o="while (left < right) {";const r=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`;const i=st().getNumber("WEBGL_VERSION")===2?o:r;const c=s==="left"?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${c} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(t){const{inputs:n,backend:e,attrs:s}=t;const{sortedSequence:o,values:r}=n;const{side:i}=s;const c=new LK(o.shape[0],o.shape[1],r.shape[1],i);const a=[[o.shape[1]]];return e.runWebGLProgram(c,[o,r],"int32",a)}const PK={kernelName:ks,backendName:"webgl",kernelFunc:zK};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VK{constructor(t,n,e){this.variableNames=["c","a","b"];this.outputShape=n;let s;let o;if(e>4){throw Error(`Where for rank ${e} is not yet supported`)}if(e===1){o=`resRC`;s=`resRC`}else{const e=["resRC.x","resRC.y","resRC.z","resRC.w"];const r=[];const i=[];for(let s=0;s<n.length;s++){i.push(`${e[s]}`);if(s<t){r.push(`${e[s]}`)}}s=r.join();o=i.join()}const r=Wz(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BK(t){const{inputs:n,backend:e}=t;const{condition:s,t:o,e:r}=n;const i=new VK(s.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[s,o,r],Ar(o.dtype,r.dtype))}const WK={kernelName:Cs,backendName:"webgl",kernelFunc:BK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GK=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${qb};\n  float scale = ${Xb};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;const UK=RB({opSnippet:GK});const HK={kernelName:Ns,backendName:"webgl",kernelFunc:UK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jK=NB+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;const qK=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const XK=RB({opSnippet:jK,packedOpSnippet:qK,cpuKernelImpl:cV});const KK={kernelName:Is,backendName:"webgl",kernelFunc:XK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JK=`\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;const YK=RB({opSnippet:JK});const ZK={kernelName:Ts,backendName:"webgl",kernelFunc:YK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QK=NB+`\n  return sin(x);\n`;const tJ=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${fB}\n  return result;\n`;const nJ=RB({opSnippet:QK,packedOpSnippet:tJ});const eJ={kernelName:Ss,backendName:"webgl",kernelFunc:nJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJ=`\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;const oJ=RB({opSnippet:sJ});const rJ={kernelName:Es,backendName:"webgl",kernelFunc:oJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJ=`\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;const cJ=RB({opSnippet:iJ});const aJ={kernelName:As,backendName:"webgl",kernelFunc:cJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uJ=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,paddings:i}=s;x(o.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not "+"implemented yet"));const c=r.reduce(((t,n)=>t*n));const a=[[0,0]];a.push(...i);for(let t=1+r.length;t<o.shape.length;++t){a.push([0,0])}const u=[];const l=_X({inputs:{x:o},backend:e,attrs:{paddings:a,constantValue:0}});const f=Wb(l.shape,r,c,false);const h=Gb(f.length,r.length,false);const d=Ub(l.shape,r,c,false);const p=DB({inputs:{x:l},backend:e,attrs:{shape:f}});const m=KB({inputs:{x:p},backend:e,attrs:{perm:h}});const b=DB({inputs:{x:m},backend:e,attrs:{shape:d}});u.push(l);u.push(p);u.push(m);u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return b};const lJ={kernelName:_s,backendName:"webgl",kernelFunc:uJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fJ(t){const{inputs:n,backend:e}=t;const{indices:s,values:o,denseShape:r,defaultValue:i}=n;if(r.shape.length!==1){throw new Error(`Dense shape must be a vector, saw:\n         ${r.shape}`)}if(s.shape.length!==2){throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Values must be a vector, saw:\n         ${o.shape}`)}if(i.shape.length!==0){throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`)}const c=e.readSync(s.dataId);const a=e.readSync(o.dataId);const u=e.readSync(r.dataId);const l=e.readSync(i.dataId)[0];const[f,h,d,p,m]=lV(c,s.shape,s.dtype,a,o.dtype,u,l);return[e.makeTensorInfo(h,s.dtype,f),e.makeTensorInfo([h[0]],o.dtype,d),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map((t=>Number(t))))),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const hJ={kernelName:Ls,backendName:"webgl",kernelFunc:fJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(t){const{inputs:n,backend:e}=t;const{inputIndices:s,inputShape:o,newShape:r}=n;if(s.shape.length!==2){throw new Error(`Input indices should be a matrix but received shape ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Input shape should be a vector but received shape ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Target shape should be a vector but received shape ${r.shape}`)}const i=Array.from(e.readSync(o.dataId));const c=e.readSync(s.dataId);const a=Array.from(e.readSync(r.dataId));const[u,l,f]=fV(c,s.shape,s.dtype,i,a);return[e.makeTensorInfo(l,s.dtype,u),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const pJ={kernelName:zs,backendName:"webgl",kernelFunc:dJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n              ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n              ${r.shape}`)}const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=hV(i,s.shape,s.dtype,c,a,true);return e.makeTensorInfo(l,s.dtype,u)}const xJ={kernelName:Ps,backendName:"webgl",kernelFunc:mJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n             ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n             ${r.shape}`)}const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=hV(i,s.shape,s.dtype,c,a);return e.makeTensorInfo(l,s.dtype,u)}const gJ={kernelName:Vs,backendName:"webgl",kernelFunc:bJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wJ(t){const{inputs:n,backend:e,attrs:s}=t;const{sparseIndices:o,sparseValues:r,defaultValue:i}=n;const{outputShape:c}=s;const{sliceRank:a,numUpdates:u,sliceSize:l,strides:f,outputSize:h}=mm(r,o,c);const d=false;if(r.dtype==="string"){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=tr(e.readSync(i.dataId)[0]);const p=iV(t,n,c,h,l,u,a,f,s,d);return e.makeTensorInfo(c,p.dtype,p.values)}const p=new FK(u,a,o.shape.length,r.shape.length,f,[h,1],d);const m=e.runWebGLProgram(p,[r,o,i],r.dtype);const x=DB({inputs:{x:m},backend:e,attrs:{shape:c}});e.disposeIntermediateTensorInfo(m);return x}const vJ={kernelName:Bs,backendName:"webgl",kernelFunc:wJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $J(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{numOrSizeSplits:r,axis:i}=s;const c=R(i,o.shape)[0];const a=wg(o,r,c);const u=o.shape.length;const l=new Array(u).fill(0);const f=o.shape.slice();return a.map((t=>{const n=[...f];n[c]=t;const s=mG({inputs:{x:o},backend:e,attrs:{begin:l,size:n}});l[c]+=t;return s}))}const yJ={kernelName:Ms,backendName:"webgl",kernelFunc:$J};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJ=`return sqrt(x);`;const CJ=RB({opSnippet:kJ,packedOpSnippet:kJ,cpuKernelImpl:dV});const NJ={kernelName:Os,backendName:"webgl",kernelFunc:CJ};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RJ=`return x * x;`;const SJ=RB({opSnippet:RJ});const EJ={kernelName:Gs,backendName:"webgl",kernelFunc:SJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TJ="return (a - b) * (a - b);";const IJ=SB({opSnippet:TJ,packedOpSnippet:TJ});const AJ={kernelName:Ws,backendName:"webgl",kernelFunc:IJ};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OJ(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;if(o.dtype!=="string"){throw new Error("Input must be of datatype string")}const r=e.readSync(o.dataId);const i=Dg(r);const c=pV(i,"string",s);return e.makeTensorInfo(o.shape,"string",c)}const FJ={kernelName:Us,backendName:"webgl",kernelFunc:OJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _J({inputs:t,attrs:n,backend:e}){const{x:s}=t;const o=zV+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `;const r=new LV(s.shape,o);return e.runWebGLProgram(r,[s],s.dtype)}const MJ={kernelName:io,backendName:"webgl",kernelFunc:_J};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DJ{constructor(t,n,e){this.variableNames=["x"];this.outputShape=e;const s=e.length;const o=Wz(e.length);const r=Wz(e.length);let i="";if(s===1){i="coords * strides + begin"}else{let t=0;i=e.map(((n,s)=>{t++;return e.length===1?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`})).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${n});\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJ(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,end:i,strides:c,beginMask:a,endMask:u,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:h}=s;const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:b,isSimpleSlice:g,begin:w,end:v,strides:$}=Cb(o.shape,r,i,c,a,u,l,f,h);let y;if(m){y=DB({inputs:{x:o},backend:e,attrs:{shape:p}})}else if(b||g){x(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const t=fb(w,v,$);const n=mG({inputs:{x:o},backend:e,attrs:{begin:w,size:t}});y=DB({inputs:{x:n},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(n)}else{const t=e.shouldExecuteOnCPU([o]);if(t){const t=e.readSync(o.dataId);const n=ba(o.shape,o.dtype,t);const s=mV(d,n,$,w);y=e.makeTensorInfo(p,o.dtype,s.values)}else{const t=new DJ(w,$,d);y=e.runWebGLProgram(t,[o],o.dtype)}}const k=DB({inputs:{x:y},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(y);return k}const zJ={kernelName:Hs,backendName:"webgl",kernelFunc:LJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(t){const{inputs:n,backend:e,attrs:s}=t;const{separator:o,nGramWidths:r,leftPad:i,rightPad:c,padWidth:a,preserveShortSequences:u}=s;const{data:l,dataSplits:f}=n;const h=e.readSync(l.dataId);const d=e.readSync(f.dataId);const[p,m]=xV(h,d,o,r,i,c,a,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(f.shape,"int32",m)]}const VJ={kernelName:js,backendName:"webgl",kernelFunc:PJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BJ(t){const{inputs:n,backend:e,attrs:s}=t;const{skipEmpty:o}=s;const{input:r,delimiter:i}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(r.shape.length!==1){throw new Error(`Input must be a vector, got shape: ${r.shape}`)}if(i.shape.length!==0){throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`)}const c=e.readSync(r.dataId);const a=e.readSync(i.dataId)[0];const[u,l,f]=bV(c,a,o);const h=l.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const WJ={kernelName:qs,backendName:"webgl",kernelFunc:BJ};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(t){const{inputs:n,backend:e,attrs:s}=t;const{numBuckets:o}=s;const{input:r}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(o<=0){throw new Error(`Number of buckets must be at least 1`)}const i=e.readSync(r.dataId);const c=gV(i,o);return e.makeTensorInfo(r.shape,"int32",c)}const UJ={kernelName:Xs,backendName:"webgl",kernelFunc:GJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HJ=`return tan(x);`;const jJ=RB({opSnippet:HJ});const qJ={kernelName:Js,backendName:"webgl",kernelFunc:jJ};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XJ=`\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;const KJ=RB({opSnippet:XJ});const JJ={kernelName:Ys,backendName:"webgl",kernelFunc:KJ};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YJ(t){const{inputs:n,backend:e}=t;const{tensor:s,indices:o,updates:r}=n;const{sliceRank:i,numUpdates:c,sliceSize:a,strides:u,outputSize:l}=mm(r,o,s.shape);const f=[l/a,a];if(l===0){return e.makeTensorInfo(s.shape,o.dtype)}const h=DB({inputs:{x:o},backend:e,attrs:{shape:[c,i]}});const d=DB({inputs:{x:r},backend:e,attrs:{shape:[c,a]}});const p=DB({inputs:{x:s},backend:e,attrs:{shape:f}});const m=new FK(c,i,h.shape.length,d.shape.length,u,f,false,true);const x=e.runWebGLProgram(m,[d,h,p],p.dtype);const b=DB({inputs:{x},backend:e,attrs:{shape:s.shape}});e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(x);return b}const ZJ={kernelName:ys,backendName:"webgl",kernelFunc:YJ};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QJ{constructor(t,n){this.variableNames=["A"];const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[s]*n[s]}this.outputShape=e;this.rank=e.length;const s=Wz(this.rank);const o=tY(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function tY(t){const n=t.length;if(n>5){throw Error(`Tile for rank ${n} is not yet supported`)}if(n===1){return`imod(resRC, ${t[0]})`}const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"];const s=[];for(let n=0;n<t.length;n++){s.push(`imod(${e[n]}, ${t[n]})`)}return s.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reps:r}=s;if(o.dtype==="string"||o.shape.length>5){const t=e.readSync(o.dataId);const n=o.dtype==="string"?t.map((t=>tr(t))):t;const s=ba(o.shape,o.dtype,n);const i=vV(s,r);return e.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new QJ(o.shape,r);const c=e.runWebGLProgram(i,[o],o.dtype);return c}const eY={kernelName:Zs,backendName:"webgl",kernelFunc:nY};class sY{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];this.outputShape=t;this.userCode=`\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `}}class oY{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];this.outputShape=t;this.userCode=`\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(t,n){if(n!==null){t.disposeIntermediateTensorInfo(n)}}function iY(t){let n=1;while(n<t){n*=2}return n}function cY(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{k:r,sorted:i}=s;const c=st().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");const a=st().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");const u=o.shape;const l=u[u.length-1];if(e.shouldExecuteOnCPU([o])||l<c||r>a){const t=e.readSync(o.dataId);const[n,s]=$V(t,u,o.dtype,r,i);return[e.makeTensorInfo(n.shape,n.dtype,n.values),e.makeTensorInfo(s.shape,s.dtype,s.values)]}if(r===0){u[u.length-1]=0;return[e.makeTensorInfo(u,o.dtype,[]),e.makeTensorInfo(u,"int32",[])]}if(l===1){return[o,GH({attrs:{shape:u,dtype:"int32",value:0},backend:e})]}const f=e.texData.get(o.dataId);const h=f!==null&&f.isPacked;const d=h?e.unpackTensor(o):o;const p=w(u);const m=p/l;const x=DB({inputs:{x:d},attrs:{shape:[m,l]},backend:e});if(h){rY(e,d)}const b=iY(r);const g=iY(l);let v=null;const $=()=>v===null?[x,x]:[x,v];const y=(t,n,s)=>{const o=$();const r=new sY(s);const i=v===null?1:0;const c=[[l],[i],[Number.NEGATIVE_INFINITY],[t],[n]];const a=v;v=e.runWebGLProgram(r,o,"int32",c);rY(e,a)};for(let t=1;t<b;t*=2){const n=t*2;for(let e=t;e>=1;e/=2){y(n,e,[m,g])}}for(let t=g;t>b;t/=2){const n=$();const s=new oY([m,t/2]);const o=v===null?1:0;const r=[[l],[o],[b]];const i=v;v=e.runWebGLProgram(s,n,"int32",r);rY(e,i);const c=b/2;const a=c*2;for(let t=c;t>=1;t/=2){y(a,t,v.shape)}}let k=v;v=mG({inputs:{x:v},backend:e,attrs:{begin:0,size:[m,r]}});rY(e,k);let C=mj({inputs:{x,indices:v},backend:e,attrs:{axis:1,batchDims:1}});rY(e,x);const N=u.slice(0,-1);N.push(r);k=v;v=DB({inputs:{x:v},attrs:{shape:N},backend:e});rY(e,k);const R=C;C=DB({inputs:{x:C},attrs:{shape:N},backend:e});rY(e,R);return[C,v]}const aY={kernelName:Qs,backendName:"webgl",kernelFunc:cY};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uY{constructor(t,n,e,s,o,r){this.variableNames=["Image","Transforms"];this.outputShape=r;const i=e==="nearest"?1:2;let c;switch(s){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${c} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${n}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o,transforms:r}=n;const{interpolation:i,fillMode:c,fillValue:a,outputShape:u}=s;const[l,f,h,d]=o.shape;const[p,m]=u!=null?u:[f,h];const x=[l,p,m,d];const b=new uY(f,h,i,c,a,x);return e.runWebGLProgram(b,[o,r],"float32")}const fY={kernelName:to,backendName:"webgl",kernelFunc:lY};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(t){const{inputs:n,attrs:e,backend:s}=t;const{axis:o}=e;const{x:r}=n;UL(r,"unique");console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(r.dataId);const{outputValues:c,outputShape:a,indices:u}=kV(i,o,r.shape,r.dtype);return[s.makeTensorInfo(a,r.dtype,c),s.makeTensorInfo([u.length],"int32",u)]}const dY={kernelName:eo,backendName:"webgl",kernelFunc:hY};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pY(t){const{inputs:n,backend:e,attrs:s}=t;const{value:o}=n;let{axis:r}=s;if(r<0){r+=o.shape.length}const i=o;const c=i.shape.length;const a=o.shape[r];const u=new Array(c-1);let l=0;for(let t=0;t<c;t++){if(t!==r){u[l++]=i.shape[t]}}const f=[];const h=new Array(c).fill(0);const d=i.shape.slice();d[r]=1;const p=new Array(a);for(let t=0;t<p.length;t++){h[r]=t;const n=mG({inputs:{x:i},backend:e,attrs:{begin:h,size:d}});const s=DB({inputs:{x:n},backend:e,attrs:{shape:u}});p[t]=s;f.push(n)}f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return p}const mY={kernelName:so,backendName:"webgl",kernelFunc:pY};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xY{constructor(t,n){this.variableNames=["x","segmentIds"];const e=t.windowSize;const s=t.batchSize;const o=t.inSize;const r=t.numSegments;const i=r*Math.ceil(o/e);this.outputShape=[s,i];const c="0.0";const a=`sumValue`;const u=Math.floor(e/4)*4;const l=e%4;const f=`\n        sumValue += dot(values, segFilter);\n    `;let h="";if(o%e>0){h=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `}let d="";if(o%e>0){d=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `}this.userCode=`\n      const float initializationValue = ${c};\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${r})) * float(${e}));\n        int currentSeg = int(mod(float(outIdx), float(${r})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${l===1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${l===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${l===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(${a});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,segmentIds:r}=n;const{numSegments:i}=s;const c=o.shape.length;const a=[];let u=0;const l=hf([u],c);let f=o;if(l!=null){f=KB({inputs:{x:o},backend:e,attrs:{perm:l}});a.push(f);u=pf(1,c)[0]}const h=Fg(f.shape,u,i);const d=w([f.shape[u]]);const p=DB({inputs:{x:f},backend:e,attrs:{shape:[-1,d]}});a.push(p);const m=Or(o.dtype);const x=(t,n,s,o,r)=>{const i=t.shape[0];const c=t.shape[1];const u=Og(c,r);const l={windowSize:u,inSize:c,batchSize:i,numSegments:r};const f=new xY(l,n);const h=e.compileAndRun(f,[t,s],o);a.push(h);if(h.shape[1]===r){return h}const d=XX({backend:e,attrs:{start:0,stop:r,step:1,dtype:"float32"}});const p=nY({inputs:{x:d},backend:e,attrs:{reps:[c/u]}});a.push(d);a.push(p);const m=x(h,n,p,o,r);return m};const b=x(p,"unsortedSegmentSum",r,m,i);const g=DB({inputs:{x:b},backend:e,attrs:{shape:h}});let v=g;if(l!=null){a.push(g);const t=df(l);v=KB({inputs:{x:v},backend:e,attrs:{perm:t}})}a.forEach((t=>e.disposeIntermediateTensorInfo(t)));return v}const gY={kernelName:oo,backendName:"webgl",kernelFunc:bY};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wY=[tW,sW,iW,uW,hW,xW,gW,vW,SW,TW,OW,MW,zW,WW,HW,KW,YW,nG,sG,rG,uG,gG,vG,CG,RG,MG,zG,WG,xB,jG,nU,lU,xU,wU,$U,kU,NU,TU,OU,MU,WU,UU,jU,KU,QU,sH,rH,aH,fH,dH,bH,$H,NH,EH,OH,_H,LH,BH,UH,jH,KH,QH,ej,cj,uj,hj,xj,vj,Cj,pB,Rj,YG,Tj,Oj,Mj,vB,Pj,Gj,Hj,Kj,Zj,eq,rq,uq,dq,xq,wq,kq,Nq,Sq,Aq,Fq,Mq,Lq,Pq,Gq,qq,Yq,uX,_B,dX,xX,wX,yX,TG,NX,TX,AX,MX,PX,CB,BX,GX,HX,qX,KX,AG,eX,ZX,eK,iK,LB,lK,dK,bK,vK,CK,RK,TK,OK,DK,PK,WK,HK,KK,ZK,eJ,rJ,xG,cX,aJ,lJ,hJ,pJ,xJ,gJ,vJ,yJ,NJ,EJ,AJ,FJ,MJ,zJ,VJ,WJ,UJ,rX,XB,qJ,JJ,ZJ,eY,aY,fY,JB,dY,mY,gY,SX];for(const t of wY){vo(t)}async function vY(t,n){const e=gc([1212,12]).print();console.info("el tensor es: ",e,t,n);return e}async function $Y(t,n){if(t.length!==n.length)throw new Error("v1 and v2 must have the same length");let e=0;let s=0;while(e<t.length){s+=Math.pow(t[e].x-n[e].x,2)+Math.pow(t[e].y-n[e].y,2)+Math.pow(t[e].z-n[e].z,2);e++}return Math.sqrt(s)}async function yY(t,n,e=1.5){let s=null;let o=Infinity;for(const r of t){const t=await $Y(r.descriptors,n);if(t>e){continue}if(t<o){o=t;s=r}}return s}e.getBestMatch=yY;e.getDistance=$Y;e.tsDistance=vY})();