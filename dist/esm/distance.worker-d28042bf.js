(()=>{"use strict";const t=(t,n)=>{const e=globalThis[n];return e!=null&&t instanceof e};const n=e=>{if(e!=null){if(t(e,"ArrayBuffer")||t(e,"MessagePort")||t(e,"ImageBitmap")||t(e,"OffscreenCanvas")){return[e]}if(typeof e==="object"){if(e.constructor===Object){e=Object.values(e)}if(Array.isArray(e)){return e.flatMap(n)}return n(e.buffer)}}return[]};const e={};const s="stencil.distance.worker";const o=s+".cb";addEventListener("message",(async({data:t})=>{if(t&&t[0]===s){let r=t[1];let i=t[2];let c=t[3];let a=0;let u=c.length;let l;let f;try{for(;a<u;a++){if(Array.isArray(c[a])&&c[a][0]===o){const t=c[a][1];c[a]=(...n)=>{postMessage([o,t,n])}}}l=await e[i](...c)}catch(t){l=null;if(t instanceof Error){f={isError:true,value:{message:t.message,name:t.name,stack:t.stack}}}else{f={isError:false,value:t}}l=undefined}const h=n(l);postMessage([s,r,l,f],h)}}));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r=1e-7;const i=1e-4;class c{constructor(t,n){this.backend=t;this.dataMover=n;this.data=new WeakMap;this.dataIdsCount=0}get(t){if(!this.data.has(t)){this.dataMover.moveData(this.backend,t)}return this.data.get(t)}set(t,n){this.dataIdsCount++;this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){this.dataIdsCount--;return this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class a{refCount(t){return u("refCount")}incRef(t){return u("incRef")}timerAvailable(){return true}time(t){return u("time")}read(t){return u("read")}readSync(t){return u("readSync")}readToGPU(t,n){return u("readToGPU")}numDataIds(){return u("numDataIds")}disposeData(t,n){return u("disposeData")}write(t,n,e){return u("write")}move(t,n,e,s,o){return u("move")}createTensorFromGPUData(t,n,e){return u("createTensorFromGPUData")}memory(){return u("memory")}floatPrecision(){return u("floatPrecision")}epsilon(){return this.floatPrecision()===32?r:i}dispose(){return u("dispose")}}function u(t){throw new Error(`'${t}' not yet implemented or not found in the registry. `+`This kernel may not be supported by the tfjs backend you have chosen`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l(t){let n=t.length;let e=0;while(n>0){e=Math.random()*n|0;n--;d(t,n,e)}}function f(t,n,e){return Math.max(t,Math.min(n,e))}function h(t){return t%2===0?t:t+1}function d(t,n,e){const s=t[n];t[n]=t[e];t[e]=s}function p(t){let n=0;for(let e=0;e<t.length;e++){n+=t[e]}return n}function m(t,n){if(!t){throw new Error(typeof n==="string"?n:n())}}function x(t,n,e=""){m(w(t,n),(()=>e+` Shapes ${t} and ${n} must match`))}function b(t){m(t!=null,(()=>`The input to the tensor constructor must be a non-null value.`))}function g(t){if(t.length===0){return 1}let n=t[0];for(let e=1;e<t.length;e++){n*=t[e]}return n}function w(t,n){if(t===n){return true}if(t==null||n==null){return false}if(t.length!==n.length){return false}for(let e=0;e<t.length;e++){if(t[e]!==n[e]){return false}}return true}function v(t){return t%1===0}function $(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function y(t,n){if(n<=t.length){return t}return t+" ".repeat(n-t.length)}function k(t,n=(t=>0),e,s){return new Promise(((o,r)=>{let i=0;const c=()=>{if(t()){o();return}i++;const a=n(i);if(e!=null&&i>=e){r();return}if(s!=null){s(c,a)}else{setTimeout(c,a)}};c()}))}function C(t,n){let e=1;let s=-1;for(let n=0;n<t.length;++n){if(t[n]>=0){e*=t[n]}else if(t[n]===-1){if(s!==-1){throw Error(`Shapes can only have 1 implicit size. `+`Found -1 at dim ${s} and dim ${n}`)}s=n}else if(t[n]<0){throw Error(`Shapes can not be < 0. Found ${t[n]} at dim ${n}`)}}if(s===-1){if(n>0&&n!==e){throw Error(`Size(${n}) must match the product of shape ${t}`)}return t}if(e===0){throw Error(`Cannot infer the missing size in [${t}] when `+`there are 0 elements`)}if(n%e!==0){throw Error(`The implicit shape can't be a fractional number. `+`Got ${n} / ${e}`)}const o=t.slice();o[s]=n/e;return o}function N(t,n){const e=n.length;t=t==null?n.map(((t,n)=>n)):[].concat(t);m(t.every((t=>t>=-e&&t<e)),(()=>`All values in axis param must be in range [-${e}, ${e}) but `+`got axis ${t}`));m(t.every((t=>v(t))),(()=>`All values in axis param must be integers but `+`got axis ${t}`));return t.map((t=>t<0?e+t:t))}function R(t,n){const e=[];const s=[];const o=n!=null&&Array.isArray(n)&&n.length===0;const r=n==null||o?null:N(n,t).sort();let i=0;for(let n=0;n<t.length;++n){if(r!=null){if(r[i]===n&&t[n]!==1){throw new Error(`Can't squeeze axis ${n} since its dim '${t[n]}' is not 1`)}if((r[i]==null||r[i]>n)&&t[n]===1){e.push(t[n]);s.push(n)}if(r[i]<=n){i++}}if(t[n]!==1){e.push(t[n]);s.push(n)}}return{newShape:e,keptDims:s}}function S(t,n){return E(t,n)}function E(t,n){let e=null;if(t==null||t==="float32"){e=new Float32Array(n)}else if(t==="int32"){e=new Int32Array(n)}else if(t==="bool"){e=new Uint8Array(n)}else if(t==="string"){e=new Array(n)}else{throw new Error(`Unknown data type ${t}`)}return e}function T(t,n){for(let e=0;e<t.length;e++){const s=t[e];if(isNaN(s)||!isFinite(s)){throw Error(`A tensor of type ${n} being uploaded contains ${s}.`)}}}function I(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function A(t,n){if(n==="complex64"){return false}if(n==="float32"&&t!=="complex64"){return false}if(n==="int32"&&t!=="float32"&&t!=="complex64"){return false}if(n==="bool"&&t==="bool"){return false}return true}function O(t){if(t==="float32"||t==="int32"){return 4}else if(t==="complex64"){return 8}else if(t==="bool"){return 1}else{throw new Error(`Unknown dtype ${t}`)}}function F(t){if(t==null){return 0}let n=0;t.forEach((t=>n+=t.length));return n}function _(t){return typeof t==="string"||t instanceof String}function M(t){return typeof t==="boolean"}function D(t){return typeof t==="number"}function L(t){if(Array.isArray(t)){return L(t[0])}if(t instanceof Float32Array){return"float32"}else if(t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray){return"int32"}else if(D(t)){return"float32"}else if(_(t)){return"string"}else if(M(t)){return"bool"}return"float32"}function z(t){return!!(t&&t.constructor&&t.call&&t.apply)}function P(t,n){for(let e=n;e<t;++e){if(t%e===0){return e}}return t}function V(t){const n=t.length;if(n<2){return[]}const e=new Array(n-1);e[n-2]=t[n-1];for(let s=n-3;s>=0;--s){e[s]=e[s+1]*t[s+1]}return e}function B(t,n,e,s=false){const o=new Array;if(n.length===1){const r=n[0]*(s?2:1);for(let n=0;n<r;n++){o[n]=e[t+n]}}else{const r=n[0];const i=n.slice(1);const c=i.reduce(((t,n)=>t*n))*(s?2:1);for(let n=0;n<r;n++){o[n]=B(t+n*c,i,e,s)}}return o}function W(t,n,e=false){if(t.length===0){return n[0]}const s=t.reduce(((t,n)=>t*n))*(e?2:1);if(s===0){return[]}if(s!==n.length){throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`)}return B(0,t,n,e)}function G(t,n){if(Array.isArray(t)){return t}if(n==="float32"){return t instanceof Float32Array?t:new Float32Array(t)}else if(n==="int32"){return t instanceof Int32Array?t:new Int32Array(t)}else if(n==="bool"||n==="string"){return Uint8Array.from(new Int32Array(t))}else{throw new Error(`Unknown dtype ${n}`)}}function U(t,n){const e=H(t,n);for(let t=0;t<e.length;t++){e[t]=1}return e}function H(t,n){if(n==null||n==="float32"||n==="complex64"){return new Float32Array(t)}else if(n==="int32"){return new Int32Array(t)}else if(n==="bool"){return new Uint8Array(t)}else{throw new Error(`Unknown data type ${n}`)}}function j(t,n){const e=t.reduce(((t,n)=>t*n),1);if(n==null||n==="float32"){return W(t,new Float32Array(e))}else if(n==="int32"){return W(t,new Int32Array(e))}else if(n==="bool"){return W(t,new Uint8Array(e))}else{throw new Error(`Unknown data type ${n}`)}}function q(t){t.forEach((n=>{m(Number.isInteger(n)&&n>=0,(()=>`Tensor must have a shape comprised of positive integers but got `+`shape [${t}].`))}))}function X(t,n,e){if(n===0){return 0}else if(n===1){return t[0]}let s=t[t.length-1];for(let n=0;n<t.length-1;++n){s+=e[n]*t[n]}return s}function K(t,n,e){if(n===0){return[]}else if(n===1){return[t]}const s=new Array(n);for(let n=0;n<s.length-1;++n){s[n]=Math.floor(t/e[n]);t-=s[n]*e[n]}s[s.length-1]=t;return s}function J(t){return t&&t.then&&typeof t.then==="function"}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y="tfjsflags";class Z{constructor(t){this.global=t;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=Q;this.populateURLFlags()}setPlatform(t,n){if(this.platform!=null){if(!(et().getBool("IS_TEST")||et().getBool("PROD"))){console.warn(`Platform ${this.platformName} has already been set. `+`Overwriting the platform with ${t}.`)}}this.platformName=t;this.platform=n}registerFlag(t,n,e){this.flagRegistry[t]={evaluationFn:n,setHook:e};if(this.urlFlags[t]!=null){const n=this.urlFlags[t];if(!(et().getBool("IS_TEST")||et().getBool("PROD"))){console.warn(`Setting feature override from URL ${t}: ${n}.`)}this.set(t,n)}}async getAsync(t){if(t in this.flags){return this.flags[t]}this.flags[t]=await this.evaluateFlag(t);return this.flags[t]}get(t){if(t in this.flags){return this.flags[t]}const n=this.evaluateFlag(t);if(J(n)){throw new Error(`Flag ${t} cannot be synchronously evaluated. `+`Please use getAsync() instead.`)}this.flags[t]=n;return this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null){throw new Error(`Cannot set flag ${t} as it has not been registered.`)}this.flags[t]=n;if(this.flagRegistry[t].setHook!=null){this.flagRegistry[t].setHook(n)}}evaluateFlag(t){if(this.flagRegistry[t]==null){throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`)}return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={};this.urlFlags={};this.populateURLFlags()}populateURLFlags(){if(typeof this.global==="undefined"||typeof this.global.location==="undefined"||typeof this.global.location.search==="undefined"){return}const t=this.getQueryParams(this.global.location.search);if(Y in t){const n=t[Y].split(",");n.forEach((t=>{const[n,e]=t.split(":");this.urlFlags[n]=nt(n,e)}))}}}function Q(t){const n={};t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...e)=>{tt(n,e[0],e[1]);return e.join("=")}));return n}function tt(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}function nt(t,n){const e=n.toLowerCase();if(e==="true"||e==="false"){return e==="true"}else if(`${+e}`===e){return+e}else{return n}}function et(){return st}let st=null;function ot(t){st=t}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rt;function it(){if(rt==null){let t;if(typeof window!=="undefined"){t=window}else if(typeof global!=="undefined"){t=global}else if(typeof process!=="undefined"){t=process}else if(typeof self!=="undefined"){t=self}else{throw new Error("Could not find a global object")}rt=t}return rt}function ct(){const t=it();if(t._tfGlobals==null){t._tfGlobals=new Map}return t._tfGlobals}function at(t,n){const e=ct();if(e.has(t)){return e.get(t)}else{const s=n();e.set(t,s);return e.get(t)}}const ut="Abs";const lt="Acos";const ft="Acosh";const ht="Add";const dt="AddN";const pt="All";const mt="Any";const xt="ArgMax";const bt="ArgMin";const gt="Asin";const wt="Asinh";const vt="Atan";const $t="Atanh";const yt="Atan2";const kt="AvgPool";const Ct="AvgPoolGrad";const Nt="AvgPool3D";const Rt="AvgPool3DGrad";const St="BatchMatMul";const Et="BatchToSpaceND";const Tt="Bincount";const It="BitwiseAnd";const At="BroadcastTo";const Ot="BroadcastArgs";const Ft="Cast";const _t="Ceil";const Mt="ClipByValue";const Dt="Complex";const Lt="ComplexAbs";const zt="Concat";const Pt="Conv2D";const Vt="Conv2DBackpropFilter";const Bt="Conv2DBackpropInput";const Wt="Conv3D";const Gt="Conv3DBackpropFilterV2";const Ut="Conv3DBackpropInputV2";const Ht="Cos";const jt="Cosh";const qt="Cumprod";const Xt="Cumsum";const Kt="CropAndResize";const Jt="DenseBincount";const Yt="DepthToSpace";const Zt="DepthwiseConv2dNative";const Qt="DepthwiseConv2dNativeBackpropFilter";const tn="DepthwiseConv2dNativeBackpropInput";const nn="Diag";const en="Dilation2D";const sn="Dilation2DBackpropInput";const on="Dilation2DBackpropFilter";const rn="Draw";const cn="RealDiv";const an="Einsum";const un="Elu";const ln="EluGrad";const fn="Erf";const hn="Equal";const dn="Exp";const pn="ExpandDims";const mn="Expm1";const xn="FFT";const bn="Fill";const gn="FlipLeftRight";const wn="Floor";const vn="FloorDiv";const $n="FusedBatchNorm";const yn="GatherV2";const kn="GatherNd";const Cn="Greater";const Nn="GreaterEqual";const Rn="Identity";const Sn="IFFT";const En="Imag";const Tn="IsFinite";const In="IsInf";const An="IsNan";const On="LeakyRelu";const Fn="Less";const _n="LessEqual";const Mn="LinSpace";const Dn="Log";const Ln="Log1p";const zn="LogicalAnd";const Pn="LogicalNot";const Vn="LogicalOr";const Bn="LogSoftmax";const Wn="LRN";const Gn="LRNGrad";const Un="Max";const Hn="Maximum";const jn="MaxPool";const qn="MaxPoolGrad";const Xn="MaxPool3D";const Kn="MaxPool3DGrad";const Jn="MaxPoolWithArgmax";const Yn="Mean";const Zn="Min";const Qn="Minimum";const te="MirrorPad";const ne="Mod";const ee="Multinomial";const se="Multiply";const oe="Neg";const re="NotEqual";const ie="NonMaxSuppressionV3";const ce="NonMaxSuppressionV4";const ae="NonMaxSuppressionV5";const ue="OnesLike";const le="OneHot";const fe="Pack";const he="PadV2";const de="Pow";const pe="Prelu";const me="Prod";const xe="RaggedGather";const be="RaggedRange";const ge="RaggedTensorToTensor";const we="Range";const ve="Real";const $e="Reciprocal";const ye="Relu";const ke="Reshape";const Ce="ResizeNearestNeighbor";const Ne="ResizeNearestNeighborGrad";const Re="ResizeBilinear";const Se="ResizeBilinearGrad";const Ee="Relu6";const Te="Reverse";const Ie="Round";const Ae="Rsqrt";const Oe="ScatterNd";const Fe="TensorScatterUpdate";const _e="SearchSorted";const Me="Select";const De="Selu";const Le="Slice";const ze="Sin";const Pe="Sinh";const Ve="Sign";const Be="Sigmoid";const We="Softplus";const Ge="Sqrt";const Ue="Sum";const He="SpaceToBatchND";const je="SplitV";const qe="Softmax";const Xe="SparseFillEmptyRows";const Ke="SparseReshape";const Je="SparseSegmentMean";const Ye="SparseSegmentSum";const Ze="SparseToDense";const Qe="SquaredDifference";const ts="Square";const ns="StaticRegexReplace";const es="StridedSlice";const ss="StringNGrams";const os="StringSplit";const rs="StringToHashBucketFast";const is="Sub";const cs="Tan";const as="Tanh";const us="Tile";const ls="TopK";const fs="Transform";const hs="Transpose";const ds="Unique";const ps="Unpack";const ms="UnsortedSegmentSum";const xs="ZerosLike";const bs="Step";const gs="FromPixels";const ws="RotateWithOffset";const vs="_FusedMatMul";const $s="FusedConv2D";const ys="FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(...t){if(!(et().getBool("IS_TEST")||et().getBool("PROD"))){console.warn(...t)}}function Cs(...t){if(!(et().getBool("IS_TEST")||et().getBool("PROD"))){console.log(...t)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns=at("kernelRegistry",(()=>new Map));const Rs=at("gradRegistry",(()=>new Map));function Ss(t,n){const e=Os(t,n);return Ns.get(e)}function Es(t){return Rs.get(t)}function Ts(t){const n=Ns.entries();const e=[];while(true){const{done:s,value:o}=n.next();if(s){break}const[r,i]=o;const[c]=r.split("_");if(c===t){e.push(i)}}return e}function Is(t){const{kernelName:n,backendName:e}=t;const s=Os(n,e);if(Ns.has(s)){ks(`The kernel '${n}' for backend `+`'${e}' is already registered`)}Ns.set(s,t)}function As(t){const{kernelName:n}=t;if(Rs.has(n)){if(et().getBool("DEBUG")){ks(`Overriding the gradient for '${n}'`)}}Rs.set(n,t)}function Os(t,n){return`${n}_${t}`}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fs(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var _s=Ds;var Ms=null;try{Ms=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function Ds(t,n,e){this.low=t|0;this.high=n|0;this.unsigned=!!e}Object.defineProperty(Ds.prototype,"__isLong__",{value:true});function Ls(t){return(t&&t["__isLong__"])===true}Ds.isLong=Ls;var zs={};var Ps={};function Vs(t,n){var e,s,o;if(n){t>>>=0;if(o=0<=t&&t<256){s=Ps[t];if(s)return s}e=Ws(t,(t|0)<0?-1:0,true);if(o)Ps[t]=e;return e}else{t|=0;if(o=-128<=t&&t<128){s=zs[t];if(s)return s}e=Ws(t,t<0?-1:0,false);if(o)zs[t]=e;return e}}Ds.fromInt=Vs;function Bs(t,n){if(isNaN(t))return n?Qs:Zs;if(n){if(t<0)return Qs;if(t>=Ks)return oo}else{if(t<=-Js)return ro;if(t+1>=Js)return so}if(t<0)return Bs(-t,n).neg();return Ws(t%Xs|0,t/Xs|0,n)}Ds.fromNumber=Bs;function Ws(t,n,e){return new Ds(t,n,e)}Ds.fromBits=Ws;var Gs=Math.pow;function Us(t,n,e){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return Zs;if(typeof n==="number"){e=n,n=false}else{n=!!n}e=e||10;if(e<2||36<e)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");else if(s===0){return Us(t.substring(1),n,e).neg()}var o=Bs(Gs(e,8));var r=Zs;for(var i=0;i<t.length;i+=8){var c=Math.min(8,t.length-i),a=parseInt(t.substring(i,i+c),e);if(c<8){var u=Bs(Gs(e,c));r=r.mul(u).add(Bs(a))}else{r=r.mul(o);r=r.add(Bs(a))}}r.unsigned=n;return r}Ds.fromString=Us;function Hs(t,n){if(typeof t==="number")return Bs(t,n);if(typeof t==="string")return Us(t,n);return Ws(t.low,t.high,typeof n==="boolean"?n:t.unsigned)}Ds.fromValue=Hs;var js=1<<16;var qs=1<<24;var Xs=js*js;var Ks=Xs*Xs;var Js=Ks/2;var Ys=Vs(qs);var Zs=Vs(0);Ds.ZERO=Zs;var Qs=Vs(0,true);Ds.UZERO=Qs;var to=Vs(1);Ds.ONE=to;var no=Vs(1,true);Ds.UONE=no;var eo=Vs(-1);Ds.NEG_ONE=eo;var so=Ws(4294967295|0,2147483647|0,false);Ds.MAX_VALUE=so;var oo=Ws(4294967295|0,4294967295|0,true);Ds.MAX_UNSIGNED_VALUE=oo;var ro=Ws(0,2147483648|0,false);Ds.MIN_VALUE=ro;var io=Ds.prototype;io.toInt=function t(){return this.unsigned?this.low>>>0:this.low};io.toNumber=function t(){if(this.unsigned)return(this.high>>>0)*Xs+(this.low>>>0);return this.high*Xs+(this.low>>>0)};io.toString=function t(n){n=n||10;if(n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ro)){var e=Bs(n),s=this.div(e),o=s.mul(e).sub(this);return s.toString(n)+o.toInt().toString(n)}else return"-"+this.neg().toString(n)}var r=Bs(Gs(n,6),this.unsigned),i=this;var c="";while(true){var a=i.div(r),u=i.sub(a.mul(r)).toInt()>>>0,l=u.toString(n);i=a;if(i.isZero())return l+c;else{while(l.length<6)l="0"+l;c=""+l+c}}};io.getHighBits=function t(){return this.high};io.getHighBitsUnsigned=function t(){return this.high>>>0};io.getLowBits=function t(){return this.low};io.getLowBitsUnsigned=function t(){return this.low>>>0};io.getNumBitsAbs=function t(){if(this.isNegative())return this.eq(ro)?64:this.neg().getNumBitsAbs();var n=this.high!=0?this.high:this.low;for(var e=31;e>0;e--)if((n&1<<e)!=0)break;return this.high!=0?e+33:e+1};io.isZero=function t(){return this.high===0&&this.low===0};io.eqz=io.isZero;io.isNegative=function t(){return!this.unsigned&&this.high<0};io.isPositive=function t(){return this.unsigned||this.high>=0};io.isOdd=function t(){return(this.low&1)===1};io.isEven=function t(){return(this.low&1)===0};io.equals=function t(n){if(!Ls(n))n=Hs(n);if(this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1)return false;return this.high===n.high&&this.low===n.low};io.eq=io.equals;io.notEquals=function t(n){return!this.eq(n)};io.neq=io.notEquals;io.ne=io.notEquals;io.lessThan=function t(n){return this.comp(n)<0};io.lt=io.lessThan;io.lessThanOrEqual=function t(n){return this.comp(n)<=0};io.lte=io.lessThanOrEqual;io.le=io.lessThanOrEqual;io.greaterThan=function t(n){return this.comp(n)>0};io.gt=io.greaterThan;io.greaterThanOrEqual=function t(n){return this.comp(n)>=0};io.gte=io.greaterThanOrEqual;io.ge=io.greaterThanOrEqual;io.compare=function t(n){if(!Ls(n))n=Hs(n);if(this.eq(n))return 0;var e=this.isNegative(),s=n.isNegative();if(e&&!s)return-1;if(!e&&s)return 1;if(!this.unsigned)return this.sub(n).isNegative()?-1:1;return n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1};io.comp=io.compare;io.negate=function t(){if(!this.unsigned&&this.eq(ro))return ro;return this.not().add(to)};io.neg=io.negate;io.add=function t(n){if(!Ls(n))n=Hs(n);var e=this.high>>>16;var s=this.high&65535;var o=this.low>>>16;var r=this.low&65535;var i=n.high>>>16;var c=n.high&65535;var a=n.low>>>16;var u=n.low&65535;var l=0,f=0,h=0,d=0;d+=r+u;h+=d>>>16;d&=65535;h+=o+a;f+=h>>>16;h&=65535;f+=s+c;l+=f>>>16;f&=65535;l+=e+i;l&=65535;return Ws(h<<16|d,l<<16|f,this.unsigned)};io.subtract=function t(n){if(!Ls(n))n=Hs(n);return this.add(n.neg())};io.sub=io.subtract;io.multiply=function t(n){if(this.isZero())return Zs;if(!Ls(n))n=Hs(n);if(Ms){var e=Ms.mul(this.low,this.high,n.low,n.high);return Ws(e,Ms.get_high(),this.unsigned)}if(n.isZero())return Zs;if(this.eq(ro))return n.isOdd()?ro:Zs;if(n.eq(ro))return this.isOdd()?ro:Zs;if(this.isNegative()){if(n.isNegative())return this.neg().mul(n.neg());else return this.neg().mul(n).neg()}else if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(Ys)&&n.lt(Ys))return Bs(this.toNumber()*n.toNumber(),this.unsigned);var s=this.high>>>16;var o=this.high&65535;var r=this.low>>>16;var i=this.low&65535;var c=n.high>>>16;var a=n.high&65535;var u=n.low>>>16;var l=n.low&65535;var f=0,h=0,d=0,p=0;p+=i*l;d+=p>>>16;p&=65535;d+=r*l;h+=d>>>16;d&=65535;d+=i*u;h+=d>>>16;d&=65535;h+=o*l;f+=h>>>16;h&=65535;h+=r*u;f+=h>>>16;h&=65535;h+=i*a;f+=h>>>16;h&=65535;f+=s*l+o*u+r*a+i*c;f&=65535;return Ws(d<<16|p,f<<16|h,this.unsigned)};io.mul=io.multiply;io.divide=function t(n){if(!Ls(n))n=Hs(n);if(n.isZero())throw Error("division by zero");if(Ms){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1){return this}var e=(this.unsigned?Ms.div_u:Ms.div_s)(this.low,this.high,n.low,n.high);return Ws(e,Ms.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Qs:Zs;var s,o,r;if(!this.unsigned){if(this.eq(ro)){if(n.eq(to)||n.eq(eo))return ro;else if(n.eq(ro))return to;else{var i=this.shr(1);s=i.div(n).shl(1);if(s.eq(Zs)){return n.isNegative()?to:eo}else{o=this.sub(n.mul(s));r=s.add(o.div(n));return r}}}else if(n.eq(ro))return this.unsigned?Qs:Zs;if(this.isNegative()){if(n.isNegative())return this.neg().div(n.neg());return this.neg().div(n).neg()}else if(n.isNegative())return this.div(n.neg()).neg();r=Zs}else{if(!n.unsigned)n=n.toUnsigned();if(n.gt(this))return Qs;if(n.gt(this.shru(1)))return no;r=Qs}o=this;while(o.gte(n)){s=Math.max(1,Math.floor(o.toNumber()/n.toNumber()));var c=Math.ceil(Math.log(s)/Math.LN2),a=c<=48?1:Gs(2,c-48),u=Bs(s),l=u.mul(n);while(l.isNegative()||l.gt(o)){s-=a;u=Bs(s,this.unsigned);l=u.mul(n)}if(u.isZero())u=to;r=r.add(u);o=o.sub(l)}return r};io.div=io.divide;io.modulo=function t(n){if(!Ls(n))n=Hs(n);if(Ms){var e=(this.unsigned?Ms.rem_u:Ms.rem_s)(this.low,this.high,n.low,n.high);return Ws(e,Ms.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};io.mod=io.modulo;io.rem=io.modulo;io.not=function t(){return Ws(~this.low,~this.high,this.unsigned)};io.and=function t(n){if(!Ls(n))n=Hs(n);return Ws(this.low&n.low,this.high&n.high,this.unsigned)};io.or=function t(n){if(!Ls(n))n=Hs(n);return Ws(this.low|n.low,this.high|n.high,this.unsigned)};io.xor=function t(n){if(!Ls(n))n=Hs(n);return Ws(this.low^n.low,this.high^n.high,this.unsigned)};io.shiftLeft=function t(n){if(Ls(n))n=n.toInt();if((n&=63)===0)return this;else if(n<32)return Ws(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned);else return Ws(0,this.low<<n-32,this.unsigned)};io.shl=io.shiftLeft;io.shiftRight=function t(n){if(Ls(n))n=n.toInt();if((n&=63)===0)return this;else if(n<32)return Ws(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned);else return Ws(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};io.shr=io.shiftRight;io.shiftRightUnsigned=function t(n){if(Ls(n))n=n.toInt();n&=63;if(n===0)return this;else{var e=this.high;if(n<32){var s=this.low;return Ws(s>>>n|e<<32-n,e>>>n,this.unsigned)}else if(n===32)return Ws(e,0,this.unsigned);else return Ws(e>>>n-32,0,this.unsigned)}};io.shru=io.shiftRightUnsigned;io.shr_u=io.shiftRightUnsigned;io.toSigned=function t(){if(!this.unsigned)return this;return Ws(this.low,this.high,false)};io.toUnsigned=function t(){if(this.unsigned)return this;return Ws(this.low,this.high,true)};io.toBytes=function t(n){return n?this.toBytesLE():this.toBytesBE()};io.toBytesLE=function t(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};io.toBytesBE=function t(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Ds.fromBytes=function t(n,e,s){return s?Ds.fromBytesLE(n,e):Ds.fromBytesBE(n,e)};Ds.fromBytesLE=function t(n,e){return new Ds(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,e)};Ds.fromBytesBE=function t(n,e){return new Ds(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],e)};const co=Object.freeze(Object.assign(Object.create(null),_s,{default:_s}));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao=_s||co;function uo(t){return ao.fromString(t,true,16)}const lo=uo("c3a5c85c97cb3127");const fo=uo("b492b66fbe98f273");const ho=uo("9ae16a3b2f90404f");function po(t){return t.xor(t.shru(47))}function mo(t,n,e){const s=t.slice(n,n+e);return ao.fromBytes(Array.from(s),true,true)}function xo(t,n){return mo(t,n,8)}function bo(t,n){return mo(t,n,4)}function go(t,n){return n===0?t:t.shru(n).or(t.shl(64-n))}function wo(t,n,e=uo("9ddfea08eb382d69")){let s=t.xor(n).mul(e);s=s.xor(s.shru(47));let o=n.xor(s).mul(e);o=o.xor(o.shru(47));o=o.mul(e);return o}function vo(t,n,e,s,o,r){o=o.add(t);r=go(r.add(o).add(s),21);const i=o;o=o.add(n);o=o.add(e);r=r.add(go(o,44));return[o.add(s),r.add(i)]}function $o(t,n,e,s){return vo(xo(t,n),xo(t,n+8),xo(t,n+16),xo(t,n+24),e,s)}function yo(t,n=t.length){if(n>=8){const e=ho.add(n*2);const s=xo(t,0).add(ho);const o=xo(t,n-8);const r=go(o,37).mul(e).add(s);const i=go(s,25).add(o).mul(e);return wo(r,i,e)}if(n>=4){const e=ho.add(n*2);const s=bo(t,0);return wo(s.shl(3).add(n),bo(t,n-4),e)}if(n>0){const e=t[0];const s=t[n>>1];const o=t[n-1];const r=e+(s<<8);const i=n+(o<<2);return po(ho.mul(r).xor(lo.mul(i))).mul(ho)}return ho}function ko(t,n=t.length){const e=ho.add(n*2);const s=xo(t,0).mul(fo);const o=xo(t,8);const r=xo(t,n-8).mul(e);const i=xo(t,n-16).mul(ho);return wo(go(s.add(o),43).add(go(r,30)).add(i),s.add(go(o.add(ho),18)).add(r),e)}function Co(t,n=t.length){const e=ho.add(n*2);const s=xo(t,0).mul(ho);const o=xo(t,8);const r=xo(t,n-8).mul(e);const i=xo(t,n-16).mul(ho);const c=go(s.add(o),43).add(go(r,30)).add(i);const a=wo(c,s.add(go(o.add(ho),18)).add(r),e);const u=xo(t,16).mul(e);const l=xo(t,24);const f=c.add(xo(t,n-32)).mul(e);const h=a.add(xo(t,n-24)).mul(e);return wo(go(u.add(l),43).add(go(f,30)).add(h),u.add(go(l.add(s),18)).add(f),e)}function No(t,n=t.length){const e=ao.fromNumber(81,true);if(n<=32){if(n<=16){return yo(t,n)}else{return ko(t,n)}}else if(n<=64){return Co(t,n)}let s=e;let o=e.mul(fo).add(113);let r=po(o.mul(ho).add(113)).mul(ho);let i=[ao.UZERO,ao.UZERO];let c=[ao.UZERO,ao.UZERO];s=s.mul(ho).add(xo(t,0));let a=0;const u=(n-1>>6)*64;const l=u+(n-1&63)-63;do{s=go(s.add(o).add(i[0]).add(xo(t,a+8)),37).mul(fo);o=go(o.add(i[1]).add(xo(t,a+48)),42).mul(fo);s=s.xor(c[1]);o=o.add(i[0]).add(xo(t,a+40));r=go(r.add(c[0]),33).mul(fo);i=$o(t,a,i[1].mul(fo),s.add(c[0]));c=$o(t,a+32,r.add(c[1]),o.add(xo(t,a+16)));[r,s]=[s,r];a+=64}while(a!==u);const f=fo.add(r.and(255).shl(1));a=l;c[0]=c[0].add(n-1&63);i[0]=i[0].add(c[0]);c[0]=c[0].add(i[0]);s=go(s.add(o).add(i[0]).add(xo(t,a+8)),37).mul(f);o=go(o.add(i[1]).add(xo(t,a+48)),42).mul(f);s=s.xor(c[1].mul(9));o=o.add(i[0].mul(9).add(xo(t,a+40)));r=go(r.add(c[0]),33).mul(f);i=$o(t,a,i[1].mul(f),s.add(c[0]));c=$o(t,a+32,r.add(c[1]),o.add(xo(t,a+16)));[r,s]=[s,r];return wo(wo(i[0],c[0],f).add(po(o).mul(lo)).add(r),wo(i[1],c[1],f).add(s),f)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ro(t,n){if(n==="string"){return Io(t)}return Eo([t],n)}function So(t,n){return t instanceof Float32Array&&n==="float32"||t instanceof Int32Array&&n==="int32"||t instanceof Uint8Array&&n==="bool"}function Eo(t,n){if(n==="string"){throw new Error("Cannot convert a string[] to a TypedArray")}if(Array.isArray(t)){t=Fo(t)}if(et().getBool("DEBUG")){T(t,n)}if(So(t,n)){return t}if(n==null||n==="float32"||n==="complex64"){return new Float32Array(t)}else if(n==="int32"){return new Int32Array(t)}else if(n==="bool"){const n=new Uint8Array(t.length);for(let e=0;e<n.length;++e){if(Math.round(t[e])!==0){n[e]=1}}return n}else{throw new Error(`Unknown data type ${n}`)}}function To(){return et().platform.now()}function Io(t,n="utf-8"){n=n||"utf-8";return et().platform.encode(t,n)}function Ao(t,n="utf-8"){n=n||"utf-8";return et().platform.decode(t,n)}function Oo(t){if(et().platform.isTypedArray!=null){return et().platform.isTypedArray(t)}else{return Fs(t)}}function Fo(t,n=[],e=false){if(n==null){n=[]}if(typeof t==="boolean"||typeof t==="number"||typeof t==="string"||J(t)||t==null||Oo(t)&&e){n.push(t)}else if(Array.isArray(t)||Oo(t)){for(let s=0;s<t.length;++s){Fo(t[s],n,e)}}else{let s=-1;for(const n of Object.keys(t)){if(/^([1-9]+[0-9]*|0)$/.test(n)){s=Math.max(s,Number(n))}}for(let o=0;o<=s;o++){Fo(t[o],n,e)}}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _o{constructor(t,n){this.backendTimer=t;this.logger=n;if(n==null){this.logger=new Do}}profileKernel(t,n,e){let s;const o=()=>{s=e()};let r;const i=To();if(this.backendTimer.timerAvailable()){r=this.backendTimer.time(o)}else{o();for(const t of s){t.dataSync()}r=Promise.resolve({kernelMs:To()-i})}if(et().getBool("CHECK_COMPUTATION_FOR_ERRORS")){for(let n=0;n<s.length;n++){const e=s[n];e.data().then((n=>{Mo(n,e.dtype,t)}))}}const c={kernelName:t,outputs:s,inputs:n,timeMs:r.then((t=>t.kernelMs)),extraInfo:r.then((t=>t.getExtraProfileInfo!=null?t.getExtraProfileInfo():""))};return c}logKernelProfile(t){const{kernelName:n,outputs:e,timeMs:s,inputs:o,extraInfo:r}=t;e.forEach((t=>{Promise.all([t.data(),s,r]).then((e=>{this.logger.logKernelProfile(n,t,e[0],e[1],o,e[2])}))}))}}function Mo(t,n,e){if(n!=="float32"){return false}for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s)){console.warn(`Found ${s} in the result of '${e}'`);return true}}return false}class Do{logKernelProfile(t,n,e,s,o,r){const i=typeof s==="number"?y(`${s}ms`,9):s["error"];const c=y(t,25);const a=n.rank;const u=n.size;const l=y(n.shape.toString(),14);let f="";for(const t in o){const e=o[t];if(e!=null){const s=e.shape||n.shape;const o=s.length;f+=`${t}: ${o}D ${o>0?s:""} `}}console.log(`%c${c}\t%c${i}\t%c${a}D ${l}\t%c${u}\t%c${f}\t%c${r}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lo(t,n,e){const s={};const o={};for(let t=0;t<n.length;t++){s[n[t].id]=true}for(let e=0;e<t.length;e++){const r=t[e];const i=r.inputs;for(const t in i){const e=i[t];let c=false;for(let t=0;t<n.length;t++){if(s[e.id]){r.outputs.forEach((t=>s[t.id]=true));c=true;o[r.id]=true;break}}if(c){break}}}const r={};r[e.id]=true;const i={};for(let n=t.length-1;n>=0;n--){const e=t[n];const s=e.inputs;for(let t=0;t<e.outputs.length;t++){if(r[e.outputs[t].id]){for(const t in s){r[s[t].id]=true;i[e.id]=true}break}}}const c=[];for(let n=0;n<t.length;n++){const e=t[n];if(o[e.id]&&i[e.id]){const t={};for(const n in e.inputs){const o=e.inputs[n];if(s[o.id]){t[n]=o}}const n=Object.assign({},e);n.inputs=t;n.outputs=e.outputs;c.push(n)}}return c}function zo(t,n,e,s){for(let o=n.length-1;o>=0;o--){const r=n[o];const i=[];r.outputs.forEach((n=>{const e=t[n.id];if(e!=null){i.push(e)}else{i.push(null)}}));if(r.gradient==null){throw new Error(`Cannot compute gradient: gradient function not found `+`for ${r.kernelName}.`)}const c=r.gradient(i);for(const n in r.inputs){if(!(n in c)){throw new Error(`Cannot backprop through input ${n}. `+`Available gradients found: ${Object.keys(c)}.`)}const o=e((()=>c[n]()));if(o.dtype!=="float32"){throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input `+`${n} must have 'float32' dtype, but has '${o.dtype}'`)}const i=r.inputs[n];if(!w(o.shape,i.shape)){throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input `+`'${n}' has shape '${o.shape}', which does not match `+`the shape of the input '${i.shape}'`)}if(t[i.id]==null){t[i.id]=o}else{const n=t[i.id];t[i.id]=s(n,o);n.dispose()}}}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po=20;const Vo=3;const Bo=7;function Wo(t,n,e,s){const o=V(n);const r=Go(t,n,e,o);const i=n.length;const c=jo(t,n,e,o,r);const a=["Tensor"];if(s){a.push(`  dtype: ${e}`);a.push(`  rank: ${i}`);a.push(`  shape: [${n}]`);a.push(`  values:`)}a.push(c.map((t=>"    "+t)).join("\n"));return a.join("\n")}function Go(t,n,e,s){const o=g(n);const r=s[s.length-1];const i=new Array(r).fill(0);const c=n.length;const a=e==="complex64"?qo(t):t;if(c>1){for(let t=0;t<o/r;t++){const n=t*r;for(let t=0;t<r;t++){i[t]=Math.max(i[t],Uo(a[n+t],0,e).length)}}}return i}function Uo(t,n,e){let s;if(Array.isArray(t)){s=`${parseFloat(t[0].toFixed(Bo))} + `+`${parseFloat(t[1].toFixed(Bo))}j`}else if(_(t)){s=`'${t}'`}else if(e==="bool"){s=Ho(t)}else{s=parseFloat(t.toFixed(Bo)).toString()}return y(s,n)}function Ho(t){return t===0?"false":"true"}function jo(t,n,e,s,o,r=true){const i=e==="complex64"?2:1;const c=n[0];const a=n.length;if(a===0){if(e==="complex64"){const n=qo(t);return[Uo(n[0],0,e)]}if(e==="bool"){return[Ho(t[0])]}return[t[0].toString()]}if(a===1){if(c>Po){const n=Vo*i;let s=Array.from(t.slice(0,n));let r=Array.from(t.slice((c-Vo)*i,c*i));if(e==="complex64"){s=qo(s);r=qo(r)}return["["+s.map(((t,n)=>Uo(t,o[n],e))).join(", ")+", ..., "+r.map(((t,n)=>Uo(t,o[c-Vo+n],e))).join(", ")+"]"]}const n=e==="complex64"?qo(t):Array.from(t);return["["+n.map(((t,n)=>Uo(t,o[n],e))).join(", ")+"]"]}const u=n.slice(1);const l=s.slice(1);const f=s[0]*i;const h=[];if(c>Po){for(let n=0;n<Vo;n++){const s=n*f;const r=s+f;h.push(...jo(t.slice(s,r),u,e,l,o,false))}h.push("...");for(let n=c-Vo;n<c;n++){const s=n*f;const r=s+f;h.push(...jo(t.slice(s,r),u,e,l,o,n===c-1))}}else{for(let n=0;n<c;n++){const s=n*f;const r=s+f;h.push(...jo(t.slice(s,r),u,e,l,o,n===c-1))}}const d=a===2?",":"";h[0]="["+(c>0?h[0]+d:"");for(let t=1;t<h.length-1;t++){h[t]=" "+h[t]+d}let p=",\n";for(let t=2;t<a;t++){p+="\n"}h[h.length-1]=" "+h[h.length-1]+"]"+(r?"":p);return h}function qo(t){const n=[];for(let e=0;e<t.length;e+=2){n.push([t[e],t[e+1]])}return n}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xo{constructor(t,n,e){this.dtype=n;this.shape=t.slice();this.size=g(t);if(e!=null){const t=e.length;m(t===this.size,(()=>`Length of values '${t}' does not match the size `+`inferred by the shape '${this.size}'.`))}if(n==="complex64"){throw new Error(`complex64 dtype TensorBuffers are not supported. Please create `+`a TensorBuffer for the real and imaginary parts separately and `+`call tf.complex(real, imag).`)}this.values=e||E(n,this.size);this.strides=V(t)}set(t,...n){if(n.length===0){n=[0]}m(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must `+`match the rank (${this.rank})`));const e=this.locToIndex(n);this.values[e]=t}get(...t){if(t.length===0){t=[0]}let n=0;for(const e of t){if(e<0||e>=this.shape[n]){const n=`Requested out of range element at ${t}. `+`  Buffer shape=${this.shape}`;throw new Error(n)}n++}let e=t[t.length-1];for(let n=0;n<t.length-1;++n){e+=this.strides[n]*t[n]}return this.values[e]}locToIndex(t){if(this.rank===0){return 0}else if(this.rank===1){return t[0]}let n=t[t.length-1];for(let e=0;e<t.length-1;++e){n+=this.strides[e]*t[e]}return n}indexToLoc(t){if(this.rank===0){return[]}else if(this.rank===1){return[t]}const n=new Array(this.shape.length);for(let e=0;e<n.length-1;++e){n[e]=Math.floor(t/this.strides[e]);t-=n[e]*this.strides[e]}n[n.length-1]=t;return n}get rank(){return this.shape.length}toTensor(){return Ko().makeTensor(this.values,this.shape,this.dtype)}}let Ko=null;let Jo=null;function Yo(t){Ko=t}function Zo(t){Jo=t}class Qo{constructor(t,n,e,s){this.kept=false;this.isDisposedInternal=false;this.shape=t.slice();this.dtype=n||"float32";this.size=g(t);this.strides=V(t);this.dataId=e;this.id=s;this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Jo.buffer(this.shape,this.dtype,t)}bufferSync(){return Jo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return W(this.shape,t,this.dtype==="complex64")}arraySync(){return W(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Ko().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map((t=>Ao(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){this.throwIfDisposed();return Ko().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ko().readSync(this.dataId);if(this.dtype==="string"){try{return t.map((t=>Ao(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return t}async bytes(){this.throwIfDisposed();const t=await Ko().read(this.dataId);if(this.dtype==="string"){return t}else{return new Uint8Array(t.buffer)}}dispose(){if(this.isDisposed){return}if(this.kerasMask){this.kerasMask.dispose()}Ko().disposeTensor(this);this.isDisposedInternal=true}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed){throw new Error(`Tensor is disposed.`)}}print(t=false){return Jo.print(this,t)}clone(){this.throwIfDisposed();return Jo.clone(this)}toString(t=false){const n=this.dataSync();return Wo(n,this.shape,this.dtype,t)}cast(t){this.throwIfDisposed();return Jo.cast(this,t)}variable(t=true,n,e){this.throwIfDisposed();return Ko().makeVariable(this,t,n,e)}}Object.defineProperty(Qo,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function tr(){return at("Tensor",(()=>Qo))}tr();class nr extends Qo{constructor(t,n,e,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=n;this.name=e}assign(t){if(t.dtype!==this.dtype){throw new Error(`dtype of the new value (${t.dtype}) and `+`previous value (${this.dtype}) must match`)}if(!w(t.shape,this.shape)){throw new Error(`shape of the new value (${t.shape}) and `+`previous value (${this.shape}) must match`)}Ko().disposeTensor(this);this.dataId=t.dataId;Ko().incRef(this,null)}dispose(){Ko().disposeVariable(this);this.isDisposedInternal=true}}Object.defineProperty(nr,Symbol.hasInstance,{value:t=>t instanceof Qo&&t.assign!=null&&t.assign instanceof Function});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var er;(function(t){t["R0"]="R0";t["R1"]="R1";t["R2"]="R2";t["R3"]="R3";t["R4"]="R4";t["R5"]="R5";t["R6"]="R6"})(er||(er={}));var sr;(function(t){t["float32"]="float32";t["int32"]="int32";t["bool"]="int32";t["complex64"]="complex64"})(sr||(sr={}));var or;(function(t){t["float32"]="float32";t["int32"]="int32";t["bool"]="bool";t["complex64"]="complex64"})(or||(or={}));var rr;(function(t){t["float32"]="float32";t["int32"]="float32";t["bool"]="float32";t["complex64"]="complex64"})(rr||(rr={}));var ir;(function(t){t["float32"]="complex64";t["int32"]="complex64";t["bool"]="complex64";t["complex64"]="complex64"})(ir||(ir={}));const cr={float32:rr,int32:sr,bool:or,complex64:ir};function ar(t,n){if(t==="string"||n==="string"){if(t==="string"&&n==="string"){return"string"}throw new Error(`Can not upcast ${t} with ${n}`)}return cr[t][n]}function ur(t){return ar(t,"int32")}function lr(t){return t!=null&&typeof t==="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function fr(t){return typeof GPUBuffer!=="undefined"&&t!=null&&typeof t==="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(t,n){if(t.dtype===n.dtype){return[t,n]}const e=ar(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function dr(t){const n=[];const e=new Set;pr(t,n,e);return n}function pr(t,n,e){if(t==null){return}if(t instanceof Qo){n.push(t);return}if(!mr(t)){return}const s=t;for(const t in s){const o=s[t];if(!e.has(o)){e.add(o);pr(o,n,e)}}}function mr(t){return Array.isArray(t)||typeof t==="object"}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(t){return t.kernelName!=null}class br{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=false;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables){this.registeredVariables[t].dispose()}}}class gr{constructor(t){this.ENV=t;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new br}async ready(){if(this.pendingBackendInit!=null){return this.pendingBackendInit.then((()=>{}))}if(this.backendInstance!=null){return}const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n];const s=await this.initializeBackend(e).success;if(s){await this.setBackend(e);return}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}get backend(){if(this.pendingBackendInit!=null){throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make `+`sure to await tf.ready() or await tf.setBackend() before calling `+`other methods`)}if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n){throw new Error(`The highest priority backend '${t}' has not yet been `+`initialized. Make sure to await tf.ready() or `+`await tf.setBackend() before calling other methods`)}this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n){return null}}else{return null}}return this.registry[t]}findBackendFactory(t){if(!(t in this.registryFactory)){return null}return this.registryFactory[t].factory}registerBackend(t,n,e=1){if(t in this.registryFactory){ks(`${t} backend was already registered. `+`Reusing existing backend factory.`);return false}this.registryFactory[t]={factory:n,priority:e};return true}async setBackend(t){if(this.registryFactory[t]==null){throw new Error(`Backend name '${t}' not found in registry`)}this.backendName=t;if(this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:e}=this.initializeBackend(t);const s=e?await n:n;if(!s){return false}}this.backendInstance=this.registry[t];this.setupRegisteredKernels();this.profiler=new _o(this.backendInstance);return true}setupRegisteredKernels(){const t=Ts(this.backendName);t.forEach((t=>{if(t.setupFunc!=null){t.setupFunc(this.backendInstance)}}))}disposeRegisteredKernels(t){const n=Ts(t);n.forEach((n=>{if(n.disposeFunc!=null){n.disposeFunc(this.registry[t])}}))}initializeBackend(t){const n=this.registryFactory[t];if(n==null){throw new Error(`Cannot initialize backend ${t}, no registration found.`)}try{const e=n.factory();if(e&&!(e instanceof a)&&typeof e.then==="function"){const n=++this.pendingBackendInitId;const s=e.then((e=>{if(n<this.pendingBackendInitId){return false}this.registry[t]=e;this.pendingBackendInit=null;return true})).catch((e=>{if(n<this.pendingBackendInitId){return false}this.pendingBackendInit=null;ks(`Initialization of backend ${t} failed`);ks(e.stack||e.message);return false}));this.pendingBackendInit=s;return{success:s,asyncInit:true}}else{this.registry[t]=e;return{success:true,asyncInit:false}}}catch(n){ks(`Initialization of backend ${t} failed`);ks(n.stack||n.message);return{success:false,asyncInit:false}}}removeBackend(t){if(!(t in this.registryFactory)){throw new Error(`${t} backend not found in registry`)}if(this.backendName===t&&this.pendingBackendInit!=null){this.pendingBackendInitId++}if(t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}delete this.registryFactory[t];if(this.backendName===t){this.pendingBackendInit=null;this.backendName=null;this.backendInstance=null}}getSortedBackends(){if(Object.keys(this.registryFactory).length===0){throw new Error("No backend found in registry.")}return Object.keys(this.registryFactory).sort(((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const e=t[n];const{success:s,asyncInit:o}=this.initializeBackend(e);if(o||s){return{name:e,asyncInit:o}}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}moveData(t,n){const e=this.state.tensorInfo.get(n);const s=e.backend;const o=this.readSync(n);const r=s.refCount(n);s.disposeData(n,true);e.backend=t;t.move(n,o,e.shape,e.dtype,r);if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}}tidy(t,n){let e=null;if(n==null){if(typeof t!=="function"){throw new Error("Please provide a function to tidy()")}n=t}else{if(typeof t!=="string"&&!(t instanceof String)){throw new Error("When calling with two arguments, the first argument "+"to tidy() must be a string")}if(typeof n!=="function"){throw new Error("When calling with two arguments, the 2nd argument "+"to tidy() must be a function")}e=t}let s;return this.scopedRun((()=>this.startScope(e)),(()=>this.endScope(s)),(()=>{s=n();if(s instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}return s}))}scopedRun(t,n,e){t();try{const t=e();n();return t}catch(t){n();throw t}}nextTensorId(){return gr.nextTensorId++}nextVariableId(){return gr.nextVariableId++}clone(t){const n=$r.runKernel(Rn,{x:t});const e={x:t};const s=t=>({x:()=>{const n="float32";const e={x:t};const s={dtype:n};return $r.runKernel(Ft,e,s)}});const o=[];this.addTapeNode(this.state.activeScope.name,e,[n],s,o,{});return n}runKernel(t,n,e){const s=Ss(t,this.backendName)!=null;if(!s){throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`)}return this.runKernelFunc({kernelName:t,inputs:n,attrs:e})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,e){const s=this.backend.numDataIds();let o=0;e.forEach((t=>{o+=t.dtype==="complex64"?3:1}));const r=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];const i=s-n-o-r;if(i>0){throw new Error(`Backend '${this.backendName}' has an internal memory leak `+`(${i} data ids) after running '${t}'`)}}runKernelFunc(t){let n;let e=[];const s=this.isTapeOn();const o=this.state.numBytes;const r=this.state.numTensors;if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack.push(0)}let i;let c;const a=xr(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(xr(t)){const{kernelName:n,inputs:o,attrs:r}=t;const a=Ss(n,this.backendName);m(a!=null,(()=>`Cannot find registered kernel '${n}' for backend '${this.backendName}'`));i=()=>{const t=this.backend.numDataIds();c=a.kernelFunc({inputs:o,attrs:r,backend:this.backend});const i=Array.isArray(c)?c:[c];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(n,t,i)}const u=i.map((t=>{if(t.rank!=null){return t}return this.makeTensorFromTensorInfo(t)}));if(s){const t=this.getTensorsForGradient(n,o,u);e=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:n}=t;const o=t=>{if(!s){return}e=t.map((t=>this.keep(this.clone(t))))};i=()=>{const t=this.backend.numDataIds();c=this.tidy((()=>n(this.backend,o)));const e=Array.isArray(c)?c:[c];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(a,t,e)}return e}}const{inputs:u,attrs:l}=t;const f=xr(t)?null:t.backwardsFunc;let h;this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{if(!this.ENV.getBool("DEBUG")&&!this.state.profiling){n=i()}else{h=this.profiler.profileKernel(a,u,(()=>i()));if(this.ENV.getBool("DEBUG")){this.profiler.logKernelProfile(h)}n=h.outputs}}));if(s){this.addTapeNode(a,u,n,f,e,l)}if(this.state.profiling){this.state.activeProfile.kernels.push({name:a,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-r,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>u[t]!=null?u[t].shape:null)),outputShapes:n.map((t=>t.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo})}return Array.isArray(c)?n:n[0]}saveTensorsForBackwardMode(t){const n=t.map((t=>this.keep(this.clone(t))));return n}getTensorsForGradient(t,n,e){const s=Es(t);if(s!=null){const t=s.inputsToSave||[];const o=s.outputsToSave||[];let r;if(s.saveAllInputs){m(Array.isArray(n),(()=>"saveAllInputs is true, expected inputs to be an array."));r=Object.keys(n).map((t=>n[t]))}else{r=t.map((t=>n[t]))}const i=e.filter(((t,n)=>o[n]));return r.concat(i)}return[]}makeTensor(t,n,e,s){if(t==null){throw new Error("Values passed to engine.makeTensor() are null")}e=e||"float32";s=s||this.backend;let o=t;if(e==="string"&&_(t[0])){o=t.map((t=>Io(t)))}const r=s.write(o,n,e);const i=new Qo(n,e,r,this.nextTensorId());this.trackTensor(i,s);if(e==="string"){const t=this.state.tensorInfo.get(r);const n=F(o);this.state.numBytes+=n-t.bytes;t.bytes=n}return i}makeTensorFromDataId(t,n,e,s){e=e||"float32";const o={dataId:t,shape:n,dtype:e};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(t,n){const{dataId:e,shape:s,dtype:o}=t;const r=new Qo(s,o,e,this.nextTensorId());this.trackTensor(r,n);return r}makeVariable(t,n=true,e,s){e=e||this.nextVariableId().toString();if(s!=null&&s!==t.dtype){t=t.cast(s)}const o=new nr(t,n,e,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null){throw new Error(`Variable with name ${o.name} was already registered`)}this.state.registeredVariables[o.name]=o;this.incRef(o,this.backend);return o}trackTensor(t,n){this.state.numTensors++;if(t.dtype==="string"){this.state.numStringTensors++}let e=0;if(t.dtype!=="complex64"&&t.dtype!=="string"){e=t.size*O(t.dtype)}this.state.numBytes+=e;if(!this.state.tensorInfo.has(t.dataId)){this.state.numDataBuffers++;this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:e})}if(!(t instanceof nr)){this.track(t)}}incRef(t,n){this.trackTensor(t,n);this.backend.incRef(t.dataId)}removeDataId(t,n){if(this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n){this.state.tensorInfo.delete(t);this.state.numDataBuffers--}}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId)){return}const n=this.state.tensorInfo.get(t.dataId);this.state.numTensors--;if(t.dtype==="string"){this.state.numStringTensors--;this.state.numBytes-=n.bytes}if(t.dtype!=="complex64"&&t.dtype!=="string"){const n=t.size*O(t.dtype);this.state.numBytes-=n}if(n.backend.disposeData(t.dataId)){this.removeDataId(t.dataId,n.backend)}}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t);if(this.state.registeredVariables[t.name]!=null){delete this.state.registeredVariables[t.name]}}memory(){const t=this.backend.memory();t.numTensors=this.state.numTensors;t.numDataBuffers=this.state.numDataBuffers;t.numBytes=this.state.numBytes;if(this.state.numStringTensors>0){t.unreliable=true;if(t.reasons==null){t.reasons=[]}t.reasons.push("Memory usage by string tensors is approximate "+"(2 bytes per character)")}return t}async profile(t){this.state.profiling=true;const n=this.state.numBytes;const e=this.state.numTensors;this.state.activeProfile.kernels=[];this.state.activeProfile.result=await t();this.state.profiling=false;this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot)));this.state.activeProfile.newBytes=this.state.numBytes-n;this.state.activeProfile.newTensors=this.state.numTensors-e;for(const t of this.state.activeProfile.kernels){t.kernelTimeMs=await t.kernelTimeMs;t.extraInfo=await t.extraInfo}return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,e,s,o,r){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:e,saved:o};const c=Es(t);if(c!=null){s=c.gradFunc}if(s!=null){i.gradient=t=>{t=t.map(((t,n)=>{if(t==null){const t=e[n];const s=H(t.size,t.dtype);return this.makeTensor(s,t.shape,t.dtype)}return t}));return s(t.length>1?t:t[0],o,r)}}this.state.activeTape.push(i)}keep(t){t.kept=true;return t}startTape(){if(this.state.gradientDepth===0){this.state.activeTape=[]}this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};if(t){n.name=t}this.state.scopeStack.push(n);this.state.activeScope=n}endScope(t){const n=dr(t);const e=new Set(n.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const n=this.state.activeScope.track[t];if(!n.kept&&!e.has(n.id)){n.dispose()}}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1];n.forEach((t=>{if(!t.kept&&t.scopeId===s.id){this.track(t)}}))}gradients(t,n,e,s=false){m(n.length>0,(()=>"gradients() received an empty list of xs."));if(e!=null&&e.dtype!=="float32"){throw new Error(`dy must have 'float32' dtype, but has '${e.dtype}'`)}const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));m(o instanceof Qo,(()=>"The result y returned by f() must be a tensor."));const r=Lo(this.state.activeTape,n,o);if(!s&&r.length===0&&n.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure "+"that the f you passed encloses all operations that lead from x "+"to y.")}return this.tidy("backward",(()=>{const t={};t[o.id]=e==null?wr(o.shape):e;zo(t,r,(t=>this.tidy(t)),yr);const s=n.map((n=>t[n.id]));if(this.state.gradientDepth===0){this.state.activeTape.forEach((t=>{for(const n of t.saved){n.dispose()}}));this.state.activeTape=null}return{value:o,grads:s}}))}customGrad(t){m(z(t),(()=>"The f passed in customGrad(f) must be a function."));return(...n)=>{m(n.every((t=>t instanceof Qo)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be "+"tensors"));let e;const s={};n.forEach(((t,n)=>{s[n]=t}));const o=(s,o)=>{e=t(...[...n,o]);m(e.value instanceof Qo,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.value` is a tensor"));m(z(e.gradFunc),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function."));return e.value};const r=(t,s)=>{const o=e.gradFunc(t,s);const r=Array.isArray(o)?o:[o];m(r.length===n.length,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"the same number of tensors as inputs passed to f(...)."));m(r.every((t=>t instanceof Qo)),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"a list of only tensors."));const i={};r.forEach(((t,n)=>{i[n]=()=>t}));return i};return this.runKernelFunc({forwardFunc:o,backwardsFunc:r,inputs:s})}}readSync(t){const n=this.state.tensorInfo.get(t);return n.backend.readSync(t)}read(t){const n=this.state.tensorInfo.get(t);return n.backend.read(t)}readToGPU(t,n){const e=this.state.tensorInfo.get(t);return e.backend.readToGPU(t,n)}async time(t){const n=To();const e=await this.backend.time(t);e.wallMs=To()-n;return e}track(t){if(this.state.activeScope!=null){t.scopeId=this.state.activeScope.id;this.state.activeScope.track.push(t)}return t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++;this.state.dispose();this.ENV.reset();this.state=new br;for(const t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}this.backendName=null;this.backendInstance=null;this.pendingBackendInit=null}}gr.nextTensorId=0;gr.nextVariableId=0;function wr(t){const n=U(g(t),"float32");return $r.makeTensor(n,t,"float32")}function vr(){const t=it();if(t._tfengine==null){const n=new Z(t);t._tfengine=new gr(n)}ot(t._tfengine.ENV);Yo((()=>t._tfengine));return t._tfengine}const $r=vr();function yr(t,n){const e={a:t,b:n};return $r.runKernel(ht,e)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kr(){return typeof navigator!=="undefined"&&navigator!=null}function Cr(t){if(t||kr()){if(!t){t=navigator}if(t.product==="ReactNative"){return true}const n=t.userAgent||t.vendor||(typeof window!=="undefined"?window.opera:"");if(!n){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return false}function Nr(){return typeof window!=="undefined"&&window.document!=null||typeof WorkerGlobalScope!=="undefined"}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr=et();Rr.registerFlag("DEBUG",(()=>false),(t=>{if(t){console.warn("Debugging mode is ON. The output of every math call will "+"be downloaded to CPU and checked for NaNs. "+"This significantly impacts performance.")}}));Rr.registerFlag("IS_BROWSER",(()=>Nr()));Rr.registerFlag("IS_NODE",(()=>typeof process!=="undefined"&&typeof process.versions!=="undefined"&&typeof process.versions.node!=="undefined"));Rr.registerFlag("IS_CHROME",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)));Rr.registerFlag("IS_SAFARI",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)));Rr.registerFlag("PROD",(()=>false));Rr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Rr.getBool("DEBUG")));Rr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>true));Rr.registerFlag("IS_TEST",(()=>false));Rr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Rr.getBool("DEBUG")));Rr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>false));Rr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>false));Rr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>false));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sr(t,n){let e=t;if(Oo(t)){return n==="string"?[]:[t.length]}if(lr(t)){const n=t.channels||"RGBA";return[t.height,t.width*n.length]}else if(fr(t)){return[t.buffer.size/(n==null?4:O(n))]}if(!Array.isArray(t)){return[]}const s=[];while(Array.isArray(e)||Oo(e)&&n!=="string"){s.push(e.length);e=e[0]}if(Array.isArray(t)&&et().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")){Er(t,s,[])}return s}function Er(t,n,e){e=e||[];if(!Array.isArray(t)&&!Oo(t)){m(n.length===0,(()=>`Element arr[${e.join("][")}] is a primitive, `+`but should be an array/TypedArray of ${n[0]} elements`));return}m(n.length>0,(()=>`Element arr[${e.join("][")}] should be a primitive, `+`but is an array of ${t.length} elements`));m(t.length===n[0],(()=>`Element arr[${e.join("][")}] should have ${n[0]} `+`elements, but has ${t.length} elements`));const s=n.slice(1);for(let n=0;n<t.length;++n){Er(t[n],s,e.concat(n))}}function Tr(t,n,e,s){if(t==="string_or_numeric"){return}if(t==null){throw new Error(`Expected dtype cannot be null.`)}if(t!=="numeric"&&t!==n||t==="numeric"&&n==="string"){throw new Error(`Argument '${e}' passed to '${s}' must `+`be ${t} tensor, but got ${n} tensor`)}}function Ir(t,n,e,s="numeric"){if(t instanceof Qo){Tr(s,t.dtype,n,e);return t}let o=L(t);if(o!=="string"&&["bool","int32","float32"].indexOf(s)>=0){o=s}Tr(s,o,n,e);if(t==null||!Oo(t)&&!Array.isArray(t)&&typeof t!=="number"&&typeof t!=="boolean"&&typeof t!=="string"){const s=t==null?"null":t.constructor.name;throw new Error(`Argument '${n}' passed to '${e}' must be a `+`Tensor or TensorLike, but got '${s}'`)}const r=Sr(t,o);if(!Oo(t)&&!Array.isArray(t)){t=[t]}const i=true;const c=o!=="string"?Eo(t,o):Fo(t,[],i);return $r.makeTensor(c,r,o)}function Ar(t,n,e,s="numeric"){if(!Array.isArray(t)){throw new Error(`Argument ${n} passed to ${e} must be a `+"`Tensor[]` or `TensorLike[]`")}const o=t;return o.map(((t,o)=>Ir(t,`${n}[${o}]`,e,s)))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Or="__op";function Fr(t){const n=Object.keys(t);if(n.length!==1){throw new Error(`Please provide an object with a single key `+`(operation name) mapping to a function. Got an object with `+`${n.length} keys.`)}let e=n[0];const s=t[e];if(e.endsWith("_")){e=e.substring(0,e.length-1)}e=e+Or;const o=(...t)=>{$r.startScope(e);try{const n=s(...t);if(J(n)){console.error("Cannot return a Promise inside of tidy.")}$r.endScope(n);return n}catch(t){$r.endScope(null);throw t}};Object.defineProperty(o,"name",{value:e,configurable:true});return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _r(t,n){const e=Ir(t,"real","complex");const s=Ir(n,"imag","complex");x(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, `+`must match in call to tf.complex().`);const o={real:e,imag:s};return $r.runKernel(Dt,o)}const Mr=Fr({complex_:_r});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(t,n,e,s){if(s==null){s=L(t)}else if(s==="complex64"){throw new Error(`Cannot construct a complex64 tensor directly. `+`Please use tf.complex(real, imag).`)}if(fr(t)||lr(t)){if(s!=="float32"&&s!=="int32"){throw new Error(`Creating tensor from GPU data only supports `+`'float32'|'int32' dtype, while the dtype is ${s}.`)}return $r.backend.createTensorFromGPUData(t,n||e,s)}if(!Oo(t)&&!Array.isArray(t)&&typeof t!=="number"&&typeof t!=="boolean"&&typeof t!=="string"){throw new Error("values passed to tensor(values) must be a number/boolean/string or "+"an array of numbers/booleans/strings, or a TypedArray")}if(n!=null){q(n);const t=g(n);const s=g(e);m(t===s,(()=>`Based on the provided shape, [${n}], the tensor should have `+`${t} values but has ${s}`));for(let t=0;t<e.length;++t){const s=e[t];const o=t===e.length-1?s!==g(n.slice(t)):true;m(e[t]===n[t]||!o,(()=>`Error creating a new Tensor. Inferred shape `+`(${e}) does not match the provided `+`shape (${n}). `))}}if(!Oo(t)&&!Array.isArray(t)){t=[t]}n=n||e;t=s!=="string"?Eo(t,s):Fo(t,[],true);return $r.makeTensor(t,n,s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lr(t,n,e){const s=Sr(t,e);return Dr(t,n,s,e)}class zr{static join(t){return new zr(t).slice()}constructor(t){this.shards=[];this.previousShardIndex=0;if(t==null){return}if(!(t instanceof Array)){t=[t]}t=t.map((t=>{if(Oo(t)){return t.buffer}return t}));if(t.length===0){return}this.bufferUniformSize=t[0].byteLength;let n=0;for(let e=0;e<t.length;e++){const s=t[e];if(e!==t.length-1&&s.byteLength!==this.bufferUniformSize){this.bufferUniformSize=undefined}const o=n+s.byteLength;this.shards.push({buffer:s,start:n,end:o});n=o}if(this.shards.length===0){this.byteLength=0}this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0){return new ArrayBuffer(0)}t=isNaN(Number(t))?0:t;n=isNaN(Number(n))?0:n;t=Math.max(0,t);n=Math.min(this.byteLength,n);if(n<=t){return new ArrayBuffer(0)}const e=this.findShardForByte(t);if(e===-1){throw new Error(`Could not find start shard for byte ${t}`)}const s=n-t;const o=new ArrayBuffer(s);const r=new Uint8Array(o);let i=0;for(let s=e;s<this.shards.length;s++){const e=this.shards[s];const o=t+i;const c=o-e.start;const a=i;const u=Math.min(n,e.end);const l=u-e.start;const f=new Uint8Array(e.buffer,c,l-c);r.set(f,a);i+=f.length;if(n<e.end){break}}return o}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength){return-1}if(this.bufferUniformSize!=null){this.previousShardIndex=Math.floor(t/this.bufferUniformSize);return this.previousShardIndex}function n(n){if(t<n.start){return-1}if(t>=n.end){return 1}return 0}if(n(this.shards[this.previousShardIndex])===0){return this.previousShardIndex}const e=Pr(this.shards,n);if(e===-1){return-1}this.previousShardIndex=e;return this.previousShardIndex}}function Pr(t,n){let e=0;let s=t.length;while(e<=s){const o=Math.floor((s-e)/2)+e;const r=n(t[o]);if(r===0){return o}else if(r<0){s=o}else{e=o+1}}return-1}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vr=4;async function Br(t,n){const e=[];const s=[];const o=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let r=0;r<o.length;++r){const i=o[r];const c=Array.isArray(t)?t[r].tensor:t[i];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64"){throw new Error(`Unsupported dtype in weight '${i}': ${c.dtype}`)}const a={name:i,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const t=new Promise((async t=>{const n=await c.bytes();const e=n.reduce(((t,n)=>t+n.length),0)+Vr*n.length;const s=new Uint8Array(e);let o=0;for(let t=0;t<n.length;t++){const e=n[t];const r=new Uint8Array(new Uint32Array([e.length]).buffer);s.set(r,o);o+=Vr;s.set(e,o);o+=e.length}t(s)}));s.push(t)}else{s.push(c.data())}if(n!=null){a.group=n}e.push(a)}const r=await Promise.all(s);return{data:Wr(r),specs:e}}function Wr(t){if(t===null){throw new Error(`Invalid input value: ${JSON.stringify(t)}`)}let n=0;const e=[];t.forEach((t=>{n+=t.byteLength;e.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t));if(!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array)){throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}}));const s=new Uint8Array(n);let o=0;e.forEach((t=>{s.set(new Uint8Array(t.buffer),o);o+=t.byteLength}));return s.buffer}const Gr=typeof Buffer!=="undefined"&&(typeof Blob==="undefined"||typeof atob==="undefined"||typeof btoa==="undefined");function Ur(t){if(Gr){return Buffer.byteLength(t,"utf8")}return new Blob([t]).size}function Hr(t){if(Gr){return Buffer.from(t).toString("base64")}const n=new Uint8Array(t);let e="";for(let t=0,s=n.length;t<s;t++){e+=String.fromCharCode(n[t])}return btoa(e)}function jr(t){if(Gr){const n=Buffer.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t);const e=new Uint8Array(n.length);for(let t=0;t<n.length;++t){e.set([n.charCodeAt(t)],t)}return e.buffer}function qr(t){return zr.join(t)}function Xr(t,n){const e={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};if(t.signature!=null){e.signature=t.signature}if(t.userDefinedMetadata!=null){e.userDefinedMetadata=t.userDefinedMetadata}if(t.modelInitializer!=null){e.modelInitializer=t.modelInitializer}if(t.initializerSignature!=null){e.initializerSignature=t.initializerSignature}if(t.trainingConfig!=null){e.trainingConfig=t.trainingConfig}return e}function Kr(t,n,e){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null){s.trainingConfig=t.trainingConfig}if(t.weightsManifest!=null){if(!n){throw new Error("modelJSON has weightsManifest but weightSpecs is null")}if(!e){throw new Error("modelJSON has weightsManifest but weightData is null")}s.weightSpecs=n;s.weightData=e}if(t.signature!=null){s.signature=t.signature}if(t.userDefinedMetadata!=null){s.userDefinedMetadata=t.userDefinedMetadata}if(t.modelInitializer!=null){s.modelInitializer=t.modelInitializer}if(t.initializerSignature!=null){s.initializerSignature=t.initializerSignature}return s}async function Jr(t,n){let e;let s;if(t.weightsManifest!=null){[e,s]=await n(t.weightsManifest)}return Kr(t,e,s)}function Yr(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:Ur(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:Ur(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new zr(t.weightData).byteLength}}function Zr(t){const n=[];for(const e of t){n.push(...e.weights)}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qr{constructor(){this.saveRouters=[];this.loadRouters=[]}static getInstance(){if(Qr.instance==null){Qr.instance=new Qr}return Qr.instance}static registerSaveRouter(t){Qr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Qr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Qr.getHandlers(t,"save")}static getLoadHandlers(t,n){return Qr.getHandlers(t,"load",n)}static getHandlers(t,n,e){const s=[];const o=n==="load"?Qr.getInstance().loadRouters:Qr.getInstance().saveRouters;o.forEach((n=>{const o=n(t,e);if(o!==null){s.push(o)}}));return s}}const ti=t=>Qr.getSaveHandlers(t)
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const ni="tensorflowjs";const ei=1;const si="models_store";const oi="model_info_store";function ri(){if(!et().getBool("IS_BROWSER")){throw new Error("Failed to obtain IndexedDB factory because the current environment"+"is not a web browser.")}const t=typeof window==="undefined"?self:window;const n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(n==null){throw new Error("The current browser does not appear to support IndexedDB.")}return n}function ii(t){const n=t.result;n.createObjectStore(si,{keyPath:"modelPath"});n.createObjectStore(oi,{keyPath:"modelPath"})}class ci{constructor(t){this.indexedDB=ri();if(t==null||!t){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise(((t,e)=>{const s=this.indexedDB.open(ni,ei);s.onupgradeneeded=()=>ii(s);s.onsuccess=()=>{const o=s.result;if(n==null){const n=o.transaction(si,"readonly");const s=n.objectStore(si);const r=s.get(this.modelPath);r.onsuccess=()=>{if(r.result==null){o.close();return e(new Error(`Cannot find model with path '${this.modelPath}' `+`in IndexedDB.`))}else{t(r.result.modelArtifacts)}};r.onerror=t=>{o.close();return e(r.error)};n.oncomplete=()=>o.close()}else{n.weightData=zr.join(n.weightData);const s=Yr(n);const r=o.transaction(oi,"readwrite");let i=r.objectStore(oi);let c;try{c=i.put({modelPath:this.modelPath,modelArtifactsInfo:s})}catch(t){return e(t)}let a;c.onsuccess=()=>{a=o.transaction(si,"readwrite");const c=a.objectStore(si);let u;try{u=c.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:s})}catch(t){return e(t)}u.onsuccess=()=>t({modelArtifactsInfo:s});u.onerror=t=>{i=r.objectStore(oi);const n=i.delete(this.modelPath);n.onsuccess=()=>{o.close();return e(u.error)};n.onerror=t=>{o.close();return e(u.error)}}};c.onerror=t=>{o.close();return e(c.error)};r.oncomplete=()=>{if(a==null){o.close()}else{a.oncomplete=()=>o.close()}}}};s.onerror=t=>e(s.error)}))}}ci.URL_SCHEME="indexeddb://";const ai=t=>{if(!et().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(t)&&t.startsWith(ci.URL_SCHEME)){return ui(t.slice(ci.URL_SCHEME.length))}else{return null}}};Qr.registerSaveRouter(ai);Qr.registerLoadRouter(ai);function ui(t){return new ci(t)}function li(t){return t.startsWith(ci.URL_SCHEME)?t.slice(ci.URL_SCHEME.length):t}class fi{constructor(){this.indexedDB=ri()}async listModels(){return new Promise(((t,n)=>{const e=this.indexedDB.open(ni,ei);e.onupgradeneeded=()=>ii(e);e.onsuccess=()=>{const s=e.result;const o=s.transaction(oi,"readonly");const r=o.objectStore(oi);const i=r.getAll();i.onsuccess=()=>{const n={};for(const t of i.result){n[t.modelPath]=t.modelArtifactsInfo}t(n)};i.onerror=t=>{s.close();return n(i.error)};o.oncomplete=()=>s.close()};e.onerror=t=>n(e.error)}))}async removeModel(t){t=li(t);return new Promise(((n,e)=>{const s=this.indexedDB.open(ni,ei);s.onupgradeneeded=()=>ii(s);s.onsuccess=()=>{const o=s.result;const r=o.transaction(oi,"readwrite");const i=r.objectStore(oi);const c=i.get(t);let a;c.onsuccess=()=>{if(c.result==null){o.close();return e(new Error(`Cannot find model with path '${t}' `+`in IndexedDB.`))}else{const s=i.delete(t);const r=()=>{a=o.transaction(si,"readwrite");const s=a.objectStore(si);const r=s.delete(t);r.onsuccess=()=>n(c.result.modelArtifactsInfo);r.onerror=t=>e(c.error)};s.onsuccess=r;s.onerror=t=>{r();o.close();return e(c.error)}}};c.onerror=t=>{o.close();return e(c.error)};r.oncomplete=()=>{if(a==null){o.close()}else{a.oncomplete=()=>o.close()}}};s.onerror=t=>e(s.error)}))}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hi="/";const di="tensorflowjs_models";const pi="info";const mi="model_topology";const xi="weight_specs";const bi="weight_data";const gi="model_metadata";function wi(t){return{info:[di,t,pi].join(hi),topology:[di,t,mi].join(hi),weightSpecs:[di,t,xi].join(hi),weightData:[di,t,bi].join(hi),modelMetadata:[di,t,gi].join(hi)}}function vi(t){for(const n of Object.values(t)){window.localStorage.removeItem(n)}}function $i(t){const n=t.split(hi);if(n.length<3){throw new Error(`Invalid key format: ${t}`)}return n.slice(1,n.length-1).join(hi)}function yi(t){return t.startsWith(ki.URL_SCHEME)?t.slice(ki.URL_SCHEME.length):t}class ki{constructor(t){if(!et().getBool("IS_BROWSER")||typeof window==="undefined"||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(t==null||!t){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=t;this.keys=wi(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}else{const n=JSON.stringify(t.modelTopology);const e=JSON.stringify(t.weightSpecs);const s=Yr(t);const o=zr.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s));this.LS.setItem(this.keys.topology,n);this.LS.setItem(this.keys.weightSpecs,e);this.LS.setItem(this.keys.weightData,Hr(o));const r={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:undefined,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:undefined,modelInitializer:t.modelInitializer!=null?t.modelInitializer:undefined,initializerSignature:t.initializerSignature!=null?t.initializerSignature:undefined,trainingConfig:t.trainingConfig!=null?t.trainingConfig:undefined};this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r));return{modelArtifactsInfo:s}}catch(t){vi(this.keys);throw new Error(`Failed to save model '${this.modelPath}' to local storage: `+`size quota being exceeded is a possible cause of this failure: `+`modelTopologyBytes=${s.modelTopologyBytes}, `+`weightSpecsBytes=${s.weightSpecsBytes}, `+`weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null){throw new Error(`In local storage, there is no model with name '${this.modelPath}'`)}if(t.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model "+"topology yet.")}const n={};const e=JSON.parse(this.LS.getItem(this.keys.topology));if(e==null){throw new Error(`In local storage, the topology of model '${this.modelPath}' `+`is missing.`)}n.modelTopology=e;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null){throw new Error(`In local storage, the weight specs of model '${this.modelPath}' `+`are missing.`)}n.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const t=JSON.parse(o);n.format=t.format;n.generatedBy=t.generatedBy;n.convertedBy=t.convertedBy;if(t.signature!=null){n.signature=t.signature}if(t.userDefinedMetadata!=null){n.userDefinedMetadata=t.userDefinedMetadata}if(t.modelInitializer!=null){n.modelInitializer=t.modelInitializer}if(t.initializerSignature!=null){n.initializerSignature=t.initializerSignature}if(t.trainingConfig!=null){n.trainingConfig=t.trainingConfig}}const r=this.LS.getItem(this.keys.weightData);if(r==null){throw new Error(`In local storage, the binary weight values of model `+`'${this.modelPath}' are missing.`)}n.weightData=jr(r);return n}}ki.URL_SCHEME="localstorage://";const Ci=t=>{if(!et().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(t)&&t.startsWith(ki.URL_SCHEME)){return Ni(t.slice(ki.URL_SCHEME.length))}else{return null}}};Qr.registerSaveRouter(Ci);Qr.registerLoadRouter(Ci);function Ni(t){return new ki(t)}class Ri{constructor(){m(et().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser"));m(typeof window==="undefined"||typeof window.localStorage!=="undefined",(()=>"Current browser does not appear to support localStorage"));this.LS=window.localStorage}async listModels(){const t={};const n=di+hi;const e=hi+pi;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(n)&&o.endsWith(e)){const n=$i(o);t[n]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=yi(t);const n=wi(t);if(this.LS.getItem(n.info)==null){throw new Error(`Cannot find model at path '${t}'`)}const e=JSON.parse(this.LS.getItem(n.info));vi(n);return e}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Si="://";class Ei{constructor(){this.managers={}}static getInstance(){if(Ei.instance==null){Ei.instance=new Ei}return Ei.instance}static registerManager(t,n){m(t!=null,(()=>"scheme must not be undefined or null."));if(t.endsWith(Si)){t=t.slice(0,t.indexOf(Si))}m(t.length>0,(()=>"scheme must not be an empty string."));const e=Ei.getInstance();m(e.managers[t]==null,(()=>`A model store manager is already registered for scheme '${t}'.`));e.managers[t]=n}static getManager(t){const n=Ei.getInstance().managers[t];if(n==null){throw new Error(`Cannot find model manager for scheme '${t}'`)}return n}static getSchemes(){return Object.keys(Ei.getInstance().managers)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ti{constructor(){this.messageName="setTimeoutCustom";this.functionRefs=[];this.handledMessageCount=0;this.hasEventListener=false}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Browser's encoder only supports utf-8, but got ${n}`)}if(this.textEncoder==null){this.textEncoder=new TextEncoder}return this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window==="undefined"||!et().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t);setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),n);if(!this.hasEventListener){this.hasEventListener=true;window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();const n=this.functionRefs[t.data.index];n();this.handledMessageCount++;if(this.handledMessageCount===this.functionRefs.length){this.functionRefs=[];this.handledMessageCount=0}}}),true)}}isTypedArray(t){return Fs(t)}}if(et().get("IS_BROWSER")){et().setPlatform("browser",new Ti);try{Ei.registerManager(ki.URL_SCHEME,new Ri)}catch(t){}try{Ei.registerManager(ci.URL_SCHEME,new fi)}catch(t){}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ii={importFetch:()=>require("node-fetch")};let Ai;class Oi{constructor(){this.util=require("util");this.textEncoder=new this.util.TextEncoder}fetch(t,n){if(et().global.fetch!=null){return et().global.fetch(t,n)}if(Ai==null){Ai=Ii.importFetch()}return Ai(t,n)}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`)}return this.textEncoder.encode(t)}decode(t,n){if(t.length===0){return""}return new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}if(et().get("IS_NODE")&&!et().get("IS_BROWSER")){et().setPlatform("node",new Oi)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fi(t,n="float32",e){n=n||"float32";q(t);return new Xo(t,n,e)}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _i(t,n){const e=Ir(t,"x","cast");if(!I(n)){throw new Error(`Failed to cast to unknown dtype ${n}`)}if(n==="string"&&e.dtype!=="string"||n!=="string"&&e.dtype==="string"){throw new Error("Only strings can be casted to strings")}const s={x:e};const o={dtype:n};return $r.runKernel(Ft,s,o)}const Mi=Fr({cast_:_i});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(t){const n=Ir(t,"x","clone","string_or_numeric");const e={x:n};return $r.runKernel(Rn,e)}const Li=Fr({clone_:Di});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(t,n=false){console.log(t.toString(n))}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */vr();const Pi={buffer:Fi,cast:Mi,clone:Li,print:zi};Zo(Pi);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vi(){return $r}function Bi(){return $r.memory()}function Wi(t,n){return $r.tidy(t,n)}function Gi(t){const n=dr(t);n.forEach((t=>t.dispose()))}function Ui(t){return $r.keep(t)}function Hi(t,n,e=1){return $r.registerBackend(t,n,e)}function ji(){return $r.backend}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qi(t,n){let e=Ir(t,"a","add");let s=Ir(n,"b","add");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(ht,o)}const Xi=Fr({add_:qi});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ki(t,n){let e=Ir(t,"a","floorDiv");let s=Ir(n,"b","floorDiv");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(vn,o)}const Ji=Fr({floorDiv_:Ki});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(t,n){let e=Ir(t,"a","div");let s=Ir(n,"b","div");[e,s]=hr(e,s);if(e.dtype==="int32"&&s.dtype==="int32"){return Ji(e,s)}const o={a:e,b:s};const r={};return $r.runKernel(cn,o,r)}const Zi=Fr({div_:Yi});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(t,n){let e=Ir(t,"a","mul");let s=Ir(n,"b","mul");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(se,o)}const tc=Fr({mul_:Qi});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nc(t){const n=Ir(t,"x","abs");if(n.dtype==="complex64"){const t={x:n};return $r.runKernel(Lt,t)}else{const t={x:n};return $r.runKernel(ut,t)}}const ec=Fr({abs_:nc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sc(t){const n=Ir(t,"x","acos");const e={x:n};return $r.runKernel(lt,e)}const oc=Fr({acos_:sc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rc(t){const n=Ir(t,"x","acosh");const e={x:n};return $r.runKernel(ft,e)}const ic=Fr({acosh_:rc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cc(t,n=null,e=false){const s=Ir(t,"x","all","bool");const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(pt,o,r)}const ac=Fr({all_:cc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uc(t,n=null,e=false){const s=Ir(t,"x","any","bool");const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(mt,o,r)}const lc=Fr({any_:uc});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fc(t,n=0){const e=Ir(t,"x","argMax");const s={x:e};const o={axis:n};return $r.runKernel(xt,s,o)}const hc=Fr({argMax_:fc});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dc(t,n=0){const e=Ir(t,"x","argMin");const s={x:e};const o={axis:n};return $r.runKernel(bt,s,o)}const pc=Fr({argMin_:dc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mc(t){const n=Ir(t,"x","asin");const e={x:n};return $r.runKernel(gt,e)}const xc=Fr({asin_:mc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bc(t){const n=Ir(t,"x","asinh");const e={x:n};return $r.runKernel(wt,e)}const gc=Fr({asinh_:bc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wc(t){const n=Ir(t,"x","atan");const e={x:n};return $r.runKernel(vt,e)}const vc=Fr({atan_:wc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $c(t,n){let e=Ir(t,"a","atan2");let s=Ir(n,"b","atan2");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(yt,o)}const yc=Fr({atan2_:$c});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kc(t){const n=Ir(t,"x","atanh");const e={x:n};return $r.runKernel($t,e)}const Cc=Fr({atanh_:kc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nc(t,n,e,s,o="NHWC",r){const i=t[3];const c=[...n,i];const a=Wc(o);return Ec(t,c,e,r,s,null,null,a)}function Rc(t,n,e,s,o,r,i="channelsLast"){const[c,a]=Fc(n);let u;if(i==="channelsLast"){u=[c,a,t[3],t[3]]}else if(i==="channelsFirst"){u=[c,a,t[1],t[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return Ec(t,u,e,s,o,r,false,i)}function Sc(t,n,e,s,o,r,i="NDHWC"){const[c,a,u]=_c(n);let l;let f;if(i==="NDHWC"){f="channelsLast";l=[c,a,u,t[4],t[4]]}else if(i==="NCDHW"){f="channelsFirst";l=[c,a,u,t[1],t[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return Tc(t,l,e,s,o,false,f,r)}function Ec(t,n,e,s,o,r,i=false,c="channelsLast"){let[a,u,l,f]=[-1,-1,-1,-1];if(c==="channelsLast"){[a,u,l,f]=t}else if(c==="channelsFirst"){[a,f,u,l]=t}else{throw new Error(`Unknown dataFormat ${c}`)}const[h,d,,p]=n;const[m,x]=Fc(e);const[b,g]=Fc(s);const w=Mc(h,b);const v=Mc(d,g);const{padInfo:$,outHeight:y,outWidth:k}=Dc(o,u,l,m,x,w,v,r,c);const C=i?p*f:p;let N;if(c==="channelsFirst"){N=[a,C,y,k]}else if(c==="channelsLast"){N=[a,y,k,C]}return{batchSize:a,dataFormat:c,inHeight:u,inWidth:l,inChannels:f,outHeight:y,outWidth:k,outChannels:C,padInfo:$,strideHeight:m,strideWidth:x,filterHeight:h,filterWidth:d,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:g,inShape:t,outShape:N,filterShape:n}}function Tc(t,n,e,s,o,r=false,i="channelsLast",c){let[a,u,l,f,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast"){[a,u,l,f,h]=t}else if(i==="channelsFirst"){[a,h,u,l,f]=t}else{throw new Error(`Unknown dataFormat ${i}`)}const[d,p,m,,x]=n;const[b,g,w]=_c(e);const[v,$,y]=_c(s);const k=Mc(d,v);const C=Mc(p,$);const N=Mc(m,y);const{padInfo:R,outDepth:S,outHeight:E,outWidth:T}=Lc(o,u,l,f,b,g,w,k,C,N,c);const I=r?x*h:x;let A;if(i==="channelsFirst"){A=[a,I,S,E,T]}else if(i==="channelsLast"){A=[a,S,E,T,I]}return{batchSize:a,dataFormat:i,inDepth:u,inHeight:l,inWidth:f,inChannels:h,outDepth:S,outHeight:E,outWidth:T,outChannels:I,padInfo:R,strideDepth:b,strideHeight:g,strideWidth:w,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:C,effectiveFilterWidth:N,dilationDepth:v,dilationHeight:$,dilationWidth:y,inShape:t,outShape:A,filterShape:n}}function Ic(t,n,e,s,o){if(s==null){s=Oc(t,n,e)}const r=t[0];const i=t[1];const c=zc((r-n+2*s)/e+1,o);const a=zc((i-n+2*s)/e+1,o);return[c,a]}function Ac(t,n,e,s,o,r){if(o==null){o=Oc(t,n[0],s[0])}const i=[0,0,0,e];for(let e=0;e<3;e++){if(t[e]+2*o>=n[e]){i[e]=zc((t[e]-n[e]+2*o)/s[e]+1,r)}}return i}function Oc(t,n,e,s=1){const o=Mc(n,s);return Math.floor((t[0]*(e-1)-e+o)/2)}function Fc(t){if(typeof t==="number"){return[t,t,t]}if(t.length===2){return[t[0],t[1],1]}return t}function _c(t){return typeof t==="number"?[t,t,t]:t}function Mc(t,n){if(n<=1){return t}return t+(t-1)*(n-1)}function Dc(t,n,e,s,o,r,i,c,a){let u;let l;let f;if(typeof t==="number"){const o=t===0?"VALID":"NUMBER";u={top:t,bottom:t,left:t,right:t,type:o};const i=Ic([n,e],r,s,t,c);l=i[0];f=i[1]}else if(t==="same"){l=Math.ceil(n/s);f=Math.ceil(e/o);const t=Math.max(0,(l-1)*s+r-n);const c=Math.max(0,(f-1)*o+i-e);const a=Math.floor(t/2);const h=t-a;const d=Math.floor(c/2);const p=c-d;u={top:a,bottom:h,left:d,right:p,type:"SAME"}}else if(t==="valid"){u={top:0,bottom:0,left:0,right:0,type:"VALID"};l=Math.ceil((n-r+1)/s);f=Math.ceil((e-i+1)/o)}else if(typeof t==="object"){const h=a==="channelsLast"?t[1][0]:t[2][0];const d=a==="channelsLast"?t[1][1]:t[2][1];const p=a==="channelsLast"?t[2][0]:t[3][0];const m=a==="channelsLast"?t[2][1]:t[3][1];const x=h===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT";u={top:h,bottom:d,left:p,right:m,type:x};l=zc((n-r+h+d)/s+1,c);f=zc((e-i+p+m)/o+1,c)}else{throw Error(`Unknown padding parameter: ${t}`)}return{padInfo:u,outHeight:l,outWidth:f}}function Lc(t,n,e,s,o,r,i,c,a,u,l){let f;let h;let d;let p;if(t==="valid"){t=0}if(typeof t==="number"){const m=t===0?"VALID":"NUMBER";f={top:t,bottom:t,left:t,right:t,front:t,back:t,type:m};const x=Ac([n,e,s,1],[c,a,u],1,[o,r,i],t,l);h=x[0];d=x[1];p=x[2]}else if(t==="same"){h=Math.ceil(n/o);d=Math.ceil(e/r);p=Math.ceil(s/i);const t=(h-1)*o+c-n;const l=(d-1)*r+a-e;const m=(p-1)*i+u-s;const x=Math.floor(t/2);const b=t-x;const g=Math.floor(l/2);const w=l-g;const v=Math.floor(m/2);const $=m-v;f={top:g,bottom:w,left:v,right:$,front:x,back:b,type:"SAME"}}else{throw Error(`Unknown padding parameter: ${t}`)}return{padInfo:f,outDepth:h,outHeight:d,outWidth:p}}function zc(t,n){if(!n){return Math.trunc(t)}switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function Pc(t){const[n,e,s]=Fc(t);return n===1&&e===1&&s===1}function Vc(t,n){return Pc(t)||Pc(n)}function Bc(t){return Fc(t).every((t=>t>0))}function Wc(t){if(t==="NHWC"){return"channelsLast"}else if(t==="NCHW"){return"channelsFirst"}else{throw new Error(`Unknown dataFormat ${t}`)}}function Gc(t,n,e){if(e!=null){if(typeof n==="string"){throw Error(`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`)}else if(typeof n==="number"){m(v(n),(()=>`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`))}else if(typeof n==="object"){n.forEach((n=>{n.forEach((n=>{m(v(n),(()=>`Error in ${t}: pad must be an integer when using `+`dimRoundingMode ${e} but got pad ${n}.`))}))}))}else{throw Error(`Error in ${t}: Unknown padding parameter: ${n}`)}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uc(t,n){const e=Ir(t,"x","reshape","string_or_numeric");const s={x:e};const o={shape:n};return $r.runKernel(ke,s,o)}const Hc=Fr({reshape_:Uc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jc(t,n,e,s,o){const r=Ir(t,"x","avgPool","float32");const i=1;m(Vc(e,i),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${i}'`));let c=r;let a=false;if(r.rank===3){a=true;c=Hc(r,[1,r.shape[0],r.shape[1],r.shape[2]])}m(c.rank===4,(()=>`Error in avgPool: x must be rank 4 but got rank ${c.rank}.`));Gc("avgPool",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o};let f=$r.runKernel(kt,u,l);f=Mi(f,r.dtype);if(a){return Hc(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const qc=Fr({avgPool_:jc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xc(t,n,e,s,o,r="NDHWC"){const i=Ir(t,"x","avgPool3d","float32");let c=i;let a=false;if(i.rank===4){a=true;c=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}m(c.rank===5,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${c.rank}.`));m(r==="NDHWC",(()=>`Error in avgPool3d: Only NDHWC is currently supported, `+`but got dataFormat of ${r}`));m(typeof e==="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`));Gc("avgPool3d",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o,dataFormat:r};let f=$r.runKernel(Nt,u,l);f=Mi(f,c.dtype);if(a){return Hc(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const Kc=Fr({avgPool3d_:Xc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jc(t,n=0){m(t.length>=1,(()=>"Pass at least one tensor to concat"));const e=Ar(t,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"){e.forEach((t=>{if(t.dtype!=="complex64"){throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}}))}if(e.length===1){return Li(e[0])}const s=e;const o={axis:n};return $r.runKernel(zt,s,o)}const Yc=Fr({concat_:Jc});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zc(t,n,e=false,s=false){let o=Ir(t,"a","matMul");let r=Ir(n,"b","matMul");[o,r]=hr(o,r);const i={a:o,b:r};const c={transposeA:e,transposeB:s};return $r.runKernel(St,i,c)}const Qc=Fr({matMul_:Zc});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta(t){const n=Ir(t,"x","sigmoid","float32");const e={x:n};return $r.runKernel(Be,e)}const na=Fr({sigmoid_:ta});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ea(t,n,e){const s=Ir(t,"x","slice","string_or_numeric");if(s.rank===0){throw new Error("Slicing scalar is not possible")}const o={x:s};const r={begin:n,size:e};return $r.runKernel(Le,o,r)}const sa=Fr({slice_:ea});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(t){const n=Ir(t,"x","tanh","float32");const e={x:n};return $r.runKernel(as,e)}const ra=Fr({tanh_:oa});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(t,n,e){const s=Ir(t,"x","batchToSpaceND");const o=n.reduce(((t,n)=>t*n));m(s.rank>=1+n.length,(()=>`input rank is ${s.rank} but should be > than blockShape.length ${n.length}`));m(e.length===n.length,(()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`));m(s.shape[0]%o===0,(()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of `+`the elements of blockShape ${n.join(" * ")} === ${o}`));const r={x:s};const i={blockShape:n,crops:e};return $r.runKernel(Et,r,i)}const ca=Fr({batchToSpaceND_:ia});function aa(t){let n;if(t.rank===0||t.rank===1){n=Hc(t,[1,1,1,t.size])}else if(t.rank===2){n=Hc(t,[1,1,t.shape[0],t.shape[1]])}else if(t.rank===3){n=Hc(t,[1,t.shape[0],t.shape[1],t.shape[2]])}else{n=t}return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(t,n,e,s,o,r){if(r==null){r=.001}const i=Ir(t,"x","batchNorm");const c=Ir(n,"mean","batchNorm");const a=Ir(e,"variance","batchNorm");let u;if(o!=null){u=Ir(o,"scale","batchNorm")}let l;if(s!=null){l=Ir(s,"offset","batchNorm")}m(c.rank===a.rank,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));m(l==null||c.rank===l.rank,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));m(u==null||c.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));const f=aa(i);const h={x:f,scale:u,offset:l,mean:c,variance:a};const d={varianceEpsilon:r};const p=$r.runKernel($n,h,d);return Hc(p,i.shape)}const la=Fr({batchNorm_:ua});function fa(t,n,e,s,o,r){const i=Ir(t,"x","batchNorm");const c=Ir(n,"mean","batchNorm");const a=Ir(e,"variance","batchNorm");let u;if(o!=null){u=Ir(o,"scale","batchNorm")}let l;if(s!=null){l=Ir(s,"offset","batchNorm")}m(i.rank===2,(()=>`Error in batchNorm2D: x must be rank 2 but got rank `+`${i.rank}.`));m(c.rank===2||c.rank===1,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but `+`got rank ${c.rank}.`));m(a.rank===2||a.rank===1,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){m(u.rank===2||u.rank===1,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){m(l.rank===2||l.rank===1,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 `+`but got rank ${l.rank}.`))}return la(i,c,a,l,u,r)}const ha=Fr({batchNorm2d_:fa});function da(t,n,e,s,o,r){const i=Ir(t,"x","batchNorm");const c=Ir(n,"mean","batchNorm");const a=Ir(e,"variance","batchNorm");let u;if(o!=null){u=Ir(o,"scale","batchNorm")}let l;if(s!=null){l=Ir(s,"offset","batchNorm")}m(i.rank===3,(()=>`Error in batchNorm3D: x must be rank 3 but got rank `+`${i.rank}.`));m(c.rank===3||c.rank===1,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but `+`got rank ${c.rank}.`));m(a.rank===3||a.rank===1,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){m(u.rank===3||u.rank===1,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){m(l.rank===3||l.rank===1,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 `+`but got rank ${l.rank}.`))}return la(i,c,a,l,u,r)}const pa=Fr({batchNorm3d_:da});function ma(t,n,e,s,o,r){const i=Ir(t,"x","batchNorm");const c=Ir(n,"mean","batchNorm");const a=Ir(e,"variance","batchNorm");let u;if(o!=null){u=Ir(o,"scale","batchNorm")}let l;if(s!=null){l=Ir(s,"offset","batchNorm")}m(i.rank===4,(()=>`Error in batchNorm4D: x must be rank 4 but got rank `+`${i.rank}.`));m(c.rank===4||c.rank===1,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but `+`got rank ${c.rank}.`));m(a.rank===4||a.rank===1,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 `+`but got rank ${a.rank}.`));if(u!=null){m(u.rank===4||u.rank===1,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 `+`but got rank ${u.rank}.`))}if(l!=null){m(l.rank===4||l.rank===1,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 `+`but got rank ${l.rank}.`))}return la(i,c,a,l,u,r)}const xa=Fr({batchNorm4d_:ma});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(t,n,e){const s=Ir(t,"x","bincount");const o=Ir(n,"weights","bincount");m(s.dtype==="int32",(()=>`Error in bincount: input `+`dtype must be int32, but got ${s.dtype}`));m(e>=0,(()=>`size must be non-negative, but got ${e}.`));m(o.size===s.size||o.size===0,(()=>`Error in bincount: weights must have the same size as input or`+`0-length, but got input shape: ${s.shape}, weights shape: `+`${o.shape}.`));const r={x:s,weights:o};const i={size:e};return $r.runKernel(Tt,r,i)}const ga=Fr({bincount_:ba});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(t,n){let e=Ir(t,"broadcastTo","x");const s=e.shape;q(n);if(n.length<e.rank){throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`)}if(n.length>e.rank){const t=e.shape.slice();while(t.length<n.length){t.unshift(1)}e=Hc(e,t)}const o=e.shape;const r=Array.from(n);for(let t=n.length-1;t>=0;t--){if(o[t]===n[t]){r[t]=1}else if(e.shape[t]!==1){throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${n}].`)}}const i=r.map(((t,n)=>t>1?n:-1)).filter((t=>t>=0));if(i.length===0){return Li(e)}const c={x:e};const a={reps:r};return $r.runKernel(us,c,a)}const va=Fr({broadcastTo_:wa});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $a(t){const n=Ir(t,"x","ceil","float32");const e={x:n};return $r.runKernel(_t,e)}const ya=Fr({ceil_:$a});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(t,n,e){q(t);e=e||L(n);const s={shape:t,value:n,dtype:e};return $r.runKernel(bn,{},s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(t,n,e){const s=Ir(t,"x","clipByValue");m(n<=e,(()=>`Error in clip: min (${n}) must be `+`less than or equal to max (${e}).`));if(n===e){return ka(s.shape,n,s.dtype)}const o={x:s};const r={clipValueMin:n,clipValueMax:e};return $r.runKernel(Mt,o,r)}const Na=Fr({clipByValue_:Ca});function Ra(t){return Yc(t,0)}const Sa=Fr({concat1d_:Ra});function Ea(t,n){return Yc(t,n)}const Ta=Fr({concat2d_:Ea});function Ia(t,n){return Yc(t,n)}const Aa=Fr({concat3d_:Ia});function Oa(t,n){return Yc(t,n)}const Fa=Fr({concat4d_:Oa});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(t,n,e,s,o="NHWC",r=[1,1],i){const c=Ir(t,"x","conv2d","float32");const a=Ir(n,"filter","conv2d","float32");let u=c;let l=false;if(c.rank===3){l=true;u=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2]])}m(u.rank===4,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`));m(a.rank===4,(()=>`Error in conv2d: filter must be rank 4, but got rank `+`${a.rank}.`));Gc("conv2d",s,i);const f=o==="NHWC"?u.shape[3]:u.shape[1];m(f===a.shape[2],(()=>`Error in conv2d: depth of input (${f}) must match `+`input depth for filter ${a.shape[2]}.`));m(Vc(e,r),(()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));m(Bc(r),(()=>"Error in conv2D: Dilated rates should be larger than 0."));m(Bc(e),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:a};const d={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i};const p=$r.runKernel(Pt,h,d);if(l){return Hc(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const Ma=Fr({conv2d_:_a});function Da(t,n,e,s,o="NWC",r=1,i){const c=Ir(t,"x","conv1d");const a=Ir(n,"filter","conv1d");let u=c;let l=false;if(c.rank===2){l=true;u=Hc(c,[1,c.shape[0],c.shape[1]])}m(u.rank===3,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`));m(a.rank===3,(()=>`Error in conv1d: filter must be rank 3, but got rank `+`${a.rank}.`));Gc("conv1d",s,i);m(u.shape[2]===a.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match `+`input depth for filter ${a.shape[1]}.`));m(Vc(e,r),(()=>"Error in conv1D: Either stride or dilation must be 1. "+`Got stride ${e} and dilation '${r}'`));m(Bc(r),(()=>"Error in conv1D: Dilated rates should be larger than 0."));m(Bc(e),(()=>"Error in conv1D: Stride should be larger than 0."));m(o==="NWC",(()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`));const f=Hc(a,[1,a.shape[0],a.shape[1],a.shape[2]]);const h=Hc(u,[u.shape[0],1,u.shape[1],u.shape[2]]);const d=[1,e];const p=[1,r];const x="NHWC";const b=Ma(h,f,d,s,x,p,i);if(l){return Hc(b,[b.shape[2],b.shape[3]])}return Hc(b,[b.shape[0],b.shape[2],b.shape[3]])}const La=Fr({conv1d_:Da});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function za(t,n,e,s,o,r="NHWC",i){m(t.length===n.rank,(()=>`Length of inShape `+`(${t.length}) and rank of dy (${n.rank}) must match`));let c=t;let a=n;let u=false;if(n.rank===3){u=true;a=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2]]);c=[1,t[0],t[1],t[2]]}m(c.length===4,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length `+`${c.length}.`));m(a.rank===4,(()=>`Error in conv2dDerInput: dy must be rank 4, but got `+`rank ${a.rank}`));m(e.rank===4,(()=>`Error in conv2dDerInput: filter must be rank 4, but got `+`rank ${e.rank}`));const l=r==="NHWC"?c[3]:c[1];const f=r==="NHWC"?a.shape[3]:a.shape[1];m(l===e.shape[2],(()=>`Error in conv2dDerInput: depth of input (${l}) must `+`match input depth for filter ${e.shape[2]}.`));m(f===e.shape[3],(()=>`Error in conv2dDerInput: depth of output (${f}) must `+`match output depth for filter ${e.shape[3]}.`));Gc("conv2dDerInput",o,i);const h={dy:a,filter:e};const d={strides:s,pad:o,dataFormat:r,dimRoundingMode:i,inputShape:c};const p=$r.runKernel(Bt,h,d);if(u){return Hc(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const Pa=Fr({conv2DBackpropInput_:za});function Va(t,n,e,s,o,r){const i=Ir(t,"x","conv2dTranspose");const c=Ir(n,"filter","conv2dTranspose");return Pa(e,i,c,s,o,"NHWC",r)}const Ba=Fr({conv2dTranspose_:Va});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(t,n,e,s,o="NDHWC",r=[1,1,1]){const i=Ir(t,"x","conv3d");const c=Ir(n,"filter","conv3d");let a=i;let u=false;if(i.rank===4){u=true;a=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}m(a.rank===5,(()=>`Error in conv3d: input must be rank 5, but got rank ${a.rank}.`));m(c.rank===5,(()=>`Error in conv3d: filter must be rank 5, but got rank `+`${c.rank}.`));m(a.shape[4]===c.shape[3],(()=>`Error in conv3d: depth of input (${a.shape[4]}) must match `+`input depth for filter ${c.shape[3]}.`));m(Vc(e,r),(()=>"Error in conv3D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));m(o==="NDHWC",(()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`));m(Bc(r),(()=>"Error in conv3D: Dilated rates should be larger than 0."));m(Bc(e),(()=>"Error in conv3D: Strides should be larger than 0."));const l={x:a,filter:c};const f={strides:e,pad:s,dataFormat:o,dilations:r};const h=$r.runKernel(Wt,l,f);if(u){return Hc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const Ga=Fr({conv3d_:Wa});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(t,n,e,s,o){m(t.length===n.rank,(()=>`Length of inShape `+`(${t.length}) and rank of dy (${n.rank}) must match`));let r=t;let i=n;let c=false;if(n.rank===4){c=true;i=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]);r=[1,t[0],t[1],t[2],t[3]]}const a=r[4];const u=i.shape[4];m(r.length===5,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length `+`${r.length}.`));m(i.rank===5,(()=>`Error in conv3dDerInput: dy must be rank 5, but got `+`rank ${i.rank}`));m(e.rank===5,(()=>`Error in conv3dDerInput: filter must be rank 5, but got `+`rank ${e.rank}`));m(a===e.shape[3],(()=>`Error in conv3dDerInput: depth of input (${a}) must `+`match input depth for filter ${e.shape[3]}.`));m(u===e.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must `+`match output depth for filter ${e.shape[4]}.`));const l={dy:i,filter:e};const f={pad:o,strides:s,inputShape:r};const h=$r.runKernel(Ut,l,f);if(c){return Hc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const Ha=Fr({conv3DBackpropInput_:Ua});function ja(t,n,e,s,o){const r=Ir(t,"x","conv3dTranspose");const i=Ir(n,"filter","conv3dTranspose");return Ha(e,r,i,s,o)}const qa=Fr({conv3dTranspose_:ja});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(t){const n=Ir(t,"x","cos","float32");const e={x:n};return $r.runKernel(Ht,e)}const Ka=Fr({cos_:Xa});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(t){const n=Ir(t,"x","cosh","float32");const e={x:n};return $r.runKernel(jt,e)}const Ya=Fr({cosh_:Ja});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(t,n=0,e=false,s=false){const o=Ir(t,"x","cumprod");const r={x:o};const i={axis:n,exclusive:e,reverse:s};return $r.runKernel(qt,r,i)}const Qa=Fr({cumprod_:Za});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(t,n=0,e=false,s=false){const o=Ir(t,"x","cumsum");const r={x:o};const i={axis:n,exclusive:e,reverse:s};return $r.runKernel(Xt,r,i)}const nu=Fr({cumsum_:tu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(t,n,e,s=false){const o=Ir(t,"x","denseBincount");const r=Ir(n,"weights","denseBincount");m(o.dtype==="int32",(()=>`Error in denseBincount: input `+`dtype must be int32, but got ${o.dtype}`));m(o.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got `+`rank ${o.rank}.`));m(e>=0,(()=>`size must be non-negative, but got ${e}.`));m(r.size===o.size||r.size===0,(()=>`Error in denseBincount: weights must have the same shape as x or `+`0-length, but got x shape: ${o.shape}, weights shape: `+`${r.shape}.`));const i={x:o,weights:r};const c={size:e,binaryOutput:s};return $r.runKernel(Jt,i,c)}const su=Fr({denseBincount_:eu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(t,n,e="NHWC"){const s=Ir(t,"x","depthToSpace","float32");const o=e==="NHWC"?s.shape[1]:s.shape[2];const r=e==="NHWC"?s.shape[2]:s.shape[3];const i=e==="NHWC"?s.shape[3]:s.shape[1];m(n>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`));m(o*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n}  for depthToSpace with input shape\n    ${s.shape}`));m(r*n>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${n} for depthToSpace with input shape\n        ${s.shape}`));m(i%(n*n)===0,(()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${s.shape}`));const c={x:s};const a={blockSize:n,dataFormat:e};return $r.runKernel(Yt,c,a)}const ru=Fr({depthToSpace_:ou});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iu(t,n,e,s,o="NHWC",r=[1,1],i){const c=Ir(t,"x","depthwiseConv2d","float32");const a=Ir(n,"filter","depthwiseConv2d","float32");let u=c;let l=false;if(c.rank===3){l=true;u=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2]])}m(u.rank===4,(()=>`Error in depthwiseConv2d: input must be rank 4, but got `+`rank ${u.rank}.`));m(a.rank===4,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank `+`${a.rank}.`));const f=o==="NHWC"?u.shape[3]:u.shape[1];m(f===a.shape[2],(()=>`Error in depthwiseConv2d: number of input channels `+`(${f}) must match the inChannels dimension in `+`filter ${a.shape[2]}.`));Gc("depthwiseConv2d",s,i);const h={x:u,filter:a};const d={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i};const p=$r.runKernel(Zt,h,d);if(l){return Hc(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}const cu=Fr({depthwiseConv2d_:iu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function au(t,n,e,s,o=[1,1],r="NHWC"){const i=Ir(t,"x","dilation2d");const c=Ir(n,"filter","dilation2d");m(i.rank===3||i.rank===4,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank `+`${i.rank}.`));m(c.rank===3,(()=>`Error in dilation2d: filter must be rank 3, but got rank `+`${c.rank}.`));m(r==="NHWC",(()=>`Error in dilation2d: Only NHWC is currently supported, `+`but got dataFormat of ${r}`));let a=i;let u=false;if(i.rank===3){a=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2]]);u=true}m(a.shape[3]===c.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${a.shape[3]} vs ${c.shape[2]}`));const l={x:a,filter:c};const f={strides:e,pad:s,dilations:o};const h=$r.runKernel(en,l,f);if(u){return Hc(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}const uu=Fr({dilation2d_:au});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lu(t,n){const e=t.length;const s=[];for(let o=0;o<e;o++){const r=e-1-o;const i=t[r]||1;const c=n[n.length-1-o]||1;if(c>1&&i===1){s.unshift(r)}}return s}function fu(t,n){const e=[];for(let s=0;s<n.length;s++){const o=t[t.length-s-1];const r=n.length-s-1;const i=n[r];if(o==null||o===1&&i>1){e.unshift(r)}}return e}function hu(t,n){const e=Math.max(t.length,n.length);const s=new Array(e);for(let o=0;o<e;o++){let r=t[t.length-o-1];if(r==null){r=1}let i=n[n.length-o-1];if(i==null){i=1}if(r===1){s[e-o-1]=i}else if(i===1){s[e-o-1]=r}else if(r!==i){const e=`Operands could not be broadcast together with shapes `+`${t} and ${n}.`;throw Error(e)}else{s[e-o-1]=r}}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(t,n){let e=Ir(t,"a","equal","string_or_numeric");let s=Ir(n,"b","equal","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(hn,o)}const pu=Fr({equal_:du});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(t,n,e){const s=Ir(n,"a","where");const o=Ir(e,"b","where");const r=Ir(t,"condition","where","bool");const i=hu(hu(r.shape,s.shape),o.shape);const c=va(r,i);const a=va(s,i);const u=va(o,i);const l={condition:c,t:a,e:u};return $r.runKernel(Me,l)}const xu=Fr({where_:mu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bu(t){const n=Ir(t,"x","zerosLike");const e={x:n};return $r.runKernel(xs,e)}const gu=Fr({zerosLike_:bu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wu(t,n){let e=Ir(t,"a","div");let s=Ir(n,"b","div");[e,s]=hr(e,s);const o=Zi(e,s);const r=gu(o);const i=pu(s,r);return xu(i,r,o)}const vu=Fr({divNoNan_:wu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $u(t,n){const e=Ir(t,"t1","dot");const s=Ir(n,"t2","dot");m((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks `+`${e.rank} and ${s.rank}.`));const o=e.rank===1?e.size:e.shape[1];const r=s.rank===1?s.size:s.shape[0];m(o===r,(()=>`Error in dot: inner dimensions of inputs must match, but got `+`${o} and ${r}.`));if(e.rank===1&&s.rank===1){const t=Hc(e,[1,-1]);const n=Hc(s,[-1,1]);const o=Qc(t,n);return Hc(o,[])}else if(e.rank===1&&s.rank===2){const t=Hc(e,[1,-1]);const n=Hc(s,[s.shape[0],s.shape[1]]);const o=Qc(t,n);return Hc(o,[o.size])}else if(e.rank===2&&s.rank===1){const t=Hc(s,[-1,1]);const n=Qc(e,t);return Hc(n,[n.size])}else{const t=Hc(s,[s.shape[0],s.shape[1]]);const n=Qc(e,t);return n}}const yu=Fr({dot_:$u});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(t,...n){const e=n.map(((t,n)=>Ir(t,`tensors${n}`,"einsum")));const s={equation:t};return $r.runKernel(an,e,s)}const Cu=Fr({einsum_:ku});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(t){const n=Ir(t,"x","elu","float32");const e={x:n};return $r.runKernel(un,e)}const Ru=Fr({elu_:Nu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(t){let n=Ir(t,"x","erf");m(n.dtype==="int32"||n.dtype==="float32",(()=>"Input dtype must be `int32` or `float32`."));if(n.dtype==="int32"){n=Mi(n,"float32")}const e={x:n};return $r.runKernel(fn,e)}const Eu=Fr({erf_:Su});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(t,n){for(let e=0;e<t.length;++e){if(t[t.length-e-1]!==n-1-e){return false}}return true}function Iu(t,n,e){const s=t.length+n.length;const o=[];let r=0;let i=0;for(let c=0;c<s;c++){if(e.indexOf(c)===-1){o.push(t[r++])}else{o.push(n[i++])}}return o}function Au(t,n){const e=[];const s=t.length;for(let o=0;o<s;o++){if(n.indexOf(o)===-1){e.push(t[o])}}const o=n.map((n=>t[n]));return[e,o]}function Ou(t,n){const e=n.map((t=>1));return Iu(t,e,n)}function Fu(t,n,e){m(Tu(n,e),(()=>`${t} supports only inner-most axes for now. `+`Got axes ${n} and rank-${e} input.`))}function _u(t,n){if(Tu(t,n)){return null}const e=[];for(let s=0;s<n;++s){if(t.indexOf(s)===-1){e.push(s)}}t.forEach((t=>e.push(t)));return e}function Mu(t){return t.map(((t,n)=>[n,t])).sort(((t,n)=>t[1]-n[1])).map((t=>t[0]))}function Du(t,n){const e=[];for(let s=n-t;s<n;++s){e.push(s)}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lu(t,n=null,e=false){const s=Ir(t,"x","max");const o={x:s};const r={reductionIndices:n,keepDims:e};return $r.runKernel(Un,o,r)}const zu=Fr({max_:Lu});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(t,n=null,e=false){const s=Ir(t,"x","min");const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(Zn,o,r)}const Vu=Fr({min_:Pu});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bu(t,n){let e=Ir(t,"base","pow");let s=Ir(n,"exp","pow");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(de,o)}const Wu=Fr({pow_:Bu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gu(t,n){if((Oo(t)&&n!=="string"||Array.isArray(t))&&n!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive "+"(number|boolean|string)")}if(n==="string"&&Oo(t)&&!(t instanceof Uint8Array)){throw new Error("When making a scalar from encoded string, "+"the value must be `Uint8Array`.")}const e=[];const s=[];return Dr(t,e,s,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uu(t){const n=Ir(t,"x","sqrt","float32");const e={x:n};return $r.runKernel(Ge,e)}const Hu=Fr({sqrt_:Uu});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ju(t){const n=Ir(t,"x","square");const e={};return $r.runKernel("Square",{x:n},e)}const qu=Fr({square_:ju});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xu(t,n=null,e=false){let s=Ir(t,"x","sum");if(s.dtype==="bool"){s=Mi(s,"int32")}const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(Ue,o,r)}const Ku=Fr({sum_:Xu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(t,n="euclidean",e=null,s=false){t=Ir(t,"x","norm");const o=Yu(t,n,e);let r=o.shape;if(s){const n=N(e,t.shape);r=Ou(o.shape,n)}return Hc(o,r)}function Yu(t,n,e=null){if(t.rank===0){return ec(t)}if(t.rank!==1&&e===null){return Yu(Hc(t,[-1]),n,e)}if(t.rank===1||typeof e==="number"||Array.isArray(e)&&e.length===1){if(n===1){return Ku(ec(t),e)}if(n===Infinity){return zu(ec(t),e)}if(n===-Infinity){return Vu(ec(t),e)}if(n==="euclidean"||n===2){return Hu(Ku(Wu(ec(t),Gu(2,"int32")),e))}throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&e.length===2){if(n===1){return zu(Ku(ec(t),e[0]),e[1]-1)}if(n===Infinity){return zu(Ku(ec(t),e[1]),e[0])}if(n===-Infinity){return Vu(Ku(ec(t),e[1]),e[0])}if(n==="fro"||n==="euclidean"){return Hu(Ku(qu(t),e))}throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Zu=Fr({norm_:Ju});
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(t,n=null,e=false){return Zu(t,"euclidean",n,e)}const tl=Fr({euclideanNorm_:Qu});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(t){const n=Ir(t,"x","exp");const e={x:n};return $r.runKernel(dn,e)}const el=Fr({exp_:nl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(t,n=0){const e=Ir(t,"x","expandDims","string_or_numeric");m(n<=e.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:e};const o={dim:n};return $r.runKernel(pn,s,o)}const ol=Fr({expandDims_:sl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(t){const n=Ir(t,"x","expm1");const e={x:n};return $r.runKernel(mn,e)}const il=Fr({expm1_:rl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(t,n){const e=Ir(t,"x","tile","string_or_numeric");m(e.rank===n.length,(()=>`Error in transpose: rank of input ${e.rank} `+`must match length of reps ${n}.`));const s={x:e};const o={reps:n};return $r.runKernel(us,s,o)}const al=Fr({tile_:cl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(t,n,e,s="float32"){if(n==null){n=t}const o=Fi([t,n],s);const r=t<=n?t:n;for(let t=0;t<r;++t){o.set(1,t,t)}const i=Hc(o.toTensor(),[t,n]);if(e==null){return i}else{if(e.length===1){return al(ol(i,0),[e[0],1,1])}else if(e.length===2){return al(ol(ol(i,0),0),[e[0],e[1],1,1])}else if(e.length===3){return al(ol(ol(ol(i,0),0),0),[e[0],e[1],e[2],1,1])}else{throw new Error(`eye() currently supports only 1D and 2D `+`batchShapes, but received ${e.length}D.`)}}}const ll=Fr({eye_:ul});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fl(t){const n=Ir(t,"x","floor","float32");const e={x:n};return $r.runKernel(wn,e)}const hl=Fr({floor_:fl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(t,n,e=0,s=0){const o=Ir(t,"x","gather");const r=Ir(n,"indices","gather","int32");const i={x:o,indices:r};const c={axis:e,batchDims:s};return $r.runKernel(yn,i,c)}const pl=Fr({gather_:dl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(t,n){let e=Ir(t,"a","greater","string_or_numeric");let s=Ir(n,"b","greater","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Cn,o)}const xl=Fr({greater_:ml});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(t,n){let e=Ir(t,"a","greaterEqual","string_or_numeric");let s=Ir(n,"b","greaterEqual","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Nn,o)}const gl=Fr({greaterEqual_:bl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(t){const n=Ir(t,"input","imag");const e={input:n};return $r.runKernel(En,e)}const vl=Fr({imag_:wl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $l(t){const n=Ir(t,"x","isFinite");const e={x:n};return $r.runKernel(Tn,e)}const yl=Fr({isFinite_:$l});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t){const n=Ir(t,"x","isInf");const e={x:n};return $r.runKernel(In,e)}const Cl=Fr({isInf_:kl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nl(t){const n=Ir(t,"x","isNaN");const e={x:n};return $r.runKernel(An,e)}const Rl=Fr({isNaN_:Nl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(t,n=.2){const e=Ir(t,"x","leakyRelu");const s={x:e};const o={alpha:n};return $r.runKernel(On,s,o)}const El=Fr({leakyRelu_:Sl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(t,n){let e=Ir(t,"a","less","string_or_numeric");let s=Ir(n,"b","less","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Fn,o)}const Il=Fr({less_:Tl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(t,n){let e=Ir(t,"a","lessEqual","string_or_numeric");let s=Ir(n,"b","lessEqual","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(_n,o)}const Ol=Fr({lessEqual_:Al});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(t,n=5,e=1,s=1,o=.5){const r=Ir(t,"x","localResponseNormalization");m(r.rank===4||r.rank===3,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${r.rank}.`));m(v(n),(()=>`Error in localResponseNormalization: depthRadius must be an `+`integer but got depthRadius ${n}.`));let i=r;let c=false;if(r.rank===3){c=true;i=Hc(r,[1,r.shape[0],r.shape[1],r.shape[2]])}const a={x:i};const u={depthRadius:n,bias:e,alpha:s,beta:o};const l=$r.runKernel(Wn,a,u);if(c){return Hc(l,[l.shape[1],l.shape[2],l.shape[3]])}else{return l}}const _l=Fr({localResponseNormalization_:Fl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(t){const n=Ir(t,"x","log","float32");const e={x:n};return $r.runKernel(Dn,e)}const Dl=Fr({log_:Ml});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ll(t){const n=Ir(t,"x","log1p");const e={x:n};return $r.runKernel(Ln,e)}const zl=Fr({log1p_:Ll});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pl(t,n){m(z(t),(()=>"The f passed in variableGrads(f) must be a function"));m(n==null||Array.isArray(n)&&n.every((t=>t instanceof nr)),(()=>"The varList passed in variableGrads(f, varList) must be an array "+"of variables"));const e=n!=null;if(!e){n=[];for(const t in $r.registeredVariables){n.push($r.registeredVariables[t])}}const s=e?n.filter((t=>!t.trainable)):null;const o=n.length;n=n.filter((t=>t.trainable));m(n.length>0,(()=>`variableGrads() expects at least one of the input variables to `+`be trainable, but none of the ${o} variables is `+`trainable.`));const r=true;const{value:i,grads:c}=$r.gradients(t,n,null,r);m(c.some((t=>t!=null)),(()=>"Cannot find a connection between any variable and the result of "+"the loss function y=f(x). Please make sure the operations that "+"use variables are inside the function f passed to minimize()."));m(i.rank===0,(()=>`The f passed in variableGrads(f) must return a scalar, but it `+`returned a rank-${i.rank} tensor`));const a={};n.forEach(((t,n)=>{if(c[n]!=null){a[t.name]=c[n]}}));if(s!=null){s.forEach((t=>a[t.name]=null))}return{value:i,grads:a}}function Vl(t){return $r.customGrad(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bl(t){const n=Ir(t,"x","neg");const e={x:n};return $r.runKernel(oe,e)}const Wl=Fr({neg_:Bl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gl(t){const n=Ir(t,"x","softplus");const e={x:n};return $r.runKernel(We,e)}const Ul=Fr({softplus_:Gl});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(t){const n=Ir(t,"x","logSigmoid");const e=Vl((t=>{const n=Wl(Ul(Wl(t)));const e=n=>{const e=tc(n,na(Wl(t)));return e};return{value:n,gradFunc:e}}));return e(n)}const jl=Fr({logSigmoid_:Hl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ql(t,n){let e=Ir(t,"a","sub");let s=Ir(n,"b","sub");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(is,o)}const Xl=Fr({sub_:ql});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kl(t,n=-1){const e=Ir(t,"logits","logSoftmax");if(n===-1){n=e.rank-1}if(n!==e.rank-1){throw Error("Log Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${e.rank} and axis was ${n}`)}const s=Vl(((t,e)=>{const s=true;const o=zu(t,n,true);const r=Xl(t,o);const i=Xl(Mi(r,"float32"),Dl(Ku(el(r),n,s)));e([i]);const c=(t,e)=>{const[s]=e;const o=true;const r=el(s);return Xl(t,tc(Ku(t,n,o),r))};return{value:i,gradFunc:c}}));return s(e)}const Jl=Fr({logSoftmax_:Kl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yl(t,n=null,e=false){const s=Ir(t,"x","logSumExp");const o=N(n,s.shape);const r=zu(s,o,true);const i=Xl(s,r);const c=el(i);const a=Ku(c,o);const u=Dl(a);const l=Xi(Hc(r,u.shape),u);if(e){const t=Ou(l.shape,o);return Hc(l,t)}return l}const Zl=Fr({logSumExp_:Yl});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(t,n){const e=Ir(t,"a","logicalAnd","bool");const s=Ir(n,"b","logicalAnd","bool");hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(zn,o)}const tf=Fr({logicalAnd_:Ql});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nf(t){const n=Ir(t,"x","logicalNot","bool");const e={x:n};return $r.runKernel(Pn,e)}const ef=Fr({logicalNot_:nf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sf(t,n){const e=Ir(t,"a","logicalOr","bool");const s=Ir(n,"b","logicalOr","bool");hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Vn,o)}const of=Fr({logicalOr_:sf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rf(t,n){const e=Ir(t,"a","logicalXor","bool");const s=Ir(n,"b","logicalXor","bool");hu(e.shape,s.shape);return tf(of(t,n),ef(tf(t,n)))}const cf=Fr({logicalXor_:rf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function af(t,n,e,s,o){const r=Ir(t,"x","maxPool");const i=1;let c=r;let a=false;if(r.rank===3){a=true;c=Hc(r,[1,r.shape[0],r.shape[1],r.shape[2]])}m(c.rank===4,(()=>`Error in maxPool: input must be rank 4 but got rank ${c.rank}.`));m(Vc(e,i),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${i}'`));Gc("maxPool",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o};const f=$r.runKernel(jn,u,l);if(a){return Hc(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const uf=Fr({maxPool_:af});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(t,n=[1,1,1],e,s,o,r="NDHWC"){const i=Ir(t,"x","maxPool3d");let c=i;let a=false;if(i.rank===4){a=true;c=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}m(c.rank===5,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${c.rank}.`));m(r==="NDHWC",(()=>`Error in maxPool3d: Only NDHWC is currently supported, `+`but got dataFormat of ${r}`));Gc("maxPool3d",s,o);const u={x:c};const l={filterSize:n,strides:e,pad:s,dimRoundingMode:o,dataFormat:r};const f=$r.runKernel(Xn,u,l);if(a){return Hc(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const ff=Fr({maxPool3d_:lf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hf(t,n){let e=Ir(t,"a","maximum");let s=Ir(n,"b","maximum");[e,s]=hr(e,s);if(e.dtype==="bool"){e=Mi(e,"int32");s=Mi(s,"int32")}hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Hn,o)}const df=Fr({maximum_:hf});
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(t,n=null,e=false){const s=Ir(t,"x","mean");const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(Yn,o,r)}const mf=Fr({mean_:pf});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xf(t,n="float32"){q(t);if(n==="complex64"){const n=xf(t,"float32");const e=xf(t,"float32");return Mr(n,e)}const e=H(g(t),n);return $r.makeTensor(e,t,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(t,n="float32"){q(t);if(n==="complex64"){const n=bf(t,"float32");const e=xf(t,"float32");return Mr(n,e)}const e=U(g(t),n);return $r.makeTensor(e,t,n)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gf(t,n){let e=Ir(t,"a","minimum");let s=Ir(n,"b","minimum");[e,s]=hr(e,s);if(e.dtype==="bool"){e=Mi(e,"int32");s=Mi(s,"int32")}hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(Qn,o)}const wf=Fr({minimum_:gf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vf(t,n,e){m(e==="reflect"||e==="symmetric",(()=>`Invalid mode. Mode must be either reflect or symmetric. `+`Got ${e}.`));const s=Ir(t,"x","mirrorPad");if(s.rank===0){throw new Error("mirrorPad(scalar) is not defined. "+"Pass non-scalar to mirrorPad")}m(n.length===s.rank,(()=>`Padding doesn't match input. Must be ${s.rank}. `+`Got ${n.length}.`));const o=e==="reflect"?1:0;for(let t=0;t<s.rank;t++){m(n[t].length===2,(()=>`Invalid number of paddings. Must be length of 2 each.`));m(n[t][0]>=0&&n[t][0]<=s.shape[t]-o&&n[t][1]>=0&&n[t][1]<=s.shape[t]-o,(()=>`Padding in dimension ${t} cannot be greater than or equal `+`to ${s.shape[t]-o} or less than 0 for input of `+`shape ${s.shape}`))}const r={paddings:n,mode:e};const i={x:s};return $r.runKernel(te,i,r)}const $f=Fr({mirrorPad_:vf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(t,n){let e=Ir(t,"a","mod");let s=Ir(n,"b","mod");[e,s]=hr(e,s);const o={a:e,b:s};return $r.runKernel(ne,o)}const kf=Fr({mod_:yf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cf(t,n=null,e=false){t=Ir(t,"x","moments");const s=N(n,t.shape);const o=mf(t,s,e);let r=o.shape;if(!e){r=Ou(o.shape,s)}const i=qu(Xl(Mi(t,"float32"),Hc(o,r)));const c=mf(i,s,e);return{mean:o,variance:c}}const Nf=Fr({moments_:Cf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(t,n){let e=Ir(t,"a","notEqual","string_or_numeric");let s=Ir(n,"b","notEqual","string_or_numeric");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};return $r.runKernel(re,o)}const Sf=Fr({notEqual_:Rf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ef(t,n,e=1,s=0,o="int32"){if(n<2){throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`)}const r=Ir(t,"indices","oneHot","int32");const i={indices:r};const c={dtype:o,depth:n,onValue:e,offValue:s};return $r.runKernel(le,i,c)}const Tf=Fr({oneHot_:Ef});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function If(t){const n=Ir(t,"x","onesLike");const e={x:n};return $r.runKernel(ue,e)}const Af=Fr({onesLike_:If});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(t,n,e=0){const s=Ir(t,"x","pad");if(s.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}const o={paddings:n,constantValue:e};const r={x:s};return $r.runKernel(he,r,o)}const Ff=Fr({pad_:Of});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _f(t,n,e){const s=Ir(t,"x","spaceToBatchND");m(s.rank>=1+n.length,(()=>`input rank ${s.rank} should be > than [blockShape] ${n.length}`));m(e.length===n.length,(()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`));m(s.shape.reduce(((t,s,o)=>{if(o>0&&o<=n.length){return t&&(s+e[o-1][0]+e[o-1][1])%n[o-1]===0}return t}),true),(()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`));const o={x:s};const r={blockShape:n,paddings:e};return $r.runKernel(He,o,r)}const Mf=Fr({spaceToBatchND_:_f});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Df(t,n,e,s,o,r,i){if(o==null){o=[1,1]}if(r==null){r=1}if(s===0){s="valid"}const c=Ir(t,"x","maxPool");let a=c;let u=false;if(c.rank===3){u=true;a=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2]])}m(Vc(r,o),(()=>"Error in pool: Either strides or dilations must be 1. "+`Got strides ${r} and dilations '${o}'`));const l=Rc(a.shape,n,r,o,s);const f=[l.dilationHeight,l.dilationWidth];let h;if(s==="same"){h=zf([l.filterHeight,l.filterWidth],f)}else{h=[[0,0],[0,0]]}const d=f[0]===1&&f[1]===1;const[p,x]=Lf([l.inHeight,l.inWidth],f,h);const b=d?s:"valid";const g=d?a:Mf(a,f,p);const w=e==="avg"?()=>qc(g,n,r,b,i):()=>uf(g,n,r,b,i);const v=w();const $=d?v:ca(v,f,x);if(u){return Hc($,[$.shape[1],$.shape[2],$.shape[3]])}return $}function Lf(t,n,e){const s=e.map((t=>t[0]));const o=e.map((t=>t[1]));const r=t.concat(s,o);const i=n.map(((t,n)=>(t-r[n]%t)%t));const c=o.map(((t,n)=>t+i[n]));const a=n.map(((t,n)=>[s[n],c[n]]));const u=n.map(((t,n)=>[0,i[n]]));return[a,u]}function zf(t,n){const e=t.map(((t,e)=>t+(t-1)*(n[e]-1)));const s=e.map((t=>t-1));const o=s.map((t=>Math.floor(t/2)));const r=s.map(((t,n)=>t-o[n]));return s.map(((t,n)=>[o[n],r[n]]))}const Pf=Fr({pool_:Df});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(t,n){const e=Ir(t,"x","prelu");const s=Ir(n,"alpha","prelu");const o={x:e,alpha:s};return $r.runKernel(pe,o)}const Bf=Fr({prelu_:Vf});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wf(t,n=null,e=false){let s=Ir(t,"x","prod");if(s.dtype==="bool"){s=Mi(s,"int32")}const o={x:s};const r={axis:n,keepDims:e};return $r.runKernel(me,o,r)}const Gf=Fr({prod_:Wf});var Uf=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};function Hf(t,n,e){return e={path:n,exports:{},require:function(t,n){return qf()}},t(e,e.exports),e.exports}function jf(t){if(t.__esModule)return t;var n=Object.defineProperty({},"__esModule",{value:true});Object.keys(t).forEach((function(e){var s=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(n,e,s.get?s:{enumerable:true,get:function(){return t[e]}})}));return n}function qf(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var Xf=Hf((function(t){(function(t,n,e){function s(t){var n=this,e=i();n.next=function(){var t=2091639*n.s0+n.c*2.3283064365386963e-10;n.s0=n.s1;n.s1=n.s2;return n.s2=t-(n.c=t|0)};n.c=1;n.s0=e(" ");n.s1=e(" ");n.s2=e(" ");n.s0-=e(t);if(n.s0<0){n.s0+=1}n.s1-=e(t);if(n.s1<0){n.s1+=1}n.s2-=e(t);if(n.s2<0){n.s2+=1}e=null}function o(t,n){n.c=t.c;n.s0=t.s0;n.s1=t.s1;n.s2=t.s2;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=e.next;i.int32=function(){return e.next()*4294967296|0};i.double=function(){return i()+(i()*2097152|0)*11102230246251565e-32};i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}function i(){var t=4022871197;var n=function(n){n=String(n);for(var e=0;e<n.length;e++){t+=n.charCodeAt(e);var s=.02519603282416938*t;t=s>>>0;s-=t;s*=t;t=s>>>0;s-=t;t+=s*4294967296}return(t>>>0)*2.3283064365386963e-10};return n}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.alea=r}})(Uf,t,typeof undefined=="function")}));var Kf=Hf((function(t){(function(t,n,e){function s(t){var n=this,e="";n.x=0;n.y=0;n.z=0;n.w=0;n.next=function(){var t=n.x^n.x<<11;n.x=n.y;n.y=n.z;n.z=n.w;return n.w^=n.w>>>19^t^t>>>8};if(t===(t|0)){n.x=t}else{e+=t}for(var s=0;s<e.length+64;s++){n.x^=e.charCodeAt(s)|0;n.next()}}function o(t,n){n.x=t.x;n.y=t.y;n.z=t.z;n.w=t.w;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.xor128=r}})(Uf,t,typeof undefined=="function")}));var Jf=Hf((function(t){(function(t,n,e){function s(t){var n=this,e="";n.next=function(){var t=n.x^n.x>>>2;n.x=n.y;n.y=n.z;n.z=n.w;n.w=n.v;return(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^(t^t<<1))|0};n.x=0;n.y=0;n.z=0;n.w=0;n.v=0;if(t===(t|0)){n.x=t}else{e+=t}for(var s=0;s<e.length+64;s++){n.x^=e.charCodeAt(s)|0;if(s==e.length){n.d=n.x<<10^n.x>>>4}n.next()}}function o(t,n){n.x=t.x;n.y=t.y;n.z=t.z;n.w=t.w;n.v=t.v;n.d=t.d;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.xorwow=r}})(Uf,t,typeof undefined=="function")}));var Yf=Hf((function(t){(function(t,n,e){function s(t){var n=this;n.next=function(){var t=n.x,e=n.i,s,o;s=t[e];s^=s>>>7;o=s^s<<24;s=t[e+1&7];o^=s^s>>>10;s=t[e+3&7];o^=s^s>>>3;s=t[e+4&7];o^=s^s<<7;s=t[e+7&7];s=s^s<<13;o^=s^s<<9;t[e]=o;n.i=e+1&7;return o};function e(t,n){var e,s=[];if(n===(n|0)){s[0]=n}else{n=""+n;for(e=0;e<n.length;++e){s[e&7]=s[e&7]<<15^n.charCodeAt(e)+s[e+1&7]<<13}}while(s.length<8)s.push(0);for(e=0;e<8&&s[e]===0;++e);if(e==8)s[7]=-1;t.x=s;t.i=0;for(e=256;e>0;--e){t.next()}}e(n,t)}function o(t,n){n.x=t.x.slice();n.i=t.i;return n}function r(t,n){if(t==null)t=+new Date;var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(r.x)o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.xorshift7=r}})(Uf,t,typeof undefined=="function")}));var Zf=Hf((function(t){(function(t,n,e){function s(t){var n=this;n.next=function(){var t=n.w,e=n.X,s=n.i,o,r;n.w=t=t+1640531527|0;r=e[s+34&127];o=e[s=s+1&127];r^=r<<13;o^=o<<17;r^=r>>>15;o^=o>>>12;r=e[s]=r^o;n.i=s;return r+(t^t>>>16)|0};function e(t,n){var e,s,o,r,i,c=[],a=128;if(n===(n|0)){s=n;n=null}else{n=n+"\0";s=0;a=Math.max(a,n.length)}for(o=0,r=-32;r<a;++r){if(n)s^=n.charCodeAt((r+32)%n.length);if(r===0)i=s;s^=s<<10;s^=s>>>15;s^=s<<4;s^=s>>>13;if(r>=0){i=i+1640531527|0;e=c[r&127]^=s+i;o=0==e?o+1:0}}if(o>=128){c[(n&&n.length||0)&127]=-1}o=127;for(r=4*128;r>0;--r){s=c[o+34&127];e=c[o=o+1&127];s^=s<<13;e^=e<<17;s^=s>>>15;e^=e>>>12;c[o]=s^e}t.w=i;t.X=c;t.i=o}e(n,t)}function o(t,n){n.i=t.i;n.w=t.w;n.X=t.X.slice();return n}function r(t,n){if(t==null)t=+new Date;var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(r.X)o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.xor4096=r}})(Uf,t,typeof undefined=="function")}));var Qf=Hf((function(t){(function(t,n,e){function s(t){var n=this,e="";n.next=function(){var t=n.b,e=n.c,s=n.d,o=n.a;t=t<<25^t>>>7^e;e=e-s|0;s=s<<24^s>>>8^o;o=o-t|0;n.b=t=t<<20^t>>>12^e;n.c=e=e-s|0;n.d=s<<16^e>>>16^o;return n.a=o-t|0};n.a=0;n.b=0;n.c=2654435769|0;n.d=1367130551;if(t===Math.floor(t)){n.a=t/4294967296|0;n.b=t|0}else{e+=t}for(var s=0;s<e.length+20;s++){n.b^=e.charCodeAt(s)|0;n.next()}}function o(t,n){n.a=t.a;n.b=t.b;n.c=t.c;n.d=t.d;return n}function r(t,n){var e=new s(t),r=n&&n.state,i=function(){return(e.next()>>>0)/4294967296};i.double=function(){do{var t=e.next()>>>11,n=(e.next()>>>0)/4294967296,s=(t+n)/(1<<21)}while(s===0);return s};i.int32=e.next;i.quick=i;if(r){if(typeof r=="object")o(r,e);i.state=function(){return o(e,{})}}return i}if(n&&n.exports){n.exports=r}else if(e&&e.amd){e((function(){return r}))}else{this.tychei=r}})(Uf,t,typeof undefined=="function")}));const th={};const nh=Object.freeze({__proto__:null,default:th});const eh=jf(nh);var sh=Hf((function(t){(function(n,e,s){var o=256,r=6,i=52,c="random",a=s.pow(o,r),u=s.pow(2,i),l=u*2,f=o-1,h;function d(t,n,i){var f=[];n=n==true?{entropy:true}:n||{};var h=b(x(n.entropy?[t,w(e)]:t==null?g():t,3),f);var d=new p(f);var v=function(){var t=d.g(r),n=a,e=0;while(t<u){t=(t+e)*o;n*=o;e=d.g(1)}while(t>=l){t/=2;n/=2;e>>>=1}return(t+e)/n};v.int32=function(){return d.g(4)|0};v.quick=function(){return d.g(4)/4294967296};v.double=v;b(w(d.S),e);return(n.pass||i||function(t,n,e,o){if(o){if(o.S){m(o,d)}t.state=function(){return m(d,{})}}if(e){s[c]=t;return n}else return t})(v,h,"global"in n?n.global:this==s,n.state)}function p(t){var n,e=t.length,s=this,r=0,i=s.i=s.j=0,c=s.S=[];if(!e){t=[e++]}while(r<o){c[r]=r++}for(r=0;r<o;r++){c[r]=c[i=f&i+t[r%e]+(n=c[r])];c[i]=n}(s.g=function(t){var n,e=0,r=s.i,i=s.j,c=s.S;while(t--){n=c[r=f&r+1];e=e*o+c[f&(c[r]=c[i=f&i+n])+(c[i]=n)]}s.i=r;s.j=i;return e})(o)}function m(t,n){n.i=t.i;n.j=t.j;n.S=t.S.slice();return n}function x(t,n){var e=[],s=typeof t,o;if(n&&s=="object"){for(o in t){try{e.push(x(t[o],n-1))}catch(t){}}}return e.length?e:s=="string"?t:t+"\0"}function b(t,n){var e=t+"",s,o=0;while(o<e.length){n[f&o]=f&(s^=n[f&o]*19)+e.charCodeAt(o++)}return w(n)}function g(){try{var t;if(h&&(t=h.randomBytes)){t=t(o)}else{t=new Uint8Array(o);(n.crypto||n.msCrypto).getRandomValues(t)}return w(t)}catch(t){var s=n.navigator,r=s&&s.plugins;return[+new Date,n,r,n.screen,w(e)]}}function w(t){return String.fromCharCode.apply(0,t)}b(s.random(),e);if(t.exports){t.exports=d;try{h=eh}catch(t){}}else{s["seed"+c]=d}})(typeof self!=="undefined"?self:Uf,[],Math)}));sh.alea=Xf;sh.xor128=Kf;sh.xorwow=Jf;sh.xorshift7=Yf;sh.xor4096=Zf;sh.tychei=Qf;var oh=sh;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rh{constructor(t,n,e,s,o){this.mean=t;this.stdDev=n;this.dtype=e;this.nextVal=NaN;this.truncated=s;if(this.truncated){this.upper=this.mean+this.stdDev*2;this.lower=this.mean-this.stdDev*2}const r=o?o:Math.random();this.random=oh.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;this.nextVal=NaN;return t}let t,n;let e=false;while(!e){let s,o,r;do{s=2*this.random()-1;o=2*this.random()-1;r=s*s+o*o}while(r>=1||r===0);const i=Math.sqrt(-2*Math.log(r)/r);t=this.mean+this.stdDev*s*i;n=this.mean+this.stdDev*o*i;if(!this.truncated||this.isValidTruncated(t)){e=true}}if(!this.truncated||this.isValidTruncated(n)){this.nextVal=this.convertValue(n)}return this.convertValue(t)}convertValue(t){if(this.dtype==null||this.dtype==="float32"){return t}return Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class ih{constructor(t=0,n=1,e,s){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";this.min=t;this.range=n-t;this.dtype=e;if(s==null){s=Math.random()}if(typeof s==="number"){s=s.toString()}if(!this.canReturnFloat()&&this.range<=1){throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`)}this.random=oh.alea(s)}convertValue(t){if(this.canReturnFloat()){return t}return Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ch(t,n=0,e=1,s,o){q(t);if(s!=null&&s==="bool"){throw new Error(`Unsupported data type ${s}`)}const r=new rh(n,e,s,false,o);const i=Fi(t,s);for(let t=0;t<i.values.length;t++){i.values[t]=r.nextValue()}return i.toTensor()}const ah=Fr({randomNormal_:ch});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(t,n=0,e=1,s="float32",o){q(t);const r=Fi(t,s);const i=new ih(n,e,null,o);for(let t=0;t<r.values.length;t++){r.values[t]=i.nextValue()}return r.toTensor()}const lh=Fr({randomUniform_:uh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fh(t,n,e=1,s="float32"){if(e===0){throw new Error("Cannot have a step of zero")}const o={start:t,stop:n,step:e,dtype:s};return $r.runKernel(we,{},o)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(t){const n=Ir(t,"input","real");const e={input:n};return $r.runKernel(ve,e)}const dh=Fr({real_:hh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ph(t){const n=Ir(t,"x","reciprocal");const e={x:n};return $r.runKernel($e,e)}const mh=Fr({reciprocal_:ph});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xh(t){const n=Ir(t,"x","relu");const e={x:n};return $r.runKernel(ye,e)}const bh=Fr({relu_:xh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gh(t){const n=Ir(t,"x","relu6");const e={x:n};return $r.runKernel(Ee,e)}const wh=Fr({relu6_:gh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vh(t,n){const e=Ir(t,"x","reverse");const s={x:e};const o={dims:n};return $r.runKernel(Te,s,o)}const $h=Fr({reverse_:vh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yh(t){const n=Ir(t,"x","round");const e={x:n};return $r.runKernel(Ie,e)}const kh=Fr({round_:yh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ch(t){const n=Ir(t,"x","rsqrt","float32");const e={x:n};return $r.runKernel(Ae,e)}const Nh=Fr({rsqrt_:Ch});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rh(t){const n=Ir(t,"x","selu");const e={x:n};return $r.runKernel(De,e)}const Sh=Fr({selu_:Rh});function Eh(t,n,e,s,o,r=[1,1],i="NHWC"){const c=Ir(t,"x","separableConv2d");const a=Ir(n,"depthwiseFilter","separableConv2d");const u=Ir(e,"pointwiseFilter","separableConv2d");let l=c;let f=false;if(c.rank===3){f=true;l=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2]])}if(i==="NCHW"){throw new Error("separableConv2d currently does not support dataFormat NCHW; only "+"NHWC is supported")}m(l.rank===4,(()=>`Error in separableConv2d: input must be rank 4, but got `+`rank ${l.rank}.`));m(a.rank===4,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but `+`got rank ${a.rank}.`));m(u.rank===4,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but `+`got rank ${a.rank}.`));m(u.shape[0]===1,(()=>`Error in separableConv2d: the first dimension of pointwise filter `+` must be 1, but got ${u.shape[0]}.`));m(u.shape[1]===1,(()=>`Error in separableConv2d: the second dimension of pointwise `+`filter must be 1, but got ${u.shape[1]}.`));const h=a.shape[2];const d=a.shape[3];m(u.shape[2]===h*d,(()=>`Error in separableConv2d: the third dimension of pointwise filter `+`must be ${h*d}, `+`but got ${u.shape[2]}.`));const p=cu(l,a,s,o,i,r);const x=1;const b=Ma(p,u,x,"valid",i);if(f){return Hc(b,[b.shape[1],b.shape[2],b.shape[3]])}return b}const Th=Fr({separableConv2d_:Eh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ih(t){const n=Ir(t,"x","sign");const e={x:n};return $r.runKernel(Ve,e)}const Ah=Fr({sign_:Ih});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(t){const n=Ir(t,"x","sin","float32");const e={x:n};return $r.runKernel(ze,e)}const Fh=Fr({sin_:Oh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(t){const n=Ir(t,"x","sinh");const e={x:n};return $r.runKernel(Pe,e)}const Mh=Fr({sinh_:_h});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(t,n,e){const s=Ir(t,"x","slice1d");m(s.rank===1,(()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`));return sa(s,[n],[e])}const Lh=Fr({slice1d_:Dh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(t,n,e){const s=Ir(t,"x","slice2d");m(s.rank===2,(()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`));return sa(s,n,e)}const Ph=Fr({slice2d_:zh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vh(t,n,e){const s=Ir(t,"x","slice3d");m(s.rank===3,(()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`));return sa(s,n,e)}const Bh=Fr({slice3d_:Vh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wh(t,n,e){const s=Ir(t,"x","slice4d");m(s.rank===4,(()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`));return sa(s,n,e)}const Gh=Fr({slice4d_:Wh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uh(t,n=-1){const e=Ir(t,"logits","softmax","float32");if(n===-1){n=e.rank-1}if(n!==e.rank-1){throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${e.rank} and dim was ${n}`)}const s={logits:e};const o={dim:n};return $r.runKernel(qe,s,o)}const Hh=Fr({softmax_:Uh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jh(t){m(t.dtype==="complex64",(()=>`The dtype for tf.spectral.fft() must be complex64 `+`but got ${t.dtype}.`));const n={input:t};return $r.runKernel(xn,n)}const qh=Fr({fft_:jh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xh(t){m(t.dtype==="complex64",(()=>`The dtype for tf.spectral.ifft() must be complex64 `+`but got ${t.dtype}.`));const n={input:t};return $r.runKernel(Sn,n)}const Kh=Fr({ifft_:Xh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jh(t){const n=t.shape[t.shape.length-1];const e=t.size/n;let s;if(n<=2){const o=Hc(t,[e,n]);s=Kh(o)}else{const o=[e,2*(n-1)];const r=Hc(dh(t),[e,n]);const i=Hc(vl(t),[e,n]);const c=$h(sa(r,[0,1],[e,n-2]),1);const a=tc($h(sa(i,[0,1],[e,n-2]),1),Gu(-1));const u=Yc([r,c],1);const l=Yc([i,a],1);const f=Hc(Mr(u,l),[o[0],o[1]]);s=Kh(f)}s=dh(s);if(t.rank===3&&t.shape[0]!==0){const n=s;const e=t.shape[0];s=Hc(s,[e,s.shape[0]/e,s.shape[1]]);n.dispose()}return s}const Yh=Fr({irfft_:Jh});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zh(t,n,e=0){const s=Ir(t,"x","split");const o={x:s};const r={numOrSizeSplits:n,axis:e};return $r.runKernel(je,o,r)}const Qh=Fr({split_:Zh});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function td(t,n){m(t.dtype==="float32",(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let e=t.shape[t.shape.length-1];const s=t.size/e;let o;if(n!=null&&n<e){const s=t.shape.map((t=>0));const r=t.shape.map((t=>t));r[t.shape.length-1]=n;o=sa(t,s,r);e=n}else if(n!=null&&n>e){const s=t.shape.map((t=>t));s[t.shape.length-1]=n-e;o=Yc([t,xf(s)],t.shape.length-1);e=n}else{o=t}const r=gu(o);const i=Hc(Mr(o,r),[s,e]);const c=qh(i);const a=Math.floor(e/2)+1;const u=dh(c);const l=vl(c);const f=Qh(u,[a,e-a],u.shape.length-1);const h=Qh(l,[a,e-a],l.shape.length-1);const d=o.shape.slice();d[o.shape.length-1]=a;return Hc(Mr(f[0],h[0]),d)}const nd=Fr({rfft_:td});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ed(t,n){let e=Ir(t,"a","squaredDifference");let s=Ir(n,"b","squaredDifference");[e,s]=hr(e,s);hu(e.shape,s.shape);const o={a:e,b:s};const r={};return $r.runKernel(Qe,o,r)}const sd=Fr({squaredDifference_:ed});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function od(t,n){const e=Ir(t,"x","squeeze","string_or_numeric");return Hc(e,R(e.shape,n).newShape)}const rd=Fr({squeeze_:od});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(t,n=0){const e=Ar(t,"tensors","stack","string_or_numeric");m(e.length>=1,(()=>"Pass at least one tensor to tf.stack"));if(e.length>0){m(n<=e[0].rank,(()=>"Axis must be <= rank of the tensor"))}const s=e;const o={axis:n};return $r.runKernel(fe,s,o)}const cd=Fr({stack_:id});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ad(t,n=0){const e=Ir(t,"x","step");const s={x:e};const o={alpha:n};return $r.runKernel(bs,s,o)}const ud=Fr({step_:ad});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ld(t,n,e,s,o=0,r=0,i=0,c=0,a=0){const u=Ir(t,"x","stridedSlice","string_or_numeric");const l={x:u};const f={begin:n,end:e,strides:s,beginMask:o,endMask:r,ellipsisMask:i,newAxisMask:c,shrinkAxisMask:a};return $r.runKernel(es,l,f)}const fd=Fr({stridedSlice_:ld});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hd(t){const n=Ir(t,"x","tan","float32");const e={x:n};return $r.runKernel(cs,e)}const dd=Fr({tan_:hd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pd(t,n){b(t);const e=Sr(t,n);if(e.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}const s=null;return Dr(t,s,e,n)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function md(t,n,e){b(t);if(n!=null&&n.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}const s=Sr(t,e);if(s.length!==2&&s.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(s.length===1&&n==null){throw new Error("tensor2d() requires shape to be provided when `values` "+"are a flat/TypedArray")}return Dr(t,n,s,e)}function xd(t,n,e){const s=n.rank>1?n.shape[n.rank-1]:1;const o=n.rank>1?n.rank-1:1;const r="Must have updates.shape = indices.shape[:batchDim] + "+`shape[sliceDim:], got updates.shape: ${e.shape}`+`, indices.shape: ${n.shape}, shape: ${t}`+`, sliceDim: ${s}, and batchDim: ${o}.`;if(e.rank<o){throw new Error(r+` update.rank < ${o}. `)}if(t.length<s+(e.rank-o)){throw new Error(r+` Output shape length < ${s+(e.rank-o)}`)}if(e.rank!==o+t.length-s){throw new Error(r+` update.rank != ${o+t.length-s}`)}for(let t=0;t<o;++t){if(e.shape[t]!==n.shape[t]){throw new Error(r+` updates.shape[${t}] (${e.shape[t]}) != indices.shape[${t}] (${n.shape[t]}).`)}}for(let n=0;n<e.rank-o;++n){if(e.shape[n+o]!==t[n+s]){throw new Error(r+` updates.shape[${n+o}] (${e.shape[n+o]}) != shape[${n+o}] (${t[n+o]})`)}}}function bd(t,n,e){if(n.rank<1){throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+` but the rank was ${n.rank}.`)}if(t.rank<1){throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+` but the rank was ${t.rank}.`)}if(n.dtype!=="int32"){throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`)}if(e.length<1){throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`)}if(e.length===0){if(n.size===0){throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`)}if(t.size===0){throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}}xd(e,n,t)}function gd(t,n,e){const s=n.shape.length;const o=s>1?n.shape[s-1]:1;const r=e.length;let i=1;for(let t=o;t<r;++t){i*=e[t]}const c=o<1?1:o;const a=g(n.shape)/c;const u=[...V(e.slice(0,o)),1];const l=g(e);return{sliceRank:o,numUpdates:a,sliceSize:i,strides:u,outputSize:l}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(t,n=1,e=true){const s=Ir(t,"x","topk");if(s.rank===0){throw new Error("topk() expects the input to be of rank 1 or higher")}const o=s.shape[s.shape.length-1];if(n<0){throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`)}if(n>o){throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) `+`but got ${n}`)}const r={x:s};const i={k:n,sorted:e};const[c,a]=$r.runKernel(ls,r,i);return{values:c,indices:a}}const vd=Fr({topk_:wd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(t,n=0,e=1,s,o){q(t);if(s!=null&&s==="bool"){throw new Error(`Unsupported data type $ { dtype }`)}const r=new rh(n,e,s,true,o);const i=Fi(t,s);for(let t=0;t<i.values.length;t++){i.values[t]=r.nextValue()}return i.toTensor()}const yd=Fr({truncatedNormal_:$d});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(t,n=0){const e=Ir(t,"x","unique","string_or_numeric");m(e.rank>0,(()=>"The input tensor must be at least 1D"));const s={x:e};const o={axis:n};const[r,i]=$r.runKernel(ds,s,o);return{values:r,indices:i}}const Cd=Fr({unique_:kd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nd(t,n,e){const s=Ir(t,"x","unsortedSegmentSum");const o=Ir(n,"segmentIds","unsortedSegmentSum","int32");m(v(e),(()=>"numSegments must be of dtype int"));const r={x:s,segmentIds:o};const i={numSegments:e};return $r.runKernel(ms,r,i)}const Rd=Fr({unsortedSegmentSum_:Nd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sd(t,n=0){const e=Ir(t,"x","unstack","string_or_numeric");m(n>=-e.shape.length&&n<e.shape.length,(()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`));const s={value:e};const o={axis:n};return $r.runKernel(ps,s,o)}const Ed=Fr({unstack_:Sd});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(t,n=true,e,s){return $r.makeVariable(t,n,e,s)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Id(t,n){const e=[];for(let t=0;t<n.length;t++){if(n[t]){e.push(t)}}const s=Fi(t,"int32");const o=Fi([e.length,t.length],"int32");for(let n=0;n<e.length;n++){const r=s.indexToLoc(e[n]);const i=n*t.length;o.values.set(r,i)}return o.toTensor()}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ad(t,n,e){const s=Ir(t,"x","transpose");if(n==null){n=s.shape.map(((t,n)=>n)).reverse()}m(s.rank===n.length,(()=>`Error in transpose: rank of input ${s.rank} `+`must match length of perm ${n}.`));n.forEach((t=>{m(t>=0&&t<s.rank,(()=>`All entries in 'perm' must be between 0 and ${s.rank-1}`+` but got ${n}`))}));if(s.rank<=1){return s.clone()}const o={x:s};const r={perm:n};if(s.dtype==="complex64"){return Wi((()=>{let t=dh(s);let n=vl(s);t=$r.runKernel(hs,{x:t},r);n=$r.runKernel(hs,{x:n},r);if(e){n=Wl(n)}return Mr(t,n)}))}return $r.runKernel(hs,o,r)}const Od=Fr({transpose_:Ad});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fd(t,n){if(n==null){return t.shape.slice()}if(w(t.shape,n)){return n}if(t.shape.length===n.length){const e=[];for(let s=0;s<t.shape.length;s++){if(n[s]==null&&t.shape[s]!=null){e.push(t.shape[s])}else{e.push(n[s])}}return e}return n}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _d(t,n,e,s){const o=Ir(t,"x","dropout");m(o.dtype==="float32",(()=>`x has to be a floating point tensor since it's going to be `+`scaled, but got a ${o.dtype} tensor instead.`));m(n>=0&&n<1,(()=>`rate must be a float in the range [0, 1), but got ${n}.`));if(n===0){return t instanceof Qo?o.clone():o}const r=Fd(o,e);const i=1-n;const c=Zi(hl(Xi(lh(r,0,1,"float32",s),i)),i);return tc(o,c)}const Md=Fr({dropout_:_d});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(t,n,e,s,o,r="NHWC",i){let c=t;if(t.rank===3){c=Hc(t,[1,t.shape[0],t.shape[1],t.shape[2]])}let a=n;if(a.rank===3){a=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2]])}m(c.rank===4,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape `+`${c.shape}.`));m(a.rank===4,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape `+`${a.shape}.`));m(e.length===4,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got `+`${e}.`));const u=r==="NHWC"?c.shape[3]:c.shape[1];const l=r==="NHWC"?a.shape[3]:a.shape[1];m(u===e[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must `+`match input depth in filter (${e[2]}.`));m(l===e[3],(()=>`Error in conv2dDerFilter: depth of dy (${l}) must `+`match output depth for filter (${e[3]}).`));Gc("conv2dDerFilter",o,i);const f={x:c,dy:a};const h={strides:s,pad:o,dataFormat:r,dimRoundingMode:i,filterShape:e};return $r.runKernel(Vt,f,h)}const Ld=Fr({conv2DBackpropFilter_:Dd});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zd(t,n,e){if(e==null||e==="linear"){return t}if(e==="relu"){return tc(t,ud(n))}throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Pd(t,n){let e=n;const s=fu(t.shape,n.shape);if(s.length>0){e=Ku(e,s)}return Hc(e,t.shape)}function Vd(t,n,e,s){if(n==="linear"){return t}else if(n==="relu"){return bh(t)}else if(n==="elu"){return Ru(t)}else if(n==="relu6"){return wh(t)}else if(n==="prelu"){return Bf(t,e)}else if(n==="leakyrelu"){return El(t,s)}else if(n==="sigmoid"){return na(t)}throw new Error(`Unknown fused activation ${n}.`)}const Bd=(t,n)=>{const e=t>0;return!e||n==="linear"};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wd({x:t,filter:n,strides:e,pad:s,dataFormat:o="NHWC",dilations:r=[1,1],dimRoundingMode:i,bias:c,activation:a="linear",preluActivationWeights:u,leakyreluAlpha:l}){a=a||"linear";if(Bd($r.state.gradientDepth,a)===false){m(o==="NHWC",(()=>`Error in fused conv2d: got dataFormat of ${o} but `+`only NHWC is currently supported for the case of gradient depth `+`is 0 and the activation is not linear.`));let f=Ma(t,n,e,s,o,r,i);if(c!=null){f=Xi(f,c)}return Vd(f,a,u,l)}const f=Ir(t,"x","conv2d","float32");const h=Ir(n,"filter","conv2d","float32");let d=f;let p=false;if(f.rank===3){p=true;d=Hc(f,[1,f.shape[0],f.shape[1],f.shape[2]])}m(d.rank===4,(()=>`Error in fused conv2d: input must be rank 4, but got rank `+`${d.rank}.`));m(h.rank===4,(()=>`Error in fused conv2d: filter must be rank 4, but got rank `+`${h.rank}.`));Gc("fused conv2d",s,i);const x=o==="NHWC"?d.shape[3]:d.shape[1];m(h.shape[2]===x,(()=>`Error in conv2d: depth of input (${x}) must match `+`input depth for filter ${h.shape[2]}.`));m(Vc(e,r),(()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${e} and dilations '${r}'`));const b=Ec(d.shape,h.shape,e,r,s,i);let g;if(c!=null){g=Ir(c,"bias","fused conv2d");[g]=hr(g,f);if(o==="NHWC"){hu(b.outShape,g.shape)}else{m(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor `+`bias for NCHW format but got the bias of `+`rank-${g.shape.length}.`));m(g.shape.length===0||g.shape[0]===b.outChannels||g.shape[0]===1,(()=>`Error in fused conv2d: bias shape (${g.shape}) is not `+`compatible with the number of output channels `+`(${b.outChannels})`))}}let w;if(u!=null){const t=u.shape;m(t.length<=1||t.length===3,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or `+`3-D Tensor PReLU activation weights but got a tensor of `+`rank-${t.length}.`));if(t.length===1){m(t[0]===1||t[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights `+`(${t}) is not compatible with the number of output `+`channels (${b.outChannels}).`))}else if(t.length===3){try{hu(t,b.outShape)}catch(n){const e=`Error in fused conv2d: PReLU activation weights (${t}) `+`is not compatible with the output shape of the conv2d `+`(${b.outShape}).`;throw Error(e)}}w=Ir(u,"prelu weights","fused conv2d")}const v=(t,n)=>{m(o==="NHWC",(()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`));const[i,c,u,l]=n;const f=zd(t,u,a);m(Pc(r),(()=>"Error in gradient of fused conv2D: "+`dilation rates greater than 1 `+`are not yet supported in gradients. Got dilations '${r}'`));const h=Pa(c.shape,f,i,e,s);const d=Ld(c,f,i.shape,e,s);const p=[h,d];if(l!=null){const t=Pd(l,f);p.push(t)}return p};const $={x:d,filter:h,bias:g,preluActivationWeights:w};const y={strides:e,pad:s,dataFormat:o,dilations:r,dimRoundingMode:i,activation:a,leakyreluAlpha:l};if(c==null){const t=Vl(((t,n,e)=>{let s=$r.runKernel($s,$,y);e([n,t,s]);if(p){s=Hc(s,[s.shape[1],s.shape[2],s.shape[3]])}return{value:s,gradFunc:v}}));return t(d,h)}else{const t=Vl(((t,n,e,s)=>{let o=$r.runKernel($s,$,y);s([n,t,o,e]);if(p){o=Hc(o,[o.shape[1],o.shape[2],o.shape[3]])}return{value:o,gradFunc:v}}));return t(d,h,g)}}const Gd=Fr({fusedConv2d_:Wd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ud(t,n,e,s,o,r=[1,1],i){let c=t;if(t.rank===3){c=Hc(t,[1,t.shape[0],t.shape[1],t.shape[2]])}let a=n;if(a.rank===3){a=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2]])}const u={x:c,dy:a};const l={strides:s,pad:o,dimRoundingMode:i,dilations:r,filterShape:e};return $r.runKernel(Qt,u,l)}const Hd=Fr({depthwiseConv2dNativeBackpropFilter_:Ud});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jd(t,n,e,s,o,r=[1,1],i){let c=n;let a=false;if(n.rank===3){a=true;c=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2]])}const u={dy:c,filter:e};const l={strides:s,pad:o,dimRoundingMode:i,dilations:r,inputShape:t};const f=$r.runKernel(tn,u,l);if(a){return Hc(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const qd=Fr({depthwiseConv2dNativeBackpropInput_:jd});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xd({a:t,b:n,transposeA:e=false,transposeB:s=false,bias:o,activation:r="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}){if(Bd($r.state.gradientDepth,r)===false){let a=Qc(t,n,e,s);if(o!=null){a=Xi(a,o)}return Vd(a,r,i,c)}let a=Ir(t,"a","fused matMul");let u=Ir(n,"b","fused matMul");[a,u]=hr(a,u);const l=e?a.shape[a.rank-2]:a.shape[a.rank-1];const f=s?u.shape[u.rank-1]:u.shape[u.rank-2];const h=e?a.shape[a.rank-1]:a.shape[a.rank-2];const d=s?u.shape[u.rank-2]:u.shape[u.rank-1];const p=a.shape.slice(0,-2);const x=u.shape.slice(0,-2);const b=g(p);const w=g(x);m(l===f,(()=>`Error in fused matMul: inner shapes (${l}) and (`+`${f}) of Tensors with shapes ${a.shape} and `+`${u.shape} and transposeA=${e}`+` and transposeB=${s} must match.`));const v=hu(a.shape.slice(0,-2),u.shape.slice(0,-2));const $=v.concat([h,d]);const y=e?Hc(a,[b,l,h]):Hc(a,[b,h,l]);const k=s?Hc(u,[w,d,f]):Hc(u,[w,f,d]);let C;if(o!=null){C=Ir(o,"bias","fused matMul");[C]=hr(C,a);hu($,C.shape)}let N;if(i!=null){N=Ir(i,"prelu weights","fused matMul")}const R=(t,n)=>{const[i,c,a,u]=n;const l=zd(Hc(t,a.shape),a,r);let f;let h;if(!e&&!s){f=Qc(l,c,false,true);h=Qc(i,l,true,false)}else if(!e&&s){f=Qc(l,c,false,false);h=Qc(l,i,true,false)}else if(e&&!s){f=Qc(c,l,false,true);h=Qc(i,l,false,false)}else{f=Qc(c,l,true,true);h=Qc(l,i,true,true)}if(o!=null){const t=Pd(u,l);return[f,h,t]}else{return[f,h]}};const S={a:y,b:k,bias:C,preluActivationWeights:N};const E={transposeA:e,transposeB:s,activation:r,leakyreluAlpha:c};if(o==null){const t=Vl(((t,n,e)=>{const s=$r.runKernel(vs,S,E);e([t,n,s]);return{value:Hc(s,$),gradFunc:R}}));return t(y,k)}else{const t=Vl(((t,n,e,s)=>{const o=$r.runKernel(vs,S,E);s([t,n,o,e]);return{value:Hc(o,$),gradFunc:R}}));return t(y,k,C)}}const Kd=Fr({fusedMatMul_:Xd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jd(t,n,e,s,o="bilinear",r=0){const i=Ir(t,"image","cropAndResize");const c=Ir(n,"boxes","cropAndResize","float32");const a=Ir(e,"boxInd","cropAndResize","int32");const u=c.shape[0];m(i.rank===4,(()=>"Error in cropAndResize: image must be rank 4,"+`but got rank ${i.rank}.`));m(c.rank===2&&c.shape[1]===4,(()=>`Error in cropAndResize: boxes must be have size [${u},4] `+`but had shape ${c.shape}.`));m(a.rank===1&&a.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] `+`but had shape ${c.shape}.`));m(s.length===2,(()=>`Error in cropAndResize: cropSize must be of length 2, but got `+`length ${s.length}.`));m(s[0]>=1&&s[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${s}`));m(o==="bilinear"||o==="nearest",(()=>`method must be bilinear or nearest, but was ${o}`));const l={image:i,boxes:c,boxInd:a};const f={method:o,extrapolationValue:r,cropSize:s};const h=$r.runKernel(Kt,l,f);return h}const Yd=Fr({cropAndResize_:Jd});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zd(t){const n=Ir(t,"image","flipLeftRight","float32");m(n.rank===4,(()=>"Error in flipLeftRight: image must be rank 4,"+`but got rank ${n.rank}.`));const e={image:n};const s=$r.runKernel(gn,e,{});return s}const Qd=Fr({flipLeftRight_:Zd});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tp(t){const n=Ir(t,"image","grayscaleToRGB");const e=n.rank-1;const s=n.shape[e];m(n.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+`but got rank ${n.rank}.`));m(s===1,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+`should be size 1, but got size ${s}.`));const o=new Array(n.rank);o.fill(1,0,e);o[e]=3;return al(n,o)}const np=Fr({grayscaleToRGB_:tp});
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ep(t){const n=Ir(t,"image","RGBToGrayscale");const e=n.rank-1;const s=n.shape[e];m(n.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+`but got rank ${n.rank}.`));m(s===3,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+`should be size 3, but got size ${s}.`));const o=n.dtype;const r=Mi(n,"float32");const i=pd([.2989,.587,.114]);let c;switch(n.rank){case 2:c=Cu("ij,j->i",r,i);break;case 3:c=Cu("ijk,k->ij",r,i);break;case 4:c=Cu("ijkl,l->ijk",r,i);break;case 5:c=Cu("ijklm,m->ijkl",r,i);break;case 6:c=Cu("ijklmn,n->ijklm",r,i);break;default:throw new Error("Not a valid tensor rank.")}c=ol(c,-1);return Mi(c,o)}const sp=Fr({rgbToGrayscale_:ep});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function op(t,n,e=0,s=.5){const o=Ir(t,"image","rotateWithOffset","float32");m(o.rank===4,(()=>"Error in rotateWithOffset: image must be rank 4,"+`but got rank ${o.rank}.`));const r={image:o};const i={radians:n,fillValue:e,center:s};const c=$r.runKernel(ws,r,i);return c}const rp=Fr({rotateWithOffset_:op});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ip(t,n,e,s,o,r){if(s==null){s=.5}if(o==null){o=Number.NEGATIVE_INFINITY}if(r==null){r=0}const i=t.shape[0];e=Math.min(e,i);m(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`));m(t.rank===2,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`));m(t.shape[1]===4,(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`));m(n.rank===1,(()=>"scores must be a 1D tensor"));m(n.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, `+`but was ${n.shape[0]}`));m(0<=r&&r<=1,(()=>`softNmsSigma must be in [0, 1], but was '${r}'`));return{maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:r}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cp(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY){const r=Ir(t,"boxes","nonMaxSuppression","float32");const i=Ir(n,"scores","nonMaxSuppression","float32");const c=ip(r,i,e,s,o);e=c.maxOutputSize;s=c.iouThreshold;o=c.scoreThreshold;const a={maxOutputSize:e,iouThreshold:s,scoreThreshold:o};return $r.runKernel(ie,{boxes:r,scores:i},a)}const ap=Fr({nonMaxSuppression_:cp});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function up(t,n,e){const s=lp(t,n,e);const o=s<0?-(s+1):s;t.splice(o,0,n)}function lp(t,n,e){return hp(t,n,e||fp)}function fp(t,n){return t>n?1:t<n?-1:0}function hp(t,n,e){let s=0;let o=t.length;let r=0;let i=false;while(s<o){r=s+(o-s>>>1);const c=e(n,t[r]);if(c>0){s=r+1}else{o=r;i=!c}}return i?s:-s-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dp(t,n,e,s,o){return xp(t,n,e,s,o,0)}function pp(t,n,e,s,o,r){return xp(t,n,e,s,o,0,false,r,true)}function mp(t,n,e,s,o,r){return xp(t,n,e,s,o,r,true)}function xp(t,n,e,s,o,r,i=false,c=false,a=false){const u=[];for(let t=0;t<n.length;t++){if(n[t]>o){u.push({score:n[t],boxIndex:t,suppressBeginIndex:0})}}u.sort(wp);const l=r>0?-.5/r:0;const f=[];const h=[];while(f.length<e&&u.length>0){const n=u.pop();const{score:e,boxIndex:r,suppressBeginIndex:i}=n;if(e<o){break}let c=false;for(let e=f.length-1;e>=i;--e){const i=bp(t,r,f[e]);if(i>=s){c=true;break}n.score=n.score*gp(s,l,i);if(n.score<=o){break}}n.suppressBeginIndex=f.length;if(!c){if(n.score===e){f.push(r);h.push(n.score)}else if(n.score>o){up(u,n,wp)}}}const d=f.length;const p=e-d;if(c&&p>0){f.push(...new Array(p).fill(0));h.push(...new Array(p).fill(0))}const m={selectedIndices:f};if(i){m["selectedScores"]=h}if(a){m["validOutputs"]=d}return m}function bp(t,n,e){const s=t.subarray(n*4,n*4+4);const o=t.subarray(e*4,e*4+4);const r=Math.min(s[0],s[2]);const i=Math.min(s[1],s[3]);const c=Math.max(s[0],s[2]);const a=Math.max(s[1],s[3]);const u=Math.min(o[0],o[2]);const l=Math.min(o[1],o[3]);const f=Math.max(o[0],o[2]);const h=Math.max(o[1],o[3]);const d=(c-r)*(a-i);const p=(f-u)*(h-l);if(d<=0||p<=0){return 0}const m=Math.max(r,u);const x=Math.max(i,l);const b=Math.min(c,f);const g=Math.min(a,h);const w=Math.max(b-m,0)*Math.max(g-x,0);return w/(d+p-w)}function gp(t,n,e){const s=Math.exp(n*e*e);return e<=t?s:0}function wp(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vp(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY){const r=Ir(t,"boxes","nonMaxSuppressionAsync");const i=Ir(n,"scores","nonMaxSuppressionAsync");const c=ip(r,i,e,s,o);e=c.maxOutputSize;s=c.iouThreshold;o=c.scoreThreshold;const a=await Promise.all([r.data(),i.data()]);const u=a[0];const l=a[1];const{selectedIndices:f}=dp(u,l,e,s,o);if(r!==t){r.dispose()}if(i!==n){i.dispose()}return pd(f,"int32")}const $p=vp;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yp(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=0){const i=Ir(t,"boxes","nonMaxSuppression");const c=Ir(n,"scores","nonMaxSuppression");const a=ip(i,c,e,s,o,r);e=a.maxOutputSize;s=a.iouThreshold;o=a.scoreThreshold;r=a.softNmsSigma;const u={boxes:i,scores:c};const l={maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:r};const f=$r.runKernel(ae,u,l);return{selectedIndices:f[0],selectedScores:f[1]}}const kp=Fr({nonMaxSuppressionWithScore_:yp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cp(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=0){const i=Ir(t,"boxes","nonMaxSuppressionAsync");const c=Ir(n,"scores","nonMaxSuppressionAsync");const a=ip(i,c,e,s,o,r);e=a.maxOutputSize;s=a.iouThreshold;o=a.scoreThreshold;r=a.softNmsSigma;const u=await Promise.all([i.data(),c.data()]);const l=u[0];const f=u[1];const{selectedIndices:h,selectedScores:d}=mp(l,f,e,s,o,r);if(i!==t){i.dispose()}if(c!==n){c.dispose()}return{selectedIndices:pd(h,"int32"),selectedScores:pd(d)}}const Np=Cp;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=false){const i=Ir(t,"boxes","nonMaxSuppression");const c=Ir(n,"scores","nonMaxSuppression");const a=ip(i,c,e,s,o,null);const u=a.maxOutputSize;const l=a.iouThreshold;const f=a.scoreThreshold;const h={boxes:i,scores:c};const d={maxOutputSize:u,iouThreshold:l,scoreThreshold:f,padToMaxOutputSize:r};const p=$r.runKernel(ce,h,d);return{selectedIndices:p[0],validOutputs:p[1]}}const Sp=Fr({nonMaxSuppressionPadded_:Rp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ep(t,n,e,s=.5,o=Number.NEGATIVE_INFINITY,r=false){const i=Ir(t,"boxes","nonMaxSuppressionAsync");const c=Ir(n,"scores","nonMaxSuppressionAsync");const a=ip(i,c,e,s,o,null);const u=a.maxOutputSize;const l=a.iouThreshold;const f=a.scoreThreshold;const[h,d]=await Promise.all([i.data(),c.data()]);const{selectedIndices:p,validOutputs:m}=pp(h,d,u,l,f,r);if(i!==t){i.dispose()}if(c!==n){c.dispose()}return{selectedIndices:pd(p,"int32"),validOutputs:Gu(m,"int32")}}const Tp=Ep;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(t,n,e=false,s=false){const o=Ir(t,"images","resizeBilinear");m(o.rank===3||o.rank===4,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got `+`rank ${o.rank}.`));m(n.length===2,(()=>`Error in resizeBilinear: new shape must 2D, but got shape `+`${n}.`));m(s===false||e===false,(()=>`Error in resizeBilinear: If halfPixelCenters is true, `+`alignCorners must be false.`));let r=o;let i=false;if(o.rank===3){i=true;r=Hc(o,[1,o.shape[0],o.shape[1],o.shape[2]])}const c={images:r};const a={alignCorners:e,halfPixelCenters:s,size:n};const u=$r.runKernel(Re,c,a);if(i){return Hc(u,[u.shape[1],u.shape[2],u.shape[3]])}return u}const Ap=Fr({resizeBilinear_:Ip});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Op(t,n,e=false,s=false){const o=Ir(t,"images","resizeNearestNeighbor");m(o.rank===3||o.rank===4,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got `+`rank ${o.rank}.`));m(n.length===2,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape `+`${n}.`));m(o.dtype==="float32"||o.dtype==="int32",(()=>"`images` must have `int32` or `float32` as dtype"));m(s===false||e===false,(()=>`Error in resizeNearestNeighbor: If halfPixelCenters is true, `+`alignCorners must be false.`));let r=o;let i=false;if(o.rank===3){i=true;r=Hc(o,[1,o.shape[0],o.shape[1],o.shape[2]])}const c={images:r};const a={alignCorners:e,halfPixelCenters:s,size:n};const u=$r.runKernel(Ce,c,a);if(i){return Hc(u,[u.shape[1],u.shape[2],u.shape[3]])}return u}const Fp=Fr({resizeNearestNeighbor_:Op});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(t,n="binary",e=false,s=.5){const o=Ir(t,"image","threshold");const r=.2989;const i=.587;const c=.114;const a=o.shape[0]*o.shape[1];let u=tc(pd([s]),255);let l,f,h,d;m(o.rank===3,(()=>"Error in threshold: image must be rank 3,"+`but got rank ${o.rank}.`));m(o.shape[2]===3||o.shape[2]===1,(()=>"Error in threshold: "+"image color channel must be equal to 3 or 1"+`but got ${o.shape[2]}.`));m(o.dtype==="int32"||o.dtype==="float32",(()=>"Error in dtype: image dtype must be int32 or float32,"+`but got dtype ${o.dtype}.`));m(n==="otsu"||n==="binary",(()=>`Method must be binary or otsu, but was ${n}`));if(o.shape[2]===3){[l,f,h]=Qh(o,[1,1,1],-1);const t=tc(l,r);const n=tc(f,i);const e=tc(h,c);d=Xi(Xi(t,n),e)}else{d=t}if(n==="otsu"){const t=ga(Mi(kh(d),"int32"),Lr([]),256);u=Mp(t,a)}const p=e?Ol(d,u):xl(d,u);const x=Mi(tc(p,255),"int32");return x}function Mp(t,n){let e=pd([-1]);let s=pd([0]);let o=pd([0]);let r,i,c,a,u,l;for(let f=0;f<t.size-1;f++){r=sa(t,0,f+1);i=sa(t,f+1);u=Zi(Ku(r),n);l=Zi(Ku(i),n);const h=Ku(tc(r,fh(0,r.size)));c=Zi(h,Ku(r));const d=ka(i.shape,r.size);const p=Xi(fh(0,i.size),d);const m=tc(i,p);a=Zi(Ku(m),Ku(i));const x=Xl(c,a);const b=Xl(c,a);const g=tc(u,l);o=tc(tc(g,x),b);const w=xl(o,s);s=xu(w,o,s);e=xu(w,pd([f]),e)}return e}const Dp=Fr({threshold_:_p});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lp(t,n,e="nearest",s="constant",o=0,r){const i=Ir(t,"image","transform","float32");const c=Ir(n,"transforms","transform","float32");m(i.rank===4,(()=>"Error in transform: image must be rank 4,"+`but got rank ${i.rank}.`));m(c.rank===2&&(c.shape[0]===i.shape[0]||c.shape[0]===1)&&c.shape[1]===8,(()=>`Error in transform: Input transform should be batch x 8 or 1 x 8`));m(r==null||r.length===2,(()=>"Error in transform: outputShape must be [height, width] or null, "+`but got ${r}.`));const a={image:i,transforms:c};const u={interpolation:e,fillMode:s,fillValue:o,outputShape:r};return $r.runKernel(fs,a,u)}const zp=Fr({transform_:Lp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pp(t,n,e){const s=Ir(t,"a","bandPart");m(s.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`));const o=s.shape;const[r,i]=s.shape.slice(-2);let c;let a;if(typeof n==="number"){m(n%1===0,(()=>`bandPart(): numLower must be an integer, got ${n}.`));m(n<=r,(()=>`bandPart(): numLower (${n})`+` must not be greater than the number of rows (${r}).`));c=Ir(n<0?r:n,"numLower","bandPart")}else{m(n.dtype==="int32",(()=>`bandPart(): numLower's dtype must be an int32.`));c=xu(Il(n,0),r,wf(n,r))}if(typeof e==="number"){m(e%1===0,(()=>`bandPart(): numUpper must be an integer, got ${e}.`));m(e<=i,(()=>`bandPart(): numUpper (${e})`+` must not be greater than the number of columns (${i}).`));a=Ir(e<0?i:e,"numUpper","bandPart")}else{m(e.dtype==="int32",(()=>`bandPart(): numUpper's dtype must be an int32.`));a=xu(Il(e,0),i,wf(e,i))}const u=Hc(fh(0,r,1,"int32"),[-1,1]);const l=fh(0,i,1,"int32");const f=Xl(u,l);const h=tf(Ol(f,c),gl(f,Wl(a)));const d=xf([r,i],s.dtype);return Hc(cd(Ed(Hc(s,[-1,r,i])).map((t=>xu(h,t,d)))),o)}const Vp=Fr({bandPart_:Pp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bp(t){let n;if(Array.isArray(t)){n=false;m(t!=null&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or "+"empty"));const e=t[0].shape[0];for(let n=1;n<t.length;++n){m(t[n].shape[0]===e,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+`(${t[n].shape[0]} vs. ${e})`))}}else{n=true;t=Qh(t,t.shape[0],0).map((t=>rd(t,[0])))}m(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds `+`number of dimensions (${t[0].shape[0]}).`));const e=[];const s=t;for(let n=0;n<t.length;++n){e.push($r.tidy((()=>{let t=s[n];if(n>0){for(let s=0;s<n;++s){const n=tc(Ku(tc(e[s],t)),e[s]);t=Xl(t,n)}}return Zi(t,Zu(t,"euclidean"))})))}if(n){return cd(e,0)}else{return e}}const Wp=Fr({gramSchmidt_:Bp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gp(t,n=false){m(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`));if(t.rank===2){return Up(t,n)}else{const e=t.shape.slice(0,t.shape.length-2).reduce(((t,n)=>t*n));const s=Ed(Hc(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0);const o=[];const r=[];s.forEach((t=>{const[e,s]=Up(t,n);o.push(e);r.push(s)}));const i=Hc(cd(o,0),t.shape);const c=Hc(cd(r,0),t.shape);return[i,c]}}function Up(t,n=false){return $r.tidy((()=>{m(t.shape.length===2,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const e=t.shape[0];const s=t.shape[1];let o=ll(e);let r=Li(t);const i=md([[1]],[1,1]);let c=Li(i);const a=e>=s?s:e;for(let t=0;t<a;++t){const n=r;const a=c;const u=o;[c,r,o]=$r.tidy((()=>{const n=sa(r,[t,t],[e-t,1]);const a=Zu(n);const u=sa(r,[t,t],[1,1]);const l=xu(xl(u,0),md([[-1]]),md([[1]]));const f=Xl(u,tc(l,a));const h=Zi(n,f);if(h.shape[0]===1){c=Li(i)}else{c=Yc([i,sa(h,[1,0],[h.shape[0]-1,h.shape[1]])],0)}const d=Wl(Zi(Qc(l,f),a));const p=sa(r,[t,0],[e-t,s]);const m=tc(d,c);const x=Od(c);if(t===0){r=Xl(p,Qc(m,Qc(x,p)))}else{const n=Xl(p,Qc(m,Qc(x,p)));r=Yc([sa(r,[0,0],[t,s]),n],0)}const b=Od(m);const g=sa(o,[0,t],[e,o.shape[1]-t]);if(t===0){o=Xl(g,Qc(Qc(g,c),b))}else{const n=Xl(g,Qc(Qc(g,c),b));o=Yc([sa(o,[0,0],[e,t]),n],1)}return[c,r,o]}));Gi([n,a,u])}if(!n&&e>s){o=sa(o,[0,0],[e,s]);r=sa(r,[0,0],[s,s])}return[o,r]}))}const Hp=Fr({qr_:Gp});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jp={flipLeftRight:Qd,grayscaleToRGB:np,resizeNearestNeighbor:Fp,resizeBilinear:Ap,rgbToGrayscale:sp,rotateWithOffset:rp,cropAndResize:Yd,nonMaxSuppression:ap,nonMaxSuppressionAsync:$p,nonMaxSuppressionWithScore:kp,nonMaxSuppressionWithScoreAsync:Np,nonMaxSuppressionPadded:Sp,nonMaxSuppressionPaddedAsync:Tp,threshold:Dp,transform:zp};const qp={bandPart:Vp,gramSchmidt:Wp,qr:Hp};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xp=new Map;const Kp=new Map;class Jp{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Yp{constructor(){this.classNameMap={}}static getMap(){if(Yp.instance==null){Yp.instance=new Yp}return Yp.instance}static register(t){Yp.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Zp(t,n,e){m(t.className!=null,(()=>`Class being registered does not have the static className `+`property defined.`));m(typeof t.className==="string",(()=>`className is required to be a string, but got type `+typeof t.className));m(t.className.length>0,(()=>`Class being registered has an empty-string as its className, `+`which is disallowed.`));if(typeof n==="undefined"){n="Custom"}if(typeof e==="undefined"){e=t.className}const s=e;const o=n+">"+s;Yp.register(t);Xp.set(o,t);Kp.set(t,o);return t}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qp extends Jp{minimize(t,n=false,e){const{value:s,grads:o}=this.computeGradients(t,e);if(e!=null){const t=e.map((t=>({name:t.name,tensor:o[t.name]})));this.applyGradients(t)}else{this.applyGradients(o)}Gi(o);if(n){return s}else{s.dispose();return null}}get iterations(){if(this.iterations_==null){this.iterations_=0}return this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Pl(t,n)}dispose(){if(this.iterations_!=null){Gi(this.iterations_)}}async saveIterations(){if(this.iterations_==null){this.iterations_=0}return{name:"iter",tensor:Gu(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class `+`${this.getClassName()}`)}async extractIterations(t){this.iterations_=(await t[0].tensor.data())[0];return t.slice(1)}}Object.defineProperty(Qp,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tm extends Qp{static get className(){return"Adadelta"}constructor(t,n,e=null){super();this.learningRate=t;this.rho=n;this.epsilon=e;this.accumulatedGrads=[];this.accumulatedUpdates=[];if(e==null){this.epsilon=$r.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=$r.registeredVariables[n];const o=false;if(this.accumulatedGrads[e]==null){this.accumulatedGrads[e]={originalName:`${n}/accum_grad`,variable:Wi((()=>gu(s).variable(o)))}}if(this.accumulatedUpdates[e]==null){this.accumulatedUpdates[e]={originalName:`${n}/accum_var`,variable:Wi((()=>gu(s).variable(o)))}}const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}const i=this.accumulatedGrads[e].variable;const c=this.accumulatedUpdates[e].variable;Wi((()=>{const t=Xi(tc(i,this.rho),tc(qu(r),1-this.rho));const n=tc(Zi(Hu(Xi(c,this.epsilon)),Hu(Xi(i,this.epsilon))),r);const e=Xi(tc(c,this.rho),tc(qu(n),1-this.rho));i.assign(t);c.assign(e);const o=Xi(tc(n,-this.learningRate),s);s.assign(o)}))}));this.incrementIterations()}dispose(){if(this.accumulatedUpdates!=null){Gi(this.accumulatedGrads.map((t=>t.variable)));Gi(this.accumulatedUpdates.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2;const e=false;this.accumulatedGrads=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedUpdates=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n["learningRate"],n["rho"],n["epsilon"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nm extends Qp{static get className(){return"Adagrad"}constructor(t,n=.1){super();this.learningRate=t;this.initialAccumulatorValue=n;this.accumulatedGrads=[]}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=$r.registeredVariables[n];if(this.accumulatedGrads[e]==null){const t=false;this.accumulatedGrads[e]={originalName:`${n}/accumulator`,variable:Wi((()=>ka(s.shape,this.initialAccumulatorValue).variable(t)))}}const o=Array.isArray(t)?t[e].tensor:t[n];if(o==null){return}const r=this.accumulatedGrads[e].variable;Wi((()=>{const t=Xi(r,qu(o));r.assign(t);const n=Xi(tc(Zi(o,Hu(Xi(t,$r.backend.epsilon()))),-this.learningRate),s);s.assign(n)}))}));this.incrementIterations()}dispose(){if(this.accumulatedGrads!=null){Gi(this.accumulatedGrads.map((t=>t.variable)))}}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=false;this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n["learningRate"],n["initialAccumulatorValue"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class em extends Qp{static get className(){return"Adam"}constructor(t,n,e,s=null){super();this.learningRate=t;this.beta1=n;this.beta2=e;this.epsilon=s;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];Wi((()=>{this.accBeta1=Gu(n).variable();this.accBeta2=Gu(e).variable()}));if(s==null){this.epsilon=$r.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Wi((()=>{const e=Xl(1,this.accBeta1);const s=Xl(1,this.accBeta2);n.forEach(((n,o)=>{const r=$r.registeredVariables[n];const i=false;if(this.accumulatedFirstMoment[o]==null){this.accumulatedFirstMoment[o]={originalName:`${n}/m`,variable:Wi((()=>gu(r).variable(i)))}}if(this.accumulatedSecondMoment[o]==null){this.accumulatedSecondMoment[o]={originalName:`${n}/v`,variable:Wi((()=>gu(r).variable(i)))}}const c=Array.isArray(t)?t[o].tensor:t[n];if(c==null){return}const a=this.accumulatedFirstMoment[o].variable;const u=this.accumulatedSecondMoment[o].variable;const l=Xi(tc(a,this.beta1),tc(c,1-this.beta1));const f=Xi(tc(u,this.beta2),tc(qu(c),1-this.beta2));const h=Zi(l,e);const d=Zi(f,s);a.assign(l);u.assign(f);const p=Xi(tc(Zi(h,Xi(Hu(d),this.epsilon)),-this.learningRate),r);r.assign(p)}));this.accBeta1.assign(tc(this.accBeta1,this.beta1));this.accBeta2.assign(tc(this.accBeta2,this.beta2))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.accBeta2.dispose();if(this.accumulatedFirstMoment!=null){Gi(this.accumulatedFirstMoment.map((t=>t.variable)))}if(this.accumulatedSecondMoment!=null){Gi(this.accumulatedSecondMoment.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);Wi((()=>{this.accBeta1.assign(Wu(this.beta1,this.iterations_+1));this.accBeta2.assign(Wu(this.beta2,this.iterations_+1))}));const n=t.length/2;const e=false;this.accumulatedFirstMoment=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedSecondMoment=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n["learningRate"],n["beta1"],n["beta2"],n["epsilon"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sm extends Qp{static get className(){return"Adamax"}constructor(t,n,e,s=null,o=0){super();this.learningRate=t;this.beta1=n;this.beta2=e;this.epsilon=s;this.decay=o;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];Wi((()=>{this.iteration=Gu(0).variable();this.accBeta1=Gu(n).variable()}));if(s==null){this.epsilon=$r.backend.epsilon()}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Wi((()=>{const e=Xl(1,this.accBeta1);const s=Zi(-this.learningRate,Xi(tc(this.iteration,this.decay),1));n.forEach(((n,o)=>{const r=$r.registeredVariables[n];const i=false;if(this.accumulatedFirstMoment[o]==null){this.accumulatedFirstMoment[o]={originalName:`${n}/m`,variable:gu(r).variable(i)}}if(this.accumulatedWeightedInfNorm[o]==null){this.accumulatedWeightedInfNorm[o]={originalName:`${n}/v`,variable:gu(r).variable(i)}}const c=Array.isArray(t)?t[o].tensor:t[n];if(c==null){return}const a=this.accumulatedFirstMoment[o].variable;const u=this.accumulatedWeightedInfNorm[o].variable;const l=Xi(tc(a,this.beta1),tc(c,1-this.beta1));const f=tc(u,this.beta2);const h=ec(c);const d=df(f,h);a.assign(l);u.assign(d);const p=Xi(tc(Zi(s,e),Zi(l,Xi(d,this.epsilon))),r);r.assign(p)}));this.iteration.assign(Xi(this.iteration,1));this.accBeta1.assign(tc(this.accBeta1,this.beta1))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.iteration.dispose();if(this.accumulatedFirstMoment!=null){Gi(this.accumulatedFirstMoment.map((t=>t.variable)))}if(this.accumulatedWeightedInfNorm!=null){Gi(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n["learningRate"],n["beta1"],n["beta2"],n["epsilon"],n["decay"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class om extends Qp{static get className(){return"SGD"}constructor(t){super();this.learningRate=t;this.setLearningRate(t)}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=Array.isArray(t)?t[e].tensor:t[n];if(s==null){return}const o=$r.registeredVariables[n];Wi((()=>{const t=Xi(tc(this.c,s),o);o.assign(t)}))}));this.incrementIterations()}setLearningRate(t){this.learningRate=t;if(this.c!=null){this.c.dispose()}this.c=Ui(Gu(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){t=await this.extractIterations(t);if(t.length!==0){throw new Error("SGD optimizer does not have settable weights.")}}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n["learningRate"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rm extends om{static get className(){return"Momentum"}constructor(t,n,e=false){super(t);this.learningRate=t;this.momentum=n;this.useNesterov=e;this.accumulations=[];this.m=Gu(this.momentum)}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=$r.registeredVariables[n];if(this.accumulations[e]==null){const t=false;this.accumulations[e]={originalName:`${n}/momentum`,variable:Wi((()=>gu(s).variable(t)))}}const o=this.accumulations[e].variable;const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}Wi((()=>{let t;const n=Xi(tc(this.m,o),r);if(this.useNesterov){t=Xi(tc(this.c,Xi(r,tc(n,this.m))),s)}else{t=Xi(tc(this.c,n),s)}o.assign(n);s.assign(t)}))}));this.incrementIterations()}dispose(){this.m.dispose();if(this.accumulations!=null){Gi(this.accumulations.map((t=>t.variable)))}}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=false;this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n["learningRate"],n["momentum"],n["useNesterov"])}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class im extends Qp{static get className(){return"RMSProp"}constructor(t,n=.9,e=0,s=null,o=false){super();this.learningRate=t;this.decay=n;this.momentum=e;this.epsilon=s;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];this.centered=o;if(s==null){this.epsilon=$r.backend.epsilon()}if(t==null){throw new Error(`learningRate for RMSPropOptimizer must be defined.`)}}applyGradients(t){const n=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);n.forEach(((n,e)=>{const s=$r.registeredVariables[n];const o=false;if(this.accumulatedMeanSquares[e]==null){this.accumulatedMeanSquares[e]={originalName:`${n}/rms`,variable:Wi((()=>gu(s).variable(o)))}}if(this.accumulatedMoments[e]==null){this.accumulatedMoments[e]={originalName:`${n}/momentum`,variable:Wi((()=>gu(s).variable(o)))}}if(this.accumulatedMeanGrads[e]==null&&this.centered){this.accumulatedMeanGrads[e]={originalName:`${n}/mg`,variable:Wi((()=>gu(s).variable(o)))}}const r=Array.isArray(t)?t[e].tensor:t[n];if(r==null){return}const i=this.accumulatedMeanSquares[e].variable;const c=this.accumulatedMoments[e].variable;Wi((()=>{const t=Xi(tc(i,this.decay),tc(qu(r),1-this.decay));if(this.centered){const n=this.accumulatedMeanGrads[e].variable;const o=Xi(tc(n,this.decay),tc(r,1-this.decay));const a=Zi(tc(r,this.learningRate),Hu(Xl(t,Xi(qu(o),this.epsilon))));const u=Xi(tc(c,this.momentum),a);i.assign(t);n.assign(o);c.assign(u);const l=Xl(s,u);s.assign(l)}else{const t=Xi(tc(i,this.decay),tc(qu(r),1-this.decay));const n=Xi(tc(c,this.momentum),Zi(tc(r,this.learningRate),Hu(Xi(t,this.epsilon))));i.assign(t);c.assign(n);const e=Xl(s,n);s.assign(e)}}))}));this.incrementIterations()}dispose(){if(this.accumulatedMeanSquares!=null){Gi(this.accumulatedMeanSquares.map((t=>t.variable)))}if(this.accumulatedMeanGrads!=null&&this.centered){Gi(this.accumulatedMeanGrads.map((t=>t.variable)))}if(this.accumulatedMoments!=null){Gi(this.accumulatedMoments.map((t=>t.variable)))}}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];if(this.centered){t.push(...this.accumulatedMeanGrads)}return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2;const e=false;this.accumulatedMeanSquares=t.slice(0,n).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));this.accumulatedMoments=t.slice(n,n*2).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})));if(this.centered){this.accumulatedMeanGrads=t.slice(n*2,n*3).map((t=>({originalName:t.name,variable:t.tensor.variable(e)})))}}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n["learningRate"],n["decay"],n["momentum"],n["epsilon"],n["centered"])}}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cm=[tm,nm,em,sm,rm,im,om];function am(){for(const t of cm){Zp(t)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const um="model";const lm=".json";const fm=".weights.bin";function hm(t){return new Promise((t=>setTimeout(t))).then(t)}class dm{constructor(t){if(!et().getBool("IS_BROWSER")){throw new Error("browserDownloads() cannot proceed because the current environment "+"is not a browser.")}if(t.startsWith(dm.URL_SCHEME)){t=t.slice(dm.URL_SCHEME.length)}if(t==null||t.length===0){t=um}this.modelJsonFileName=t+lm;this.weightDataFileName=t+fm}async save(t){if(typeof document==="undefined"){throw new Error("Browser downloads are not supported in "+"this environment since `document` is not present")}const n=zr.join(t.weightData);const e=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserDownloads.save() does not support saving model topology "+"in binary formats yet.")}else{const n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}];const s=Xr(t,n);const o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"}));const r=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;r.download=this.modelJsonFileName;r.href=o;await hm((()=>r.dispatchEvent(new MouseEvent("click"))));if(t.weightData!=null){const t=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName;t.href=e;await hm((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Yr(t)}}}}dm.URL_SCHEME="downloads://";const pm=t=>{if(!et().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(t)&&t.startsWith(dm.URL_SCHEME)){return mm(t.slice(dm.URL_SCHEME.length))}else{return null}}};Qr.registerSaveRouter(pm);function mm(t="model"){return new dm(t)}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xm(t,n,e,s){i(t);e=e==null?0:e;s=s==null?1:s;c(e,s);let o=0;const r=r=>{r.then((r=>{const i=e+ ++o/t.length*(s-e);n(i);return r}));return r};function i(t){m(t!=null&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}function c(t,n){m(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but `+`got startFraction ${t}`));m(n>=0&&n<=1,(()=>`Progress fraction must be in range [0, 1], but `+`got endFraction ${n}`));m(n>=t,(()=>`startFraction must be no more than endFraction, but `+`got startFraction ${t} and endFraction `+`${n}`))}return Promise.all(t.map(r))}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bm(t,n){if(n==null){n={}}const e=n.fetchFunc==null?et().platform.fetch:n.fetchFunc;const s=t.map((t=>e(t,n.requestInit,{isBinary:true})));const o=0;const r=.5;const i=n.onProgress==null?await Promise.all(s):await xm(s,n.onProgress,o,r);const c=i.map((t=>t.arrayBuffer()));const a=.5;const u=1;const l=n.onProgress==null?await Promise.all(c):await xm(c,n.onProgress,a,u);return l}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gm="application/octet-stream";const wm="application/json";class vm{constructor(t,n){this.DEFAULT_METHOD="POST";if(n==null){n={}}this.weightPathPrefix=n.weightPathPrefix;this.onProgress=n.onProgress;this.weightUrlConverter=n.weightUrlConverter;if(n.fetchFunc!=null){m(typeof n.fetchFunc==="function",(()=>"Must pass a function that matches the signature of "+"`fetch` (see "+"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"));this.fetch=n.fetchFunc}else{this.fetch=et().platform.fetch}m(t!=null&&t.length>0,(()=>"URL path for http must not be null, undefined or "+"empty."));if(Array.isArray(t)){m(t.length===2,(()=>"URL paths for http must have a length of 2, "+`(actual length is ${t.length}).`))}this.path=t;if(n.requestInit!=null&&n.requestInit.body!=null){throw new Error("requestInit is expected to have no pre-existing body, but has one.")}this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserHTTPRequest.save() does not support saving model topology "+"in binary formats yet.")}const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const e=[{paths:["./model.weights.bin"],weights:t.weightSpecs}];const s=Xr(t,e);n.body.append("model.json",new Blob([JSON.stringify(s)],{type:wm}),"model.json");if(t.weightData!=null){const e=zr.join(t.weightData);n.body.append("model.weights.bin",new Blob([e],{type:gm}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok){return{modelArtifactsInfo:Yr(t),responses:[o]}}else{throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status `+`${o.status}.`)}}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok){throw new Error(`Request to ${this.path} failed with status code `+`${t.status}. Please verify this URL points to `+`the model JSON of the model to load.`)}let n;try{n=await t.json()}catch(t){let n=`Failed to parse model JSON of response from ${this.path}.`;if(this.path.endsWith(".pb")){n+=" Your path contains a .pb file extension. "+"Support for .pb models have been removed in TensorFlow.js 1.0 "+"in favor of .json models. You can re-convert your Python "+"TensorFlow model using the TensorFlow.js 1.0 conversion scripts "+"or you can convert your.pb models with the 'pb2json'"+"NPM script in the tensorflow/tfjs-converter repository."}else{n+=" Please make sure the server is serving valid "+"JSON for this request."}throw new Error(n)}const e=n.modelTopology;const s=n.weightsManifest;if(e==null&&s==null){throw new Error(`The JSON from HTTP path ${this.path} contains neither model `+`topology or manifest for weights.`)}return Jr(n,(t=>this.loadWeights(t)))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path;const[e,s]=$m(n);const o=this.weightPathPrefix||e;const r=Zr(t);const i=[];const c=[];for(const n of t){for(const t of n.paths){if(this.weightUrlConverter!=null){c.push(this.weightUrlConverter(t))}else{i.push(o+t+s)}}}if(this.weightUrlConverter){i.push(...await Promise.all(c))}const a=await bm(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[r,a]}}vm.URL_SCHEME_REGEX=/^https?:\/\//;function $m(t){const n=t.lastIndexOf("/");const e=t.lastIndexOf("?");const s=t.substring(0,n);const o=e>n?t.substring(e):"";return[s+"/",o]}function ym(t){return t.match(vm.URL_SCHEME_REGEX)!=null}const km=(t,n)=>{if(typeof fetch==="undefined"&&(n==null||n.fetchFunc==null)){return null}else{let e=true;if(Array.isArray(t)){e=t.every((t=>ym(t)))}else{e=ym(t)}if(e){return Cm(t,n)}}return null};Qr.registerSaveRouter(km);Qr.registerLoadRouter(km);function Cm(t,n){return new vm(t,n)}function Nm(t,n){const e=t.shape.length;const s=n.shape.length;if(e<1){throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+` but the rank was ${e}.`)}if(s<1){throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+` but the rank was ${s}.`)}if(n.dtype!=="int32"){throw new Error("tf.gatherND() expects the indices to be int32 type,"+` but the dtype was ${n.dtype}.`)}if(n.shape[s-1]>e){throw new Error("index innermost dimension length must be <= tensor rank; saw: "+`${n.shape[s-1]} vs. ${e}`)}if(g(t.shape)===0){throw new Error("Requested more than 0 entries, but input is empty."+` Input shape: ${t.shape}.`)}const o=n.shape;const r=o[o.length-1];let i=1;for(let t=0;t<o.length-1;++t){i*=o[t]}const c=t.shape;const a=o.slice();a.pop();let u=1;for(let t=r;t<e;++t){u*=c[t];a.push(c[t])}const l=[...V(t.shape).map((t=>t/u)),1].slice(0,r);return[a,i,u,l]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rm=-2;const Sm=-1;function Em(t,n,e){const s=t.shape.length;m(s===n.length,(()=>`Error in slice${s}D: Length of begin ${n} must `+`match the rank of the array (${s}).`));m(s===e.length,(()=>`Error in slice${s}D: Length of size ${e} must `+`match the rank of the array (${s}).`));for(let o=0;o<s;++o){m(n[o]+e[o]<=t.shape[o],(()=>`Error in slice${s}D: begin[${o}] + size[${o}] `+`(${n[o]+e[o]}) would overflow input.shape[${o}] (${t.shape[o]})`))}}function Tm(t){const n=[];let e=0;while(t>0){if(t&1){n.push(e)}t/=2;e++}return n}function Im(t,n,e){const s=[];for(let o=0;o<t.length;o++){s[o]=Math.ceil((n[o]-t[o])/e[o])}return s}function Am(t,n,e,s){const o=[...t];for(let t=o.length;t<s.length;t++){o.push(1)}for(let t=0;t<e;t++){if(t===0){o[n]=1}else{o.splice(n,0,1);o.pop()}}return o}function Om(t,n,e){if(e<=t){return e}return e-(n-1)}function Fm(t,n){const e=[];for(let s=0;s<t;s++){e.push(n+s)}return e}function _m(t,n,e,s,o,r,i,c,a){const u=t.length;let l=new Array(u),f=new Array(u),h=new Array(u);if(n.length&&e>0){const a=n[0];const u=e+1;l=Mm(i,a,u,s,t);f=Dm(c,a,u,o,t);h=Am(r,a,u,t)}else{for(let n=0;n<u;n++){l[n]=zm(i,s,r,t,n,a);f[n]=Pm(c,o,r,t,n,a);h[n]=Lm(r,n,a)}}return{begin:l,end:f,strides:h}}function Mm(t,n,e,s,o){const r=[...o];const i=Fm(e,n);for(let o=0;o<r.length;o++){if(i.indexOf(o)>-1){r[o]=0}else{const i=Om(n,e,o);let c=s[i];if(t&1<<i){c=0}r[o]=c}}return r}function Dm(t,n,e,s,o){const r=[...o];const i=Fm(e,n);for(let o=0;o<r.length;o++){if(i.indexOf(o)>-1){r[o]=Number.MAX_SAFE_INTEGER}else{const i=Om(n,e,o);let c=s[i];if(t&1<<i){c=Number.MAX_SAFE_INTEGER}r[o]=c}}for(let t=0;t<r.length;t++){const n=o[t];if(r[t]<0){r[t]+=n}r[t]=f(0,r[t],o[t])}return r}function Lm(t,n,e){let s=t[n];if(e&1<<n||s==null){s=1}return s}function zm(t,n,e,s,o,r){let i=n[o];const c=e[o]||1;if(t&1<<o||r&1<<o||i==null){if(c>0){i=Number.MIN_SAFE_INTEGER}else{i=Number.MAX_SAFE_INTEGER}}const a=s[o];if(i<0){i+=a}i=f(0,i,a-1);return i}function Pm(t,n,e,s,o,r){let i=n[o];const c=e[o]||1;if(t&1<<o||r&1<<o||i==null){if(c>0){i=Number.MAX_SAFE_INTEGER}else{i=Number.MIN_SAFE_INTEGER}}const a=s[o];if(i<0){i+=a}if(c>0){i=f(0,i,a)}else{i=f(-1,i,a-1)}return i}function Vm(t,n,e){let s=e.length;for(let t=0;t<e.length;t++){if(e[t]>1){s=t;break}}for(let o=s+1;o<e.length;o++){if(n[o]>0||e[o]!==t[o]){return false}}return true}function Bm(t,n){let e=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++){e+=t[s]*n[s]}return e}function Wm(t,n,e){let s;const o=t.shape.length;if(typeof n==="number"){s=[n,...new Array(o-1).fill(0)]}else if(n.length<o){s=n.concat(new Array(o-n.length).fill(0))}else{s=n.slice()}s.forEach((t=>{m(t!==-1,(()=>"slice() does not support negative begin indexing."))}));let r;if(e==null){r=new Array(o).fill(-1)}else if(typeof e==="number"){r=[e,...new Array(o-1).fill(-1)]}else if(e.length<o){r=e.concat(new Array(o-e.length).fill(-1))}else{r=e}r=r.map(((n,e)=>{if(n>=0){return n}else{m(n===-1,(()=>`Negative size values should be exactly -1 but got `+`${n} for the slice() size at index ${e}.`));return t.shape[e]-s[e]}}));return[s,r]}function Gm(t,n,e,s,o,r,i,c,a){let u;if(s==null){u=new Array(n.length);u.fill(1)}else{u=s}if(i!=null&&(i&i-1)!==0){throw new Error("Multiple ellipses in slice is not allowed.")}let l=false;const f={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:u.slice(),beginMask:o,endMask:r,ellipsisMask:i,newAxisMask:c,shrinkAxisMask:a};for(let t=0;t<f.dims;t++){if(l&&(1<<t&c)!==0){f.numAddAxisAfterEllipsis++}if(1<<t&i){l=true}}if(!l){f.ellipsisMask|=1<<f.dims;f.dims++}const h={dims:t.length,beginMask:0,endMask:0,beginValid:false,endValid:false};Um(f,h);let d=true;let p=true;let m=true;const x=[];const b=[];for(let n=0;n<t.length;++n){if(h.strides[n]===0){throw Error(`strides[${n}] must be non-zero`)}const e=!!(h.shrinkAxisMask&1<<n);const s=t[n];if(s===-1){x.push(e?1:-1);continue}const o=[h.beginMask&1<<n,h.endMask&1<<n];const r=[h.strides[n]>0?0:-1,h.strides[n]>0?s:s-1];if(e&&h.strides[n]<=0){throw Error("only stride 1 allowed on non-range indexing.")}m=m&&h.strides[n]===1;const i=!!(h.beginMask&1<<n&&h.endMask&1<<n);if(h.beginValid&&h.endValid){if(e){const t=h.begin[n]<0?s+h.begin[n]:h.begin[n];h.begin[n]=t;h.end[n]=h.begin[n]+1;if(t<0||t>=s){throw Error(`slice index ${h.begin[n]} of dimension ${n} out of bounds.`)}}else{h.begin[n]=Hm(h.begin[n],0,h.strides[n],s,o,r);h.end[n]=Hm(h.end[n],1,h.strides[n],s,o,r)}const t=h.strides[n]===1&&h.begin[n]===0&&h.end[n]===s;d=d&&t;p=p&&(n===0&&h.strides[n]===1||t)}else{d=d&&(h.strides[n]===1&&i);p=p&&(n===0&&h.strides[n]===1||i)}let c;let a=false;if(h.beginValid&&h.endValid){c=h.end[n]-h.begin[n];a=true}else if(e){c=1;a=true}else if(i){if(s>=0){if(h.strides[n]<0){c=-s}else{c=s}a=true}}if(a){let t;if(c===0||c<0!==h.strides[n]<0){t=0}else{t=Math.trunc(c/h.strides[n])+(c%h.strides[n]!==0?1:0)}x.push(t)}else{x.push(-1)}}for(let t=0;t<h.finalShapeGatherIndices.length;++t){const n=h.finalShapeGatherIndices[t];if(n>=0){b.push(x[n])}else if(n===Rm){b.push(1)}}const g=b.filter(((t,n)=>h.finalShapeGatherIndices[n]!==Rm));return{finalShapeSparse:g,finalShape:b,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Um(t,n){n.beginMask=0;n.endMask=0;n.shrinkAxisMask=0;let e=0;n.beginValid=t.begin!=null;n.endValid=t.end!=null;n.begin=new Array(n.dims);n.end=new Array(n.dims);n.strides=new Array(n.dims);n.finalShapeGatherIndices=[];n.finalShapeGatherIndicesSparse=[];n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let s=0;s<t.dims;s++){if(1<<s&t.ellipsisMask){const o=Math.min(n.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<o;e++){n.begin[e]=0;n.end[e]=0;n.strides[e]=1;n.beginMask|=1<<e;n.endMask|=1<<e;n.finalShapeGatherIndices.push(e);n.finalShapeGatherIndicesSparse.push(-1);n.inputShapeGatherIndicesSparse[e]=s}}else if(1<<s&t.newAxisMask){n.finalShapeGatherIndices.push(Rm);n.finalShapeGatherIndicesSparse.push(-1)}else{if(e===n.begin.length){throw Error(`Index out of range using input dim ${e}; input `+`has only ${n.dims} dims, ${n.begin.length}.`)}if(t.begin!=null){n.begin[e]=t.begin[s]}if(t.end!=null){n.end[e]=t.end[s]}n.strides[e]=t.strides[s];if(t.beginMask&1<<s){n.beginMask|=1<<e}if(t.endMask&1<<s){n.endMask|=1<<e}if(t.shrinkAxisMask&1<<s){n.finalShapeGatherIndices.push(Sm);n.finalShapeGatherIndicesSparse.push(-1);n.shrinkAxisMask|=1<<e}else{n.finalShapeGatherIndices.push(e);n.finalShapeGatherIndicesSparse.push(s)}n.inputShapeGatherIndicesSparse[e]=s;e++}}}function Hm(t,n,e,s,o,r){if(o[n]){return e>0?r[n]:r[n+1&1]}else{const n=t<0?s+t:t;return n<r[0]?r[0]:n>r[1]?r[1]:n}}const jm=Object.freeze({__proto__:null,assertParamsValid:Em,maskToAxes:Tm,computeOutShape:Im,stridesWithElidedDims:Am,getNormalizedAxes:_m,startIndicesWithElidedDims:Mm,stopIndicesWithElidedDims:Dm,stridesForAxis:Lm,startForAxis:zm,stopForAxis:Pm,isSliceContinous:Vm,computeFlatOffset:Bm,parseSliceParams:Wm,sliceInfo:Gm});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qm{static sgd(t){return new om(t)}static momentum(t,n,e=false){return new rm(t,n,e)}static rmsprop(t,n=.9,e=0,s=null,o=false){return new im(t,n,e,s,o)}static adam(t=.001,n=.9,e=.999,s=null){return new em(t,n,e,s)}static adadelta(t=.001,n=.95,e=null){return new tm(t,n,e)}static adamax(t=.002,n=.9,e=.999,s=null,o=0){return new sm(t,n,e,s,o)}static adagrad(t,n=.1){return new nm(t,n)}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xm=qm;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Km=(()=>{if(typeof requestAnimationFrame!=="undefined"){return requestAnimationFrame}else if(typeof setImmediate!=="undefined"){return setImmediate}return t=>t()})();function Jm(){return new Promise((t=>Km((()=>t()))))}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(t,n){const e=t[0].length;t.forEach(((t,n)=>{m(t.length===e,(()=>`Error in concat${e}D: rank of tensors[${n}] must be the same `+`as the rank of the rest (${e})`))}));m(n>=0&&n<e,(()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`));const s=t[0];t.forEach(((t,o)=>{for(let r=0;r<e;r++){m(r===n||t[r]===s[r],(()=>`Error in concat${e}D: Shape of tensors[${o}] (${t}) `+`does not match the shape of the rest (${s}) `+`along the non-concatenated axis ${o}.`))}}))}function Zm(t,n){const e=t[0].slice();for(let s=1;s<t.length;s++){e[n]+=t[s][n]}return e}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Qm;(function(t){t[t["FIRST_DIM_SIZE"]=0]="FIRST_DIM_SIZE";t[t["VALUE_ROWIDS"]=1]="VALUE_ROWIDS";t[t["ROW_LENGTHS"]=2]="ROW_LENGTHS";t[t["ROW_SPLITS"]=3]="ROW_SPLITS";t[t["ROW_LIMITS"]=4]="ROW_LIMITS";t[t["ROW_STARTS"]=5]="ROW_STARTS"})(Qm||(Qm={}));function tx(t,n,e){let s=new Array;if(e==null&&n==null){return s}if(n==null){while(s.length<t+e.length){s.push(-1)}}else{s=n.slice()}if(e==null){return s}if(t+e.length!==s.length){throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${s.length}`)}for(let o=1;o<e.length;++o){const r=e[o];const i=s[s.length-e.length+o];const c=s[i];if(r>=0){if(c>=0){if(c!==r){throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${o+t}] = ${r} but shape[${o+t}] = ${c}`)}}else{s[i]=r}}}return s}function nx(t){const n={FIRST_DIM_SIZE:Qm.FIRST_DIM_SIZE,VALUE_ROWIDS:Qm.VALUE_ROWIDS,ROW_LENGTHS:Qm.ROW_LENGTHS,ROW_SPLITS:Qm.ROW_SPLITS,ROW_LIMITS:Qm.ROW_LIMITS,ROW_STARTS:Qm.ROW_STARTS};const e=[];for(const s of t){if(s in n){e.push(n[s])}else{break}}return e}function ex(t){if(t.length===0){return 0}if(t[0]===Qm.FIRST_DIM_SIZE){return t.length-1}return t.length}function sx(t,n){if(t==null||n==null){return}const e=t.length;const s=n.length;if(e>=s){throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`)}for(let o=0;o<Math.min(e,s-1);++o){const e=t[o];const s=n[o+1];if(e>=0&&s>=0&&e!==1&&e!==s){throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${o-t.length}] = ${e} but ragged tensor input.flatValues.shape[${o-t.length}] = ${s}`)}}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ox=30;function rx(t){if(t<=ox){return t}return P(t,Math.floor(Math.sqrt(t)))}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ix(t,n,e){const s=e*(typeof t==="number"?t:t[0]);const o=n*(typeof t==="number"?t:t[1]);return[s,o]}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(t,n,e,s=true){let o=[];if(s){o=o.concat(n.slice(0));o.push(t[0]/e);o=o.concat(t.slice(1))}else{o=o.concat(t[0]);const e=n.length;for(let s=0;s<e;++s){o=o.concat([t[s+1]/n[s],n[s]])}o=o.concat(t.slice(e+1))}return o}function ax(t,n,e=true){const s=[];if(e){s.push(n);for(let e=n+1;e<t;++e){if(e<=2*n){s.push(e);s.push(e-(n+1))}else{s.push(e)}}}else{const e=[];const o=[];for(let s=1;s<t;++s){if(s>=n*2+1||s%2===1){o.push(s)}else{e.push(s)}}s.push(...e);s.push(0);s.push(...o)}return s}function ux(t,n,e,s=true){const o=[];if(s){o.push(t[0]/e)}else{o.push(t[0]*e)}for(let e=1;e<t.length;++e){if(e<=n.length){if(s){o.push(n[e-1]*t[e])}else{o.push(t[e]/n[e-1])}}else{o.push(t[e])}}return o}function lx(t,n){const e=[0];for(let s=0;s<n;++s){e.push(t[s][0])}return e}function fx(t,n,e){const s=t.slice(0,1);for(let o=0;o<e;++o){s.push(t[o+1]-n[o][0]-n[o][1])}return s}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hx=1.7580993408473768;const dx=1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const px=.3275911;const mx=.254829592;const xx=-.284496736;const bx=1.421413741;const gx=-1.453152027;const wx=1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vx(t,n){if(t.length!==n.length){throw new Error(`Cannot merge real and imag arrays of different lengths. real:`+`${t.length}, imag: ${n.length}.`)}const e=new Float32Array(t.length*2);for(let s=0;s<e.length;s+=2){e[s]=t[s/2];e[s+1]=n[s/2]}return e}function $x(t){const n=new Float32Array(t.length/2);const e=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2){n[s/2]=t[s];e[s/2]=t[s+1]}return{real:n,imag:e}}function yx(t){const n=Math.ceil(t.length/4);const e=new Float32Array(n);const s=new Float32Array(n);for(let n=0;n<t.length;n+=4){e[Math.floor(n/4)]=t[n];s[Math.floor(n/4)]=t[n+1]}return{real:e,imag:s}}function kx(t){const n=Math.floor(t.length/4);const e=new Float32Array(n);const s=new Float32Array(n);for(let n=2;n<t.length;n+=4){e[Math.floor(n/4)]=t[n];s[Math.floor(n/4)]=t[n+1]}return{real:e,imag:s}}function Cx(t,n){const e=t[n*2];const s=t[n*2+1];return{real:e,imag:s}}function Nx(t,n,e,s){t[s*2]=n;t[s*2+1]=e}function Rx(t,n){const e=new Float32Array(t/2);const s=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const r=(n?2:-2)*Math.PI*(o/t);e[o]=Math.cos(r);s[o]=Math.sin(r)}return{real:e,imag:s}}function Sx(t,n,e){const s=(e?2:-2)*Math.PI*(t/n);const o=Math.cos(s);const r=Math.sin(s);return{real:o,imag:r}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ex="->";const Tx=/->/g;const Ix=",";const Ax="...";function Ox(t,n){t=t.replace(/\s/g,"");const e=(t.length-t.replace(Tx,"").length)/Ex.length;if(e<1){throw new Error("Equations without an arrow are not supported.")}else if(e>1){throw new Error(`Equation must contain exactly one arrow ("${Ex}").`)}const[s,o]=t.split(Ex);m(s.indexOf(Ax)===-1,(()=>`The ellipsis notation ("${Ax}") is not supported yet.`));const r=s.split(Ix);const i=r.length;if(n!==i){throw new Error(`Expected ${i} input tensors, received ${n}`)}if(i>2){throw new Error("Support for more than 2 input tensors is not implemented yet.")}const c=[];for(let t=0;t<o.length;++t){const n=o[t];if(!r.some((t=>t.indexOf(n)!==-1))){throw new Error(`Output subscripts contain the label ${n} `+`not present in the input subscripts.`)}if(c.indexOf(n)===-1){c.push(n)}}for(let t=0;t<s.length;++t){const n=s[t];if(c.indexOf(n)===-1&&n!==Ix){c.push(n)}}const a=new Array(r.length);for(let t=0;t<i;++t){if(new Set(r[t].split("")).size!==r[t].length){throw new Error(`Found duplicate axes in input component ${r[t]}. `+`Support for duplicate axes in input is not implemented yet.`)}a[t]=[];for(let n=0;n<r[t].length;++n){a[t].push(c.indexOf(r[t][n]))}}const u=c.length;const l=o.length;const f=[];for(let t=l;t<u;++t){f.push(t)}return{allDims:c,summedDims:f,idDims:a}}function Fx(t,n){let e=new Array(t);e.fill(-1);for(let t=0;t<n.length;++t){e[n[t]]=t}const s=[];for(let n=0;n<t;++n){if(e[n]===-1){s.push(n)}}e=e.filter((t=>t!==-1));return{permutationIndices:e,expandDims:s}}function _x(t,n,e){const s=new Array(t);for(let t=0;t<e.length;++t){const o=e[t].shape;for(let e=0;e<n[t].length;++e){if(s[n[t][e]]===undefined){s[n[t][e]]=o[e]}else{m(s[n[t][e]]===o[e],(()=>`Expected dimension ${s[n[t][e]]} at axis ${e} `+`of input shaped ${JSON.stringify(o)}, `+`but got dimension ${o[e]}`))}}}}function Mx(t,n){const e=t;const s=[];let o=0;if(t.length===0){e.push(-1)}o=t.length+1;for(let t=0;t<o;++t){s.push([])}const r=[];for(let t=0;t<e.length;++t){const o=e[t];const i=Lx(n,o);for(const n of i){if(r.indexOf(n)===-1){s[t].push(n);r.push(n)}}}return{path:e,steps:s}}function Dx(t){return t.every(((t,n)=>t===n))}function Lx(t,n){const e=[];for(let s=0;s<t.length;++s){if(t[s].length===0||t[s].indexOf(n)!==-1||n===-1){e.push(s)}}return e}function zx(t,n,e=0){let s=[];if(typeof n==="number"){m(t.shape[e]%n===0,(()=>"Number of splits must evenly divide the axis."));s=new Array(n).fill(t.shape[e]/n)}else{const o=n.reduce(((t,n)=>{if(n===-1){t+=1}return t}),0);m(o<=1,(()=>"There should be only one negative value in split array."));const r=n.indexOf(-1);if(r!==-1){const s=n.reduce(((t,n)=>n>0?t+n:t));n[r]=t.shape[e]-s}m(t.shape[e]===n.reduce(((t,n)=>t+n)),(()=>"The sum of sizes must match the size of the axis dimension."));s=n}return s}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function Vx(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function Bx(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function Gx(t,n){return`size ${t} must be non-negative, not ${n}`}function Ux(){return"reshape cannot infer the missing input size for an empty tensor "+"unless all specified input sizes are non-zero"}function Hx(t,n){const e=g(t);const s=g(n);return`Input to reshape is a SparseTensor with ${e}\n  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${n}`}function jx(t,n){const e=g(t);const s=g(n);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${n}`}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(){return`segment ids must be >= 0`}function Xx(){return`segment ids are not increasing`}function Kx(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function Jx(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yx(t,n){let e=false;let s;if(t<=ox){s=t;e=true}else{s=P(t,Math.floor(Math.sqrt(t)))}while(!e){if(s>n||s===t){e=true}else{s=P(t,s+1)}}return s}function Zx(t,n,e){const s=[];const o=t.length;for(let r=0;r<o;r++){if(r!==n){s.push(t[r])}else{s.push(e)}}return s}function Qx(t,n,e,s){const o=n.shape.length;const r=t.shape.length;if(s!==0){if(s<-o||s>o){throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`)}}if(s<0){s+=o}if(s>r){throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${r}).`)}if(e<s){throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`)}for(let e=0;e<s;++e){if(t.shape[e]!==n.shape[e]){throw new Error(`x.shape[${e}]: ${t.shape[e]} should be equal to indices.shape[${e}]: ${n.shape[e]}.`)}}const i=t.shape[e];const c=[];let a=1;let u=1;let l=1;for(let n=0;n<s;++n){c.push(t.shape[n]);a*=t.shape[n]}for(let n=s;n<e;n++){c.push(t.shape[n]);u*=t.shape[n]}for(let t=s;t<o;t++){c.push(n.shape[t])}for(let n=e+1;n<r;n++){c.push(t.shape[n]);l*=t.shape[n]}return{batchSize:a,sliceSize:l,outerSize:u,dimSize:i,outputShape:c}}const tb=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:Yx,computeOutShape:Zx,collectGatherOpShapeInfo:Qx});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(t){try{return t.map((t=>Ao(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function eb(t){return t.map((t=>Io(t)))}const sb=Object.freeze({__proto__:null,slice_util:jm,segment_util:tb,fromUint8ToStringArray:nb,fromStringArrayToUint8:eb,upcastType:ar,axesAreInnerMostDims:Tu,combineLocations:Iu,computeOutAndReduceShapes:Au,expandShapeToKeepDim:Ou,assertAxesAreInnerMostDims:Fu,getAxesPermutation:_u,getUndoAxesPermutation:Mu,getInnerMostAxes:Du,getBroadcastDims:lu,getReductionAxes:fu,assertAndGetBroadcastShape:hu,assertParamsConsistent:Ym,computeOutShape:Zm,computeDilation2DInfo:Nc,computePool2DInfo:Rc,computePool3DInfo:Sc,computeConv2DInfo:Ec,computeConv3DInfo:Tc,computeDefaultPad:Oc,tupleValuesAreOne:Pc,eitherStridesOrDilationsAreOne:Vc,stridesOrDilationsArePositive:Bc,convertConv2DDataFormat:Wc,checkPadOnDimRoundingMode:Gc,getFusedDyActivation:zd,getFusedBiasGradient:Pd,applyActivation:Vd,shouldFuse:Bd,get RowPartitionType(){return Qm},combineRaggedTensorToTensorShapes:tx,getRowPartitionTypesHelper:nx,getRaggedRank:ex,validateDefaultValueShape:sx,PARALLELIZE_THRESHOLD:ox,computeOptimalWindowSize:rx,getImageCenter:ix,getReshaped:cx,getPermuted:ax,getReshapedPermuted:ux,getSliceBeginCoords:lx,getSliceSize:fx,prepareAndValidate:Nm,validateUpdateShape:xd,validateInput:bd,calculateShapes:gd,SELU_SCALEALPHA:hx,SELU_SCALE:dx,ERF_P:px,ERF_A1:mx,ERF_A2:xx,ERF_A3:bx,ERF_A4:gx,ERF_A5:wx,warn:ks,log:Cs,mergeRealAndImagArrays:vx,splitRealAndImagArrays:$x,complexWithEvenIndex:yx,complexWithOddIndex:kx,getComplexWithIndex:Cx,assignToTypedArray:Nx,exponents:Rx,exponent:Sx,decodeEinsumEquation:Ox,getEinsumPermutation:Fx,checkEinsumDimSizes:_x,getEinsumComputePath:Mx,isIdentityPermutation:Dx,prepareSplitSize:zx,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Px,getSparseFillEmptyRowsNegativeIndexErrorMessage:Vx,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Bx,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Wx,getSparseReshapeNegativeOutputDimErrorMessage:Gx,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ux,getSparseReshapeInputOutputMultipleErrorMessage:Hx,getSparseReshapeInputOutputMismatchErrorMessage:jx,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:qx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Xx,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Kx,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Jx});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */am();
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob={kernelName:ut,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,ud(Mi(e,"float32"),-1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rb={kernelName:lt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=qu(Mi(e,"float32"));const s=Hu(Xl(Gu(1),n));return Wl(Zi(t,s))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ib={kernelName:ft,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=Hu(Xl(qu(Mi(e,"float32")),1));return Zi(t,n)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cb={kernelName:ht,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{let n=t;const s=fu(e.shape,o);if(s.length>0){n=Ku(n,s)}return Hc(n,e.shape)};const i=()=>{let n=t;const e=fu(s.shape,o);if(e.length>0){n=Ku(n,e)}return Hc(n,s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ab={kernelName:dt,saveAllInputs:true,gradFunc:(t,n)=>{const e={};n.forEach(((n,s)=>{e[s]=()=>t.clone()}));return e}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ub={kernelName:xt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>gu(e)}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lb={kernelName:bt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>gu(e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fb={kernelName:gt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Hu(Xl(Gu(1),qu(Mi(e,"float32")))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb={kernelName:wt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=Hu(Xi(Gu(1),qu(Mi(e,"float32"))));return Zi(t,n)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const db={kernelName:yt,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{const n=Xi(qu(e),qu(s));let r=tc(t,Zi(s,n));const i=fu(e.shape,o);if(i.length>0){r=Ku(r,i)}return Hc(r,e.shape)};const i=()=>{const n=Xi(qu(e),qu(s));let r=Wl(tc(t,Zi(e,n)));const i=fu(s.shape,o);if(i.length>0){r=Ku(r,i)}return Hc(r,s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pb={kernelName:vt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Xi(qu(Mi(e,"float32")),1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mb={kernelName:$t,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Xl(Gu(1),qu(Mi(e,"float32"))))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(t,n,e,s,o,r){const i=Ir(t,"dy","avgPool3dGrad");const c=Ir(n,"input","avgPool3dGrad");let a=i;let u=c;let l=false;if(c.rank===4){l=true;a=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]);u=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])}m(a.rank===5,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank `+`${a.rank}.`));m(u.rank===5,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank `+`${u.rank}.`));Gc("avgPool3dGrad",o,r);const f={dy:a,input:u};const h={filterSize:e,strides:s,pad:o,dimRoundingMode:r};const d=$r.runKernel(Rt,f,h);if(l){return Hc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]])}return d}const bb=Fr({avgPool3dGrad_:xb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gb={kernelName:Nt,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{filterSize:o,strides:r,pad:i,dimRoundingMode:c}=e;return{x:()=>bb(t,s,o,r,i,c)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wb(t,n,e,s,o){const r=Ir(t,"dy","avgPoolGrad");const i=Ir(n,"input","avgPoolGrad");m(i.rank===r.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${r.rank})`));let c=i;let a=r;let u=false;if(i.rank===3){u=true;c=Hc(i,[1,i.shape[0],i.shape[1],i.shape[2]]);a=Hc(r,[1,r.shape[0],r.shape[1],r.shape[2]])}m(a.rank===4,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank `+`${a.rank}.`));m(c.rank===4,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank `+`${c.rank}.`));const l={dy:a,input:c};const f={filterSize:e,strides:s,pad:o};const h=$r.runKernel(Ct,l,f);if(u){return Hc(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}const vb=Fr({avgPoolGrad_:wb});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $b={kernelName:kt,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{filterSize:o,strides:r,pad:i}=e;return{x:()=>vb(t,s,o,r,i)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yb={kernelName:St,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{const[s,o]=n;const{transposeA:r,transposeB:i}=e;if(!r&&!i){return{a:()=>Qc(t,o,false,true),b:()=>Qc(s,t,true,false)}}else if(!r&&i){return{a:()=>Qc(t,o,false,false),b:()=>Qc(t,s,true,false)}}else if(r&&!i){return{a:()=>Qc(o,t,false,true),b:()=>Qc(s,t,false,false)}}else{return{a:()=>Qc(o,t,true,true),b:()=>Qc(t,s,true,true)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kb={kernelName:Et,gradFunc:(t,n,e)=>{const{blockShape:s,crops:o}=e;return{x:()=>Mf(t,s,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cb={kernelName:At,gradFunc:(t,n,e)=>{const s=e;const o=s.inputShape;const r=s.shape;const i=Array.from(r);for(let t=o.length-1;t>=0;t--){if(o[t]===r[t]){i[t]=1}else if(o[t]!==1){throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${r}].`)}}const c=[];for(let t=0;t<i.length;t++){if(i[t]>1){c.push(t)}}return{x:()=>Ku(t,c,true)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nb={kernelName:Ft,gradFunc:t=>({x:()=>t.clone()})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rb={kernelName:_t,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sb={kernelName:Mt,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{clipValueMin:o,clipValueMax:r}=e;return{x:()=>xu(tf(gl(s,o),Ol(s,r)),t,gu(t))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eb={kernelName:Lt,inputsToSave:["x"],gradFunc:ob.gradFunc};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tb={kernelName:zt,saveAllInputs:true,gradFunc:(t,n,e)=>{const s=n.map((t=>t.shape));const{axis:o}=e;const r=N(o,n[0].shape)[0];const i=s.map((t=>t[r]));const c=Qh(t,i,r);return c.map((t=>()=>t))}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ib={kernelName:Pt,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const{dilations:r,strides:i,pad:c,dataFormat:a}=e;m(Pc(r),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+`are not yet supported in gradients. Got dilations '${r}'`));return{x:()=>Pa(s.shape,t,o,i,c,a),filter:()=>Ld(s,t,o.shape,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ab={kernelName:Bt,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const{strides:r,pad:i,dataFormat:c,dimRoundingMode:a}=e;return{dy:()=>Ma(t,o,r,i,c,1,a),filter:()=>Ld(t,s,o.shape,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ob(t,n,e,s,o){let r=t;if(t.rank===4){r=Hc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])}let i=n;if(i.rank===4){i=Hc(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])}m(r.rank===5,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape `+`${r.shape}.`));m(i.rank===5,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape `+`${i.shape}.`));m(e.length===5,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got `+`${e}.`));m(r.shape[4]===e[3],(()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must `+`match input depth in filter (${e[3]}.`));m(i.shape[4]===e[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must `+`match output depth for filter (${e[4]}).`));const c={x:r,dy:i};const a={strides:s,pad:o,filterShape:e};return $r.runKernel(Gt,c,a)}const Fb=Fr({conv3DBackpropFilter_:Ob});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _b={kernelName:Wt,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:s,strides:o,pad:r}=e;m(Pc(s),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+`not yet supported in gradients. Got dilations '${s}'`));const[i,c]=n;return{x:()=>Ha(i.shape,t,c,o,r),filter:()=>Fb(i,t,c.shape,o,r)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mb={kernelName:Ht,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(Wl(Fh(Mi(e,"float32"))),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Db={kernelName:jt,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(Mh(Mi(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lb={kernelName:Xt,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o,exclusive:r,reverse:i}=e;return{x:()=>{const n=_u([o],s.rank);let e=nu(t,o,r,!i);if(n!=null){e=Od(e,n)}return e}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb={kernelName:Zt,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const{dilations:s,strides:o,pad:r,dimRoundingMode:i}=e;const c=s==null?[1,1]:s;m(Pc(c),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates "+`greater than 1 are not yet supported. Got dilations `+`'${c}'`));const[a,u]=n;m(a.rank===4,(()=>`Error in gradient of depthwiseConv2dNative: input must be `+`rank 4, but got rank ${a.rank}.`));m(u.rank===4,(()=>`Error in gradient of depthwiseConv2dNative: filter must be `+`rank 4, but got rank ${u.rank}.`));m(a.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input `+`channels (${a.shape[3]}) must match the inChannels dimension `+`in filter ${u.shape[2]}.`));m(Vc(o,c),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+`dilations must be  1. Got strides ${o} and dilations `+`'${c}'.`));Gc("depthwiseConv2d",r,i);return{x:()=>qd(a.shape,t,u,o,r,c,i),filter:()=>Hd(a,t,u.shape,o,r,c,i)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb={kernelName:en,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{const[s,o]=n;const r={x:s,filter:o,dy:t};const i={x:s,filter:o,dy:t};return{x:()=>$r.runKernel(sn,r,e),filter:()=>$r.runKernel(on,i,e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb={kernelName:un,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;const s={dy:t,y:e};return{x:()=>$r.runKernel(ln,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bb={kernelName:fn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;const s=tc(el(Wl(qu(e))),2/Math.sqrt(Math.PI));return{x:()=>tc(t,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wb={kernelName:dn,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,e)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gb={kernelName:pn,inputsToSave:["input"],gradFunc:(t,n)=>{const[e]=n;return{input:()=>Hc(t,e.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ub={kernelName:mn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,el(e))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hb={kernelName:wn,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jb={kernelName:vn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{const n=Zi(t,Mi(s,"float32"));const r=fu(e.shape,o);if(r.length>0){return Hc(Ku(n,r),e.shape)}return n};const i=()=>{let n=tc(t,Mi(e,"float32"));const r=fu(s.shape,o);if(r.length>0){n=Hc(Ku(n,r),s.shape)}const i=qu(s);return Wl(Zi(n,Mi(i,"float32")))};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb={kernelName:$n,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{const{varianceEpsilon:s}=e;const[o,r,i,c]=n;const a=c==null?Gu(1):c;const u=fu(r.shape,o.shape);const l=[];if(r.rank===1){for(let t=0;t<o.shape.length-1;++t){l.push(o.shape[t])}l.push(1)}const f=Xl(o,r);const h=tc(t,a);const d=Nh(Xi(i,Gu(s)));const p=tc(tc(tc(d,d),d),Gu(-.5));const m=()=>{if(r.rank===1){return Hc(tc(tc(t,al(Hc(d,[1,1,1,r.shape[0]]),l)),a),o.shape)}else{return Hc(tc(tc(t,d),a),o.shape)}};const x=()=>{let t=tc(tc(d,Gu(-1)),h);if(r.rank===1){t=Ku(t,u)}return Hc(t,r.shape)};const b=()=>{let t=tc(tc(p,f),h);if(r.rank===1){t=Ku(t,u)}return Hc(t,r.shape)};const g=()=>{const n=tc(f,d);let e=tc(t,n);if(r.rank===1){e=Ku(e,u)}return Hc(e,r.shape)};const w=()=>{let n=t;if(r.rank===1){n=Ku(n,u)}return Hc(n,r.shape)};return{x:m,mean:x,variance:b,scale:g,offset:w}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xb={kernelName:yn,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{const[s,o]=n;const{axis:r,batchDims:i}=e;const c=N(r,s.shape)[0];const a=(t,n,e)=>()=>{const s=t.shape;const o=n.size;const i=s.slice(0,c);const a=i.length;const u=s.slice(r,s.length).slice(1);const l=u.length;const f=Kb(0,a);const h=Kb(a+1,a+1+l);const d=Jb([i,[o],u]);const p=Hc(e,d);const m=Hc(n,[o]);const x=Jb([[a],f,h]);const b=Od(p,x);let g=Rd(b,m,t.shape[c]);const w=Mu(x);g=Od(g,w);return g};if(i===1){const n=s.shape[0];const e=s.split(n,0);const r=()=>{const n=cd(e.map(((n,e)=>a(n,o.slice(e,1),t.slice(e,1))())));return n.reshape(s.shape)};return{x:r,indices:()=>o}}else{return{x:a(s,o,t),indices:()=>o}}}};function Kb(t,n){const e=[];for(let s=t;s<n;++s){e.push(s)}return e}function Jb(t){const n=[];for(let e=0;e<t.length;++e){for(let s=0;s<t[e].length;++s){n.push(t[e][s])}}return n}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yb={kernelName:Nn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;return{a:()=>gu(e),b:()=>gu(s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zb={kernelName:Rn,gradFunc:t=>({x:()=>Mi(t,"float32")})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qb={kernelName:Tn,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tg={kernelName:In,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ng={kernelName:An,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eg={kernelName:On,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{alpha:o}=e;const r=xl(s,0);return{x:()=>xu(r,t,tc(t,o))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sg={kernelName:Ln,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Xi(e,1))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const og={kernelName:Dn,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Mi(e,"float32"))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rg={kernelName:Bn,inputsToSave:[],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;return{logits:()=>{const n=true;const e=el(s);return Xl(t,tc(Ku(t,o,n),e))}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ig(t,n,e,s=5,o=1,r=1,i=.5){const c={x:t,y:n,dy:e};const a={depthRadius:s,bias:o,alpha:r,beta:i};return $r.runKernel(Gn,c,a)}const cg=Fr({localResponseNormalizationBackprop_:ig});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ag={kernelName:Wn,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=e;return{x:()=>cg(s,o,t,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ug(t,n,e,s){if(n.rank<e.rank){n=Hc(n,Ou(n.shape,s))}if(t.rank<e.rank){t=Hc(t,Ou(t.shape,s))}return{x:()=>{const s=tc(t,Mi(pu(e,n),t.dtype));return s}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lg={kernelName:Un,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const s=e;const{reductionIndices:o}=s;const r=n[0];const i=n[1];const c=N(o,r.shape);const a=ug(t,i,r,c);return{x:()=>a["x"]()}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fg={kernelName:Hn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=()=>tc(t,Mi(gl(e,s),"float32"));const r=()=>tc(t,Mi(Il(e,s),"float32"));return{a:o,b:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hg(t,n,e,s,o,r,i){const c=Ir(t,"dy","maxPool3dGrad");const a=Ir(n,"input","maxPool3dGrad");const u=Ir(e,"output","maxPool3dGrad");let l=c;let f=a;let h=u;let d=false;if(a.rank===4){d=true;l=Hc(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]);f=Hc(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]);h=Hc(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])}m(l.rank===5,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank `+`${l.rank}.`));m(f.rank===5,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank `+`${f.rank}.`));m(h.rank===5,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank `+`${h.rank}.`));Gc("maxPool3dGrad",r,i);const p={dy:l,input:f,output:h};const x={filterSize:s,strides:o,pad:r,dimRoundingMode:i};const b=$r.runKernel(Kn,p,x);if(d){return Hc(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]])}return b}const dg=Fr({maxPool3dGrad_:hg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pg={kernelName:Xn,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=e;return{x:()=>dg(t,s,o,r,i,c,a)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mg(t,n,e,s,o,r,i){const c=Ir(t,"dy","maxPoolGrad");const a=Ir(n,"input","maxPoolGrad");const u=Ir(e,"output","maxPoolGrad");m(a.rank===c.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy `+`(${c.rank})`));m(c.rank===4,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank `+`${c.rank}.`));m(a.rank===4,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank `+`${a.rank}.`));Gc("maxPoolGrad",r,i);const l={dy:c,input:a,output:u};const f={filterSize:s,strides:o,pad:r,dimRoundingMode:i};return $r.runKernel(qn,l,f)}const xg=Fr({maxPoolGrad_:mg});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bg={kernelName:jn,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const[s,o]=n;const{filterSize:r,strides:i,pad:c}=e;return{x:()=>xg(t,s,o,r,i,c)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gg={kernelName:Yn,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;const r=N(o,s.shape);const i=Au(s.shape,r);const c=i[1];const a=g(c);const u=()=>{const n=s.shape.slice();r.forEach((t=>{n[t]=1}));const e=Hc(t,n);const o=Zi(tc(e,bf(s.shape,"float32")),a);return o};return{x:u}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wg={kernelName:Zn,inputsToSave:["x"],outputsToSave:[true],gradFunc:(t,n,e)=>{const s=e;const{axis:o}=s;const[r,i]=n;const c=N(o,r.shape);const a=ug(t,i,r,c);return{x:()=>a["x"]()}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vg={kernelName:Qn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=()=>tc(t,Mi(Ol(e,s),"float32"));const r=()=>tc(t,Mi(xl(e,s),"float32"));return{a:o,b:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $g={kernelName:te,inputsToSave:["x"],gradFunc:(t,n,e)=>{const s=n[0];const{paddings:o}=e;const r=o.map((t=>t[0]));return{x:()=>sa(t,r,s.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yg={kernelName:ne,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{const n=fu(e.shape,o);if(n.length>0){return Hc(Ku(t,n),e.shape)}return t};const i=()=>{const n=tc(t,Wl(hl(Zi(e,s))));const r=fu(s.shape,o);if(r.length>0){return Hc(Ku(n,r),s.shape)}return n};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kg={kernelName:se,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{const n=tc(t,Mi(s,"float32"));const r=fu(e.shape,o);if(r.length>0){return Hc(Ku(n,r),e.shape)}return n};const i=()=>{const n=tc(t,Mi(e,"float32"));const r=fu(s.shape,o);if(r.length>0){return Hc(Ku(n,r),s.shape)}return n};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cg={kernelName:oe,gradFunc:t=>({x:()=>Wl(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ng={kernelName:le,inputsToSave:["indices"],gradFunc:(t,n)=>{const e=n[0];return{indices:()=>xf(e.shape,"float32")}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rg={kernelName:ue,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sg={kernelName:fe,saveAllInputs:true,gradFunc:(t,n,e)=>{const{axis:s}=e;const o=Ed(t,s);return o.map((t=>()=>t))}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eg={kernelName:he,inputsToSave:["x"],gradFunc:(t,n,e)=>{const s=n[0];const{paddings:o}=e;const r=o.map((t=>t[0]));return{x:()=>sa(t,r,s.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tg={kernelName:de,inputsToSave:["a","b"],outputsToSave:[true],gradFunc:(t,n)=>{const[e,s,o]=n;const r=e;const i=s;const c=hu(r.shape,i.shape);const a=()=>{const n=Mi(i,"float32");let e=tc(t,tc(n,Wu(r,Xl(n,Gu(1)))));const s=fu(r.shape,c);if(s.length>0){e=Ku(e,s)}return Hc(e,r.shape)};const u=()=>{const n=xl(r,0);const e=xu(n,Dl(r),gu(r));let s=tc(t,tc(o,e));const a=fu(i.shape,c);if(a.length>0){s=Ku(s,a)}return Hc(s,i.shape)};return{a,b:u}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ig={kernelName:pe,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{const[e,s]=n;const o=xl(e,0);return{x:()=>xu(o,t,tc(t,s)),alpha:()=>{let n=xu(o,gu(t),tc(t,e));const r=fu(s.shape,t.shape);if(r.length>0){n=Ku(n,r)}return Hc(n,s.shape)}}}};
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ag(t,n,e){const s=t.shape.slice();s[e]=1;const o=Hc(n,s);const r=Qa(t,e,true,false);const i=Qa(t,e,true,true);const c=tc(r,i);return tc(o,c)}function Og(t,n,e){const s=t.shape.length;const o=s-e.length;const r=_u(e,s);let i=t;if(r!=null){i=Od(t,r)}const c=i.shape.slice();const a=c.splice(s-e.length,e.length);const u=a.reduce(((t,n)=>t*n),1);c.push(u);const l=i.reshape(c);let f=Ag(l,n,o);f=f.reshape(i.shape);if(r!=null){const t=Mu(r);f=Od(f,t)}return f}const Fg={kernelName:me,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{axis:o}=e;let r=[];if(o===undefined||o===null){r=s.shape.map(((t,n)=>n))}else if(typeof o==="number"){r=[o]}else{r=o}return{x:()=>Og(s,t,r)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _g={kernelName:cn,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{const n=Zi(t,Mi(s,"float32"));const r=fu(e.shape,o);if(r.length>0){return Hc(Ku(n,r),e.shape)}return n};const i=()=>{let n=tc(t,Mi(e,"float32"));const r=fu(s.shape,o);if(r.length>0){n=Hc(Ku(n,r),s.shape)}const i=qu(s);return Wl(Zi(n,Mi(i,"float32")))};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mg={kernelName:$e,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,Wl(qu(e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dg={kernelName:Ee,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;const s=tc(Ol(e,6),ud(e));return{x:()=>tc(t,Mi(s,"float32"))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lg={kernelName:ye,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,Mi(ud(e),"float32"))}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zg={kernelName:ke,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Hc(t,e.shape)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pg={kernelName:Re,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[s]=n;const o={dy:t,images:s};const r=()=>$r.runKernel(Se,o,e);return{images:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vg={kernelName:Ce,inputsToSave:["images"],gradFunc:(t,n,e)=>{const[s]=n;const o={dy:t,images:s};const r=()=>$r.runKernel(Ne,o,e);return{images:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bg={kernelName:Te,gradFunc:(t,n,e)=>{const{dims:s}=e;const o=N(s,t.shape);return{x:()=>$h(t,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wg={kernelName:Ie,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gg={kernelName:Ae,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Wl(Zi(t,tc(Wu(e,1.5),2)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ug={kernelName:Me,inputsToSave:["condition"],gradFunc:(t,n)=>{const[e]=n;return{condition:()=>Mi(gu(e),"float32"),t:()=>tc(t,Mi(e,t.dtype)),e:()=>tc(t,Mi(ef(e),t.dtype))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hg={kernelName:De,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>{const n=xl(e,Gu(0));const s=Gu(hx);const o=Gu(dx);const r=tc(t,o);const i=tc(tc(t,s),el(Mi(e,"float32")));return xu(n,r,i)}}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jg={kernelName:Be,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,tc(e,Xl(Gu(1),e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qg={kernelName:Ve,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xg={kernelName:ze,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(Ka(Mi(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kg={kernelName:Pe,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(Ya(Mi(e,"float32")),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jg={kernelName:Le,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{begin:o,size:r}=e;const i=s.shape;const[c,a]=Wm(s,o,r);const u=[];for(let n=0;n<t.rank;n++){u.push([c[n],i[n]-c[n]-a[n]])}return{x:()=>Ff(t,u)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yg={kernelName:qe,outputsToSave:[true],gradFunc:(t,n,e)=>{const[s]=n;const{dim:o}=e;const r=true;const i=tc(t,s);return{logits:()=>Xl(i,tc(Ku(i,[o],r),s))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zg={kernelName:We,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,na(e))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qg={kernelName:He,gradFunc:(t,n,e)=>{const{blockShape:s,paddings:o}=e;return{x:()=>ca(t,s,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tw={kernelName:je,gradFunc:(t,n,e)=>{const{axis:s}=e;return{x:()=>Yc(t,s)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nw={kernelName:Ge,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,tc(Hu(Mi(e,"float32")),2))}}};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ew={kernelName:ts,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(t,tc(Mi(e,"float32"),2))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sw={kernelName:Qe,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=Gu(2);const r=()=>tc(t,tc(o,Xl(e,s)));const i=()=>tc(t,tc(o,Xl(s,e)));return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ow={kernelName:bs,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rw={kernelName:is,inputsToSave:["a","b"],gradFunc:(t,n)=>{const[e,s]=n;const o=hu(e.shape,s.shape);const r=()=>{let n=t;const s=fu(e.shape,o);if(s.length>0){n=Ku(n,s)}return Hc(n,e.shape)};const i=()=>{let n=t;const e=fu(s.shape,o);if(e.length>0){n=Ku(n,e)}return Hc(Wl(n),s.shape)};return{a:r,b:i}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iw={kernelName:Ue,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const o=s.shape.slice();const{axis:r}=e;const i=N(r,s.shape);i.forEach((t=>{o[t]=1}));const c=Hc(t,o);const a=tc(c,bf(s.shape,"float32"));return{x:()=>a}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cw={kernelName:cs,inputsToSave:["x"],gradFunc:(t,n)=>{const[e]=n;return{x:()=>Zi(t,qu(Ka(e)))}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aw={kernelName:as,outputsToSave:[true],gradFunc:(t,n)=>{const[e]=n;return{x:()=>tc(Xl(Gu(1),qu(e)),t)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uw={kernelName:us,inputsToSave:["x"],gradFunc:(t,n,e)=>{const[s]=n;const{reps:o}=e;const r=()=>{let n=gu(s);if(s.rank===1){for(let e=0;e<o[0];++e){n=Xi(n,sa(t,[e*s.shape[0]],[s.shape[0]]))}}else if(s.rank===2){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){n=Xi(n,sa(t,[e*s.shape[0],r*s.shape[1]],[s.shape[0],s.shape[1]]))}}}else if(s.rank===3){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){for(let i=0;i<o[2];++i){n=Xi(n,sa(t,[e*s.shape[0],r*s.shape[1],i*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]))}}}}else if(s.rank===4){for(let e=0;e<o[0];++e){for(let r=0;r<o[1];++r){for(let i=0;i<o[2];++i){for(let c=0;c<o[3];++c){n=Xi(n,sa(t,[e*s.shape[0],r*s.shape[1],i*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}}}}}else{throw new Error(`Gradient for tile operation is not implemented for rank-`+`${s.rank} tensors yet.`)}return n};return{x:r}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lw={kernelName:hs,gradFunc:(t,n,e)=>{const s=e;const{perm:o}=s;const r=Mu(o);return{x:()=>Od(t,r)}}};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fw={kernelName:ps,gradFunc:(t,n,e)=>{const s=e;const{axis:o}=s;return{value:()=>cd(t,o)}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hw={kernelName:ms,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{const[e]=n;const s=()=>dw(t,e);return{x:s}}};function dw(t,n){const e=df(n,gu(n));const s=pl(t,e);let o=gl(n,Gu(0,"int32"));const r=s.rank-o.rank;for(let t=0;t<r;++t){o=ol(o,t+1)}o=tf(o,bf(s.shape,"bool"));const i=gu(s);return xu(o,s,i)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pw={kernelName:xs,gradFunc:t=>({x:()=>gu(t)})};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mw=[ob,rb,ib,cb,ab,ub,lb,fb,hb,db,pb,mb,gb,$b,yb,kb,Cb,Nb,Rb,Sb,Eb,Tb,Ab,Ib,_b,Mb,Db,Lb,zb,Pb,_g,Vb,Bb,Wb,Gb,Ub,jb,Hb,qb,Xb,Yb,Zb,Qb,tg,ng,eg,sg,og,rg,ag,lg,lg,fg,pg,bg,gg,wg,vg,$g,yg,kg,Cg,Ng,Rg,Sg,Eg,Eg,Tg,Ig,Fg,Mg,Dg,Lg,zg,Pg,Vg,Bg,Wg,Gg,Ug,Hg,jg,qg,Xg,Kg,Jg,Yg,Zg,Qg,Qg,tw,tw,nw,sw,ew,ow,rw,iw,cw,aw,uw,lw,fw,hw,pw];for(const t of mw){As(t)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.abs=function(){this.throwIfDisposed();return ec(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.acos=function(){this.throwIfDisposed();return oc(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.acosh=function(){this.throwIfDisposed();return ic(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.add=function(t){this.throwIfDisposed();return Xi(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.all=function(t,n){this.throwIfDisposed();return ac(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.any=function(t,n){this.throwIfDisposed();return lc(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.argMax=function(t){this.throwIfDisposed();return hc(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.argMin=function(t){this.throwIfDisposed();return pc(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.asScalar=function(){this.throwIfDisposed();m(this.size===1,(()=>"The array must have only 1 element."));return Hc(this,[])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.asType=function(t){this.throwIfDisposed();return Mi(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.as1D=function(){this.throwIfDisposed();return Hc(this,[this.size])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.as2D=function(t,n){this.throwIfDisposed();return Hc(this,[t,n])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.as3D=function(t,n,e){this.throwIfDisposed();return Hc(this,[t,n,e])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.as4D=function(t,n,e,s){this.throwIfDisposed();return Hc(this,[t,n,e,s])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.as5D=function(t,n,e,s,o){this.throwIfDisposed();return Hc(this,[t,n,e,s,o])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.asin=function(){this.throwIfDisposed();return xc(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.asinh=function(){this.throwIfDisposed();return gc(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.atan=function(){this.throwIfDisposed();return vc(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.atan2=function(t){this.throwIfDisposed();return yc(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.atanh=function(){this.throwIfDisposed();return Cc(this)};tr().prototype.avgPool=function(t,n,e,s){this.throwIfDisposed();return qc(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.batchToSpaceND=function(t,n){this.throwIfDisposed();return ca(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.batchNorm=function(t,n,e,s,o){this.throwIfDisposed();return la(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.broadcastTo=function(t){this.throwIfDisposed();return va(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.cast=function(t){this.throwIfDisposed();return Mi(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.ceil=function(){this.throwIfDisposed();return ya(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.clipByValue=function(t,n){this.throwIfDisposed();return Na(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.concat=function(t,n){this.throwIfDisposed();if(t instanceof Qo){t=[t]}return Yc([this,...t],n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.conv1d=function(t,n,e,s,o,r){this.throwIfDisposed();return La(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.conv2dTranspose=function(t,n,e,s,o){this.throwIfDisposed();return Ba(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.conv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return Ma(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.cos=function(){this.throwIfDisposed();return Ka(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.cosh=function(){this.throwIfDisposed();return Ya(this)};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.cumprod=function(t,n,e){this.throwIfDisposed();return Qa(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.cumsum=function(t,n,e){this.throwIfDisposed();return nu(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.depthToSpace=function(t,n){this.throwIfDisposed();return ru(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.depthwiseConv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return cu(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.dilation2d=function(t,n,e,s,o){this.throwIfDisposed();return uu(this,t,n,e,s,o)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.divNoNan=function(t){this.throwIfDisposed();return vu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.div=function(t){this.throwIfDisposed();return Zi(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.dot=function(t){this.throwIfDisposed();return yu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.elu=function(){this.throwIfDisposed();return Ru(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.equal=function(t){this.throwIfDisposed();return pu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.erf=function(){this.throwIfDisposed();return Eu(this)};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.euclideanNorm=function(t,n){this.throwIfDisposed();return tl(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.exp=function(){this.throwIfDisposed();return el(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.expandDims=function(t){this.throwIfDisposed();return ol(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.expm1=function(){this.throwIfDisposed();return il(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.fft=function(){this.throwIfDisposed();return qh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.flatten=function(){this.throwIfDisposed();return Hc(this,[this.size])};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.floor=function(){this.throwIfDisposed();return hl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.floorDiv=function(t){this.throwIfDisposed();return Ji(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.gather=function(t,n,e){this.throwIfDisposed();return pl(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.greaterEqual=function(t){this.throwIfDisposed();return gl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.greater=function(t){this.throwIfDisposed();return xl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.ifft=function(){this.throwIfDisposed();return Kh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.irfft=function(){this.throwIfDisposed();return Yh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.isFinite=function(){this.throwIfDisposed();return yl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.isInf=function(){this.throwIfDisposed();return Cl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.isNaN=function(){this.throwIfDisposed();return Rl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.leakyRelu=function(t){this.throwIfDisposed();return El(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.lessEqual=function(t){this.throwIfDisposed();return Ol(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.less=function(t){this.throwIfDisposed();return Il(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.localResponseNormalization=function(t,n,e,s){this.throwIfDisposed();return _l(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logSigmoid=function(){this.throwIfDisposed();return jl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logSoftmax=function(t){this.throwIfDisposed();return Jl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logSumExp=function(t,n){this.throwIfDisposed();return Zl(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.log=function(){this.throwIfDisposed();return Dl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.log1p=function(){this.throwIfDisposed();return zl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logicalAnd=function(t){this.throwIfDisposed();return tf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logicalNot=function(){this.throwIfDisposed();return ef(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logicalOr=function(t){this.throwIfDisposed();return of(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.logicalXor=function(t){this.throwIfDisposed();return cf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.matMul=function(t,n,e){this.throwIfDisposed();return Qc(this,t,n,e)};tr().prototype.maxPool=function(t,n,e,s){this.throwIfDisposed();return uf(this,t,n,e,s)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.max=function(t,n){this.throwIfDisposed();return zu(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.maximum=function(t){this.throwIfDisposed();return df(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.mean=function(t,n){this.throwIfDisposed();return mf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.min=function(t,n){this.throwIfDisposed();return Vu(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.minimum=function(t){this.throwIfDisposed();return wf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.mirrorPad=function(t,n){this.throwIfDisposed();return $f(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.mod=function(t){this.throwIfDisposed();return kf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.mul=function(t){this.throwIfDisposed();return tc(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.neg=function(){this.throwIfDisposed();return Wl(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.norm=function(t,n,e){this.throwIfDisposed();return Zu(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.notEqual=function(t){this.throwIfDisposed();return Sf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.oneHot=function(t,n=1,e=0){this.throwIfDisposed();return Tf(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.onesLike=function(){this.throwIfDisposed();return Af(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.pad=function(t,n){this.throwIfDisposed();return Ff(this,t,n)};tr().prototype.pool=function(t,n,e,s,o,r){this.throwIfDisposed();return Pf(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.pow=function(t){this.throwIfDisposed();return Wu(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.prelu=function(t){this.throwIfDisposed();return Bf(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.prod=function(t,n){this.throwIfDisposed();return Gf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.reciprocal=function(){this.throwIfDisposed();return mh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.relu=function(){this.throwIfDisposed();return bh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.relu6=function(){this.throwIfDisposed();return wh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.reshapeAs=function(t){this.throwIfDisposed();return Hc(this,t.shape)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.reshape=function(t){this.throwIfDisposed();return Hc(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.resizeBilinear=function(t,n,e){this.throwIfDisposed();return Ap(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.resizeNearestNeighbor=function(t,n,e){this.throwIfDisposed();return Fp(this,t,n,e)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.reverse=function(t){this.throwIfDisposed();return $h(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.rfft=function(){this.throwIfDisposed();return nd(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.round=function(){this.throwIfDisposed();return kh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.rsqrt=function(){this.throwIfDisposed();return Nh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.selu=function(){this.throwIfDisposed();return Sh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.separableConv2d=function(t,n,e,s,o,r){this.throwIfDisposed();return Th(this,t,n,e,s,o,r)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sigmoid=function(){this.throwIfDisposed();return na(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sign=function(){this.throwIfDisposed();return Ah(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sin=function(){this.throwIfDisposed();return Fh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sinh=function(){this.throwIfDisposed();return Mh(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.slice=function(t,n){this.throwIfDisposed();return sa(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.softmax=function(t){this.throwIfDisposed();return Hh(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.softplus=function(){this.throwIfDisposed();return Ul(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.spaceToBatchND=function(t,n){this.throwIfDisposed();return Mf(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.split=function(t,n){this.throwIfDisposed();return Qh(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sqrt=function(){this.throwIfDisposed();return Hu(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.square=function(){this.throwIfDisposed();return qu(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.squaredDifference=function(t){this.throwIfDisposed();return sd(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.squeeze=function(t){this.throwIfDisposed();return rd(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.stack=function(t,n){this.throwIfDisposed();const e=t instanceof Qo?[this,t]:[this,...t];return cd(e,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.step=function(t){this.throwIfDisposed();return ud(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.stridedSlice=function(t,n,e,s,o,r,i,c){this.throwIfDisposed();return fd(this,t,n,e,s,o,r,i,c)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sub=function(t){this.throwIfDisposed();return Xl(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.sum=function(t,n){this.throwIfDisposed();return Ku(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.tan=function(){this.throwIfDisposed();return dd(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.tanh=function(){this.throwIfDisposed();return ra(this)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.tile=function(t){this.throwIfDisposed();return al(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.toBool=function(){this.throwIfDisposed();return Mi(this,"bool")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.toFloat=function(){this.throwIfDisposed();return Mi(this,"float32")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.toInt=function(){this.throwIfDisposed();return Mi(this,"int32")};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.topk=function(t,n){this.throwIfDisposed();return vd(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.transpose=function(t){this.throwIfDisposed();return Od(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.unique=function(t){this.throwIfDisposed();return Cd(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.unsortedSegmentSum=function(t,n){this.throwIfDisposed();return Rd(this,t,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.unstack=function(t){this.throwIfDisposed();return Ed(this,t)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.where=function(t,n){this.throwIfDisposed();return xu(t,this,n)};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tr().prototype.zerosLike=function(){this.throwIfDisposed();return gu(this)};
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xw extends Error{constructor(t){super(t);Object.setPrototypeOf(this,xw.prototype)}}class bw extends Error{constructor(t){super(t);Object.setPrototypeOf(this,bw.prototype)}}class gw extends Error{constructor(t){super(t);Object.setPrototypeOf(this,gw.prototype)}}class ww extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ww.prototype)}}class vw extends Error{constructor(t){super(t);Object.setPrototypeOf(this,vw.prototype)}}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $w{constructor(t){this.maxEntries=t||100;this.cache=new Map}get(t){let n;if(this.cache.has(t)){n=this.cache.get(t);this.cache.delete(t);this.cache.set(t,n)}return n}put(t,n){if(this.cache.has(t)){this.cache.delete(t)}else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0){throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`)}if(this.maxEntries>t){for(let n=0;n<this.maxEntries-t;n++){const t=this.cache.keys().next().value;this.cache.delete(t)}}this.maxEntries=t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yw(t,n){if(Array.isArray(t)){let e=[];for(let s=0;s<n;s++){e=e.concat(t)}return e}else{const e=new Array(n);e.fill(t);return e}}function kw(t,n){if(!t){throw new vw(n)}}function Cw(t,n){let e=0;for(const s of t){if(s===n){e++}}return e}function Nw(t){if(t.length===1){return t[0]}return t}function Rw(t){if(Array.isArray(t)){return t}return[t]}function Sw(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2");const e=n.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();if(e[0]!=="_"){return e}return"private"+e}function Ew(t){if(t.length<=1){return t}if(t.indexOf("_")===-1){return t}return t.replace(/[_]+(\w|$)/g,((t,n)=>n.toUpperCase()))}let Tw={};function Iw(t){if(t===null||t===undefined){return null}const n={};n["className"]=t.getClassName();n["config"]=t.getConfig();return n}function Aw(t){if(t==null||typeof t!=="object"){return}else if(Array.isArray(t)){t.forEach((t=>Aw(t)))}else{const n=Object.keys(t);for(const e of n){const n=t[e];if(n!=null&&typeof n==="object"){if(!Array.isArray(n)&&n["type"]==="ndarray"&&typeof n["value"]==="number"){t[e]=n["value"]}else{Aw(n)}}}}}function Ow(t,n={},e={},s="object",o=false){if(typeof t==="string"){const o=t;let r;if(o in e){r=e[o]}else if(o in Tw){r=Tw[o]}else{r=n[o];if(r==null){throw new gw(`Unknown ${s}: ${t}. `+`This may be due to one of the following reasons:\n`+`1. The ${s} is defined in Python, in which `+`case it needs to be ported to TensorFlow.js or your JavaScript `+`code.\n`+`2. The custom ${s} is defined in JavaScript, `+`but is not registered properly with `+`tf.serialization.registerClass().`)}}return r}else{const r=t;if(r["className"]==null||r["config"]==null){throw new gw(`${s}: Improper config format: `+`${JSON.stringify(r)}.\n`+`'className' and 'config' must set.`)}const i=r["className"];let c,a;if(i in e){[c,a]=e[i]}else if(i in Tw){[c,a]=Tw["className"]}else if(i in n){[c,a]=n[i]}if(c==null){throw new gw(`Unknown ${s}: ${i}. `+`This may be due to one of the following reasons:\n`+`1. The ${s} is defined in Python, in which `+`case it needs to be ported to TensorFlow.js or your JavaScript `+`code.\n`+`2. The custom ${s} is defined in JavaScript, `+`but is not registered properly with `+`tf.serialization.registerClass().`)}if(a!=null){const t={};for(const n of Object.keys(Tw)){t[n]=Tw[n]}for(const n of Object.keys(e)){t[n]=e[n]}const n=r["config"];n["customObjects"]=t;const s=Object.assign({},Tw);for(const t of Object.keys(e)){Tw[t]=e[t]}Aw(r["config"]);const i=a(c,r["config"],e,o);Tw=Object.assign({},s);return i}else{const t=Object.assign({},Tw);for(const t of Object.keys(e)){Tw[t]=e[t]}const n=new c(r["config"]);Tw=Object.assign({},t);return n}}}function Fw(t,n){return t<n?-1:t>n?1:0}function _w(t,n){return-1*Fw(t,n)}function Mw(t){if(t==null){return t}const n=[];for(const e of t){if(n.indexOf(e)===-1){n.push(e)}}return n}function Dw(t){if(t==null){throw new gw(`Invalid value in obj: ${JSON.stringify(t)}`)}for(const n in t){if(t.hasOwnProperty(n)){return false}}return true}function Lw(t,n,e){if(e==null){return}if(t.indexOf(e)<0){throw new gw(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}}function zw(t,n,e=0,s=Infinity){kw(e>=0);kw(s>=e);return Array.isArray(t)&&t.length>=e&&t.length<=s&&t.every((t=>typeof t===n))}function Pw(t,n){if(Array.isArray(t)){m(t.length>0,(()=>`${n} is unexpectedly an empty array.`));t.forEach(((t,e)=>Pw(t,`element ${e+1} of ${n}`)))}else{m(Number.isInteger(t)&&t>0,(()=>`Expected ${n} to be a positive integer, but got `+`${Vw(t)}.`))}}function Vw(t){if(t===null){return"null"}else if(Array.isArray(t)){return"["+t.map((t=>Vw(t))).join(",")+"]"}else if(typeof t==="string"){return`"${t}"`}else{return`${t}`}}function Bw(t,n,e){let s=e!=null?e():To();let o;const r=(...r)=>{const i=e!=null?e():To();if(i-s<n){return o}s=i;o=t(...r);return o};return r}function Ww(t){if(t==="relu"){return"relu"}if(t==="linear"){return"linear"}if(t==="elu"){return"elu"}return null}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Gw=0;function Uw(){return Gw++}const Hw={};function jw(t=""){if(!(t in Hw)){Hw[t]=0}Hw[t]+=1;return t+Hw[t].toString()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const qw=["channelsFirst","channelsLast"];const Xw=["nearest","bilinear"];const Kw=["valid","same","causal"];const Jw=["max","avg"];const Yw=["sum","mul","concat","ave"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Zw=new Map;function Qw(t){Lw(qw,"DataFormat",t)}function tv(t){Lw(Xw,"InterpolationFormat",t)}function nv(t){Lw(Kw,"PaddingMode",t)}function ev(t){Lw(Jw,"PoolMode",t)}const sv=[];const ov="/";function rv(t,n){sv.push(t);try{const t=n();sv.pop();return t}catch(t){sv.pop();throw t}}function iv(){if(sv.length===0){return""}else{return sv.join(ov)+ov}}function cv(t){if(!lv(t)){throw new Error("Not a valid tensor name: '"+t+"'")}return iv()+t}function av(t){if(!lv(t)){throw new Error("Not a valid tensor name: '"+t+"'")}if(!Zw.has(t)){Zw.set(t,0)}const n=Zw.get(t);Zw.set(t,Zw.get(t)+1);if(n>0){const e=`${t}_${n}`;Zw.set(e,1);return e}else{return t}}const uv=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function lv(t){return!!t.match(uv)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fv(t){return t===parseInt(t.toString(),10)}function hv(t,n,e){if(n==null){n=0}if(e==null){e=t.length}let s=1;for(let o=n;o<e;++o){s*=t[o]}return s}function dv(t){if(t.length===0){return Number.NaN}let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){const s=t[e];if(s<n){n=s}}return n}function pv(t){if(t.length===0){return Number.NaN}let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const s=t[e];if(s>n){n=s}}return n}function mv(t,n){if(n<t){throw new gw(`end (${n}) < begin (${t}) is forbidden.`)}const e=[];for(let s=t;s<n;++s){e.push(s)}return e}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let xv;function bv(){if(xv==null){xv=ji().epsilon()}return xv}function gv(){return"channelsLast"}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wv(t,n){return Mi(t,n)}function vv(t,n=-1){const e=t.shape.slice();if(n<0){n=e.length+n+1}e.splice(n,0,1);return Hc(t,e)}function $v(t,n){return Wi((()=>{if(t.shape.length!==2){throw new gw(`repeat() expects a rank-2 tensor, but received a `+`rank-${t.shape.length} tensor.`)}const e=vv(t,1);return Tv(e,[1,n,1])}))}function yv(t){const n=[hv(t.shape)];return Hc(t,n)}function kv(t){if(t.rank<=1){throw new gw(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`)}const n=[t.shape[0],hv(t.shape,1)];return Hc(t,n)}function Cv(t,n,e){return Wi((()=>{switch(t.rank){case 1:return Lh(t,n,e);case 2:return Ph(t,[n,0],[e,t.shape[1]]);case 3:return Bh(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return Gh(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return sa(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return sa(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new gw(`sliceAlongFirstAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function Nv(t,n,e){return Wi((()=>{switch(t.rank){case 1:return Lh(t,n,e);case 2:return Ph(t,[0,n],[t.shape[0],e]);case 3:return Bh(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return Gh(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new gw(`sliceAlongLastAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function Rv(t,n,e,s){return Wi((()=>{switch(t.rank){case 1:return Lh(t,n,e);case 2:switch(s){case 1:return Cv(t,n,e);case 2:return Nv(t,n,e);default:throw new gw(`The axis is not within the rank of the tensor `+`${s}`)}case 3:switch(s){case 1:return Cv(t,n,e);case 2:return Bh(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return Nv(t,n,e);default:throw new gw(`The axis is not within the rank of the tensor `+`${s}`)}case 4:switch(s){case 1:return Cv(t,n,e);case 2:return Gh(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return Gh(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return Nv(t,n,e);default:throw new gw(`The axis is not within the rank of the tensor `+`${s}`)}default:throw new gw(`sliceAlongLastAxis() received an unsupported tensor rank: `+`${t.rank}`)}}))}function Sv(t,n=-1){let e;if(n<0){e=t[0].rank;if(e!==0){n=e}else{n=0}}if(n===t[0].rank){n=-1}return Yc(t,n)}function Ev(t,n){switch(t.rank){case 1:return Sa([t,n]);case 2:return Ta([t,n],0);case 3:return Aa([t,n],0);case 4:return Fa([t,n],0);default:throw new gw(`concatAlongFirstAxis() received an unsupported `+`tensor rank: ${t.rank}`)}}function Tv(t,n){if(!Array.isArray(n)){n=[n]}if(t.rank!==n.length){throw new gw(`The length of input n (${n.length}) does not match `+`the number of dimensions in input x (${t.rank})`)}return al(t,n)}function Iv(t,n=0,e=1,s,o){return ah(t,n,e,s,o)}function Av(t,n,e,s){if(t.rank<2||n.rank<2){throw new ww(`dot requires both inputs to be rank >= 2`+` but got x shape = ${t.shape} and y shape = ${n.shape}`)}if(n.rank>=3){const e=t.shape.slice(-1)[0];const s=n.shape.slice(-2)[0];if(e!==s){throw new ww(`If rank y >= 3, then the second last dim`+` of y must equal the last dim of x but got x shape = ${t.shape} and `+` y shape = ${n.shape}`)}}if(t.rank===2&&n.rank===2){const o=false;const r=false;return Kd({a:t,b:n,transposeA:o,transposeB:r,bias:s?_v(t.rank,s,gv()):null,activation:e})}else{const o=t.shape.slice();const r=o.pop();t=Hc(t,[-1,r]);const i=n.shape.slice();const c=i.pop();const a=i.pop();const u=[...i,c];const l=Array.from({length:n.rank},((t,e)=>{if(e===0){return n.rank-2}else if(e<=n.rank-2){return e-1}return e}));n=Hc(Od(n,l),[a,-1]);const f=[...o,...u];const h=false;const d=false;return Hc(Kd({a:t,b:n,transposeA:h,transposeB:d,bias:s?_v(t.rank,s,gv()):null,activation:e}),f)}}function Ov(t,n,e){return Wi((()=>{if(Array.isArray(n)){n=pd(n,"int32")}else{n=Mi(n,"int32")}return pl(t,n,e)}))}function Fv(t){return tc(t,t)}function _v(t,n,e){const s=n.shape;if(n.rank!==1&&n.rank!==t){throw new gw(`Unexpected bias dimensions: ${n.rank}`+`; expected it to be 1 or ${t}`)}if(t===5){if(e==="channelsFirst"){if(s.length===1){return Hc(n,[1,s[0],1,1,1])}else{return Hc(n,[1,s[3],s[0],s[1],s[2]])}}else if(e==="channelsLast"){if(s.length===1){return Hc(n,[1,1,1,1,s[0]])}else{return Hc(n,[1].concat(s))}}}else if(t===4){if(e==="channelsFirst"){if(s.length===1){return Hc(n,[1,s[0],1,1])}else{return Hc(n,[1,s[2],s[0],s[1]])}}else if(e==="channelsLast"){if(s.length===1){return Hc(n,[1,1,1,s[0]])}else{return Hc(n,[1].concat(s))}}}else if(t===3){if(e==="channelsFirst"){if(s.length===1){return Hc(n,[1,s[0],1])}else{return Hc(n,[1,s[1],s[0]])}}else if(e==="channelsLast"){if(s.length===1){return Hc(n,[1,1,s[0]])}else{return Hc(n,[1].concat(s))}}}else if(t<3){return n}throw new gw(`Unsupported input rank by biasAdd: ${n.rank}`)}function Mv(t,n,e){return Wi((()=>{if(e==null){e=gv()}Qw(e);return Xi(t,_v(t.rank,n,e))}))}function Dv(t,n=1){if(n!==1){throw new ww(`Support for alpha values other than 1 (${n}) is not implemented `+`yet.`)}return Ru(t)}function Lv(t){return Wi((()=>Zi(t,Xi(ec(t),1))))}function zv(t,n,e,s){return Wi((()=>Md(t,n,e,s)))}function Pv(t){return Wi((()=>{const n=Xi(.5,tc(.2,t));return Na(n,0,1)}))}function Vv(t,n,e=false){return e?t():n()}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Bv=["fanIn","fanOut","fanAvg"];const Wv=["normal","uniform","truncatedNormal"];
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gv(t){Lw(Bv,"FanMode",t)}function Uv(t){Lw(Wv,"Distribution",t)}class Hv extends Jp{fromConfigUsesCustomObjects(){return false}getConfig(){return{}}}class jv extends Hv{apply(t,n){return xf(t,n)}}jv.className="Zeros";Zp(jv);class qv extends Hv{apply(t,n){return bf(t,n)}}qv.className="Ones";Zp(qv);class Xv extends Hv{constructor(t){super();if(typeof t!=="object"){throw new gw(`Expected argument of type ConstantConfig but got ${t}`)}if(t.value===undefined){throw new gw(`config must have value set but got ${t}`)}this.value=t.value}apply(t,n){return Wi((()=>tc(Gu(this.value),bf(t,n))))}getConfig(){return{value:this.value}}}Xv.className="Constant";Zp(Xv);class Kv extends Hv{constructor(t){super();this.DEFAULT_MINVAL=-.05;this.DEFAULT_MAXVAL=.05;this.minval=t.minval||this.DEFAULT_MINVAL;this.maxval=t.maxval||this.DEFAULT_MAXVAL;this.seed=t.seed}apply(t,n){return lh(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Kv.className="RandomUniform";Zp(Kv);class Jv extends Hv{constructor(t){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=t.mean||this.DEFAULT_MEAN;this.stddev=t.stddev||this.DEFAULT_STDDEV;this.seed=t.seed}apply(t,n){n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new ww(`randomNormal does not support dType ${n}.`)}return Iv(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Jv.className="RandomNormal";Zp(Jv);class Yv extends Hv{constructor(t){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=t.mean||this.DEFAULT_MEAN;this.stddev=t.stddev||this.DEFAULT_STDDEV;this.seed=t.seed}apply(t,n){n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new ww(`truncatedNormal does not support dType ${n}.`)}return yd(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Yv.className="TruncatedNormal";Zp(Yv);class Zv extends Hv{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,n){return Wi((()=>{if(t.length!==2||t[0]!==t[1]){throw new gw("Identity matrix initializer can only be used for"+" 2D square matrices.")}else{return tc(this.gain,ll(t[0]))}}))}getConfig(){return{gain:this.gain}}}Zv.className="Identity";Zp(Zv);function Qv(t,n="channelsLast"){let e;let s;Qw(n);if(t.length===2){e=t[0];s=t[1]}else if([3,4,5].indexOf(t.length)!==-1){if(n==="channelsFirst"){const n=hv(t,2);e=t[1]*n;s=t[0]*n}else if(n==="channelsLast"){const n=hv(t,0,t.length-2);e=t[t.length-2]*n;s=t[t.length-1]*n}}else{const n=hv(t);e=Math.sqrt(n);s=Math.sqrt(n)}return[e,s]}class t$ extends Hv{constructor(t){super();if(t.scale<0){throw new gw(`scale must be a positive float. Got: ${t.scale}`)}this.scale=t.scale==null?1:t.scale;this.mode=t.mode==null?"fanIn":t.mode;Gv(this.mode);this.distribution=t.distribution==null?"normal":t.distribution;Uv(this.distribution);this.seed=t.seed}apply(t,n){const e=Qv(t);const s=e[0];const o=e[1];let r=this.scale;if(this.mode==="fanIn"){r/=Math.max(1,s)}else if(this.mode==="fanOut"){r/=Math.max(1,o)}else{r/=Math.max(1,(s+o)/2)}if(this.distribution==="normal"){const e=Math.sqrt(r);n=n||"float32";if(n!=="float32"&&n!=="int32"){throw new ww(`${this.getClassName()} does not support dType ${n}.`)}return yd(t,0,e,n,this.seed)}else{const e=Math.sqrt(3*r);return lh(t,-e,e,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}t$.className="VarianceScaling";Zp(t$);class n$ extends t${constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return t$.className}}n$.className="GlorotUniform";Zp(n$);class e$ extends t${constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return t$.className}}e$.className="GlorotNormal";Zp(e$);class s$ extends t${constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return t$.className}}s$.className="HeNormal";Zp(s$);class o$ extends t${constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return t$.className}}o$.className="HeUniform";Zp(o$);class r$ extends t${constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return t$.className}}r$.className="LeCunNormal";Zp(r$);class i$ extends t${constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return t$.className}}i$.className="LeCunUniform";Zp(i$);class c$ extends Hv{constructor(t){super();this.DEFAULT_GAIN=1;this.ELEMENTS_WARN_SLOW=2e3;this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain;this.seed=t.seed}apply(t,n){return Wi((()=>{if(t.length<2){throw new ww("Shape must be at least 2D.")}if(n!=="int32"&&n!=="float32"&&n!==undefined){throw new TypeError(`Unsupported data type ${n}.`)}n=n;const e=g(t.slice(0,-1));const s=t[t.length-1];const o=e*s;if(o>this.ELEMENTS_WARN_SLOW){console.warn(`Orthogonal initializer is being called on a matrix with more `+`than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: `+`Slowness may result.`)}const r=[Math.max(s,e),Math.min(s,e)];const i=Iv(r,0,1,n,this.seed);const c=qp.qr(i,false);let a=c[0];const u=c[1];const l=u.flatten().stridedSlice([0],[Math.min(s,e)*Math.min(s,e)],[Math.min(s,e)+1]);a=tc(a,l.sign());if(e<s){a=a.transpose()}return tc(Gu(this.gain),a.reshape(t))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}c$.className="Orthogonal";Zp(c$);const a$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function u$(t,n={}){return Ow(t,Yp.getMap().classNameMap,n,"initializer")}function l$(t){return Iw(t)}function f$(t){if(typeof t==="string"){const n=t in a$?a$[t]:t;if(n==="GlorotNormal"){return new e$}else if(n==="GlorotUniform"){return new n$}else if(n==="HeNormal"){return new s$}else if(n==="HeUniform"){return new o$}else if(n==="LeCunNormal"){return new r$}else if(n==="LeCunUniform"){return new i$}else{const t={};t["className"]=n;t["config"]={};return u$(t)}}else if(t instanceof Hv){return t}else{return u$(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h$(t){return Array.isArray(t)&&Array.isArray(t[0])}function d$(t){if(t.length===0){return[]}if(!Array.isArray(t[0])){return[t]}return t}function p$(t){let n;if(Array.isArray(t)){if(t.length!==1){throw new gw(`Expected Tensor length to be 1; got ${t.length}`)}n=t[0]}else{n=t}return n}function m$(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1){t=t;return t[0]}else{throw new gw(`Expected exactly 1 Shape; got ${t.length}`)}}else{return t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function x$(t){let n=0;for(const e of t){if(e.shape.length===0){n+=1}else{n+=e.shape.reduce(((t,n)=>t*n))}}return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const b$="Variable";class g${constructor(t,n="float32",e=b$,s=true,o=null){this.dtype=n==null?"float32":n;this.shape=t.shape;this.id=Uw();e=e==null?b$:e;this.originalName=cv(e);this.name=av(this.originalName);this.trainable_=s;this.constraint=o;this.val=Td(t,this.trainable_,this.name,this.dtype)}read(){this.assertNotDisposed();return this.val}write(t){this.assertNotDisposed();w$(this.val,t);if(this.val.id!==t.id){this.val.assign(t);if(this.constraint!=null){this.val.assign(this.constraint.apply(this.val))}}return this}dispose(){this.assertNotDisposed();this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed){throw new Error(`LayersVariable ${this.name} is already disposed.`)}}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t;this.val.trainable=t}}function w$(t,n){if(t.shape.toString()!==n.shape.toString()){throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}}function v$(t){return t.map((t=>t.read()))}function $$(t){t.forEach((t=>{const n=t[0];n.write(t[1])}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class y${constructor(t){this.dtype=t.dtype;this.shape=t.shape;if(t.shape!=null){this.ndim=t.shape.length}else{this.ndim=t.ndim}this.maxNDim=t.maxNDim;this.minNDim=t.minNDim;this.axes=t.axes||{}}}class k${constructor(t,n,e,s,o,r,i){this.dtype=t;this.shape=n;this.sourceLayer=e;this.inputs=s;this.callArgs=o;this.outputTensorIndex=i;this.id=Uw();if(r!=null){this.originalName=cv(r);this.name=av(this.originalName)}this.rank=n.length}}let C$=0;class N${constructor(t,n){this.callArgs=n;this.id=C$++;this.outboundLayer=t.outboundLayer;this.inboundLayers=t.inboundLayers;this.nodeIndices=t.nodeIndices;this.tensorIndices=t.tensorIndices;this.inputTensors=t.inputTensors;this.outputTensors=t.outputTensors;this.inputMasks=t.inputMasks;this.outputMasks=t.outputMasks;this.inputShapes=t.inputShapes;this.outputShapes=t.outputShapes;for(const n of t.inboundLayers){if(n!=null){n.outboundNodes.push(this)}}t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers){if(n!=null){t.push(n.name)}else{t.push(null)}}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let R$=0;class S$ extends Jp{constructor(t={}){super();this._callHook=null;this._addedWeightNames=[];this._stateful=false;this.id=R$++;this.activityRegularizer=null;this.inputSpec=null;this.supportsMasking=false;this._trainableWeights=[];this._nonTrainableWeights=[];this._losses=[];this._updates=[];this._built=false;this.inboundNodes=[];this.outboundNodes=[];let n=t.name;if(!n){const t=this.getClassName();n=Sw(t)+"_"+jw(t)}this.name=n;this.trainable_=t.trainable==null?true:t.trainable;if(t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null){n=t.batchInputShape}else if(t.inputShape!=null){let e=null;if(t.batchSize!=null){e=t.batchSize}n=[e].concat(t.inputShape)}this.batchInputShape=n;let e=t.dtype;if(e==null){e=t.inputDType}if(e==null){e="float32"}this.dtype=e}if(t.weights!=null){this.initialWeights=t.weights}else{this.initialWeights=null}this._refCount=null;this.fastWeightInitDuringBuild=false}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0){throw new bw("The layer has never been called "+`and thus has no defined ${n}.`)}if(this.inboundNodes.length<=t){throw new gw(`Asked to get ${n} at node ${t}, `+`but the layer has only ${this.inboundNodes.length} inbound nodes.`)}return this.inboundNodes[t]}getInputAt(t){return Nw(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Nw(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1){throw new xw(`Layer ${this.name}`+" has multiple inbound nodes, "+'hence the notion of "layer input" '+"is ill-defined. "+"Use `getInputAt(nodeIndex)` instead.")}else if(this.inboundNodes.length===0){throw new xw(`Layer ${this.name}`+" is not connected, no input to return.")}return Nw(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0){throw new xw(`Layer ${this.name}`+" has no inbound nodes.")}if(this.inboundNodes.length>1){throw new xw(`Layer ${this.name}`+" has multiple inbound nodes, "+'hence the notion of "layer output" '+"is ill-defined. "+"Use `getOutputAt(nodeIndex)` instead.")}return Nw(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((n=>n.trainable=t));this.trainable_=t}get trainableWeights(){if(this.trainable_){return this._trainableWeights.filter((t=>t.trainable))}else{return[]}}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){if(this.trainable){return this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights)}else{return this._trainableWeights.concat(this._nonTrainableWeights)}}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful){throw new Error("Cannot call the resetStates() method of a non-stateful Layer "+"object.")}}assertInputCompatibility(t){const n=Rw(t);if(this.inputSpec==null||this.inputSpec.length===0){return}const e=Rw(this.inputSpec);if(n.length!==e.length){throw new gw(`Layer ${this.name} expects ${e.length} inputs, `+`but it received ${n.length} input tensors. `+`Input received: ${t}`)}for(let t=0;t<n.length;t++){const s=n[t];const o=e[t];if(o==null){continue}const r=s.rank;if(o.ndim!=null){if(r!==o.ndim){throw new gw(`Input ${t} is incompatible with layer ${this.name}: `+`expected ndim=${o.ndim}, found ndim=${r}`)}}if(o.maxNDim!=null){if(r>o.maxNDim){throw new gw(`Input ${t} is incompatible with layer ${this.name}`+`: expected max_ndim=${o.maxNDim}, found ndim=${r}`)}}if(o.minNDim!=null){if(r<o.minNDim){throw new gw(`Input ${t} is incompatible with layer ${this.name}`+`: expected min_ndim=${o.minNDim}, found ndim=${r}.`)}}if(o.dtype!=null){if(s.dtype!==o.dtype){throw new gw(`Input ${t} is incompatible with layer ${this.name} `+`: expected dtype=${o.dtype}, found dtype=${s.dtype}.`)}}if(o.axes){const n=s.shape;for(const e in o.axes){const s=Number(e);const r=o.axes[e];const i=s>=0?n[s]:n[n.length+s];if(r!=null&&[r,null].indexOf(i)===-1){throw new gw(`Input ${t} is incompatible with layer `+`${this.name}: expected axis ${s} of input shape to `+`have value ${r} but got shape ${n}.`)}}}if(o.shape!=null){for(let n=0;n<o.shape.length;++n){const e=o.shape[n];const r=s.shape[n];if(e!=null&&r!=null){if(e!==r){throw new gw(`Input ${t} is incompatible with layer `+`${this.name}: expected shape=${o.shape}, `+`found shape=${s.shape}.`)}}}}}}call(t,n){return t}invokeCallHook(t,n){if(this._callHook!=null){this._callHook(t,n)}}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{};this.assertNotDisposed();const e=Rw(t);const s=A$(t);const o=O$(t);if(s===o){throw new gw("Arguments to apply() must be all "+"SymbolicTensors or all Tensors")}return rv(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const n=[];for(const e of Rw(t)){n.push(e.shape)}this.build(Nw(n));this.built=true;if(this.initialWeights){this.setWeights(this.initialWeights)}if(this._refCount===null&&o){this._refCount=1}}this.assertInputCompatibility(t);if(o){let s=this.call(t,n);if(this.supportsMasking){this.setMaskMetadata(t,s)}const o=Rw(s);const r=[];for(let t of o){if(e.indexOf(t)!==-1){t=t.clone()}r.push(t)}s=Nw(r);if(this.activityRegularizer!=null){throw new ww("Layer invocation in the presence of activity "+"regularizer(s) is not supported yet.")}return s}else{const e=E$(t);const s=this.computeOutputShape(e);let o;const r=T$();this.warnOnIncompatibleInputShape(Array.isArray(t)?e[0]:e);if(s!=null&&s.length>0&&Array.isArray(s[0])){o=s.map(((e,s)=>new k$(r,e,this,Rw(t),n,this.name,s)))}else{o=new k$(r,s,this,Rw(t),n,this.name)}this.addInboundNode(t,o,null,null,e,s,n);this._refCount++;if(this.activityRegularizer!=null){throw new ww("Layer invocation in the presence of activity "+"regularizer(s) is not supported yet.")}return o}}))}warnOnIncompatibleInputShape(t){if(this.batchInputShape==null){return}else if(t.length!==this.batchInputShape.length){console.warn(`The rank of the input tensor provided (shape: `+`${JSON.stringify(t)}) does not match that of the `+`batchInputShape (${JSON.stringify(this.batchInputShape)}) `+`of the layer ${this.name}`)}else{let n=false;this.batchInputShape.forEach(((e,s)=>{if(e!=null&&t[s]!=null&&t[s]!==e){n=true}}));if(n){console.warn(`The shape of the input tensor `+`(${JSON.stringify(t)}) does not `+`match the expectation of layer ${this.name}: `+`${JSON.stringify(this.batchInputShape)}`)}}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0){throw new xw(`The layer ${this.name} has never been called and thus has no `+`defined output shape.`)}const t=[];for(const n of this.inboundNodes){const e=JSON.stringify(n.outputShapes);if(t.indexOf(e)===-1){t.push(e)}}if(t.length===1){const t=this.inboundNodes[0].outputShapes;if(Array.isArray(t)&&Array.isArray(t[0])&&t.length===1){return t[0]}else{return t}}else{throw new xw(`The layer ${this.name} has multiple inbound nodes with different `+`output shapes. Hence the notion of "output shape" is ill-defined `+`for the layer.`)}}countParams(){if(!this.built){throw new bw(`You tried to call countParams() on ${this.name}, `+`but the layer is not built yet. Build it first by calling `+`build(batchInputShape).`)}return x$(this.weights)}build(t){this.built=true}getWeights(t=false){return v$(t?this.trainableWeights:this.weights)}setWeights(t){Wi((()=>{const n=this.weights;if(n.length!==t.length){throw new gw(`You called setWeights(weights) on layer "${this.name}" `+`with a weight list of length ${t.length}, `+`but the layer was expecting ${n.length} weights. `+`Provided weights: ${t}...`)}if(n.length===0){return}const e=[];const s=v$(n);for(let o=0;o<s.length;++o){const r=s[o];const i=n[o];const c=t[o];if(!w(r.shape,c.shape)){throw new gw(`Layer weight shape ${r.shape} `+`not compatible with provided weight shape ${c.shape}`)}e.push([i,c])}$$(e)}))}addWeight(t,n,e,s,o,r,i,c){if(this._addedWeightNames.indexOf(t)!==-1){throw new gw(`Duplicate weight name ${t} for layer ${this.name}`)}this._addedWeightNames.push(t);if(e==null){e="float32"}if(this.fastWeightInitDuringBuild){s=c!=null?c():f$("zeros")}const a=s.apply(n,e);const u=new g$(a,e,t,r,i);a.dispose();if(o!=null){this.addLoss((()=>o.apply(u.read())))}if(r==null){r=true}if(r){this._trainableWeights.push(u)}else{this._nonTrainableWeights.push(u)}return u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){if(t==null||Array.isArray(t)&&t.length===0){return}t=Rw(t);if(this._losses!==undefined&&this._losses!==null){this.losses.push(...t)}}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null){if(Array.isArray(n)){n.forEach((t=>{if(t!=null){throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.")}}))}else{throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.")}}return null}return n}setMaskMetadata(t,n,e){if(!this.supportsMasking){return}const s=this.computeMask(t,e);if(n instanceof Array&&s instanceof Array){if(n.length!==s.length){throw new Error(`${this.name} outputs ${n.length} tensors `+`but ${s.length} masks for those tensors`)}for(let t=0;t<n.length;t++){n[t].kerasMask=s[t]}}else if(s instanceof Array){throw new Error(`{this.name} outputs a single tensor `+`but ${s.length} masks`)}else if(n instanceof Array){throw new Error(`{this.name} outputs ${n.length} tensors `+`but only one mask`)}else{n.kerasMask=s}}addInboundNode(t,n,e,s,o,r,i=null){const c=Rw(t);n=Rw(n);e=Rw(e);s=Rw(s);o=d$(o);r=d$(r);const a=[];const u=[];const l=[];for(const t of c){a.push(t.sourceLayer);u.push(t.nodeIndex);l.push(t.tensorIndex)}new N$({outboundLayer:this,inboundLayers:a,nodeIndices:u,tensorIndices:l,inputTensors:c,outputTensors:n,inputMasks:e,outputMasks:s,inputShapes:o,outputShapes:r},i);for(let t=0;t<n.length;t++){n[t].sourceLayer=this;n[t].nodeIndex=this.inboundNodes.length-1;n[t].tensorIndex=t}}getConfig(){const t={name:this.name,trainable:this.trainable};if(this.batchInputShape!=null){t["batchInputShape"]=this.batchInputShape}if(this.dtype!=null){t["dtype"]=this.dtype}return t}disposeWeights(){this.weights.forEach((t=>t.dispose()));return this.weights.length}assertNotDisposed(){if(this._refCount===0){throw new Error(`Layer '${this.name}' is already disposed.`)}}dispose(){if(!this.built){throw new Error(`Cannot dispose Layer ${this.name} because it has not been `+`built yet.`)}if(this._refCount===null){throw new Error(`Cannot dispose Layer ${this.name} because it has not been used `+`yet.`)}this.assertNotDisposed();let t=0;if(--this._refCount===0){t=this.disposeWeights()}return{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function E$(t){t=Rw(t);const n=[];for(const e of t){n.push(e.shape)}return Nw(n)}function T$(t){return"float32"}function I$(t,n,e){if(n==null||e!=null&&e>0){n=t.sourceLayer;e=t.nodeIndex}if(n.inboundNodes.length===0){return[t]}else{const t=n.inboundNodes[e];if(t.inboundLayers.length===0){return t.inputTensors}else{const n=[];for(let e=0;e<t.inboundLayers.length;e++){const s=t.inputTensors[e];const o=t.inboundLayers[e];const r=t.nodeIndices[e];const i=I$(s,o,r);for(const t of i){if(n.indexOf(t)===-1){n.push(t)}}}return n}}}function A$(t){let n=true;for(const e of Rw(t)){if(!(e instanceof k$)){n=false;break}}return n}function O$(t){let n=true;for(const e of Rw(t)){if(e instanceof k$){n=false;break}}return n}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class F$ extends S${constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:jw("input").toString()});if(t.batchSize==null){t.batchSize=null}if(t.sparse==null){t.sparse=false}this.trainable=false;this.built=true;this.sparse=t.sparse;if(t.inputShape!=null&&t.batchInputShape!=null){throw new gw("Only provide the inputShape OR "+"batchInputShape argument to inputLayer, not both at the same time.")}let n=t.batchInputShape;if(n==null){if(t.inputShape==null){throw new gw("An InputLayer should be passed either a "+"`batchInputShape` or an `inputShape`.")}else{n=[t.batchSize].concat(t.inputShape)}}else{if(t.batchSize!=null){throw new gw("Cannot specify batchSize if batchInputShape is "+"specified when creating an InputLayer.")}}const e=t.dtype||"float32";this.batchInputShape=n;this.dtype=e;this.inputSpec=[{shape:n}];const s=new k$(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0;s.tensorIndex=0;new N$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new gw("Cannot pass any input to an "+`InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}F$.className="InputLayer";Zp(F$);function _$(t){if(t.batchShape==null&&t.shape==null){throw new Error("Please provide to Input either a `shape`"+" or a `batchShape` argument. Note that "+"`shape` does not include the batch "+"dimension.")}if(t.batchShape!=null&&t.shape!=null){throw new gw("Please provide either a `shape` or `batchShape` "+"argument to Input, but not both.")}let n=t.batchShape;if(t.shape!=null&&n==null){n=[null].concat(t.shape)}let e=t.dtype;if(e==null){e="float32"}const s=new F$({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse});const o=s.inboundNodes[0].outputTensors;return o[0]}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function M$(t,n){if(t.dtype==null||t.dtype===n.dtype){return n}try{return Mi(n,t.dtype)}catch(e){throw new gw(`The dtype of the feed (${n.dtype}) can not be cast to the dtype `+`of the key '${t.name}' (${t.dtype}).`)}}class D${constructor(t){this.id2Value={};this.id2Mask={};this.name2Id={};if(t instanceof D$){for(const n in t.id2Value){this.id2Value[n]=t.id2Value[n];if(n in t.id2Mask){this.id2Mask[n]=t.id2Mask[n]}}}else{if(t==null){return}for(const n of t){this.add(n.key,n.value)}}}add(t,n,e){if(this.id2Value[t.id]==null){this.id2Value[t.id]=M$(t,n);this.name2Id[t.name]=t.id;if(e!=null){this.id2Mask[t.id]=e}}else{throw new gw(`Duplicate key: name=${t.name}, id=${t.id}`)}return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof k$){if(this.id2Value[t.id]==null){throw new gw(`Nonexistent key: ${t.name}`)}else{return this.id2Value[t.id]}}else{const n=this.name2Id[t];if(n==null){throw new gw(`Feed dict has no SymbolicTensor name: ${t}`)}return this.id2Value[n]}}getMask(t){if(t instanceof k$){if(this.id2Value[t.id]==null){throw new gw(`Nonexistent key: ${t.name}`)}else{return this.id2Mask[t.id]}}else{const n=this.name2Id[t];if(n==null){throw new gw(`Feed dict has no SymbolicTensor name: ${t}`)}return this.id2Mask[n]}}disposeMasks(){if(this.id2Mask!=null){Gi(this.id2Mask)}}}const L$=new $w;const z$=new $w;function P$(t){if(L$!=null){L$.setMaxEntries(t)}if(z$!=null){z$.setMaxEntries(t)}}function V$(t,n,e,s){const o=e==null?false:e["training"];const r=Array.isArray(t);const i=r?t:[t];const c=i.map((t=>t.name));const a=[];const u=n.names();for(const t of c){if(u.indexOf(t)!==-1){a.push(n.getValue(t))}else{a.push(null)}}if(s!=null){s.maxNumTensors=-Infinity;s.minNumTensors=Infinity}const l=c.join(",")+"|"+n.names().sort().join(",");let f=L$.get(l);let h;if(f==null){const t=B$(i,n);f=t.sorted;h=t.recipientCounts;L$.put(l,f);z$.put(l,h)}h={};if(!o){Object.assign(h,z$.get(l))}const d=new D$(n);for(let t=0;t<f.length;++t){if(s!=null){const t=Bi().numTensors;if(t>s.maxNumTensors){s.maxNumTensors=t}if(t<s.minNumTensors){s.minNumTensors=t}}const r=f[t];const i=r.sourceLayer;if(i instanceof F$){continue}const u=[];const l=[];const p=[];let m=false;for(const t of r.inputs){const e=d.getValue(t);const s=d.getMask(t);u.push(e);l.push(s);if(s!=null){m=true}if(!o){h[t.name]--;if(h[t.name]===0&&!n.hasKey(t)&&c.indexOf(t.name)===-1&&!e.isDisposed&&t.sourceLayer.stateful!==true){p.push(e)}}}if(m){e=e||{};e["mask"]=l[0]}const x=Rw(i.apply(u,e));let b=null;if(i.supportsMasking){b=i.computeMask(u,l)}const g=U$(r);const w=Array.isArray(g)?g:[g];for(let t=0;t<w.length;++t){if(!d.hasKey(w[t])){d.add(w[t],x[t],Array.isArray(b)?b[0]:b)}const n=c.indexOf(w[t].name);if(n!==-1){a[n]=x[t]}}if(!o){Gi(p)}}d.disposeMasks();return r?a:a[0]}function B$(t,n){m(t!=null&&t.length>0,(()=>`Expected at least one fetch, got none`));let e=[];let s={};if(t.length===1){const o=G$(t[0],n);e=o.sorted;s=o.recipientMap}else{const o=new Set;for(const r of t){const{sorted:t,recipientMap:i}=G$(r,n);for(const n of t){if(!o.has(n.name)){e.push(n);o.add(n.name)}}for(const t in i){if(s[t]==null){s[t]=new Set}i[t].forEach((n=>s[t].add(n)))}}}return{sorted:e,recipientCounts:W$(s)}}function W$(t){const n={};for(const e in t){n[e]=t[e].size}return n}function G$(t,n){const e=new Set;const s=[];const o={};for(const t of n.names()){e.add(t)}const r=[];const i=[];r.push(t);while(r.length>0){const t=r[r.length-1];if(e.has(t.name)){r.pop();continue}const n=i[i.length-1]===r.length-1;if(t.inputs.length===0||n){r.pop();s.push(t);e.add(t.name);if(n){i.pop()}}else{i.push(r.length-1);for(const n of t.inputs){if(o[n.name]==null){o[n.name]=new Set}o[n.name].add(t.name);if(e.has(n.name)){continue}r.push(n)}}}return{sorted:s,recipientMap:o}}function U$(t){let n;if(t.sourceLayer.inboundNodes.length===1){n=t.sourceLayer.output}else{let e=null;for(let n=0;n<t.sourceLayer.inboundNodes.length;++n){for(const s of t.sourceLayer.inboundNodes[n].outputTensors){if(s.id===t.id){e=n;break}}}n=t.sourceLayer.getOutputAt(e)}return n}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$=et();H$.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),P$);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j$(t,n){return Wi((()=>Hu(Ku(tc(t,t),n,true))))}class q$ extends Jp{getConfig(){return{}}}class X$ extends q${constructor(t){super();this.defaultMaxValue=2;this.defaultAxis=0;this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Wi((()=>{const n=j$(t,this.axis);const e=Na(n,0,this.maxValue);return tc(t,Zi(e,Xi(bv(),n)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}X$.className="MaxNorm";Zp(X$);class K$ extends q${constructor(t){super();this.defaultAxis=0;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Wi((()=>Zi(t,Xi(bv(),j$(t,this.axis)))))}getConfig(){return{axis:this.axis}}}K$.className="UnitNorm";Zp(K$);class J$ extends q${apply(t){return bh(t)}}J$.className="NonNeg";Zp(J$);class Y$ extends q${constructor(t){super();this.defaultMinValue=0;this.defaultMaxValue=1;this.defaultRate=1;this.defaultAxis=0;this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue;this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue;this.rate=t.rate!=null?t.rate:this.defaultRate;this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Wi((()=>{const n=j$(t,this.axis);const e=Xi(tc(this.rate,Na(n,this.minValue,this.maxValue)),tc(1-this.rate,n));return tc(t,Zi(e,Xi(bv(),n)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Y$.className="MinMaxNorm";Zp(Y$);const Z$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Q$(t){return Iw(t)}function ty(t,n={}){return Ow(t,Yp.getMap().classNameMap,n,"constraint")}function ny(t){if(t==null){return null}if(typeof t==="string"){const n=t in Z$?Z$[t]:t;const e={className:n,config:{}};return ty(e)}else if(t instanceof q$){return t}else{return ty(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function ey(t){if(t==null){return}const n=[];const e=[];const s=[];for(const o in t){const r=t[o];if(typeof r!=="number"){const t=r;n.push(t.data());e.push(o);s.push(t)}}if(n.length>0){const o=await Promise.all(n);for(let n=0;n<o.length;++n){t[e[n]]=o[n][0]}Gi(s)}}function sy(t){if(t==null){return}for(const n in t){const e=t[n];if(typeof e!=="number"){e.dispose()}}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var oy;(function(t){t[t["SILENT"]=0]="SILENT";t[t["VERBOSE"]=1]="VERBOSE"})(oy||(oy={}));const ry=125;class iy{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class cy{constructor(t,n=10){if(t==null){t=[]}this.callbacks=t;this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks){n.setParams(t)}}setModel(t){for(const n of this.callbacks){n.setModel(t)}}async onEpochBegin(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onEpochBegin(t,n)}}async onEpochEnd(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onEpochEnd(t,n)}}async onBatchBegin(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onBatchBegin(t,n)}}async onBatchEnd(t,n){if(n==null){n={}}for(const e of this.callbacks){await e.onBatchEnd(t,n)}}async onTrainBegin(t){if(t==null){t={}}for(const n of this.callbacks){await n.onTrainBegin(t)}}async onTrainEnd(t){if(t==null){t={}}for(const n of this.callbacks){await n.onTrainEnd(t)}}}class ay extends iy{constructor(){super()}async onEpochBegin(t){this.seen=0;this.totals={}}async onBatchEnd(t,n){if(n==null){n={}}const e=n["size"]==null?0:n["size"];this.seen+=e;for(const t in n){const s=n[t];if(typeof s==="number"){if(!this.totals.hasOwnProperty(t)){this.totals[t]=0}this.totals[t]=this.totals[t]+s*e}else{let n;if(t in this.totals){n=this.totals[t]}else{this.totals[t]=0}const o=Wi((()=>Xi(this.totals[t],tc(s,e))));this.totals[t]=o;if(n!=null){n.dispose()}}}}async onEpochEnd(t,n){if(n!=null){for(const t of this.params["metrics"]){if(this.totals[t]==null){continue}if(typeof this.totals[t]==="number"){n[t]=this.totals[t]/this.seen}else{Wi((()=>{const e=tc(Zi(1,this.seen),this.totals[t]);n[t]=e;this.totals[t].dispose();Ui(n[t])}))}}}}}class uy extends iy{async onTrainBegin(t){this.epoch=[];this.history={}}async onEpochEnd(t,n){if(n==null){n={}}this.epoch.push(t);for(const t in n){if(this.history[t]==null){this.history[t]=[]}this.history[t].push(n[t])}}async syncData(){const t=[];const n=[];const e=[];for(const s in this.history){const o=this.history[s];for(let r=0;r<o.length;++r){if(typeof o[r]!=="number"){const i=o[r];t.push(i.data());n.push(s);e.push(r)}}}const s=await Promise.all(t);for(let t=0;t<s.length;++t){const o=this.history[n[t]][e[t]];o.dispose();this.history[n[t]][e[t]]=s[t][0]}}}class ly extends iy{constructor(t,n){super();this.currentEpoch=0;this.nowFunc=t.nowFunc;this.nextFrameFunc=t.nextFrameFunc||Jm;this.yieldEvery=n||"auto";if(this.yieldEvery==="auto"){this.yieldEvery=ry}if(this.yieldEvery==="never"&&t.onYield!=null){throw new Error("yieldEvery is `never` but you provided an `onYield` callback. "+"Either change `yieldEvery` or remove the callback")}if(D(this.yieldEvery)){this.maybeWait=Bw(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)}this.trainBegin=t.onTrainBegin;this.trainEnd=t.onTrainEnd;this.epochBegin=t.onEpochBegin;this.epochEnd=t.onEpochEnd;this.batchBegin=t.onBatchBegin;this.batchEnd=t.onBatchEnd;this.yield=t.onYield}async maybeWait(t,n,e){const s=[];if(this.yield!=null){await ey(e);s.push(this.yield(t,n,e))}s.push(this.nextFrameFunc());await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t;if(this.epochBegin!=null){await ey(n);await this.epochBegin(t,n)}}async onEpochEnd(t,n){const e=[];if(this.epochEnd!=null){await ey(n);e.push(this.epochEnd(t,n))}if(this.yieldEvery==="epoch"){e.push(this.nextFrameFunc())}await Promise.all(e)}async onBatchBegin(t,n){if(this.batchBegin!=null){await ey(n);await this.batchBegin(t,n)}}async onBatchEnd(t,n){const e=[];if(this.batchEnd!=null){await ey(n);e.push(this.batchEnd(t,n))}if(this.yieldEvery==="batch"){e.push(this.nextFrameFunc())}else if(D(this.yieldEvery)){e.push(this.maybeWait(this.currentEpoch,t,n))}await Promise.all(e)}async onTrainBegin(t){if(this.trainBegin!=null){await ey(t);await this.trainBegin(t)}}async onTrainEnd(t){if(this.trainEnd!=null){await ey(t);await this.trainEnd(t)}}}function fy(t,n){if(t==null){t={}}if(t instanceof iy){return[t]}if(Array.isArray(t)&&t[0]instanceof iy){return t}const e=Rw(t);return e.map((t=>new ly(t,n)))}class hy{constructor(){}static registerCallbackConstructor(t,n){m(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, `+`but got ${t}`));hy.checkForDuplicate(n);if(hy.constructors[t]==null){hy.constructors[t]=[]}hy.constructors[t].push(n)}static checkForDuplicate(t){for(const n in hy.constructors){const e=hy.constructors[+n];e.forEach((n=>{if(n===t){throw new gw("Duplicate callback constructor.")}}))}}static clear(){hy.constructors={}}static createCallbacks(t){const n=[];for(const e in hy.constructors){const s=+e;if(t>=s){n.push(...hy.constructors[s])}}return n.map((t=>new t))}}hy.constructors={};function dy(t,n,e,s,o,r,i,c,a){const u=new uy;const l=[new ay,...hy.createCallbacks(n)];if(t!=null){l.push(...t)}l.push(u);const f=new cy(l);f.setParams({epochs:e,initialEpoch:s,samples:o,steps:r,batchSize:i,verbose:n,doValidation:c,metrics:a});return{callbackList:f,history:u}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function py(t,n={},e=false){return Ow(t,Yp.getMap().classNameMap,n,"layer",e)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function my(t,n){return Wi((()=>{if(t.dtype!=="float32"){t=Mi(t,"float32")}const e=Ku(Fv(t),n,true);const s=ka(e.shape,bv());const o=Hu(df(e,s));return Zi(t,o)}))}function xy(t,n){return Wi((()=>mf(Fv(Xl(n,t)),-1)))}function by(t,n){return Wi((()=>mf(ec(Xl(n,t)),-1)))}function gy(t,n){return Wi((()=>{const e=Xl(t,n);const s=Na(ec(t),bv(),Number.MAX_VALUE);const o=ec(Zi(e,s));return tc(100,mf(o,-1))}))}function wy(t,n){return Wi((()=>{const e=Na(n,bv(),Number.MAX_VALUE);const s=Dl(Xi(1,e));const o=Na(t,bv(),Number.MAX_VALUE);const r=Dl(Xi(1,o));return mf(Fv(Xl(s,r)),-1)}))}function vy(t,n){return Wi((()=>{const e=df(0,Xl(1,tc(t,n)));return mf(Fv(e),-1)}))}function $y(t,n){return Wi((()=>{const e=df(0,Xl(1,tc(t,n)));return mf(e,-1)}))}function yy(t,n){return Wi((()=>{const e=Ku(tc(t,n),-1);const s=zu(tc(Xl(1,t),n),-1);return df(0,Xi(1,Xl(s,e)))}))}function ky(t,n){return Wi((()=>{const e=Math.log(2);const s=Xl(n,t);const o=Xl(Xi(s,Ul(tc(-2,s))),e);return mf(o,-1)}))}function Cy(t,n,e=false){return Wi((()=>{if(e){n=Hh(n)}else{const t=Ku(n,n.shape.length-1,true);n=Zi(n,t)}n=Na(n,bv(),1-bv());return Wl(Ku(tc(Mi(t,"float32"),Dl(n)),n.shape.length-1))}))}function Ny(t,n,e=false){return Wi((()=>{const s=Mi(hl(yv(t)),"int32");n=Na(n,bv(),1-bv());const o=n.shape;const r=Hc(Tf(s,o[o.length-1]),o);return Cy(r,n,e)}))}function Ry(t,n){if(!w(t.shape,n.shape)){throw new gw(`logits and labels must have the same shape, but got shapes `+`${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`)}return Wi((()=>{const e=bh(n);const s=Wl(ec(n));return Xi(Xl(e,tc(n,t)),zl(el(s)))}))}function Sy(t,n){return Wi((()=>{let e;e=Na(n,bv(),1-bv());e=Dl(Zi(e,Xl(1,e)));return mf(Ry(t,e),-1)}))}function Ey(t,n){return Wi((()=>{const e=Na(t,bv(),1);const s=Na(n,bv(),1);return Ku(tc(t,Dl(Zi(e,s))),-1)}))}function Ty(t,n){return Wi((()=>{const e=Dl(Xi(bv(),n));return mf(Xl(n,tc(t,e)),-1)}))}function Iy(t,n){return Wi((()=>{const e=my(t,-1);const s=my(n,-1);const o=tc(e,s);return Wl(Ku(o,-1))}))}const Ay={meanSquaredError:xy,meanAbsoluteError:by,meanAbsolutePercentageError:gy,meanSquaredLogarithmicError:wy,squaredHinge:vy,hinge:$y,categoricalHinge:yy,logcosh:ky,categoricalCrossentropy:Cy,sparseCategoricalCrossentropy:Ny,binaryCrossentropy:Sy,kullbackLeiblerDivergence:Ey,poisson:Ty,cosineProximity:Iy};function Oy(t){if(typeof t==="string"){if(t in Ay){return Ay[t]}let n=`Unknown loss ${t}`;if(t.toLowerCase().includes("softmaxcrossentropy")){n=`Unknown loss ${t}. `+'Use "categoricalCrossentropy" as the string name for '+"tf.losses.softmaxCrossEntropy"}throw new gw(n)}else{return t}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fy(t,n){return Wi((()=>{const e=tc(.5,Af(n));const s=wv(xl(n,e),t.dtype);return mf(pu(t,s),-1)}))}function _y(t,n){return Wi((()=>wv(pu(hc(t,-1),hc(n,-1)),"float32")))}function My(t,n){return Wi((()=>Mi(Ku(tf(pu(t,1),pu(n,1))),"float32")))}function Dy(t,n){return Wi((()=>Mi(Ku(tf(pu(t,0),pu(n,1))),"float32")))}function Ly(t,n){return Wi((()=>{const e=My(t,n);const s=Dy(t,n);const o=Xi(e,s);return Mi(xu(xl(o,0),Zi(e,o),0),"float32")}))}function zy(t,n){return Sy(t,n)}function Py(t,n){if(t.rank===n.rank){t=rd(t,[t.rank-1])}n=hc(n,-1);if(n.dtype!==t.dtype){n=Mi(n,t.dtype)}return Mi(pu(t,n),"float32")}const Vy=xy;const By=xy;const Wy=by;const Gy=by;const Uy=gy;const Hy=gy;const jy=Cy;const qy=Iy;const Xy=Ny;const Ky={binaryAccuracy:Fy,categoricalAccuracy:_y,precision:Ly,categoricalCrossentropy:jy,sparseCategoricalCrossentropy:Xy,mse:Vy,MSE:By,mae:Wy,MAE:Gy,mape:Uy,MAPE:Hy,cosine:qy};function Jy(t){if(typeof t==="string"&&t in Ky){return Ky[t]}else if(typeof t!=="string"&&t!=null){return t}else{throw new gw(`Unknown metric ${t}`)}}function Yy(t){kw(t!==null,`Unknown LossOrMetricFn ${t}`);if(typeof t==="string"){return t}else{let n;for(const e of Object.keys(Ay)){if(Ay[e]===t){n=e;break}}if(n!==undefined){return n}for(const e of Object.keys(Ky)){if(Ky[e]===t){n=e;break}}if(n!==undefined){return n}return t.name}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zy(t){const n={Adagrad:()=>Xm.adagrad(.01),Adadelta:()=>Xm.adadelta(1,.95,bv()),Adam:()=>Xm.adam(.001,.9,.999,bv()),Adamax:()=>Xm.adamax(.002,.9,.999,bv(),0),RMSProp:()=>Xm.rmsprop(.001,.9,0,bv()),SGD:()=>Xm.sgd(.01)};n["adagrad"]=n["Adagrad"];n["adadelta"]=n["Adadelta"];n["adam"]=n["Adam"];n["adamax"]=n["Adamax"];n["rmsprop"]=n["RMSProp"];n["sgd"]=n["SGD"];if(t in n){return n[t]()}throw new gw(`Unknown Optimizer ${t}`)}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Qy=1*1024*1024;function tk(t,n,e=false){if(t==null||typeof t!=="object"||Object.getPrototypeOf(t)!==Object.prototype||!nk(t)){throw new Error("User-defined metadata is expected to be a JSON object, but is not.")}if(e){const e=JSON.stringify(t);if(e.length>Qy){console.warn(`User-defined metadata of model "${n}" is too large in `+`size (length=${e.length} when serialized). It is not `+`recommended to store such large objects in user-defined metadata. `+`Please make sure its serialized length is <= `+`${Qy}.`)}}}function nk(t){if(t===null){return true}else if(typeof t==="object"){if(Object.getPrototypeOf(t)===Object.prototype){const n=Object.keys(t);for(const e of n){if(typeof e!=="string"){return false}if(!nk(t[e])){return false}}return true}else{if(Array.isArray(t)){for(const n of t){if(!nk(n)){return false}}return true}else{return false}}}else{const n=typeof t;return n==="string"||n==="number"||n==="boolean"}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ek(t,n,e,s=console.log){const o=ok(t);const r=["Layer (type)","Input Shape","Output shape","Param #"];if(o){n=n||90;e=e||[.32,.61,.89,1]}else{n=n||115;e=e||[.24,.48,.7,.8,1]}if(e[e.length-1]<=1){e=e.map((t=>Math.floor(n*t)))}let i;if(!o){r.push("Receives inputs");i=[];for(const n in t.nodesByDepth){i.push(...t.nodesByDepth[n])}}s("_".repeat(n));rk(r,e,s);s("=".repeat(n));const c=t.layers;for(let t=0;t<c.length;++t){if(o){ik(c[t],e,s)}else{ck(c[t],e,i,s)}s((t===c.length-1?"=":"_").repeat(n))}t.checkTrainableWeightsConsistency();const a=sk(t);const u=x$(t.nonTrainableWeights);s(`Total params: ${a+u}`);s(`Trainable params: ${a}`);s(`Non-trainable params: ${u}`);s("_".repeat(n))}function sk(t){let n;if(t.collectedTrainableWeights!=null){n=x$(t.collectedTrainableWeights)}else{n=x$(t.trainableWeights)}return n}function ok(t){let n=true;const e=[];const s=[];for(const n in t.nodesByDepth){e.push(t.nodesByDepth[n])}for(const t of e){if(t.length>1||t.length===1&&t[0].inboundLayers.length>1){n=false;break}s.push(...t)}if(n){for(const e of t.layers){let t=false;for(const o of e.inboundNodes){if(s.indexOf(o)!==-1){if(t){n=false;break}else{t=true}}}if(!n){break}}}return n}function rk(t,n,e=console.log){let s="";for(let e=0;e<t.length;++e){if(e>0){s=s.slice(0,s.length-1)+" "}s+=t[e];s=s.slice(0,n[e]);s+=" ".repeat(n[e]-s.length)}e(s)}function ik(t,n,e){let s;let o;try{o=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){o="multiple"}try{s=JSON.stringify(t.outputShape)}catch(t){s="multiple"}const r=t.name;const i=t.getClassName();const c=[`${r} (${i})`,o,s,t.countParams().toString()];rk(c,n,e)}function ck(t,n,e,s){let o;let r;try{r=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){r="multiple"}try{o=JSON.stringify(t.outputShape)}catch(t){o="multiple"}const i=[];for(const n of t.inboundNodes){if(e!=null&&e.length>0&&e.indexOf(n)===-1){continue}for(let t=0;t<n.inboundLayers.length;++t){const e=n.inboundLayers[t].name;const s=n.nodeIndices[t];const o=n.tensorIndices[t];i.push(`${e}[${s}][${o}]`)}}const c=t.name;const a=t.getClassName();const u=i.length===0?"":i[0];const l=[`${c} (${a})`,r,o,t.countParams().toString(),u];rk(l,n,s);for(let t=1;t<i.length;++t){rk(["","","","",i[t]],n,s)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ak(t,n,e){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&n===0&&typeof e==="string"}function uk(t,n){if(t===null){return null}else if(typeof t==="string"){return Ew(t)}else if(typeof t==="number"||typeof t==="boolean"){return t}else if(t instanceof Array){const e=[];const s=t.length;for(let o=0;o<s;++o){const s=t[o];if(ak(n,o,s)){e.push(s)}else{e.push(uk(s,n))}}return e}else{const n={};for(const e of Object.keys(t)){const s=t[e];if(e==="name"&&typeof s==="string"){n[e]=s}else{const t=Ew(e);n[t]=uk(s,t)}}return n}}function lk(t,n){if(t===null||t===undefined){return null}else if(typeof t==="string"){return Sw(t)}else if(typeof t==="number"||typeof t==="boolean"){return t}else if(t instanceof Array){const e=[];const s=t.length;for(let o=0;o<s;++o){const s=t[o];if(ak(n,o,s)){e.push(s)}else{e.push(lk(s,n))}}return e}else{const n={};for(const e of Object.keys(t)){const s=t[e];const o=Sw(e);if((e==="name"||e==="className")&&typeof s==="string"){n[o]=s}else{n[o]=lk(s,e)}}return n}}
/** @license See the LICENSE file. */const fk="4.11.0";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hk=t=>{const n=Object.keys(t);if(n.length===0){return false}const e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class dk extends S${constructor(t){super({});this.containerNodes=new Set;this.name=t.name;if(this.name==null){const t=this.getClassName().toLowerCase();this.name=jw(t)}this.supportsMasking=false;this.trainable_=true;if(Array.isArray(t.inputs)){this.inputs=t.inputs.slice()}else{this.inputs=[t.inputs]}if(Array.isArray(t.outputs)){this.outputs=t.outputs.slice()}else{this.outputs=[t.outputs]}if(Mw(this.inputs).length!==this.inputs.length){throw new gw("The list of inputs passed to the model is "+"redundant. All inputs should only appear once. Found: "+`${this.inputs.map((t=>t.name))}`)}if(Mw(this.outputs).length!==this.outputs.length){console.warn("The list of outputs passed to the model is redundant. "+"All outputs should only appear once. Found: "+`${this.outputs.map((t=>t.name))}`)}this.inputLayers=[];this.inputLayersNodeIndices=[];this.inputLayersTensorIndices=[];this.outputLayers=[];this.outputLayersNodeIndices=[];this.outputLayersTensorIndices=[];this.layers=[];this.internalContainerRefs=[];for(const t of this.outputs){const n=t.sourceLayer;const e=t.nodeIndex;const s=t.tensorIndex;this.outputLayers.push(n);this.outputLayersNodeIndices.push(e);this.outputLayersTensorIndices.push(s)}for(const t of this.inputs){const n=t.sourceLayer;const e=t.nodeIndex;const s=t.tensorIndex;kw(e===0,"input layer has >1 nodes");kw(s===0,"input layer has >1 tensors");this.inputLayers.push(n);this.inputLayersNodeIndices.push(e);this.inputLayersTensorIndices.push(s)}this.inputNames=[];this.outputNames=[];this.feedInputShapes=[];this.feedInputNames=[];this.feedOutputNames=[];for(let n=0;n<this.inputLayers.length;n++){const e=this.inputLayers[n];if(!(e instanceof F$)){throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+`Received inputs: ${t.inputs}. `+`Input ${n} (0-based) originates `+`from layer type ${e.getClassName()}.`)}this.inputNames.push(e.name);this.feedInputShapes.push(e.batchInputShape);this.feedInputNames.push(e.name)}for(const t of this.outputLayers){this.outputNames.push(t.name)}this.internalInputShapes=this.inputs.map((t=>t.shape));this.internalOutputShapes=this.outputs.map((t=>t.shape));const n={};const e={};const s={};const o={};const r={};const i=[];const c=(t,n,e,s,o,a)=>{if(s==null||o==null||a==null){s=t.sourceLayer;o=t.nodeIndex;a=t.tensorIndex}const u=s.inboundNodes[o];if(e.indexOf(u)!==-1){throw new bw(`The tensor ${t.name} at layer "${s.name}" `+"is part of a cycle.")}if(n.indexOf(u)!==-1){return}this.containerNodes.add(dk.nodeKey(s,o));if(!(s.id in r)){r[s.id]=Object.keys(r).length}if(e.indexOf(u)===-1){e.push(u)}const l=u.inboundLayers.length;for(let t=0;t<l;t++){const s=u.inputTensors[t];const o=u.inboundLayers[t];const r=u.nodeIndices[t];const i=u.tensorIndices[t];c(s,n,e,o,r,i)}n.push(u);while(e.indexOf(u)>=0){e.splice(e.indexOf(u),1)}i.push(u)};const a=[];const u=[];for(const t of this.outputs){c(t,a,u)}const l=i.slice().reverse();for(const t of l){e[t.id]=t;if(!(t.id in n)){n[t.id]=0}let r=n[t.id];const i=s[t.outboundLayer.id]==null?0:s[t.outboundLayer.id];r=Math.max(r,i);s[t.outboundLayer.id]=r;o[t.outboundLayer.id]=t.outboundLayer;n[t.id]=r;for(let s=0;s<t.inboundLayers.length;s++){const o=t.inboundLayers[s];const i=t.nodeIndices[s];const c=o.inboundNodes[i];const a=n[c.id]==null?0:n[c.id];n[c.id]=Math.max(r+1,a);e[c.id]=c}}const f={};for(const t in n){const s=n[t];if(!(s in f)){f[s]=[]}f[s].push(e[t])}const h={};for(const t in s){const n=s[t];if(!(n in h)){h[n]=[]}h[n].push(o[t])}let d=Object.keys(h).map((t=>parseInt(t,10))).sort(_w);this.layers=[];for(const t of d){const n=h[t];n.sort(((t,n)=>{const e=r[t.id];const s=r[n.id];if(e<s){return-1}if(e>s){return 1}return 0}));for(const t of n){if(t instanceof dk){this.internalContainerRefs.push(t)}this.layers.push(t)}}this.layersByDepth=h;d=Object.keys(f).map((t=>parseInt(t,10))).sort(_w);const p=this.inputs.slice();const m=[];for(const t of d){for(const n of f[t]){const t=n.outboundLayer;if(t!=null){for(const e of n.inputTensors){if(p.indexOf(e)===-1){throw new bw(`Graph disconnected: cannot obtain value for tensor ${e}`+` at layer "${t.name}". `+"The following previous layers were accessed without "+`issue: ${m}`)}}for(const t of n.outputTensors){p.push(t)}m.push(t.name)}}}this.nodesByDepth=f;const x=this.layers.map((t=>t.name));for(const t of x){const n=x.filter((n=>n===t)).length;if(n!==1){throw new bw(`The name "${t}" is used ${n} times `+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(x))}}this.outboundNodes=[];this.inboundNodes=[];new N$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))});this.built=true;this._refCount=1}assertNotDisposed(){if(this._refCount===0){throw new Error(`Container '${this.name}' is already disposed.`)}}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers){t.numDisposedVariables+=n.dispose().numDisposedVariables}for(const n of this.internalContainerRefs){t.numDisposedVariables+=n.dispose().numDisposedVariables}}t.refCountAfterDispose=this._refCount;return t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((n=>{n._trainableWeights.forEach((n=>n.trainable=t))}));this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0){throw new gw("Container instance unexpectedly contains _trainableWeights."+"The trainable weights of a Container are a union of the "+"trainable weights of its consituent Layers. Its own "+"_trainableWeights must remain an empty Array.")}if(!this.trainable){return[]}let t=[];for(const n of this.layers){t=t.concat(n.trainableWeights)}return t}get nonTrainableWeights(){const t=[];for(const n of this.layers){t.push(...n.nonTrainableWeights)}if(!this.trainable){const n=[];for(const t of this.layers){n.push(...t.trainableWeights)}return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=true){const e={};let s=0;const o=hk(t);if(o){this.parseWeights(t)}for(const t of this.layers){for(const[n,r]of t.weights.entries()){const t=o?`${r.name.split("/").slice(0,-1).join("/")+"/"}${n}`:r.originalName;if(e[t]!=null){throw new gw(`Duplicate weight name: ${t}`)}e[t]=r;s++}}const r=[];for(const s in t){let o=s;if(e[s]==null){const t=s.split("/");const n=t.slice(0,-2).concat([t[t.length-1]]);o=n.join("/")}if(e[o]!=null){r.push([e[o],t[s]])}else if(n){throw new gw(`Provided weight data has no target variable: ${s}`)}delete e[o]}if(n){const t=[];for(const n in e){t.push(n)}if(t.length>0){throw new gw(`${t.length} of ${s} weights are not set: `+`${t}`)}}$$(r)}parseWeights(t){for(const n in Object.keys(t)){const e=n.split("/");const s=["vars","layer_checkpoint_dependencies"];const o=e.map((t=>{if(t.startsWith("_")){return t.slice(1)}return t})).filter((t=>!s.includes(t))).join("/");if(o!==n){t[o]=t[n];delete t[n]}}}updatedConfig(){const t=this.getConfig();const n={};n["className"]=this.getClassName();n["config"]=t;n["kerasVersion"]=`tfjs-layers ${fk}`;n["backend"]="TensorFlow.js";return n}toJSON(t,n=true){const e=lk(this.updatedConfig());return n?JSON.stringify(e):e}call(t,n){return Wi((()=>{t=Rw(t);const e=new D$;for(let n=0;n<this.inputs.length;++n){e.add(this.inputs[n],t[n])}return V$(this.outputs,e,n)}))}computeMask(t,n){return Wi((()=>{t=Rw(t);let e;if(n==null){e=yw(null,t.length)}else{e=Rw(n)}return this.runInternalGraph(t,e)[1]}))}computeOutputShape(t){const n=d$(t);if(n.length!==this.inputLayers.length){throw new gw(`Invalid inputShape argument ${t}: `+`model has ${this.inputLayers.length} tensor inputs.`)}const e={};for(let t=0;t<n.length;t++){const s=this.inputLayers[t];const o=n[t];const r=s.name+"_0_0";e[r]=o}const s=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(_w);if(s.length>1){for(const t of s){const n=this.nodesByDepth[t];for(const t of n){const n=t.outboundLayer;if(this.inputLayers.map((t=>t.id)).indexOf(n.id)!==-1){continue}const s=[];for(let n=0;n<t.inboundLayers.length;n++){const o=t.inboundLayers[n];const r=t.nodeIndices[n];const i=t.tensorIndices[n];const c=`${o.name}_${r}_${i}`;const a=e[c];s.push(a)}const o=n.computeOutputShape(Nw(s));const r=d$(o);const i=n.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){const s=`${n.name}_${i}_${t}`;e[s]=r[t]}}}}const o=[];const r=[];for(let t=0;t<this.outputLayers.length;t++){const n=this.outputLayers[t];const e=this.outputLayersNodeIndices[t];const s=this.outputLayersTensorIndices[t];const o=`${n.name}_${e}_${s}`;r.push(o)}for(let t=0;t<r.length;t++){const n=r[t];kw(n in e);o.push(e[n])}return Nw(o)}runInternalGraph(t,n){if(n==null){n=yw(null,t.length)}const e={};for(let s=0;s<this.inputs.length;++s){const o=this.inputs[s];const r=t[s];const i=n[s];e[o.id]=[r,i]}const s=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(_w);for(const t of s){const n=this.nodesByDepth[t];for(const t of n){const n=t.outboundLayer;const s=t.inputTensors;const o=t.outputTensors;const r=new Array;for(const t of s){if(t.id in e){r.push(e[t.id])}}if(r.length===s.length){let s={};let i;let c;let a;let u;if(t.callArgs!=null){s=t.callArgs}if(r.length===1){const[t,e]=r[0];if(s["mask"]==null){s["mask"]=e}a=Rw(n.call(t,s));u=Rw(n.computeMask(t,e));i=[t];c=[e]}else{i=r.map((t=>t[0]));c=r.map((t=>t[1]));if(s["mask"]==null){s["mask"]=c}a=Rw(n.call(i,s));u=Rw(n.computeMask(i,c))}if(n.activityRegularizer){throw new ww("LayersModel invocation with concrete Tensor value(s) in the "+"presence of activity regularizer(s) is not supported yet.")}for(let t=0;t<o.length;++t){const n=o[t];const s=a[t];const r=u[t];e[n.id]=[s,r]}}}}const o=[];const r=[];const i=[];for(const t of this.outputs){kw(t.id in e,`Could not compute output ${t.name} : ${t.id}`);const[n,s]=e[t.id];i.push(n.shape);o.push(n);r.push(s)}return[o,r,i]}buildNodeConversionMap(t){const n={};let e;for(const t of this.layers){e=t instanceof dk?1:0;for(let s=0;s<t.inboundNodes.length;s++){const o=dk.nodeKey(t,s);if(this.containerNodes.has(o)){n[o]=e;e+=1}}}return n}getLayer(t,n){if(n!=null){return this.findLayer(n)}else{if(t==null){throw new gw("Provide either a layer name or layer index")}if(typeof t==="number"){return this.findLayer(t)}}for(const n of this.layers){if(n.name===t){return n}}throw new gw(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t){throw new gw(`Was asked to retrieve layer at index ${t}, but model only `+`has ${this.layers.length} layer(s).`)}else{return this.layers[t]}}calculateLosses(){return Wi((()=>{const t=[];for(const n of this.layers){for(let e=0;e<n.inboundNodes.length;++e){const s=dk.nodeKey(n,e);if(this.containerNodes.has(s)){t.push(...n.calculateLosses())}}}return t}))}getConfig(){const t={name:this.name};const n=this.buildNodeConversionMap(this.layers);const e=[];for(const t of this.layers){const s=t.getClassName();const o=t.getConfig();const r=[];for(let e=0;e<t.inboundNodes.length;e++){const s=t.inboundNodes[e];const o=dk.nodeKey(t,e);let i={};if(this.containerNodes.has(o)){if(s.callArgs){try{JSON.stringify(s.callArgs);i=s.callArgs}catch(n){console.warn(`Layer ${t.name} was passed `+`non-serializable keyword arguments: `+`${s.callArgs}. They will not be included `+`in the serialized model (and thus will be `+`missing at deserialization time).`);i={}}}if(s.inboundLayers.length>0){const t=[];for(let e=0;e<s.inboundLayers.length;e++){const o=s.inboundLayers[e];const r=s.nodeIndices[e];const c=s.tensorIndices[e];const a=dk.nodeKey(o,r);let u=n[a];if(u==null){u=0}t.push([o.name,u,c,i])}r.push(t)}}}const i={};i["name"]=t.name;i["className"]=s;i["config"]=o;i["inboundNodes"]=r;e.push(i)}t["layers"]=e;const s=[];for(let t=0;t<this.inputLayers.length;t++){const e=this.inputLayers[t];const o=this.inputLayersNodeIndices[t];const r=dk.nodeKey(e,o);if(!this.containerNodes.has(r)){continue}let i=n[r];if(i===null||i===undefined){i=0}const c=this.inputLayersTensorIndices[t];s.push([e.name,i,c])}t["inputLayers"]=s;const o=[];for(let t=0;t<this.outputLayers.length;t++){const e=this.outputLayers[t];const s=this.outputLayersNodeIndices[t];const r=dk.nodeKey(e,s);if(!this.containerNodes.has(r)){continue}let i=n[r];if(i===null||i===undefined){i=0}const c=this.outputLayersTensorIndices[t];o.push([e.name,i,c])}t["outputLayers"]=o;return t}static fromConfig(t,n,e={},s=false){const o={};const r={};function i(t,n){if(!(t.name in r)){r[t.name]=[n]}else{r[t.name].push(n)}}function c(t,n){const e=[];let s;for(const r of n){const c=r[0];const a=r[1];const u=r[2];s=r[3]==null?{}:r[3];if(!(c in o)){i(t,n);return}const l=o[c];if(l.inboundNodes.length<=a){i(t,n);return}const f=l.inboundNodes[a];e.push(f.outputTensors[u])}if(e.length>0){t.apply(Nw(e),s)}}function a(t){const e=t["name"];const r=py(t,n["customObjects"]!=null?n["customObjects"]:{});r.setFastWeightInitDuringBuild(s);o[e]=r;const c=t["inboundNodes"];c.forEach((t=>{if(!(t instanceof Array)){throw new gw(`Corrupted configuration, expected array for nodeData: ${t}`)}i(r,t)}))}const u=n["name"];const l=n["layers"];for(const t of l){a(t)}while(!Dw(r)){for(const t of l){const n=o[t["name"]];if(n.name in r){const t=r[n.name];delete r[n.name];for(const e of t){c(n,e)}}}}const f=[];const h=[];const d=n["inputLayers"];for(const t of d){const n=t[0];const e=t[1];const s=t[2];kw(n in o);const r=o[n];const i=r.inboundNodes[e].outputTensors;f.push(i[s])}const p=n["outputLayers"];for(const t of p){const n=t[0];const e=t[1];const s=t[2];kw(n in o);const r=o[n];const i=r.inboundNodes[e].outputTensors;h.push(i[s])}return new t({inputs:f,outputs:h,name:u})}get stateful(){if(this._stateful){throw new gw("Container instance unexpectedly has _stateful = true. The "+"statefulness of a Container is determined by the Layers it "+"contains. Its _stateful property must remain the default false.")}for(const t of this.layers){if(t.stateful){return true}}return false}resetStates(){Wi((()=>{this.layers.forEach((t=>{if(t.stateful){t.resetStates()}}))}))}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pk(t,n,e){const s=n.length;if(t==null||Array.isArray(t)&&t.length===0){return n.map((t=>null))}if(s===1){if(Array.isArray(t)&&t.length===1){return t}else if(typeof t==="object"&&n[0]in t){return[t[n[0]]]}else{return[t]}}if(Array.isArray(t)){if(t.length!==s){throw new Error(`Provided ${e} is an array of ${t.length} `+`element(s), but the model has ${s} outputs. `+`Make sure a set of weights is provided for each model output.`)}return t}else if(typeof t==="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]==="object"){const e=[];n.forEach((n=>{if(n in t){e.push(t[n])}else{e.push(null)}}));return e}else{throw new Error(`The model has multiple (${s}) outputs, `+`so ${e} must be either an array with `+`${s} elements or an object with ${n} keys. `+`Provided ${e} not understood: ${JSON.stringify(t)}`)}}function mk(t,n){return pk(t,n,"classWeight")}async function xk(t,n,e,s){if(n!=null||s!=null){throw new Error("Support sampleWeight is not implemented yet")}if(e!=null){const n=Wi((()=>{if(t.shape.length===1){return Li(t)}else if(t.shape.length===2){if(t.shape[1]>1){const n=1;return hc(t,n)}else if(t.shape[1]===1){return Hc(t,[t.shape[0]])}else{throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) `+`during handling of class weights. The size is expected to be `+`>= 1.`)}}else{throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during `+`handling of class weights. The rank is expected to be 1 or 2.`)}}));const s=Array.from(await n.data());Gi(n);const o=[];s.forEach((t=>{if(e[t]==null){throw new Error(`classWeight must contain all classes in the training data. `+`The class ${t} exists in the data but not in `+`classWeight`)}else{o.push(e[t])}}));return pd(o,"float32")}else{return null}}function bk(t,n){return tc(t,n)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const gk=32;function wk(t,n){let e;let s;const o=n;e=o["xs"];s=o["ys"];m(e!=null&&s!=null,(()=>"A Dataset iterator for fitDataset() is expected to generate "+"objects of the form `{xs: xVal, ys: yVal}`, where the two "+"values may be `tf.Tensor`, an array of Tensors, or a map of "+"string to Tensor.  The provided Dataset instead generates "+`${n}`));const r=vk("input",t.inputNames,e);const i=vk("output",t.outputNames,s);const c=r[0].shape[0];m(r.length===t.inputs.length,(()=>`LayersModel has ${t.inputs.length} inputs, but the dataset `+`provides ${r.length} inputs.  (Expected input keys: `+`${JSON.stringify(t.inputNames)})`));m(i.length===t.outputs.length,(()=>`LayersModel has ${t.outputs.length} outputs, but the dataset `+`provides ${i.length} outputs.  (Expected output keys: `+`${JSON.stringify(t.outputNames)})`));for(let n=0;n<r.length;n++){m(r[n].shape[0]===c,(()=>`Batch size mismatch: input `+`${t.inputNames[n]} has ${r[n].shape[0]}; `+`expected  ${c} based on input ${t.inputNames[0]}.`))}for(let n=0;n<i.length;n++){m(i[n].shape[0]===c,(()=>`Batch size mismatch: output `+`${t.outputNames[n]} has ${i[n].shape[0]}; `+`expected  ${c} based on input ${t.inputNames[0]}.`))}return{xs:r,ys:i}}function vk(t,n,e){if(e instanceof Qo){return[e]}else if(Array.isArray(e)){m(e.length===n.length,(()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`));return e}else{const s=[];for(const o of n){if(e[o]==null){throw new gw(`The feature data generated by the dataset lacks the required `+`${t} key '${o}'.`)}s.push(e[o])}return s}}function $k(t){if(t.length===3){throw new ww("Validation with sample weights is not implemented yet.")}return{xs:t[0],ys:t[1]}}async function yk(t,n,e){const s=e.batchesPerEpoch!=null;m(t.optimizer!=null,(()=>"You must compile a model before training/testing. Use "+"LayersModel.compile(modelCompileConfig)."));m(e!=null,(()=>`For fitDataset(), the 2nd argument (config) is required, `+`but it is not provided in this call.`));m(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive `+`integer, but got ${e.epochs}`));m(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a `+`positive integer if specified, but got ${e.batchesPerEpoch}`));m(e["validationSplit"]==null,(()=>"`validationSplit` is not supported by `fitDataset()`. "+"Use validationData instead."));if(t.isTraining){throw new Error("Cannot start training because another fit() call is ongoing.")}t.isTraining=true;try{const o=e.validationData!=null;let r;let i;if(o){if(Ck(e.validationData)){m(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),(()=>`For fitDataset() with dataset-based validation, `+`config.validationBatches is expected not to be provided, `+`or to be a positive integer, `+`but got ${e.validationBatches}`))}else{const t=$k(e.validationData);r=t.xs;i=t.ys}}const c=t.makeTrainFunction();const a=t.getDedupedMetricsNames();let u;if(o){u=a.slice().concat(a.map((t=>"val_"+t)))}else{u=a.slice()}const l=fy(e.callbacks,e.yieldEvery);const f=e.verbose==null?1:e.verbose;const{callbackList:h,history:d}=dy(l,f,e.epochs,null,null,kk(n,e),null,o,u);h.setModel(t);t.history=d;await h.onTrainBegin();t.stopTraining_=false;let p=e.initialEpoch==null?0:e.initialEpoch;let x=await n.iterator();while(p<e.epochs){const u={};await h.onEpochBegin(p);let l=0;let f=0;if(!s){x=await n.iterator()}while(s?l<e.batchesPerEpoch:true){const n=await x.next();if(s&&n.done){console.warn("You provided `batchesPerEpoch` as "+`${e.batchesPerEpoch}, `+"but your dataset iterator ran out of data after "+`${l} batches; `+"interrupting training. Make sure that your "+"dataset can generate at least `batchesPerEpoch * epochs` "+"batches (in this case, "+`${e.batchesPerEpoch*e.epochs} batches). `+"You may need to use the repeat() function when building "+"your dataset.");break}if(n.value!=null){const{xs:s,ys:o}=wk(t,n.value);const r={};r["batch"]=f;r["size"]=s[0].shape[0];await h.onBatchBegin(f,r);const i=[];if(e.classWeight!=null){const n=mk(e.classWeight,t.outputNames);for(let t=0;t<n.length;++t){i.push(await xk(o[t],null,n[t]))}}const u=s.concat(o).concat(i);const d=c(u);Gi(u);for(let t=0;t<a.length;++t){const n=a[t];const e=d[t];r[n]=e;Ui(e)}await h.onBatchEnd(f,r);sy(r);f++;l++}if(s?l>=e.batchesPerEpoch:n.done){if(o){let n;if(Ck(e.validationData)){n=Rw(await t.evaluateDataset(e.validationData,{batches:e.validationBatches}))}else{n=Rw(t.evaluate(r,i,{batchSize:e.validationBatchSize==null?gk:e.validationBatchSize,verbose:0}))}for(let e=0;e<t.metricsNames.length;++e){u[`val_${t.metricsNames[e]}`]=n[e]}}break}if(t.stopTraining_){break}}await h.onEpochEnd(p,u);p++;if(t.stopTraining_){break}}await h.onTrainEnd();await t.history.syncData();return t.history}finally{t.isTraining=false}}function kk(t,n){let e=null;if(n.batchesPerEpoch!=null){e=n.batchesPerEpoch}else if(Number.isFinite(t.size)){e=t.size}return e}function Ck(t){return typeof t.iterator==="function"}function Nk(t){return typeof t.next==="function"}async function Rk(t,n,e){e=e||{};const s=e.batches!=null;const o=t.testFunction;let r=[];if(e.verbose>0){throw new ww("Verbose mode is not implemented yet.")}m(!s||e.batches>0&&Number.isInteger(e.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+`received ${JSON.stringify(e.batches)}`));const i=Nk(n)?n:await n.iterator();let c=0;let a=0;while(s?a<e.batches:true){const n=await i.next();r=Wi((()=>{if(n.value){const{xs:e,ys:s}=wk(t,n.value);const i=e.concat(s);const u=Wi((()=>o(i)));Gi(i);if(a===0){for(let t=0;t<u.length;++t){r.push(Gu(0))}}const l=i[0].shape[0];for(let t=0;t<u.length;++t){const n=u[t];const e=r[t];r[t]=Wi((()=>Xi(r[t],tc(l,n))));if(a>0){Gi(e)}}Gi(u);c+=l;++a}return r}));if(n.done){if(s){console.warn("Your dataset iterator ran out of data during evaluateDataset(). "+"Interrupting evalution. Make sure that your "+"dataset can generate at least `batches` "+`batches (in this case, ${e.batches} batches). `+"You may need to use the repeat() function when building "+"your dataset.")}break}}for(let t=0;t<r.length;++t){const n=r[t];r[t]=Zi(r[t],c);Gi(n)}return Nw(r)}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Sk(t){m(t>0&&Number.isInteger(t),(()=>`batchSize is required to be a positive integer, but got ${t}`))}function Ek(t,n,e){if(t==null){return[null]}else if(Array.isArray(t)){return t.map((t=>Cv(t,n,e-n)))}else{return Cv(t,n,e-n)}}function Tk(t,n){return Wi((()=>{if(t==null){return null}else if(Array.isArray(t)){return t.map((t=>Tk(t,n)))}else{return Ov(t,n.dtype==="int32"?n:Mi(n,"int32"))}}))}function Ik(t,n){const e=[];let s=0;let o=null;while(s<t){o=s+n;if(o>=t){o=t}e.push([s,o]);s=o}return e}function Ak(t){const n=[];if(t instanceof Qo){t=[t]}for(let e=0;e<t.length;++e){const s=t[e];if(s.rank===1){n.push(vv(s,1))}else if(s.rank===0){throw new Error("Expected tensor to be at least 1D, but received a 0D tensor "+"(scalar).")}else{n.push(s)}}return n}function Ok(t,n){if(t==null){return}const e=[];if(n instanceof Qo){e.push(n.id)}else if(Array.isArray(n)){n.forEach((t=>e.push(t.id)))}else if(n!=null){for(const t in n){const s=n[t];e.push(s.id)}}const s=[];if(t instanceof Qo){if(e.indexOf(t.id)===-1){s.push(t)}}else if(Array.isArray(t)){t.forEach((t=>{if(e.indexOf(t.id)===-1){s.push(t)}}))}else if(t!=null){for(const n in t){const o=t[n];if(e.indexOf(o.id)===-1){s.push(o)}}}s.forEach((t=>{if(!t.isDisposed){t.dispose()}}))}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fk(t){return t instanceof Qo}function _k(t){return Array.isArray(t)}function Mk(t){return!Fk(t)&&!_k(t)}function Dk(t,n,e,s=true,o=""){if(n==null||n.length===0){if(t!=null){let n=false;if(_k(t)&&t.length>0){n=true}else if(Mk(t)){for(const e in t){if(t.hasOwnProperty(e)){n=true;break}}}else{n=true}if(n){throw new gw(`Error when checking model ${o} expected no data, `+`but got ${t}`)}}return[]}if(t==null){return n.map((t=>null))}let r;if(Mk(t)){t=t;r=[];for(const e of n){if(t[e]==null){throw new gw(`No data provided for "${e}". Need data for each key in: `+`${n}`)}r.push(t[e])}}else if(_k(t)){t=t;if(t.length!==n.length){throw new gw(`Error when checking model ${o}: the Array of `+`Tensors that you are passing to your model is not the size the `+`model expected. Expected to see ${n.length} Tensor(s), but `+`instead got the following list of Tensor(s): ${t}`)}r=t}else{t=t;if(n.length>1){throw new gw(`The model ${o} expects ${n.length} Tensor(s), `+`but only received one Tensor. Found: Tensor with shape ${t.shape}`)}r=[t]}r=Ak(r);if(e!=null){for(let t=0;t<n.length;++t){if(e[t]==null){continue}const i=r[t];if(i.shape.length!==e[t].length){throw new gw(`Error when checking ${o}: expected ${n[t]} `+`to have ${e[t].length} dimension(s). but got array with `+`shape ${i.shape}`)}for(let n=0;n<e[t].length;++n){if(n===0&&!s){continue}const r=i.shape[n];const c=e[t][n];if(c!=null&&c>=0&&r!==c){throw new gw(`${o} expected a batch of elements where each `+`example has shape [${e[t].slice(1,e[t].length)}] `+`(i.e.,tensor shape [*,${e[t].slice(1,e[t].length)}])`+` but the ${o} received an input with ${i.shape[0]}`+` examples, each with shape [${i.shape.slice(1,i.shape.length)}]`+` (tensor shape [${i.shape}])`)}}}}return r}function Lk(t,n,e){const s=Mw(t.map((t=>t.shape[0])));s.sort();const o=Mw(n.map((t=>t.shape[0])));o.sort();if(s.length>1){throw new gw(`All input Tensors (x) should have the same number of samples. `+`Got array shapes: `+`${JSON.stringify(t.map((t=>t.shape)))}`)}if(o.length>1){throw new gw(`All target Tensors (y) should have the same number of samples. `+`Got array shapes: `+`${JSON.stringify(n.map((t=>t.shape)))}`)}if(s.length>0&&o.length>0&&!w(s,o)){throw new gw(`Input Tensors should have the same number of samples as target `+`Tensors. Found ${s[0]} input sample(s) and ${o[0]} target `+`sample(s).`)}}function zk(t,n,e){const s=[xy,Sy,Cy];for(let o=0;o<t.length;++o){const r=t[o];const i=n[o];const c=e[o];if(i==null){continue}if(i===Cy){if(r.shape[r.shape.length-1]===1){throw new gw(`You are passing a target array of shape ${r.shape} while using `+`a loss 'categorical_crossentropy'. 'categorical_crossentropy'`+`expects targets to be binary matrices (1s and 0s) of shape `+`[samples, classes].`)}}if(s.indexOf(i)!==-1){const t=r.shape.slice(1);const n=c.slice(1);for(let e=0;e<t.length;++e){const s=t[e];const o=n[e];if(o!=null&&s!==o){throw new gw(`A target Tensor with shape ${r.shape} was passed for an `+`output of shape ${c}, while using a loss function that `+`expects targets to have the same shape as the output.`)}}}}}function Pk(t,n,e,s=true,o=""){let r;if(Array.isArray(t)){if(t.length!==n.length){throw new gw(`Error when checking model ${o}: the Array of `+`Tensors that you are passing to your model is not the size the `+`the model expected. Expected to see ${n.length} Tensor(s),`+` but instead got ${t.length} Tensors(s).`)}r=t}else{if(n.length>1){throw new gw(`The model expects ${n.length} ${o} Tensors, `+`but only received one Tensor. Found: array with shape `+`${JSON.stringify(t.shape)}.`)}r=[t]}if(e!=null){for(let t=0;t<n.length;++t){if(e[t]==null){continue}const i=r[t];if(i.shape.length!==e[t].length){throw new gw(`Error when checking ${o}: expected ${n[t]} `+`to have ${e[t].length} dimension(s), but got array with `+`shape ${JSON.stringify(i.shape)}`)}for(let r=0;r<e[t].length;++r){if(r===0&&!s){continue}const c=i.shape[r];const a=e[t][r];if(a!=null){if(a!==c){throw new gw(`Error when checking ${o}: expected `+`${n[t]} to have shape ${JSON.stringify(e[t])} but `+`got array with shape ${JSON.stringify(i.shape)}.`)}}}}}}function Vk(t,n){if(t==null||Array.isArray(t)&&t.length===0){return n.map((t=>[]))}let e;if(typeof t==="string"||typeof t==="function"){e=[t]}else if(Array.isArray(t)||typeof t==="object"){e=t}else{throw new TypeError("Type of metrics argument not understood. Expected an string,"+`function, Array, or Object, found: ${t}`)}if(Array.isArray(e)){return n.map((t=>e))}else{const t=[];for(const s of n){let n=e.hasOwnProperty(s)?e[s]:[];if(!Array.isArray(n)){n=[n]}t.push(n)}return t}}const Bk="layers-model";class Wk extends dk{constructor(t){super(t);this.isTraining=false}summary(t,n,e=console.log){if(!this.built){throw new gw(`This model has never been called, thus its weights have not been `+`created yet. So no summary can be displayed. Build the model `+`first (e.g., by calling it on some test data).`)}ek(this,t,n,e)}compile(t){if(t.loss==null){t.loss=[]}this.loss=t.loss;if(typeof t.optimizer==="string"){this.optimizer_=Zy(t.optimizer);this.isOptimizerOwned=true}else{if(!(t.optimizer instanceof Qp)){throw new gw(`User-defined optimizer must be an instance of tf.Optimizer.`)}this.optimizer_=t.optimizer;this.isOptimizerOwned=false}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!=="string"&&typeof t.loss!=="function"){t.loss=t.loss;for(const n in t.loss){if(this.outputNames.indexOf(n)===-1){throw new gw(`Unknown entry in loss dictionary: "${n}". `+`Only expected the following keys: ${this.outputNames}`)}}for(const e of this.outputNames){if(t.loss[e]==null){console.warn(`Output "${e}" is missing from loss dictionary. We assume `+`this was done on purpose, and we will not be expecting data `+`to be passed to ${e} during training`)}n.push(Oy(t.loss[e]))}}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length){throw new gw(`When passing an Array as loss, it should have one entry per `+`model output. The model has ${this.outputs.length} output(s), `+`but you passed loss=${t.loss}.`)}const e=t.loss;n=e.map((t=>Oy(t)))}else{const e=Oy(t.loss);this.outputs.forEach((t=>{n.push(e)}))}this.lossFunctions=n;this.feedOutputNames=[];this.feedOutputShapes=[];this.feedLossFns=[];for(let t=0;t<this.outputs.length;++t){const n=this.internalOutputShapes[t];const e=this.outputNames[t];this.feedOutputNames.push(e);this.feedOutputShapes.push(n);this.feedLossFns.push(this.lossFunctions[t])}const e=[];this.metrics=t.metrics;this.metricsNames=["loss"];this.metricsTensors=[];rv("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(e.indexOf(t)!==-1){continue}const n=this.lossFunctions[t];if(this.outputs.length>1){this.metricsTensors.push([n,t]);this.metricsNames.push(this.outputNames[t]+"_loss")}}}));const s=Vk(t.metrics,this.outputNames);const o=(t,n,e)=>{if(this.outputNames.length>1){n=this.outputNames[t]+"_"+n}this.metricsNames.push(n);this.metricsTensors.push([e,t])};rv("metric",(()=>{for(let t=0;t<this.outputs.length;++t){if(e.indexOf(t)!==-1){continue}const n=s[t];const r=n=>{const e="";let s;let r;let i;for(const c of n){if(typeof c==="string"&&["accuracy","acc","crossentropy","ce"].indexOf(c)!==-1){const n=this.internalOutputShapes[t];if(n[n.length-1]===1||this.lossFunctions[t]===Sy){if(["accuracy","acc"].indexOf(c)!==-1){r=Fy}else if(["crossentropy","ce"].indexOf(c)!==-1){r=zy}}else if(this.lossFunctions[t]===Ny){if(["accuracy","acc"].indexOf(c)!==-1){r=Py}else if(["crossentropy","ce"].indexOf(c)!==-1){r=Xy}}else{if(["accuracy","acc"].indexOf(c)!==-1){r=_y}else if(["crossentropy","ce"].indexOf(c)!==-1){r=jy}}let o;if(["accuracy","acc"].indexOf(c)!==-1){o="acc"}else if(["crossentropy","ce"].indexOf(c)!==-1){o="ce"}i=r;s=e+o}else{const t=Jy(c);i=t;s=e+Yy(c)}let n;rv(s,(()=>{n=i}));o(t,s,n)}};r(n)}}));this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){if(this.collectedTrainableWeights==null){return}if(this.trainableWeights.length!==this.collectedTrainableWeights.length){console.warn("Discrepancy between trainableweights and collected trainable "+"weights. Did you set `model.trainable` without calling "+"`model.compile()` afterwards?")}}evaluate(t,n,e={}){const s=e.batchSize==null?32:e.batchSize;Sk(s);const o=true;const r=this.standardizeUserDataXY(t,n,o,s);try{const t=r[0].concat(r[1]);this.makeTestFunction();const n=this.testFunction;const o=this.testLoop(n,t,s,e.verbose,e.steps);return Nw(o)}finally{Ok(r[0],t);Ok(r[1],n)}}async evaluateDataset(t,n){this.makeTestFunction();return Rk(this,t,n)}checkNumSamples(t,n,e,s="steps"){let o;if(e!=null){o=null;if(n!=null){throw new gw(`If ${s} is set, batchSize must be null or undefined.`+`Got batchSize = ${n}`)}}else if(t!=null){if(Array.isArray(t)){o=t[0].shape[0]}else{o=t.shape[0]}}else{throw new gw(`Either the input data should have a defined shape, or `+`${s} shoud be specified.`)}return o}execute(t,n){if(Array.isArray(n)&&n.length===0){throw new gw("`outputs` is an empty Array, which is not allowed.")}const e=Array.isArray(n);const s=e?n:[n];const o=this.retrieveSymbolicTensors(s);const r=new D$;if(t instanceof Qo){t=[t]}if(Array.isArray(t)){if(t.length!==this.inputs.length){throw new gw(`The number of inputs provided (${t.length}) `+`does not match the number of inputs of this model `+`(${this.inputs.length}).`)}for(let n=0;n<this.inputs.length;++n){r.add(this.inputs[n],t[n])}}else{for(const n of this.inputs){const e=t[n.name];if(e==null){throw new gw(`No value is provided for the model's input ${n.name}`)}r.add(n,e)}}const i=V$(o,r);return e?i:i[0]}retrieveSymbolicTensors(t){const n=yw(null,t.length);let e=t.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output];const r=o.map((t=>t.name));for(let s=0;s<t.length;++s){const i=r.indexOf(t[s]);if(i!==-1){n[s]=o[i];e--}if(e===0){break}}if(e===0){break}}if(e>0){const e=[];n.forEach(((n,s)=>{if(n==null){e.push(t[s])}}));throw new gw(`Cannot find SymbolicTensors for output name(s): `+`${JSON.stringify(e)}`)}return n}predictLoop(t,n=32,e=false){return Wi((()=>{const s=this.checkNumSamples(t);if(e){throw new ww("Verbose predictLoop() is not implemented yet.")}const o=Ik(s,n);const r=this.outputs.map((t=>[]));for(let n=0;n<o.length;++n){const e=Wi((()=>{const e=o[n][0];const s=o[n][1];const r=Ek(t,e,s);const i=[];if(Array.isArray(r)){for(let t=0;t<r.length;++t){i.push({key:this.inputs[t],value:r[t]})}}else{i.push({key:this.inputs[0],value:r})}const c=new D$(i);return V$(this.outputs,c)}));e.forEach(((t,n)=>r[n].push(t)))}return Nw(r.map((t=>Yc(t,0))))}))}predict(t,n={}){const e=Ak(t);Pk(e,this.inputNames,this.feedInputShapes,false);try{const t=n.batchSize==null?32:n.batchSize;Sk(t);return this.predictLoop(e,t)}finally{Ok(e,t)}}predictOnBatch(t){Pk(t,this.inputNames,this.feedInputShapes,true);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,e=true,s){if(this.optimizer_==null){throw new bw("You must compile a model before training/testing. Use "+"LayersModel.compile(modelCompileArgs).")}const o=[];for(let t=0;t<this.feedOutputShapes.length;++t){const n=this.feedOutputShapes[t];const e=this.feedLossFns[t];if(e===Ny){o.push(n.slice(0,n.length-1).concat([1]))}else{o.push(n)}}t=Dk(t,this.feedInputNames,this.feedInputShapes,false,"input");n=Dk(n,this.feedOutputNames,o,false,"target");Lk(t,n);zk(n,this.feedLossFns,this.feedOutputShapes);if(this.stateful&&s!=null&&s>0){if(t[0].shape[0]%s!==0){throw new gw(`In a stateful network, you should only pass inputs with a `+`number of samples that is divisible by the batch size `+`${s}. Found: ${t[0].shape[0]} sample(s).`)}}return[t,n]}async standardizeUserData(t,n,e,s,o=true,r){const[i,c]=this.standardizeUserDataXY(t,n,o,r);if(e!=null){throw new Error("sample weight is not supported yet.")}let a=null;if(s!=null){const t=mk(s,this.outputNames);a=[];for(let n=0;n<t.length;++n){a.push(await xk(c[n],null,t[n]))}}return[i,c,a]}testLoop(t,n,e,s=0,o){return Wi((()=>{const r=this.checkNumSamples(n,e,o,"steps");const i=[];if(s>0){throw new ww("Verbose mode is not implemented yet.")}if(o!=null){throw new ww("steps mode in testLoop() is not implemented yet")}else{const s=Ik(r,e);const o=pd(mv(0,r));for(let e=0;e<s.length;++e){const r=s[e][0];const c=s[e][1];const a=Cv(o,r,c-r);const u=Tk(n,a);const l=t(u);if(e===0){for(let t=0;t<l.length;++t){i.push(Gu(0))}}for(let t=0;t<l.length;++t){const n=l[t];i[t]=Xi(i[t],tc(c-r,n))}}for(let t=0;t<i.length;++t){i[t]=Zi(i[t],r)}}return i}))}getDedupedMetricsNames(){const t=this.metricsNames;const n=[];for(let e=0;e<t.length;++e){const s=t[e];let o=s;if(Cw(t,s)>1){const n=Cw(t.slice(0,e),s);o+=`_${n}`}n.push(o)}return n}makeTrainFunction(){return t=>{const n=[];const e=t.slice(0,this.inputs.length);const s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length);const o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2);const r=[];const i=()=>{const t=[];for(let n=0;n<this.inputs.length;++n){t.push({key:this.inputs[n],value:e[n]})}const i=new D$(t);const c=V$(this.outputs,i,{training:true});let a;for(let t=0;t<this.lossFunctions.length;++t){const e=this.lossFunctions[t];let r=e(s[t],c[t]);if(o[t]!=null){r=bk(r,o[t])}const i=mf(r);n.push(i);if(t===0){a=r}else{a=Xi(a,r)}}for(let t=0;t<this.metricsTensors.length;++t){let e;if(this.outputs.length>1&&t<this.outputs.length){e=n[t]}else{const n=this.metricsTensors[t][0];const o=this.metricsTensors[t][1];e=mf(n(s[o],c[o]))}Ui(e);r.push(e)}a=mf(a);this.calculateLosses().forEach((t=>{a=Xi(a,t)}));return a};const c=this.collectedTrainableWeights.map((t=>t.read()));const a=true;const u=this.optimizer_.minimize(i,a,c);return[u].concat(r)}}makeTestFunction(){this.testFunction=t=>Wi((()=>{const n=[];let e;const s=t.slice(0,this.inputs.length);const o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length);const r=[];for(let t=0;t<this.inputs.length;++t){r.push({key:this.inputs[t],value:s[t]})}const i=new D$(r);const c=V$(this.outputs,i);for(let t=0;t<this.lossFunctions.length;++t){const s=this.lossFunctions[t];const r=mf(s(o[t],c[t]));if(t===0){e=r}else{e=Xi(e,r)}n.push(e)}for(let t=0;t<this.metricsTensors.length;++t){const e=this.metricsTensors[t][0];const s=this.metricsTensors[t][1];const r=mf(e(o[s],c[s]));n.push(r)}return n}))}async fit(t,n,e={}){if(this.isTraining){throw new Error("Cannot start training because another fit() call is ongoing.")}this.isTraining=true;let s;let o;let r;let i;let c;let a;let u;let l;let f;try{const h=e.batchSize==null?32:e.batchSize;Sk(h);const d=false;const p=await this.standardizeUserData(t,n,e.sampleWeight,e.classWeight,d,h);s=p[0];o=p[1];f=p[2];let m=false;let x;if(e.validationData!=null&&e.validationData.length>0){m=true;if(e.validationData.length===2){c=e.validationData[0];a=e.validationData[1]}else if(e.validationData.length===3){throw new ww("validationData including sample weights is not supported yet.")}else{throw new gw(`When passing validation data, it must contain 2 (valX, valY) `+`or 3 (valX, valY, valSampleWeight) items; `+`${e.validationData} is invalid.`)}const t=true;const n=await this.standardizeUserData(c,a,null,null,t,h);u=n[0];l=n[1];x=u.concat(l)}else if(e.validationSplit!=null&&e.validationSplit>0&&e.validationSplit<1){m=true;const t=Math.floor(s[0].shape[0]*(1-e.validationSplit));const n=s[0].shape[0];u=Ek(s,t,n);r=s;s=Ek(s,0,t);l=Ek(o,t,n);i=o;o=Ek(o,0,t);x=u.concat(l)}else if(e.validationSteps!=null){m=true}const b=s.concat(o).concat(f);this.checkTrainableWeightsConsistency();const g=this.makeTrainFunction();const w=this.getDedupedMetricsNames();let v;let $;if(m){this.makeTestFunction();v=this.testFunction;$=w.slice().concat(w.map((t=>"val_"+t)))}else{v=null;x=[];$=w.slice()}const y=fy(e.callbacks,e.yieldEvery);const k=await this.fitLoop(g,b,w,h,e.epochs,e.verbose,y,v,x,e.shuffle,$,e.initialEpoch,null,null);return k}finally{this.isTraining=false;Ok(s,t);Ok(o,n);Ok(r,t);Ok(i,n);Ok(u,c);Ok(l,a);if(f!=null){Gi(f)}}}async fitLoop(t,n,e,s,o,r,i,c,a,u,f,h,d,p){if(s==null){s=32}if(o==null){o=1}if(u==null){u=true}if(h==null){h=0}let m=false;if(c!=null&&a!=null){m=true}if(p!=null){m=true;if(d==null){throw new gw("Can only use `validationSteps` when doing step-wise training, "+"i.e., `stepsPerEpoch` must be set.")}}const x=this.checkNumSamples(n,s,d,"steps_per_epoch");let b;if(x!=null){b=mv(0,x)}if(r==null){r=1}const{callbackList:g,history:w}=dy(i,r,o,h,x,d,s,m,f);g.setModel(this);this.history=w;await g.onTrainBegin();this.stopTraining_=false;for(let r=h;r<o;++r){await g.onEpochBegin(r);const o={};if(d!=null){throw new ww("stepsPerEpoch mode is not implemented yet.")}else{if(u==="batch"){throw new ww("batch shuffling is not implemneted"+" yet")}else if(u){l(b)}const r=pd(b);const i=Ik(x,s);for(let u=0;u<i.length;++u){const l={};await g.onBatchBegin(u,l);Wi((()=>{const f=i[u][0];const h=i[u][1];const d=Cv(r,f,h-f);l["batch"]=u;l["size"]=h-f;const p=Tk(n,d);const x=t(p);for(let t=0;t<e.length;++t){const n=e[t];const s=x[t];l[n]=s;Ui(s)}if(u===i.length-1){if(m){const t=this.testLoop(c,a,s);for(let n=0;n<e.length;++n){const s=e[n];const r=t[n];Ui(r);o["val_"+s]=r}}}}));await g.onBatchEnd(u,l);sy(l);if(this.stopTraining_){break}}r.dispose()}await g.onEpochEnd(r,o);if(this.stopTraining_){break}}await g.onTrainEnd();await this.history.syncData();return this.history}async fitDataset(t,n){return yk(this,t,n)}async trainOnBatch(t,n){const e=await this.standardizeUserData(t,n);const s=e[0];const o=e[1];const r=this.makeTrainFunction();const i=r(s.concat(o));const c=[];for(const t of i){const n=await t.data();c.push(n[0])}Gi(i);Ok(e[0],t);Ok(e[1],n);return Nw(c)}getNamedWeights(t){const n=[];const e=t!=null&&t.trainableOnly;const s=e?this.trainableWeights:this.weights;const o=this.getWeights(e);for(let t=0;t<s.length;++t){if(e&&!s[t].trainable){continue}n.push({name:s[t].originalName,tensor:o[t]})}return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){if(this.optimizer_!==t){this.optimizer_=t;this.isOptimizerOwned=false}}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=Bi().numTensors;this.optimizer_.dispose();t.numDisposedVariables+=n-Bi().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss==="string"){t=Sw(this.loss)}else if(Array.isArray(this.loss)){for(const t of this.loss){if(typeof t!=="string"){throw new Error("Serialization of non-string loss is not supported.")}}t=this.loss.map((t=>Sw(t)))}else{const n=Object.keys(this.loss);t={};const e=this.loss;for(const s of n){if(typeof e[s]==="string"){t[s]=Sw(e[s])}else{throw new Error("Serialization of non-string loss is not supported.")}}}return t}getMetricIdentifiers(){if(typeof this.metrics==="string"||typeof this.metrics==="function"){return[Sw(Yy(this.metrics))]}else if(Array.isArray(this.metrics)){return this.metrics.map((t=>Sw(Yy(t))))}else{const t={};for(const n in this.metrics){t[n]=Sw(Yy(this.metrics[n]))}return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null){throw new Error("Loading weight_metrics is not supported yet.")}if(t.loss_weights!=null){throw new Error("Loading loss_weights is not supported yet.")}if(t.sample_weight_mode!=null){throw new Error("Loading sample_weight_mode is not supported yet.")}const n=uk(t.optimizer_config);const e=py(n);let s;if(typeof t.loss==="string"){s=Ew(t.loss)}else if(Array.isArray(t.loss)){s=t.loss.map((t=>Ew(t)))}else if(t.loss!=null){s={};for(const n in t.loss){s[n]=Ew(t.loss[n])}}let o;if(Array.isArray(t.metrics)){o=t.metrics.map((t=>Ew(t)))}else if(t.metrics!=null){o={};for(const n in t.metrics){o[n]=Ew(t.metrics[n])}}this.compile({loss:s,metrics:o,optimizer:e})}async save(t,n){if(typeof t==="string"){const n=ti(t);if(n.length===0){throw new gw(`Cannot find any save handlers for URL '${t}'`)}else if(n.length>1){throw new gw(`Found more than one (${n.length}) save handlers for `+`URL '${t}'`)}t=n[0]}if(t.save==null){throw new gw("LayersModel.save() cannot proceed because the IOHandler "+"provided does not have the `save` attribute defined.")}const e=await Br(this.getNamedWeights(n));const s=false;const o=null;const r=this.toJSON(o,s);const i={modelTopology:r,format:Bk,generatedBy:`TensorFlow.js tfjs-layers v${fk}`,convertedBy:null};const c=n==null?false:n.includeOptimizer;if(c&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const t="optimizer";const{data:n,specs:s}=await Br(await this.optimizer.getWeights(),t);e.specs.push(...s);e.data=qr([e.data,n])}if(this.userDefinedMetadata!=null){const t=true;tk(this.userDefinedMetadata,this.name,t);i.userDefinedMetadata=this.userDefinedMetadata}i.weightData=e.data;i.weightSpecs=e.specs;return t.save(i)}setUserDefinedMetadata(t){tk(t,this.name);this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Wk.className="Model";Zp(Wk);class Gk extends Wk{}Gk.className="Functional";Zp(Gk);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Uk extends Wk{constructor(t){super({inputs:[],outputs:[]});t=t||{};this.trainable=true;this.built=false;this.name=t.name!=null?t.name:jw("sequential_");if(t.layers!=null){for(const n of t.layers){this.add(n)}}}checkShape(t){const n=t.inboundNodes[0].outputTensors[0].shape;if(n.some((t=>t<0))){throw new gw("Negative dimension size caused by adding layer "+`${t.name} with input shape [`+`${t.inboundNodes[0].inputTensors[0].shape}]`)}}add(t){const n=t instanceof Uk||t instanceof Wk;let e;if(n){e=t;if(e.outputs.length!==1){throw new gw("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}if(e.inputs.length!==1){throw new gw("All layers in a Sequential model "+"should have a single input tensor. "+"For multi-input layers, "+"use the functional API.")}}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null){throw new gw("The first layer in a Sequential model must "+"get an `inputShape` or `batchInputShape` argument.")}const n=_$({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(n)}if(n){this.outputs=e.outputs;this.inputs=e.inputs}else{if(t.inboundNodes.length!==1){throw new gw("A layer added to a Sequential model must not already be "+`connected somewhere else. LayersModel received layer ${t.name} `+`which has ${t.inboundNodes.length} pre-existing inbound `+"connections.")}if(t.inboundNodes[0].outputTensors.length!==1){throw new gw("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}this.checkShape(t);this.outputs=[t.inboundNodes[0].outputTensors[0]];this.inputs=I$(this.outputs[0])}this.inboundNodes=[];new N$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:yw(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const n=t.apply(this.outputs[0]);if(Array.isArray(n)){throw new TypeError("All layers in a Sequential model "+"should have a single output tensor. "+"For multi-output layers, "+"use the functional API.")}this.checkShape(t);this.outputs=[n];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t);this.built=false}pop(){if(this.layers.length===0){throw new TypeError("There are no layers in the model.")}this.layers.pop();if(this.layers.length===0){this.outputs=[];this.inboundNodes=[];this.outboundNodes=[]}else{const t=this.layers.length-1;this.layers[t].outboundNodes=[];this.outputs=[this.layers[t].output];this.inboundNodes[0].outputTensors=this.outputs;this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){if(this.model==null){this.build()}return this.model.call(t,n)}build(t){m$(t);if(this.inputs.length===0||this.outputs.length===0){throw new TypeError("Sequential model cannot be built: model is empty."+" Add some layers first.")}this.model=new Wk({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"});this.model.trainable=this.trainable;this.supportsMasking=this.model.supportsMasking;this.inputLayers=this.model.inputLayers;this.inputLayersNodeIndices=this.model.inputLayersNodeIndices;this.inputLayersTensorIndices=this.model.inputLayersTensorIndices;this.outputLayers=this.model.outputLayers;this.outputLayersNodeIndices=this.model.outputLayersNodeIndices;this.outputLayersTensorIndices=this.model.outputLayersTensorIndices;this.nodesByDepth=this.model.nodesByDepth;this.containerNodes=this.model.containerNodes;this.outputNames=this.model.outputNames;this.inputNames=this.model.inputNames;this.built=true}countParams(){if(!this.built){this.build()}return super.countParams()}summary(t,n,e=console.log){if(!this.built){this.build()}super.summary(t,n,e)}setWeights(t){if(this.model==null){this.build()}this.model.setWeights(t)}evaluate(t,n,e={}){if(!this.built){throw new bw("The model needs to be compiled before being used.")}return this.model.evaluate(t,n,e)}async evaluateDataset(t,n){if(!this.built){throw new bw("The model needs to be compiled before being used.")}return this.model.evaluateDataset(t,n)}predict(t,n={}){if(this.model==null){this.build()}return this.model.predict(t,n)}predictOnBatch(t){if(this.model==null){this.build()}return this.model.predictOnBatch(t)}compile(t){this.build();this.model.compile(t);this.optimizer_=this.model.optimizer;this.isOptimizerOwned=this.model.isOptimizerOwned;this.loss=this.model.loss;this.metrics=this.model.metrics;this.metricsTensors=this.model.metricsTensors;this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?undefined:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,e={}){if(!this.built){throw new bw("The model needs to be compiled before "+"being used.")}return this.model.fit(t,n,e)}async fitDataset(t,n){if(!this.built){throw new bw("The model needs to be compiled before "+"being used.")}return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,e={},s=false){let o;let r={};if(n instanceof Array){if(!(n[0].className!=null)||n[0]["className"]==="Merge"){throw new gw("Legacy serialization format not supported yet.")}o=n}else{m(n["layers"]!=null,(()=>`When the config data for a Sequential model is not an Array, `+`it must be an Object that contains the 'layers' field.`));o=n["layers"];delete n["layers"];r=n}const i=new t(r);if(!(i instanceof Uk)){throw new ww(`Sequential.fromConfig called on non-Sequential input: ${i}`)}for(const t of o){const n=undefined;const e=py(t,n,s);if(s){e.setFastWeightInitDuringBuild(true)}i.add(e)}return i}set stopTraining(t){if(this.model==null){throw new gw("Cannot set the stopTraining property of a sequential model before "+"it is compiled.")}this.model.stopTraining=t}get stopTraining(){if(this.model==null){throw new gw("Cannot get the stopTraining property of a sequential model before "+"it is compiled.")}return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const e={};e["className"]=n.getClassName();e["config"]=n.getConfig();t.push(e)}return{name:this.name,layers:t}}}Uk.className="Sequential";Zp(Uk);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Hk extends Jp{getConfig(){return{}}}class jk extends Hk{apply(t,n=1){return Dv(t,n)}}jk.className="elu";Zp(jk);class qk extends Hk{apply(t){return Sh(t)}}qk.className="selu";Zp(qk);class Xk extends Hk{apply(t){return bh(t)}}Xk.className="relu";Zp(Xk);class Kk extends Hk{apply(t){return Wi((()=>wf(6,bh(t))))}}Kk.className="relu6";Zp(Kk);class Jk extends Hk{apply(t){return t}}Jk.className="linear";Zp(Jk);class Yk extends Hk{apply(t){return na(t)}}Yk.className="sigmoid";Zp(Yk);class Zk extends Hk{apply(t){return Pv(t)}}Zk.className="hardSigmoid";Zp(Zk);class Qk extends Hk{apply(t){return Ul(t)}}Qk.className="softplus";Zp(Qk);class tC extends Hk{apply(t){return Lv(t)}}tC.className="softsign";Zp(tC);class nC extends Hk{apply(t){return ra(t)}}nC.className="tanh";Zp(nC);class eC extends Hk{apply(t,n=-1){return Hh(t,n)}}eC.className="softmax";Zp(eC);class sC extends Hk{apply(t,n=-1){return Jl(t,n)}}sC.className="logSoftmax";Zp(sC);class oC extends Hk{apply(t,n=1){return Wi((()=>tc(na(tc(t,n)),t)))}}oC.className="swish";Zp(oC);class rC extends Hk{apply(t){return Wi((()=>tc(t,ra(Ul(t)))))}}rC.className="mish";Zp(rC);function iC(t){return t.getClassName()}function cC(t,n={}){return Ow(t,Yp.getMap().classNameMap,n,"activation")}function aC(t){if(t==null){const t={};t["className"]="linear";t["config"]={};return cC(t)}if(typeof t==="string"){const n={};n["className"]=t;n["config"]={};return cC(n)}else if(t instanceof Hk){return t}else{return cC(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uC(t){if(t!=null&&typeof t!=="object"){throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an `+`object, but received: ${t}`)}}class lC extends Jp{}class fC extends lC{constructor(t){super();uC(t);this.l1=t==null||t.l1==null?.01:t.l1;this.l2=t==null||t.l2==null?.01:t.l2;this.hasL1=this.l1!==0;this.hasL2=this.l2!==0}apply(t){return Wi((()=>{let n=xf([1]);if(this.hasL1){n=Xi(n,Ku(tc(this.l1,ec(t))))}if(this.hasL2){n=Xi(n,Ku(tc(this.l2,Fv(t))))}return Hc(n,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n["l1"],l2:n["l2"]})}}fC.className="L1L2";Zp(fC);const hC={l1l2:"L1L2"};function dC(t){return Iw(t)}function pC(t,n={}){return Ow(t,Yp.getMap().classNameMap,n,"regularizer")}function mC(t){if(t==null){return null}if(typeof t==="string"){const n=t in hC?hC[t]:t;const e={className:n,config:{}};return pC(e)}else if(t instanceof lC){return t}else{return pC(t)}}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xC extends S${constructor(t){super(t==null?{}:t);this.supportsMasking=true;if(t!=null){this.maxValue=t.maxValue}}call(t,n){t=p$(t);let e=bh(t);if(this.maxValue!=null){e=Na(e,0,this.maxValue)}return e}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue};const n=super.getConfig();Object.assign(t,n);return t}}xC.className="ReLU";Zp(xC);class bC extends S${constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3;if(t==null){t={}}this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const e=p$(t);return El(e,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha};const n=super.getConfig();Object.assign(t,n);return t}}bC.className="LeakyReLU";Zp(bC);class gC extends S${constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA_INITIALIZER="zeros";if(t==null){t={}}this.supportsMasking=true;this.alphaInitializer=f$(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER);this.alphaRegularizer=mC(t.alphaRegularizer);this.alphaConstraint=ny(t.alphaConstraint);if(t.sharedAxes==null){this.sharedAxes=null}else if(Array.isArray(t.sharedAxes)){this.sharedAxes=t.sharedAxes}else if(typeof t.sharedAxes==="number"){this.sharedAxes=[t.sharedAxes]}else{throw new gw(`Expected sharedAxes to be a number or an array of numbers, `+`but got ${t.sharedAxes}`)}}build(t){t=m$(t);const n=t.slice(1);if(this.sharedAxes!=null){for(const t of this.sharedAxes){n[t-1]=1}}this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,true,this.alphaConstraint);const e={};if(this.sharedAxes!=null){for(let n=1;n<t.length;++n){e[n]=t[n]}}this.inputSpec=[new y$({ndim:t.length,axes:e})];this.built=true}call(t,n){t=p$(t);return Bf(t,this.alpha.read())}getConfig(){const t={alphaInitializer:l$(this.alphaInitializer),alphaRegularizer:dC(this.alphaRegularizer),alphaConstraint:Q$(this.alphaConstraint),sharedAxes:this.sharedAxes};const n=super.getConfig();Object.assign(t,n);return t}}gC.className="PReLU";Zp(gC);class wC extends S${constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=1;if(t==null){t={}}if(t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA){throw new ww(`Non-default alpha value (${t.alpha}) is not supported by the `+`ELU layer yet.`)}this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const e=p$(t);return Ru(e)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha};const n=super.getConfig();Object.assign(t,n);return t}}wC.className="ELU";Zp(wC);class vC extends S${constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1;if(t==null){t={}}this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const e=p$(t);return tc(e,Mi(xl(e,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta};const n=super.getConfig();Object.assign(t,n);return t}}vC.className="ThresholdedReLU";Zp(vC);class $C extends S${constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1;if(t==null){t={}}this.softmax=(new eC).apply;this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return Wi((()=>{let e=p$(t);const s=n["mask"];if(s!=null){const t=tc(Xl(bf(e.shape),Mi(s,e.dtype)),Gu(-1e9));e=Xi(e,t)}if(this.axis instanceof Array){if(this.axis.length>1){return el(Xl(e,Zl(e,this.axis,true)))}else{return this.softmax(e,this.axis[0])}}return this.softmax(e,this.axis)}))}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis};const n=super.getConfig();Object.assign(t,n);return t}}$C.className="Softmax";Zp($C);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yC(t,n,e){if(typeof t==="number"){return yw(t,n)}else{if(t.length!==n){throw new gw(`The ${e} argument must be an integer or tuple of ${n} integers.`+` Received: ${t.length} elements.`)}for(let s=0;s<n;++s){const o=t[s];if(!fv(o)){throw new gw(`The ${e} argument must be an integer or tuple of ${n}`+` integers. Received: ${JSON.stringify(t)} including a`+` non-integer number ${o}`)}}return t}}function kC(t,n,e,s,o=1){if(t==null){return t}const r=n+(n-1)*(o-1);let i;if(e==="same"){i=t}else{i=t-r+1}return Math.floor((i+s-1)/s)}function CC(t,n,e,s){if(t==null){return null}if(s==="valid"){t=t*n+pv([e-n,0])}else if(s==="same"){t=t*n}else{throw new gw(`Unsupport padding mode: ${s}.`)}return t}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function NC(t,n){return Wi((()=>{Qw(n);if(n==="channelsFirst"){return Od(t,[0,2,3,1])}else{return t}}))}function RC(t,n){return Wi((()=>{Qw(n);if(n==="channelsFirst"){return Od(t,[0,2,3,4,1])}else{return t}}))}function SC(t,n,e,s=1,o="valid",r,i=1){return Wi((()=>{if(r==null){r=gv()}Qw(r);if(t.shape.length!==3){throw new gw(`The input of a conv1dWithBias operation should be 3, but is `+`${t.shape.length} instead.`)}if(n.shape.length!==3){throw new gw(`The kernel for a conv1dWithBias operation should be 3, but is `+`${n.shape.length} instead`)}if(e!=null&&e.shape.length!==1){throw new gw(`The bias for a conv1dWithBias operation should be 1, but is `+`${n.shape.length} instead`)}if(r==="channelsFirst"){t=Od(t,[0,2,1])}if(o==="causal"){throw new ww("The support for CAUSAL padding mode in conv1dWithBias is not "+"implemented yet.")}let c=La(t,n,s,o==="same"?"same":"valid","NWC",i);if(e!=null){c=Mv(c,e)}return c}))}function EC(t,n,e,s=[1,1],o="valid",r,i,c=null){return Wi((()=>{if(r==null){r=gv()}Qw(r);if(t.rank!==3&&t.rank!==4){throw new gw(`conv2dWithBiasActivation expects input to be of rank 3 or 4, `+`but received ${t.rank}.`)}if(n.rank!==3&&n.rank!==4){throw new gw(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, `+`but received ${t.rank}.`)}let a=NC(t,r);if(o==="causal"){throw new ww("The support for CAUSAL padding mode in conv1dWithBias is not "+"implemented yet.")}a=Gd({x:a,filter:n,strides:s,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:c});if(r==="channelsFirst"){a=Od(a,[0,3,1,2])}return a}))}function TC(t,n,e,s=[1,1,1],o="valid",r,i){return Wi((()=>{if(r==null){r=gv()}Qw(r);if(t.rank!==4&&t.rank!==5){throw new gw(`conv3dWithBias expects input to be of rank 4 or 5, but received `+`${t.rank}.`)}if(n.rank!==4&&n.rank!==5){throw new gw(`conv3dWithBias expects kernel to be of rank 4 or 5, but received `+`${t.rank}.`)}let c=RC(t,r);if(o==="causal"){throw new ww("The support for CAUSAL padding mode in conv3dWithBias is not "+"implemented yet.")}c=Ga(c,n,s,o==="same"?"same":"valid","NDHWC",i);if(e!=null){c=Mv(c,e)}if(r==="channelsFirst"){c=Od(c,[0,4,1,2,3])}return c}))}class IC extends S${constructor(t,n){super(n);this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";IC.verifyArgs(n);this.rank=t;Pw(this.rank,"rank");if(this.rank!==1&&this.rank!==2&&this.rank!==3){throw new ww(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is `+`not implemented yet.`)}this.kernelSize=yC(n.kernelSize,t,"kernelSize");this.strides=yC(n.strides==null?1:n.strides,t,"strides");this.padding=n.padding==null?"valid":n.padding;nv(this.padding);this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat;Qw(this.dataFormat);this.activation=aC(n.activation);this.useBias=n.useBias==null?true:n.useBias;this.biasInitializer=f$(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.biasConstraint=ny(n.biasConstraint);this.biasRegularizer=mC(n.biasRegularizer);this.activityRegularizer=mC(n.activityRegularizer);this.dilationRate=yC(n.dilationRate==null?1:n.dilationRate,t,"dilationRate");if(this.rank===1&&(Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)){throw new gw(`dilationRate must be a number or an array of a single number `+`for 1D convolution, but received `+`${JSON.stringify(this.dilationRate)}`)}else if(this.rank===2){if(typeof this.dilationRate==="number"){this.dilationRate=[this.dilationRate,this.dilationRate]}else if(this.dilationRate.length!==2){throw new gw(`dilationRate must be a number or array of two numbers for 2D `+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}}else if(this.rank===3){if(typeof this.dilationRate==="number"){this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate]}else if(this.dilationRate.length!==3){throw new gw(`dilationRate must be a number or array of three numbers for 3D `+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}}}static verifyArgs(t){kw("kernelSize"in t,`required key 'kernelSize' not in config`);if(typeof t.kernelSize!=="number"&&!zw(t.kernelSize,"number",1,3)){throw new gw(`BaseConv expects config.kernelSize to be number or number[] with `+`length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:iC(this.activation),useBias:this.useBias,biasInitializer:l$(this.biasInitializer),biasRegularizer:dC(this.biasRegularizer),activityRegularizer:dC(this.activityRegularizer),biasConstraint:Q$(this.biasConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}class AC extends IC{constructor(t,n){super(t,n);this.kernel=null;AC.verifyArgs(n);this.filters=n.filters;Pw(this.filters,"filters");this.kernelInitializer=f$(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.kernelConstraint=ny(n.kernelConstraint);this.kernelRegularizer=mC(n.kernelRegularizer)}build(t){t=m$(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new gw(`The channel dimension of the input should be defined. `+`Found ${t[n]}`)}const e=t[n];const s=this.kernelSize.concat([e,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[{ndim:this.rank+2,axes:{[n]:e}}];this.built=true}call(t,n){return Wi((()=>{t=p$(t);let n;const e=this.bias==null?null:this.bias.read();const s=Ww(this.activation.getClassName());if(s!=null&&this.rank===2){n=EC(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate,s)}else{if(this.rank===1){n=SC(t,this.kernel.read(),e,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0])}else if(this.rank===2){n=EC(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate)}else if(this.rank===3){n=TC(t,this.kernel.read(),e,this.strides,this.padding,this.dataFormat,this.dilationRate)}else{throw new ww("convolutions greater than 3D are not implemented yet.")}if(this.activation!=null){n=this.activation.apply(n)}}return n}))}computeOutputShape(t){t=m$(t);const n=[];const e=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<e.length;++t){const s=kC(e[t],this.kernelSize[t],this.padding,this.strides[t],typeof this.dilationRate==="number"?this.dilationRate:this.dilationRate[t]);n.push(s)}let s=[t[0]];if(this.dataFormat==="channelsLast"){s=s.concat(n);s.push(this.filters)}else{s.push(this.filters);s=s.concat(n)}return s}getConfig(){const t={filters:this.filters,kernelInitializer:l$(this.kernelInitializer),kernelRegularizer:dC(this.kernelRegularizer),kernelConstraint:Q$(this.kernelConstraint)};const n=super.getConfig();Object.assign(t,n);return t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!=="number"||t.filters<1){throw new gw(`Convolution layer expected config.filters to be a 'number' > 0 `+`but got ${JSON.stringify(t.filters)}`)}}}class OC extends AC{constructor(t){super(2,t);OC.verifyArgs(t)}getConfig(){const t=super.getConfig();delete t["rank"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"&&!zw(t.kernelSize,"number",1,2)){throw new gw(`Conv2D expects config.kernelSize to be number or number[] with `+`length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}}OC.className="Conv2D";Zp(OC);class FC extends AC{constructor(t){super(3,t);FC.verifyArgs(t)}getConfig(){const t=super.getConfig();delete t["rank"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"){if(!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3))){throw new gw(`Conv3D expects config.kernelSize to be number or`+` [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}}}FC.className="Conv3D";Zp(FC);class _C extends OC{constructor(t){super(t);this.inputSpec=[new y$({ndim:4})];if(this.padding!=="same"&&this.padding!=="valid"){throw new gw(`Conv2DTranspose currently supports only padding modes 'same' `+`and 'valid', but received padding mode ${this.padding}`)}}build(t){t=m$(t);if(t.length!==4){throw new gw("Input should have rank 4; Received input shape: "+JSON.stringify(t))}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new gw("The channel dimension of the inputs should be defined. "+"Found `None`.")}const e=t[n];const s=this.kernelSize.concat([this.filters,e]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[new y$({ndim:4,axes:{[n]:e}})];this.built=true}call(t,n){return Wi((()=>{let n=p$(t);if(n.shape.length!==4){throw new gw(`Conv2DTranspose.call() expects input tensor to be rank-4, but `+`received a tensor of rank-${n.shape.length}`)}const e=n.shape;const s=e[0];let o;let r;if(this.dataFormat==="channelsFirst"){o=2;r=3}else{o=1;r=2}const i=e[o];const c=e[r];const a=this.kernelSize[0];const u=this.kernelSize[1];const l=this.strides[0];const f=this.strides[1];const h=CC(i,l,a,this.padding);const d=CC(c,f,u,this.padding);const p=[s,h,d,this.filters];if(this.dataFormat!=="channelsLast"){n=Od(n,[0,2,3,1])}let m=Ba(n,this.kernel.read(),p,this.strides,this.padding);if(this.dataFormat!=="channelsLast"){m=Od(m,[0,3,1,2])}if(this.bias!=null){m=Mv(m,this.bias.read(),this.dataFormat)}if(this.activation!=null){m=this.activation.apply(m)}return m}))}computeOutputShape(t){t=m$(t);const n=t.slice();let e;let s;let o;if(this.dataFormat==="channelsFirst"){e=1;s=2;o=3}else{e=3;s=1;o=2}const r=this.kernelSize[0];const i=this.kernelSize[1];const c=this.strides[0];const a=this.strides[1];n[e]=this.filters;n[s]=CC(n[s],c,r,this.padding);n[o]=CC(n[o],a,i,this.padding);return n}getConfig(){const t=super.getConfig();delete t["dilationRate"];return t}}_C.className="Conv2DTranspose";Zp(_C);class MC extends FC{constructor(t){super(t);this.inputSpec=[new y$({ndim:5})];if(this.padding!=="same"&&this.padding!=="valid"){throw new gw(`Conv3DTranspose currently supports only padding modes 'same' `+`and 'valid', but received padding mode ${this.padding}`)}}build(t){t=m$(t);if(t.length!==5){throw new gw("Input should have rank 5; Received input shape: "+JSON.stringify(t))}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null){throw new gw("The channel dimension of the inputs should be defined. "+"Found `None`.")}const e=t[n];const s=this.kernelSize.concat([this.filters,e]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}this.inputSpec=[new y$({ndim:5,axes:{[n]:e}})];this.built=true}call(t,n){return Wi((()=>{let n=p$(t);if(n.shape.length!==5){throw new gw(`Conv3DTranspose.call() expects input tensor to be rank-4, but `+`received a tensor of rank-${n.shape.length}`)}const e=n.shape;const s=e[0];let o;let r;let i;if(this.dataFormat==="channelsFirst"){i=2;o=3;r=4}else{i=1;o=2;r=3}const c=e[i];const a=e[o];const u=e[r];const l=this.kernelSize[0];const f=this.kernelSize[1];const h=this.kernelSize[2];const d=this.strides[0];const p=this.strides[1];const m=this.strides[2];const x=CC(c,d,l,this.padding);const b=CC(a,p,f,this.padding);const g=CC(u,m,h,this.padding);const w=[s,x,b,g,this.filters];if(this.dataFormat!=="channelsLast"){n=Od(n,[0,2,3,4,1])}let v=qa(n,this.kernel.read(),w,this.strides,this.padding);if(this.dataFormat!=="channelsLast"){v=Od(v,[0,4,1,2,3])}if(this.bias!==null){v=Mv(v,this.bias.read(),this.dataFormat)}if(this.activation!==null){v=this.activation.apply(v)}return v}))}computeOutputShape(t){t=m$(t);const n=t.slice();let e;let s;let o;let r;if(this.dataFormat==="channelsFirst"){e=1;s=2;o=3;r=4}else{e=4;s=1;o=2;r=3}const i=this.kernelSize[0];const c=this.kernelSize[1];const a=this.kernelSize[2];const u=this.strides[0];const l=this.strides[1];const f=this.strides[2];n[e]=this.filters;n[s]=CC(n[s],u,i,this.padding);n[o]=CC(n[o],l,c,this.padding);n[r]=CC(n[r],f,a,this.padding);return n}getConfig(){const t=super.getConfig();delete t["dilationRate"];return t}}MC.className="Conv3DTranspose";Zp(MC);class DC extends AC{constructor(t,n){super(t,n);this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";this.depthwiseKernel=null;this.pointwiseKernel=null;if(n.filters==null){throw new gw("The `filters` configuration field is required by SeparableConv, "+"but is unspecified.")}if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null){throw new gw("Fields kernelInitializer, kernelRegularizer and kernelConstraint "+"are invalid for SeparableConv2D. Use depthwiseInitializer, "+"depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, "+"pointwiseRegularizer and pointwiseConstraint instead.")}if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid"){throw new gw(`SeparableConv${this.rank}D supports only padding modes: `+`'same' and 'valid', but received ${JSON.stringify(n.padding)}`)}this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier;this.depthwiseInitializer=f$(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER);this.depthwiseRegularizer=mC(n.depthwiseRegularizer);this.depthwiseConstraint=ny(n.depthwiseConstraint);this.pointwiseInitializer=f$(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER);this.pointwiseRegularizer=mC(n.pointwiseRegularizer);this.pointwiseConstraint=ny(n.pointwiseConstraint)}build(t){t=m$(t);if(t.length<this.rank+2){throw new gw(`Inputs to SeparableConv${this.rank}D should have rank `+`${this.rank+2}, but received input shape: `+`${JSON.stringify(t)}`)}const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0){throw new gw(`The channel dimension of the inputs should be defined, `+`but found ${JSON.stringify(t[n])}`)}const e=t[n];const s=this.kernelSize.concat([e,this.depthMultiplier]);const o=[];for(let t=0;t<this.rank;++t){o.push(1)}o.push(e*this.depthMultiplier,this.filters);const r=true;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint);this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint)}else{this.bias=null}this.inputSpec=[new y$({ndim:this.rank+2,axes:{[n]:e}})];this.built=true}call(t,n){return Wi((()=>{t=p$(t);let n;if(this.rank===1){throw new ww("1D separable convolution is not implemented yet.")}else if(this.rank===2){if(this.dataFormat==="channelsFirst"){t=Od(t,[0,2,3,1])}n=Th(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")}if(this.useBias){n=Mv(n,this.bias.read(),this.dataFormat)}if(this.activation!=null){n=this.activation.apply(n)}if(this.dataFormat==="channelsFirst"){n=Od(n,[0,3,1,2])}return n}))}getConfig(){const t=super.getConfig();delete t["rank"];delete t["kernelInitializer"];delete t["kernelRegularizer"];delete t["kernelConstraint"];t["depthwiseInitializer"]=l$(this.depthwiseInitializer);t["pointwiseInitializer"]=l$(this.pointwiseInitializer);t["depthwiseRegularizer"]=dC(this.depthwiseRegularizer);t["pointwiseRegularizer"]=dC(this.pointwiseRegularizer);t["depthwiseConstraint"]=Q$(this.depthwiseConstraint);t["pointwiseConstraint"]=Q$(this.pointwiseConstraint);return t}}DC.className="SeparableConv";class LC extends DC{constructor(t){super(2,t)}}LC.className="SeparableConv2D";Zp(LC);class zC extends AC{constructor(t){super(1,t);zC.verifyArgs(t);this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();delete t["rank"];delete t["dataFormat"];return t}static verifyArgs(t){if(typeof t.kernelSize!=="number"&&!zw(t.kernelSize,"number",1,1)){throw new gw(`Conv1D expects config.kernelSize to be number or number[] with `+`length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}}zC.className="Conv1D";Zp(zC);class PC extends S${constructor(t){super(t);if(typeof t.cropping==="number"){this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]}else if(typeof t.cropping[0]==="number"){this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]}else{this.cropping=t.cropping}this.dataFormat=t.dataFormat===undefined?"channelsLast":t.dataFormat;this.inputSpec=[{ndim:4}]}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){return[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]}else{return[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}}call(t,n){return Wi((()=>{t=p$(t);if(this.dataFormat==="channelsLast"){const n=Rv(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Rv(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const n=Rv(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Rv(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}PC.className="Cropping2D";Zp(PC);class VC extends S${constructor(t){super(t);this.DEFAULT_SIZE=[2,2];this.inputSpec=[{ndim:4}];this.size=t.size==null?this.DEFAULT_SIZE:t.size;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;Qw(this.dataFormat);this.interpolation=t.interpolation==null?"nearest":t.interpolation;tv(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2];const e=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,e]}else{const n=t[1]==null?null:this.size[0]*t[1];const e=t[2]==null?null:this.size[1]*t[2];return[t[0],n,e,t[3]]}}call(t,n){return Wi((()=>{let n=p$(t);const e=n.shape;if(this.dataFormat==="channelsFirst"){n=Od(n,[0,2,3,1]);const t=this.size[0]*e[2];const s=this.size[1]*e[3];const o=this.interpolation==="nearest"?jp.resizeNearestNeighbor(n,[t,s]):jp.resizeBilinear(n,[t,s]);return Od(o,[0,3,1,2])}else{const t=this.size[0]*e[1];const s=this.size[1]*e[2];return this.interpolation==="nearest"?jp.resizeNearestNeighbor(n,[t,s]):jp.resizeBilinear(n,[t,s])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation};const n=super.getConfig();Object.assign(t,n);return t}}VC.className="UpSampling2D";Zp(VC);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function BC(t,n,e=[1,1],s="valid",o,r){return Wi((()=>{if(o==null){o=gv()}Qw(o);let i=NC(t,o);if(t.rank!==4){throw new gw(`Input for depthwiseConv2d is required to be 4-D, but is instead `+`${t.rank}-D`)}if(n.rank!==4){throw new gw(`depthwiseKernel is required to be 4-D, but is instead `+`${n.rank}-D`)}i=cu(i,n,e,s==="same"?"same":"valid","NHWC",r);if(o==="channelsFirst"){i=Od(i,[0,3,1,2])}return i}))}class WC extends IC{constructor(t){super(2,t);this.depthwiseKernel=null;this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier;this.depthwiseInitializer=f$(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.depthwiseConstraint=ny(t.depthwiseConstraint);this.depthwiseRegularizer=mC(t.depthwiseRegularizer)}build(t){t=m$(t);if(t.length<4){throw new gw(`Inputs to DepthwiseConv2D should have rank 4. `+`Received input shape: ${JSON.stringify(t)}.`)}const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0){throw new gw("The channel dimension of the inputs to DepthwiseConv2D should "+`be defined, but is not (${t[n]}).`)}const e=t[n];const s=[this.kernelSize[0],this.kernelSize[1],e,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,true,this.depthwiseConstraint);if(this.useBias){this.bias=this.addWeight("bias",[e*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return Wi((()=>{t=p$(t);let n=BC(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);if(this.useBias){n=Mv(n,this.bias.read(),this.dataFormat)}if(this.activation!=null){n=this.activation.apply(n)}return n}))}computeOutputShape(t){t=m$(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1];const e=this.dataFormat==="channelsFirst"?t[3]:t[2];const s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier;const o=kC(n,this.kernelSize[0],this.padding,this.strides[0]);const r=kC(e,this.kernelSize[1],this.padding,this.strides[1]);if(this.dataFormat==="channelsFirst"){return[t[0],s,o,r]}else{return[t[0],o,r,s]}}getConfig(){const t=super.getConfig();t["depthMultiplier"]=this.depthMultiplier;t["depthwiseInitializer"]=l$(this.depthwiseInitializer);t["depthwiseRegularizer"]=dC(this.depthwiseRegularizer);t["depthwiseConstraint"]=Q$(this.depthwiseRegularizer);return t}}WC.className="DepthwiseConv2D";Zp(WC);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function GC(t,n,e,s){if(Array.isArray(t)){if(n!=null||e!=null){throw new gw("When inputs is an array, neither initialState or constants "+"should be provided")}if(s!=null){e=t.slice(t.length-s,t.length);t=t.slice(0,t.length-s)}if(t.length>1){n=t.slice(1,t.length)}t=t[0]}function o(t){if(t==null||Array.isArray(t)){return t}else{return[t]}}n=o(n);e=o(e);return{inputs:t,initialState:n,constants:e}}function UC(t,n,e,s=false,o,r,i=false,c=false){return Wi((()=>{const a=n.shape.length;if(a<3){throw new gw(`Input should be at least 3D, but is ${a}D.`)}const u=[1,0].concat(mv(2,a));n=Od(n,u);if(r!=null){throw new ww("The rnn() functoin of the deeplearn.js backend does not support "+"constants yet.")}if(i){console.warn("Backend rnn(): the unroll = true option is not applicable to the "+"imperative deeplearn.js backend.")}if(o!=null){o=Mi(Mi(o,"bool"),"float32");if(o.rank===a-1){o=ol(o,-1)}o=Od(o,u)}if(s){n=$h(n,0);if(o!=null){o=$h(o,0)}}const l=[];let f;let h=e;const d=n.shape[0];const p=Ed(n);let m;if(o!=null){m=Ed(o)}for(let n=0;n<d;++n){const e=p[n];const s=Wi((()=>t(e,h)));if(o==null){f=s[0];h=s[1]}else{const t=Wi((()=>{const t=m[n];const e=Xl(Af(t),t);const o=Xi(tc(s[0],t),tc(h[0],e));const r=h.map(((n,o)=>Xi(tc(s[1][o],t),tc(n,e))));return{output:o,newStates:r}}));f=t.output;h=t.newStates}if(c){l.push(f)}}let x;if(c){const t=1;x=cd(l,t)}return[f,x,h]}))}class HC extends S${constructor(t){super(t);let n;if(t.cell==null){throw new gw("cell property is missing for the constructor of RNN.")}else if(Array.isArray(t.cell)){n=new QC({cells:t.cell})}else{n=t.cell}if(n.stateSize==null){throw new gw("The RNN cell should have an attribute `stateSize` (tuple of "+"integers, one integer per RNN state).")}this.cell=n;this.returnSequences=t.returnSequences==null?false:t.returnSequences;this.returnState=t.returnState==null?false:t.returnState;this.goBackwards=t.goBackwards==null?false:t.goBackwards;this._stateful=t.stateful==null?false:t.stateful;this.unroll=t.unroll==null?false:t.unroll;this.supportsMasking=true;this.inputSpec=[new y$({ndim:3})];this.stateSpec=null;this.states_=null;this.numConstants=null;this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return mv(0,t).map((t=>null))}else{return this.states_}}setStates(t){this.states_=t}computeOutputShape(t){if(h$(t)){t=t[0]}t=t;let n=this.cell.stateSize;if(!Array.isArray(n)){n=[n]}const e=n[0];let s;if(this.returnSequences){s=[t[0],t[1],e]}else{s=[t[0],e]}if(this.returnState){const e=[];for(const s of n){e.push([t[0],s])}return[s].concat(e)}else{return s}}computeMask(t,n){return Wi((()=>{if(Array.isArray(n)){n=n[0]}const t=this.returnSequences?n:null;if(this.returnState){const n=this.states.map((t=>null));return[t].concat(n)}else{return t}}))}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;const n=[];for(let e=0;e<t;++e){n.push(null)}return n}else{return this.states_}}set states(t){this.states_=t}build(t){if(this.numConstants!=null){throw new ww("Constants support is not implemented in RNN yet.")}if(h$(t)){t=t[0]}t=t;const n=this.stateful?t[0]:null;const e=t.slice(2);this.inputSpec[0]=new y$({shape:[n,null,...e]});const s=[t[0]].concat(t.slice(2));{this.cell.build(s)}let o;if(Array.isArray(this.cell.stateSize)){o=this.cell.stateSize}else{o=[this.cell.stateSize]}if(this.stateSpec!=null){if(!w(this.stateSpec.map((t=>t.shape[t.shape.length-1])),o)){throw new gw(`An initialState was passed that is not compatible with `+`cell.stateSize. Received stateSpec=${this.stateSpec}; `+`However cell.stateSize is ${this.cell.stateSize}`)}}else{this.stateSpec=o.map((t=>new y$({shape:[null,t]})))}if(this.stateful){this.resetStates()}}resetStates(t,n=false){Wi((()=>{if(!this.stateful){throw new xw("Cannot call resetStates() on an RNN Layer that is not stateful.")}const e=this.inputSpec[0].shape[0];if(e==null){throw new gw("If an RNN is stateful, it needs to know its batch size. Specify "+"the batch size of your input tensors: \n"+"- If using a Sequential model, specify the batch size by "+"passing a `batchInputShape` option to your first layer.\n"+"- If using the functional API, specify the batch size by "+"passing a `batchShape` option to your Input layer.")}if(this.states_==null){if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((t=>xf([e,t])))}else{this.states_=[xf([e,this.cell.stateSize])]}}else if(t==null){Gi(this.states_);if(this.keptStates!=null){Gi(this.keptStates);this.keptStates=[]}if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((t=>xf([e,t])))}else{this.states_[0]=xf([e,this.cell.stateSize])}}else{if(!Array.isArray(t)){t=[t]}if(t.length!==this.states_.length){throw new gw(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${t.length} state value(s). Input `+`received: ${t}`)}if(n===true){this.keptStates.push(this.states_.slice())}else{Gi(this.states_)}for(let n=0;n<this.states_.length;++n){const s=t[n];const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[n]:this.cell.stateSize;const r=[e,o];if(!w(s.shape,r)){throw new gw(`State ${n} is incompatible with layer ${this.name}: `+`expected shape=${r}, received shape=${s.shape}`)}this.states_[n]=s}}this.states_=this.states_.map((t=>Ui(t.clone())))}))}apply(t,n){let e=n==null?null:n["initialState"];let s=n==null?null:n["constants"];if(n==null){n={}}const o=GC(t,e,s,this.numConstants);t=o.inputs;e=o.initialState;s=o.constants;let r=[];let i=[];if(e!=null){n["initialState"]=e;r=r.concat(e);this.stateSpec=[];for(const t of e){this.stateSpec.push(new y$({shape:t.shape}))}i=i.concat(this.stateSpec)}if(s!=null){n["constants"]=s;r=r.concat(s);this.numConstants=s.length}const c=r[0]instanceof k$;if(c){const e=[t].concat(r);const s=this.inputSpec.concat(i);const o=this.inputSpec;this.inputSpec=s;const c=super.apply(e,n);this.inputSpec=o;return c}else{return super.apply(t,n)}}call(t,n){return Wi((()=>{const e=n==null?null:n["mask"];const s=n==null?null:n["training"];let o=n==null?null:n["initialState"];t=p$(t);if(o==null){if(this.stateful){o=this.states_}else{o=this.getInitialState(t)}}const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==r){throw new gw(`RNN Layer has ${r} state(s) but was passed `+`${o.length} initial state(s).`)}if(this.unroll){console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.")}const i={training:s};const c=(t,n)=>{const e=this.cell.call([t].concat(n),i);return[e[0],e.slice(1)]};const a=UC(c,t,o,this.goBackwards,e,null,this.unroll,this.returnSequences);const u=a[0];const l=a[1];const f=a[2];if(this.stateful){this.resetStates(f,s)}const h=this.returnSequences?l:u;if(this.returnState){return[h].concat(f)}else{return h}}))}getInitialState(t){return Wi((()=>{let n=xf(t.shape);n=Ku(n,[1,2]);n=vv(n);if(Array.isArray(this.cell.stateSize)){return this.cell.stateSize.map((t=>t>1?Tv(n,[1,t]):n))}else{return this.cell.stateSize>1?[Tv(n,[1,this.cell.stateSize])]:[n]}}))}get trainableWeights(){if(!this.trainable){return[]}return this.cell.trainableWeights}get nonTrainableWeights(){if(!this.trainable){return this.cell.weights}return this.cell.nonTrainableWeights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.cell!=null){this.cell.setFastWeightInitDuringBuild(t)}}getConfig(){const t=super.getConfig();const n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};if(this.numConstants!=null){n["numConstants"]=this.numConstants}const e=this.cell.getConfig();if(this.getClassName()===HC.className){n["cell"]={className:this.cell.getClassName(),config:e}}return Object.assign(Object.assign(Object.assign({},e),t),n)}static fromConfig(t,n,e={}){const s=n["cell"];const o=py(s,e);return new t(Object.assign(n,{cell:o}))}}HC.className="RNN";Zp(HC);class jC extends S${}class qC extends jC{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=t.units;Pw(this.units,`units`);this.activation=aC(t.activation==null?this.DEFAULT_ACTIVATION:t.activation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=f$(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=f$(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=f$(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelRegularizer=mC(t.kernelRegularizer);this.recurrentRegularizer=mC(t.recurrentRegularizer);this.biasRegularizer=mC(t.biasRegularizer);this.kernelConstraint=ny(t.kernelConstraint);this.recurrentConstraint=ny(t.recurrentConstraint);this.biasConstraint=ny(t.biasConstraint);this.dropout=dv([1,pv([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=dv([1,pv([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.stateSize=this.units;this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){t=m$(t);this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return Wi((()=>{t=t;if(t.length!==2){throw new gw(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`)}let e=t[1];t=t[0];const s=n["training"]==null?false:n["training"];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=tN({ones:()=>Af(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=tN({ones:()=>Af(e),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc})}let o;const r=this.dropoutMask;const i=this.recurrentDropoutMask;if(r!=null){o=Av(tc(t,r),this.kernel.read())}else{o=Av(t,this.kernel.read())}if(this.bias!=null){o=Mv(o,this.bias.read())}if(i!=null){e=tc(e,i)}let c=Xi(o,Av(e,this.recurrentKernel.read()));if(this.activation!=null){c=this.activation.apply(c)}return[c,c]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:iC(this.activation),useBias:this.useBias,kernelInitializer:l$(this.kernelInitializer),recurrentInitializer:l$(this.recurrentInitializer),biasInitializer:l$(this.biasInitializer),kernelRegularizer:dC(this.kernelRegularizer),recurrentRegularizer:dC(this.recurrentRegularizer),biasRegularizer:dC(this.biasRegularizer),activityRegularizer:dC(this.activityRegularizer),kernelConstraint:Q$(this.kernelConstraint),recurrentConstraint:Q$(this.recurrentConstraint),biasConstraint:Q$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}qC.className="SimpleRNNCell";Zp(qC);class XC extends HC{constructor(t){t.cell=new qC(t);super(t)}call(t,n){return Wi((()=>{if(this.cell.dropoutMask!=null){Gi(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Gi(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){return new t(n)}}XC.className="SimpleRNN";Zp(XC);class KC extends jC{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(t.resetAfter){throw new gw(`GRUCell does not support reset_after parameter set to true.`)}this.units=t.units;Pw(this.units,"units");this.activation=aC(t.activation===undefined?this.DEFAULT_ACTIVATION:t.activation);this.recurrentActivation=aC(t.recurrentActivation===undefined?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=f$(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=f$(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=f$(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelRegularizer=mC(t.kernelRegularizer);this.recurrentRegularizer=mC(t.recurrentRegularizer);this.biasRegularizer=mC(t.biasRegularizer);this.kernelConstraint=ny(t.kernelConstraint);this.recurrentConstraint=ny(t.recurrentConstraint);this.biasConstraint=ny(t.biasConstraint);this.dropout=dv([1,pv([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=dv([1,pv([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.implementation=t.implementation;this.stateSize=this.units;this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){t=m$(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return Wi((()=>{t=t;if(t.length!==2){throw new gw(`GRUCell expects 2 input Tensors (inputs, h, c), got `+`${t.length}.`)}const e=n["training"]==null?false:n["training"];let s=t[1];t=t[0];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=tN({ones:()=>Af(t),rate:this.dropout,training:e,count:3,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=tN({ones:()=>Af(s),rate:this.recurrentDropout,training:e,count:3,dropoutFunc:this.dropoutFunc})}const o=this.dropoutMask;const r=this.recurrentDropoutMask;let i;let c;let a;if(0<this.dropout&&this.dropout<1){t=tc(t,o[0])}let u=Av(t,this.kernel.read());if(this.useBias){u=Mv(u,this.bias.read())}if(0<this.recurrentDropout&&this.recurrentDropout<1){s=tc(s,r[0])}const l=this.recurrentKernel.read();const[f,h]=Qh(l,[2*this.units,this.units],l.rank-1);const d=Av(s,f);const[p,m,x]=Qh(u,3,u.rank-1);const[b,g]=Qh(d,2,d.rank-1);i=this.recurrentActivation.apply(Xi(p,b));c=this.recurrentActivation.apply(Xi(m,g));const w=Av(tc(c,s),h);a=this.activation.apply(Xi(x,w));const v=Xi(tc(i,s),tc(Xi(1,Wl(i)),a));return[v,v]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:iC(this.activation),recurrentActivation:iC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:l$(this.kernelInitializer),recurrentInitializer:l$(this.recurrentInitializer),biasInitializer:l$(this.biasInitializer),kernelRegularizer:dC(this.kernelRegularizer),recurrentRegularizer:dC(this.recurrentRegularizer),biasRegularizer:dC(this.biasRegularizer),activityRegularizer:dC(this.activityRegularizer),kernelConstraint:Q$(this.kernelConstraint),recurrentConstraint:Q$(this.recurrentConstraint),biasConstraint:Q$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:false};return Object.assign(Object.assign({},t),n)}}KC.className="GRUCell";Zp(KC);class JC extends HC{constructor(t){if(t.implementation===0){console.warn("`implementation=0` has been deprecated, and now defaults to "+"`implementation=1`. Please update your layer call.")}t.cell=new KC(t);super(t)}call(t,n){return Wi((()=>{if(this.cell.dropoutMask!=null){Gi(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Gi(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){if(n["implmentation"]===0){n["implementation"]=1}return new t(n)}}JC.className="GRU";Zp(JC);class YC extends jC{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=t.units;Pw(this.units,"units");this.activation=aC(t.activation===undefined?this.DEFAULT_ACTIVATION:t.activation);this.recurrentActivation=aC(t.recurrentActivation===undefined?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation);this.useBias=t.useBias==null?true:t.useBias;this.kernelInitializer=f$(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.recurrentInitializer=f$(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER);this.biasInitializer=f$(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.unitForgetBias=t.unitForgetBias;this.kernelRegularizer=mC(t.kernelRegularizer);this.recurrentRegularizer=mC(t.recurrentRegularizer);this.biasRegularizer=mC(t.biasRegularizer);this.kernelConstraint=ny(t.kernelConstraint);this.recurrentConstraint=ny(t.recurrentConstraint);this.biasConstraint=ny(t.biasConstraint);this.dropout=dv([1,pv([0,t.dropout==null?0:t.dropout])]);this.recurrentDropout=dv([1,pv([0,t.recurrentDropout==null?0:t.recurrentDropout])]);this.dropoutFunc=t.dropoutFunc;this.implementation=t.implementation;this.stateSize=[this.units,this.units];this.dropoutMask=null;this.recurrentDropoutMask=null}build(t){var n;t=m$(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const t=this.biasInitializer;const e=this.units;s=new(n=class n extends Hv{apply(n,s){const o=t.apply([e]);const r=(new qv).apply([e]);const i=t.apply([e*2]);return Ev(Ev(o,r),i)}},n.className="CustomInit",n)}else{s=this.biasInitializer}this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,true,this.biasConstraint)}else{this.bias=null}this.built=true}call(t,n){return Wi((()=>{const e=n["training"]==null?false:n["training"];t=t;if(t.length!==3){throw new gw(`LSTMCell expects 3 input Tensors (inputs, h, c), got `+`${t.length}.`)}let s=t[1];const o=t[2];t=t[0];if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=tN({ones:()=>Af(t),rate:this.dropout,training:e,count:4,dropoutFunc:this.dropoutFunc})}if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=tN({ones:()=>Af(s),rate:this.recurrentDropout,training:e,count:4,dropoutFunc:this.dropoutFunc})}const r=this.dropoutMask;const i=this.recurrentDropoutMask;let c;let a;let u;let l;if(0<this.dropout&&this.dropout<1){t=tc(t,r[0])}let f=Av(t,this.kernel.read());if(0<this.recurrentDropout&&this.recurrentDropout<1){s=tc(s,i[0])}f=Xi(f,Av(s,this.recurrentKernel.read()));if(this.useBias){f=Mv(f,this.bias.read())}const[h,d,p,m]=Qh(f,4,f.rank-1);c=this.recurrentActivation.apply(h);a=this.recurrentActivation.apply(d);u=Xi(tc(a,o),tc(c,this.activation.apply(p)));l=this.recurrentActivation.apply(m);const x=tc(l,this.activation.apply(u));return[x,x,u]}))}getConfig(){const t=super.getConfig();const n={units:this.units,activation:iC(this.activation),recurrentActivation:iC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:l$(this.kernelInitializer),recurrentInitializer:l$(this.recurrentInitializer),biasInitializer:l$(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dC(this.kernelRegularizer),recurrentRegularizer:dC(this.recurrentRegularizer),biasRegularizer:dC(this.biasRegularizer),activityRegularizer:dC(this.activityRegularizer),kernelConstraint:Q$(this.kernelConstraint),recurrentConstraint:Q$(this.recurrentConstraint),biasConstraint:Q$(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}YC.className="LSTMCell";Zp(YC);class ZC extends HC{constructor(t){if(t.implementation===0){console.warn("`implementation=0` has been deprecated, and now defaults to "+"`implementation=1`. Please update your layer call.")}t.cell=new YC(t);super(t)}call(t,n){return Wi((()=>{if(this.cell.dropoutMask!=null){Gi(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Gi(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}static fromConfig(t,n){if(n["implmentation"]===0){n["implementation"]=1}return new t(n)}}ZC.className="LSTM";Zp(ZC);class QC extends jC{constructor(t){super(t);this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse()){if(Array.isArray(n.stateSize)){t.push(...n.stateSize)}else{t.push(n.stateSize)}}return t}call(t,n){return Wi((()=>{t=t;let e=t.slice(1);const s=[];for(const t of this.cells.slice().reverse()){if(Array.isArray(t.stateSize)){s.push(e.splice(0,t.stateSize.length))}else{s.push(e.splice(0,1))}}s.reverse();const o=[];let r;for(let i=0;i<this.cells.length;++i){const c=this.cells[i];e=s[i];if(i===0){r=[t[0]].concat(e)}else{r=[r[0]].concat(e)}r=c.call(r,n);o.push(r.slice(1))}e=[];for(const t of o.slice().reverse()){e.push(...t)}return[r[0]].concat(e)}))}build(t){if(h$(t)){t=t[0]}t=t;let n;this.cells.forEach(((e,s)=>{rv(`RNNCell_${s}`,(()=>{e.build(t);if(Array.isArray(e.stateSize)){n=e.stateSize[0]}else{n=e.stateSize}t=[t[0],n]}))}));this.built=true}getConfig(){const t=super.getConfig();const n=t=>({className:t.getClassName(),config:t.getConfig()});const e=this.cells.map(n);const s={cells:e};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,e={}){const s=[];for(const t of n["cells"]){s.push(py(t,e))}return new t({cells:s})}get trainableWeights(){if(!this.trainable){return[]}const t=[];for(const n of this.cells){t.push(...n.trainableWeights)}return t}get nonTrainableWeights(){const t=[];for(const n of this.cells){t.push(...n.nonTrainableWeights)}if(!this.trainable){const n=[];for(const t of this.cells){n.push(...t.trainableWeights)}return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells){t.push(...n.weights)}return v$(t)}setWeights(t){const n=[];for(const e of this.cells){const s=e.weights.length;const o=t.splice(s);for(let t=0;t<e.weights.length;++t){n.push([e.weights[t],o[t]])}}$$(n)}}QC.className="StackedRNNCells";Zp(QC);function tN(t){const{ones:n,rate:e,training:s=false,count:o=1,dropoutFunc:r}=t;const i=()=>r!=null?r(n(),e):zv(n(),e);const c=()=>Vv(i,n,s);if(!o||o<=1){return Ui(c().clone())}const a=Array(o).fill(undefined).map(c);return a.map((t=>Ui(t.clone())))}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var nN=undefined&&undefined.__rest||function(t,n){var e={};for(var s in t)if(Object.prototype.hasOwnProperty.call(t,s)&&n.indexOf(s)<0)e[s]=t[s];if(t!=null&&typeof Object.getOwnPropertySymbols==="function")for(var o=0,s=Object.getOwnPropertySymbols(t);o<s.length;o++){if(n.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(t,s[o]))e[s[o]]=t[s[o]]}return e};class eN extends HC{constructor(t){if(t.unroll){throw new ww("Unrolling is not possible with convolutional RNNs.")}if(Array.isArray(t.cell)){throw new ww("It is not possible at the moment to stack convolutional cells.")}super(t);this.inputSpec=[new y$({ndim:5})]}call(t,n){return Wi((()=>{if(this.cell.dropoutMask!=null){Gi(this.cell.dropoutMask);this.cell.dropoutMask=null}if(this.cell.recurrentDropoutMask!=null){Gi(this.cell.recurrentDropoutMask);this.cell.recurrentDropoutMask=null}if(n&&n["constants"]){throw new gw("ConvRNN2D cell does not support constants")}const e=n==null?null:n["mask"];const s=n==null?null:n["training"];const o=n==null?null:n["initialState"];return super.call(t,{mask:e,training:s,initialState:o})}))}computeOutputShape(t){let n=this.computeSingleOutputShape(t);if(!this.returnSequences){n=[n[0],...n.slice(2)]}if(this.returnState){n=[n,...Array(2).fill([t[0],...n.slice(-3)])]}return n}getInitialState(t){return Wi((()=>{const{stateSize:n}=this.cell;const e=t.shape;const s=this.computeSingleOutputShape(e);const o=[s[0],...s.slice(2)];const r=xf(o);if(Array.isArray(n)){return Array(n.length).fill(r)}return[r]}))}resetStates(t,n=false){Wi((()=>{if(!this.stateful){throw new xw("Cannot call resetStates() on an RNN Layer that is not stateful.")}const e=this.inputSpec[0].shape;const s=this.computeSingleOutputShape(e);const o=[s[0],...s.slice(2)];const r=e[0];if(r==null){throw new gw("If an RNN is stateful, it needs to know its batch size. Specify "+"the batch size of your input tensors: \n"+"- If using a Sequential model, specify the batch size by "+"passing a `batchInputShape` option to your first layer.\n"+"- If using the functional API, specify the batch size by "+"passing a `batchShape` option to your Input layer.")}if(this.getStates()==null){if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((()=>xf(o)))}else{this.states_=[xf(o)]}}else if(t==null){Gi(this.states_);if(this.keptStates!=null){Gi(this.keptStates);this.keptStates=[]}if(Array.isArray(this.cell.stateSize)){this.states_=this.cell.stateSize.map((()=>xf(o)))}else{this.states_[0]=xf(o)}}else{if(!Array.isArray(t)){t=[t]}if(t.length!==this.states_.length){throw new gw(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${t.length} state value(s). Input `+`received: ${t}`)}if(n){this.keptStates.push(this.states_.slice())}else{Gi(this.states_)}for(let n=0;n<this.states_.length;++n){const e=t[n];const s=o;if(!w(e.shape,s)){throw new gw(`State ${n} is incompatible with layer ${this.name}: `+`expected shape=${s}, received shape=${e.shape}`)}this.states_[n]=e}}this.states_=this.states_.map((t=>Ui(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:n,filters:e,kernelSize:s,padding:o,strides:r,dilationRate:i}=this.cell;const c=n==="channelsFirst";const a=t[c?3:2];const u=t[c?4:3];const l=kC(a,s[0],o,r[0],i[0]);const f=kC(u,s[1],o,r[1],i[1]);const h=[...t.slice(0,2),...c?[e,l,f]:[l,f,e]];return h}}eN.className="ConvRNN2D";class sN extends YC{constructor(t){const{filters:n,kernelSize:e,strides:s,padding:o,dataFormat:r,dilationRate:i}=t;super(Object.assign(Object.assign({},t),{units:n}));this.filters=n;Pw(this.filters,"filters");this.kernelSize=yC(e,2,"kernelSize");this.kernelSize.forEach((t=>Pw(t,"kernelSize")));this.strides=yC(s||1,2,"strides");this.strides.forEach((t=>Pw(t,"strides")));this.padding=o||"valid";nv(this.padding);this.dataFormat=r||"channelsLast";Qw(this.dataFormat);this.dilationRate=yC(i||1,2,"dilationRate");this.dilationRate.forEach((t=>Pw(t,"dilationRate")))}build(t){var n;t=m$(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null){throw new gw(`The channel dimension of the input should be defined. `+`Found ${t[e]}`)}const s=t[e];const o=4;const r=this.kernelSize.concat([s,this.filters*o]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*o]);this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,true,this.recurrentConstraint);if(this.useBias){let t;if(this.unitForgetBias){const e=this.biasInitializer;const s=this.filters;t=new(n=class t extends Hv{apply(t,n){const o=e.apply([s]);const r=bf([s]);const i=e.apply([s*2]);return Sv([o,r,i])}},n.className="CustomInit",n)}else{t=this.biasInitializer}this.bias=this.addWeight("bias",[this.filters*o],null,t,this.biasRegularizer,true,this.biasConstraint)}this.built=true}call(t,n){return Wi((()=>{if(t.length!==3){throw new gw(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got `+`${t.length}.`)}const e=n["training"]||false;const s=t[0];const o=t[1];const r=t[2];const i=4;if(0<this.dropout&&this.dropout<1&&this.dropoutMask==null){this.dropoutMask=tN({ones:()=>Af(s),rate:this.dropout,training:e,count:i,dropoutFunc:this.dropoutFunc})}const c=this.dropoutMask;const a=(t,n,e)=>{if(!n||!n[e]){return t}return tc(n[e],t)};let u=a(s,c,0);let l=a(s,c,1);let f=a(s,c,2);let h=a(s,c,3);if(0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null){this.recurrentDropoutMask=tN({ones:()=>Af(o),rate:this.recurrentDropout,training:e,count:i,dropoutFunc:this.dropoutFunc})}const d=this.recurrentDropoutMask;let p=a(o,d,0);let m=a(o,d,1);let x=a(o,d,2);let b=a(o,d,3);const g=3;const[w,v,$,y]=Qh(this.kernel.read(),i,g);const[k,C,N,R]=this.useBias?Qh(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,w,k,this.padding);l=this.inputConv(l,v,C,this.padding);f=this.inputConv(f,$,N,this.padding);h=this.inputConv(h,y,R,this.padding);const[S,E,T,I]=Qh(this.recurrentKernel.read(),i,g);p=this.recurrentConv(p,S);m=this.recurrentConv(m,E);x=this.recurrentConv(x,T);b=this.recurrentConv(b,I);const A=this.recurrentActivation.apply(Xi(u,p));const O=this.recurrentActivation.apply(Xi(l,m));const F=Xi(tc(O,r),tc(A,this.activation.apply(Xi(f,x))));const _=tc(this.recurrentActivation.apply(Xi(h,b)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const t=super.getConfig(),n=nN(t,["units"]);const e={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),e)}inputConv(t,n,e,s){const o=Ma(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);if(e){return Mv(o,e,this.dataFormat)}return o}recurrentConv(t,n){const e=1;return Ma(t,n,e,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}sN.className="ConvLSTM2DCell";Zp(sN);class oN extends eN{constructor(t){const n=new sN(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}oN.className="ConvLSTM2D";Zp(oN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rN extends S${constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0);this.noiseShape=t.noiseShape;this.seed=t.seed;this.supportsMasking=true}getNoiseShape(t){if(this.noiseShape==null){return this.noiseShape}const n=t.shape;const e=[];for(let t=0;t<this.noiseShape.length;++t){e.push(this.noiseShape[t]==null?n[t]:this.noiseShape[t])}return e}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);if(0<this.rate&&this.rate<1){const t=n["training"]==null?false:n["training"];const s=this.getNoiseShape(e);const o=Vv((()=>zv(e,this.rate,s,this.seed)),(()=>e),t);return o}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed};const n=super.getConfig();Object.assign(t,n);return t}dispose(){return super.dispose()}}rN.className="Dropout";Zp(rN);class iN extends rN{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}iN.className="SpatialDropout1D";Zp(iN);class cN extends S${constructor(t){super(t);this.activation=null;this.useBias=true;this.kernel=null;this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;if(t.batchSize!=null){n=t.batchSize}this.batchInputShape=[n,t.inputDim]}this.units=t.units;Pw(this.units,"units");this.activation=aC(t.activation);if(t.useBias!=null){this.useBias=t.useBias}this.kernelInitializer=f$(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER);this.biasInitializer=f$(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER);this.kernelConstraint=ny(t.kernelConstraint);this.biasConstraint=ny(t.biasConstraint);this.kernelRegularizer=mC(t.kernelRegularizer);this.biasRegularizer=mC(t.biasRegularizer);this.activityRegularizer=mC(t.activityRegularizer);this.supportsMasking=true;this.inputSpec=[{minNDim:2}]}build(t){t=m$(t);const n=t[t.length-1];if(this.kernel==null){this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,true,this.kernelConstraint);if(this.useBias){this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,true,this.biasConstraint)}}this.inputSpec=[{minNDim:2,axes:{[-1]:n}}];this.built=true}computeOutputShape(t){t=m$(t);const n=t.slice();n[n.length-1]=this.units;return n}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);const s=Ww(this.activation.getClassName());let o;if(s!=null){o=Av(e,this.kernel.read(),s,this.bias?this.bias.read():null)}else{o=Av(e,this.kernel.read());if(this.bias!=null){o=Mv(o,this.bias.read())}if(this.activation!=null){o=this.activation.apply(o)}}return o}))}getConfig(){const t={units:this.units,activation:iC(this.activation),useBias:this.useBias,kernelInitializer:l$(this.kernelInitializer),biasInitializer:l$(this.biasInitializer),kernelRegularizer:dC(this.kernelRegularizer),biasRegularizer:dC(this.biasRegularizer),activityRegularizer:dC(this.activityRegularizer),kernelConstraint:Q$(this.kernelConstraint),biasConstraint:Q$(this.biasConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}cN.className="Dense";Zp(cN);class aN extends S${constructor(t){t=t||{};super(t);this.inputSpec=[{minNDim:3}];this.dataFormat=t.dataFormat}computeOutputShape(t){t=m$(t);for(const n of t.slice(1)){if(n==null){throw new gw(`The shape of the input to "Flatten" is not fully defined `+`(got ${t.slice(1)}). Make sure to pass a complete `+`"input_shape" or "batch_input_shape" argument to the first `+`layer in your model.`)}}return[t[0],hv(t,1)]}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);let e=p$(t);if(this.dataFormat==="channelsFirst"&&e.rank>1){const t=[0];for(let n=2;n<e.rank;++n){t.push(n)}t.push(1);e=Od(e,t)}return kv(e)}))}getConfig(){const t={};if(this.dataFormat!=null){t["dataFormat"]=this.dataFormat}const n=super.getConfig();Object.assign(t,n);return t}}aN.className="Flatten";Zp(aN);class uN extends S${constructor(t){super(t);this.supportsMasking=true;this.activation=aC(t.activation)}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);return this.activation.apply(e)}))}getConfig(){const t={activation:iC(this.activation)};const n=super.getConfig();Object.assign(t,n);return t}}uN.className="Activation";Zp(uN);class lN extends S${constructor(t){super(t);this.n=t.n;this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return Wi((()=>{t=p$(t);return $v(t,this.n)}))}getConfig(){const t={n:this.n};const n=super.getConfig();Object.assign(t,n);return t}}lN.className="RepeatVector";Zp(lN);class fN extends S${constructor(t){super(t);this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t){if(this.isUnknown(this.targetShape[t])){this.targetShape[t]=null}}}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const e="Total size of new array must be unchanged.";const s=n.slice();let o=1;let r=null;for(let t=0;t<s.length;++t){const n=s[t];if(this.isUnknown(n)){if(r===null){r=t}else{throw new gw("Can only specifiy one unknown dimension.")}}else{o*=n}}const i=hv(t);if(r!==null){if(o===0||i%o!==0){throw new gw(e)}s[r]=i/o}else if(i!==o){throw new gw(e)}return s}computeOutputShape(t){let n=false;for(let e=0;e<t.length;++e){if(this.isUnknown(t[e])){n=true;break}}if(n){return t.slice(0,1).concat(this.targetShape)}else{return t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);const s=e.shape;const o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return Hc(e,o)}))}getConfig(){const t={targetShape:this.targetShape};const n=super.getConfig();Object.assign(t,n);return t}}fN.className="Reshape";Zp(fN);class hN extends S${constructor(t){super(t);if(t.dims==null){throw new Error("Required configuration field `dims` is missing during Permute "+"constructor call.")}if(!Array.isArray(t.dims)){throw new Error("Permute constructor requires `dims` to be an Array, but received "+`${t.dims} instead.`)}const n=mv(1,t.dims.length+1);if(!w(t.dims.slice().sort(),n)){throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.")}this.dims=t.dims;this.dimsIncludingBatch=[0].concat(this.dims);this.inputSpec=[new y$({ndim:this.dims.length+1})]}computeOutputShape(t){t=m$(t);const n=t.slice();this.dims.forEach(((e,s)=>{n[s+1]=t[e]}));return n}call(t,n){return Od(p$(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims};const n=super.getConfig();Object.assign(t,n);return t}}hN.className="Permute";Zp(hN);class dN extends S${constructor(t){super(t==null?{}:t);this.supportsMasking=true;if(t!=null){this.maskValue=t.maskValue==null?0:t.maskValue}else{this.maskValue=0}}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={maskValue:this.maskValue};Object.assign(n,t);return n}computeMask(t,n){const e=p$(t);const s=-1;return lc(Sf(e,this.maskValue),s)}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);const s=-1;const o=true;const r=lc(Sf(e,this.maskValue),s,o);const i=tc(e,Mi(r,e.dtype));return i}))}}dN.className="Masking";Zp(dN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pN extends S${constructor(t){super(t);this.embeddings=null;this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";if(t.batchInputShape==null&&t.inputShape==null){let n=null;if(t.batchSize!=null){n=t.batchSize}if(t.inputLength==null){this.batchInputShape=[n,null]}else{this.batchInputShape=[n].concat(Rw(t.inputLength))}}this.inputDim=t.inputDim;Pw(this.inputDim,"inputDim");this.outputDim=t.outputDim;Pw(this.outputDim,"outputDim");this.embeddingsInitializer=f$(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER);this.embeddingsRegularizer=mC(t.embeddingsRegularizer);this.activityRegularizer=mC(t.activityRegularizer);this.embeddingsConstraint=ny(t.embeddingsConstraint);this.maskZero=t.maskZero;this.supportsMasking=t.maskZero;this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,true,this.embeddingsConstraint);this.built=true}warnOnIncompatibleInputShape(t){}computeMask(t,n){return Wi((()=>{if(!this.maskZero){return null}else{t=p$(t);return Sf(t,gu(t))}}))}computeOutputShape(t){t=m$(t);if(this.inputLength==null){return[...t,this.outputDim]}const n=Rw(this.inputLength);if(n.length!==t.length-1){throw new gw(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${t}`)}else{let e=0;for(let s=0;s<n.length;++s){const o=n[s];const r=t[s+1];if(o!=null&&r!=null&&o!==r){throw new gw(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${t}`)}else if(o==null){n[e]=r}e++}}return[t[0],...n,this.outputDim]}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);let e=p$(t);if(e.dtype!=="int32"){e=wv(e,"int32")}const s=Ov(this.embeddings.read(),Hc(e,[e.size]));return Hc(s,m$(this.computeOutputShape(e.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:l$(this.embeddingsInitializer),embeddingsRegularizer:dC(this.embeddingsRegularizer),activityRegularizer:dC(this.activityRegularizer),embeddingsConstraint:Q$(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength};const n=super.getConfig();Object.assign(t,n);return t}}pN.className="Embedding";Zp(pN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class mN extends S${constructor(t){super(t||{});this.supportsMasking=true}mergeFunction(t){throw new ww}computeElementwiseOpOutputShape(t,n){if(t==null||n==null){return null}else if(t.length<n.length){return this.computeElementwiseOpOutputShape(n,t)}else if(n.length===0){return t}const e=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const o=t[t.length-n.length+s];const r=n[s];if(o==null||r==null||o<0||r<0){e.push(null)}else if(o===1){e.push(r)}else if(r===1){e.push(o)}else{if(o!==r){throw new gw("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n))}e.push(o)}}return e}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])){t=[m$(t)]}t=t;if(t.length<2){throw new gw("A merge layer should be called on an Array of at least 2 inputs."+` Got ${t.length} input(s).`)}let n=[];for(const e of t){if(e!=null&&e[0]!==null){n.push(e[0])}}n=Mw(n);if(n.length>1){throw new gw(`Can not merge tensors with different batch sizes. `+`Got tensors with shapes: ${JSON.stringify(t)}.`)}let e=t[0]==null?null:t[0].slice(1);for(let n=1;n<t.length;++n){const s=t[n]==null?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}const s=t.map((t=>t.length));if(t.indexOf(null)===-1&&Mw(s).length===1){this.reshapeRequired=false}else{this.reshapeRequired=true}}call(t,n){return Wi((()=>{t=t;if(this.reshapeRequired){const n=[];const e=t.map((t=>t.rank));if(e.indexOf(null)===-1){const s=pv(e);for(let e of t){const t=e.rank;for(let n=0;n<s-t;++n){e=vv(e,1)}n.push(e)}return this.mergeFunction(n)}else{let e=false;for(const s of t){const t=s.rank;if(t==null){const t=s.shape;const o=t[0];const r=t.slice(1).concat([o]);let i=Hc(s,[o].concat(hv(t.slice(1))));i=Od(i,[1,0]);i=Hc(i,r);n.push(i);e=true}else if(t>1){const o=mv(1,t).concat([0]);n.push(Od(s,o));e=true}else{n.push(s)}}let s=this.mergeFunction(n);const o=s.rank;if(e){if(o==null){const t=s.shape;const n=t.length;const e=t[n-1];const o=[e].concat(t.slice(0,t.length-1));s=Hc(Od(Hc(s,[-1,e]),[1,0]),o)}else if(o>1){const t=[o-1].concat(mv(0,o-1));s=Od(s,t)}}return s}}else{return this.mergeFunction(t)}}))}computeOutputShape(t){t=t;let n;if(t[0]==null){n=null}else{n=t[0].slice(1)}for(let e=1;e<t.length;++e){const s=t[e]==null?null:t[e].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let e=[];for(const n of t){if(n!=null&&n[0]!==null){e.push(n[0])}}e=Mw(e);if(e.length===1){n=e.concat(n)}else{n=[null].concat(n)}return n}computeMask(t,n){return Wi((()=>{if(n==null){return null}if(!Array.isArray(n)){throw new gw("`mask` should be an Array")}if(!Array.isArray(t)){throw new gw("`inputs` should be an Array")}if(n.length!==t.length){throw new gw(`The Array 'inputs' and 'mask' are expected to have the same `+`length, but have different lengths `+`(${t.length} vs ${n.length})`)}if(n.every((t=>t==null))){return null}n=n.map((t=>t==null?t:ol(t,0)));let e=n[0];for(let t=1;t<n.length-1;++t){e=tf(e,n[t])}return e}))}}class xN extends mN{constructor(t){super(t)}mergeFunction(t){return Wi((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=Xi(n,t[e])}return n}))}}xN.className="Add";Zp(xN);class bN extends mN{constructor(t){super(t)}mergeFunction(t){return Wi((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=tc(n,t[e])}return n}))}}bN.className="Multiply";Zp(bN);class gN extends mN{constructor(t){super(t)}mergeFunction(t){return Wi((()=>{let n=t[0].clone();for(let e=1;e<t.length;++e){n=Xi(n,t[e])}return tc(1/t.length,n)}))}}gN.className="Average";Zp(gN);class wN extends mN{constructor(t){super(t)}mergeFunction(t){return Wi((()=>{let n=t[0];for(let e=1;e<t.length;++e){n=df(n,t[e])}return n}))}}wN.className="Maximum";Zp(wN);class vN extends mN{constructor(t){super(t)}mergeFunction(t){return Wi((()=>{let n=t[0];for(let e=1;e<t.length;++e){n=wf(n,t[e])}return n}))}}vN.className="Minimum";Zp(vN);class $N extends mN{constructor(t){super(t);this.DEFAULT_AXIS=-1;if(t==null){t={}}this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis;this.supportsMasking=true;this.reshapeRequired=false}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1){throw new gw("A `Concatenate` layer should be called on a list of at least 2 "+"inputs")}t=t;let n=true;for(const e of t){if(e!=null){n=false;break}}if(n){return}const e=[];for(let n=0;n<t.length;++n){const s=t[n].slice();s.splice(this.axis,1);let o=false;for(const t of e){if(w(t,s)){o=true;break}}if(!o){e.push(s)}}if(e.length>1){throw new gw("A `Concatenate` layer requires inputs with matching shapes "+"except for the concat axis. Got input shapes: "+JSON.stringify(t))}}mergeFunction(t){return Wi((()=>Sv(t,this.axis)))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))){throw new gw("A `Concatenate` layer should be called on a list of inputs.")}const n=t;const e=n[0].slice();const s=this.axis<0?e.length+this.axis:this.axis;for(const t of n.slice(1)){if(e[s]==null||t[s]==null){e[s]=null;break}e[s]+=t[s]}return e}computeMask(t,n){if(n==null){return null}if(!Array.isArray(n)){throw new gw("`mask` should be an array for Concatenate")}if(!Array.isArray(t)){throw new gw("`inputs` should be an array for Concatenate")}if(n.length!==t.length){throw new gw(`Mismatch in the length of mask (${n.length}) `+`and the legnth of inputs (${t.length})`)}return Wi((()=>{let e=true;n.forEach((t=>{if(t!=null){e=false;return}}));if(e){return null}const s=[];for(let e=0;e<t.length;++e){if(n[e]==null){s.push(Mi(Af(t[e]),"bool"))}else if(n[e].rank<t[e].rank){s.push(ol(n[e],-1))}else{s.push(n[e])}}const o=Yc(s,this.axis);return ac(o,-1,false)}))}getConfig(){const t={axis:this.axis};const n=super.getConfig();Object.assign(t,n);return t}}$N.className="Concatenate";Zp($N);function yN(t,n){while(t<0){t+=n}return t}function kN(t,n,e){if(t.shape.length>3||n.shape.length>3){throw new ww("batchDot is not implemented for tensors of 4D or higher rank yet")}m(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, `+`but got ${t.shape.length}`));m(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, `+`but got ${n.shape.length}`));if(typeof e==="number"){e=[e,e]}if(t.dtype==="complex64"||n.dtype==="complex64"){throw new ww("batchDot is not implemented for complex64-type Tensors yet.")}const s=t.shape.length;const o=n.shape.length;if(e==null){e=[s-1,o-2]}const r=e;return Wi((()=>{let e;if(s>o){e=s-o;const t=[];for(let n=0;n<e;++n){t.push(1)}n=Hc(n,n.shape.concat(t))}else if(o>s){e=o-s;const n=[];for(let t=0;t<e;++t){n.push(1)}t=Hc(t,t.shape.concat(n))}else{e=0}let i;if(t.shape.length===2&&n.shape.length===2){if(r[0]===r[1]){i=Ku(tc(t,n),r[0])}else{i=Ku(tc(Od(t,[1,0]),n),r[1])}}else{const e=r[0]!==t.shape.length-1;const s=r[1]===n.shape.length-1;i=Qc(t,n,e,s)}if(e>0){let t;if(s>o){t=s+o-3}else{t=s-1}const n=[];for(let s=t;s<t+e;++s){n.push(s)}i=rd(i,n)}if(i.shape.length===1){i=ol(i,1)}return i}))}class CN extends mN{constructor(t){super(t);this.axes=t.axes;this.normalize=t.normalize==null?false:t.normalize;this.supportsMasking=true;this.reshapeRequired=false}build(t){m(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const n=t[0];const e=t[1];if(n.length>3||e.length>3){throw new ww("Dot layer does not support tensors of 4D or higher rank yet.")}const s=this.interpretAxes(n,e);if(n[s[0]]!==e[s[1]]){throw new gw(`Dimension incompatibility: `+`${n[s[0]]} !== ${e[s[1]]}`)}}mergeFunction(t){if(t.length!==2){throw new gw("A `Dot` layer must be called on exactly 2 inputs, "+`but received ${t.length} input(s).`)}let n=t[0];let e=t[1];let s;if(!Array.isArray(this.axes)){s=[yN(this.axes,n.shape.length),yN(this.axes,e.shape.length)]}else{s=this.axes.map(((n,e)=>yN(n,t[e].shape.length)))}if(this.normalize){n=my(n,s[0]);e=my(e,s[1])}return kN(n,e,s)}interpretAxes(t,n){let e;if(!Array.isArray(this.axes)){e=[yN(this.axes,t.length),yN(this.axes,n.length)]}else{e=this.axes}return e}computeOutputShape(t){m(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const n=t[0].slice();const e=t[1].slice();if(n.length>3||e.length>3){throw new ww("Dot layer does not support tensors of 4D or higher rank yet.")}const s=this.interpretAxes(n,e);n.splice(s[0],1);e.splice(s[1],1);e.splice(0,1);const o=n.concat(e);if(o.length===1){o.push(1)}return o}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize};const n=super.getConfig();Object.assign(t,n);return t}}CN.className="Dot";Zp(CN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class NN extends S${constructor(t){super(t);this.supportsMasking=true;this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={stddev:this.stddev};Object.assign(n,t);return n}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);const s=()=>Xi(Iv(e.shape,0,this.stddev),e);const o=Vv(s,(()=>e),n["training"]||false);return o}))}}NN.className="GaussianNoise";Zp(NN);class RN extends S${constructor(t){super(t);this.supportsMasking=true;this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={rate:this.rate};Object.assign(n,t);return n}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);const e=p$(t);if(this.rate>0&&this.rate<1){const t=()=>{const t=Math.sqrt(this.rate/(1-this.rate));return tc(e,Iv(e.shape,1,t))};return Vv(t,(()=>e),n["training"]||false)}return e}))}}RN.className="GaussianDropout";Zp(RN);class SN extends S${constructor(t){super(t);this.supportsMasking=true;this.rate=t.rate;this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||p$(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig();const n={rate:this.rate};Object.assign(n,t);return n}call(t,n){return Wi((()=>{if(this.rate<1&&this.rate>0){const e=this._getNoiseShape(t);const s=()=>{const n=p$(t);const s=1.6732632423543772;const o=1.0507009873554805;const r=-s*o;let i=gl(lh(e),this.rate);i=wv(i,"float32");const c=((1-this.rate)*(1+this.rate*r**2))**-.5;const a=-c*r*this.rate;const u=Xi(tc(n,i),tc(Xi(i,-1),r));return Xi(tc(u,c),a)};return Vv(s,(()=>p$(t)),n["training"]||false)}return t}))}}SN.className="AlphaDropout";Zp(SN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EN(t,n,e,s,o,r=.001){let i;if(t.rank===2){i=ha(t,n,e,s,o,r)}else if(t.rank===3){i=pa(t,n,e,s,o,r)}else if(t.rank===4){i=xa(t,n,e,s,o,r)}else{throw new ww(`batchNormalization is not implemented for array of rank ${t.rank} `+`yet`)}return i}function TN(t,n,e,s,o=.001){return Wi((()=>{const r=Nf(t,s);const i=r.mean;const c=r.variance;const a=EN(t,i,c,e,n,o);return[a,i,c]}))}function IN(t,n,e,s,o=.001){return Wi((()=>{const r=Nf(t,s);const i=r.mean;const c=r.variance;const a=[];for(const n of mv(0,t.rank)){if(s.indexOf(n)!==-1){a.push(1)}else{a.push(t.shape[n])}}const u=Hc(i,a);const l=Hc(c,a);const f=n==null?null:Hc(n,a);const h=e==null?null:Hc(e,a);const d=EN(t,u,l,h,f,o);return[d,i,c]}))}function AN(t,n,e,s,o=.001){if(w(s.slice().sort(),mv(0,t.rank-1))){return TN(t,n,e,s,o)}else{return IN(t,n,e,s,o)}}class ON extends S${constructor(t){if(t==null){t={}}super(t);this.supportsMasking=true;this.axis=t.axis==null?-1:t.axis;this.momentum=t.momentum==null?.99:t.momentum;this.epsilon=t.epsilon==null?.001:t.epsilon;this.center=t.center==null?true:t.center;this.scale=t.scale==null?true:t.scale;this.betaInitializer=f$(t.betaInitializer||"zeros");this.gammaInitializer=f$(t.gammaInitializer||"ones");this.movingMeanInitializer=f$(t.movingMeanInitializer||"zeros");this.movingVarianceInitializer=f$(t.movingVarianceInitializer||"ones");this.betaConstraint=ny(t.betaConstraint);this.gammaConstraint=ny(t.gammaConstraint);this.betaRegularizer=mC(t.betaRegularizer);this.gammaRegularizer=mC(t.gammaRegularizer)}build(t){t=m$(t);const n=this.axis>=0?this.axis:this.axis+t.length;const e=t[n];if(e==null){throw new gw(`Axis ${n} of input tensor should have a defined dimension but `+`the layer received an input with shape `+`${JSON.stringify(t)}.`)}this.inputSpec=[new y$({ndim:t.length,axes:{[n]:e}})];const s=[e];if(this.scale){this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,true,this.gammaConstraint)}if(this.center){this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,true,this.betaConstraint)}this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,false);this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,false);this.built=true}call(t,n){return Wi((()=>{const e=n["training"]==null?false:n["training"];const s=p$(t);const o=s.shape;const r=o.length;const i=mv(0,r);const c=this.axis>=0?this.axis:this.axis+r;i.splice(c,1);const a=yw(1,r);a[c]=o[c];const u=i.slice();u.sort();const l=!w(u,mv(0,r).slice(0,r-1));const f=()=>{if(l){const t=Hc(this.movingMean.read(),a);const n=Hc(this.movingVariance.read(),a);const e=this.center?Hc(this.beta.read(),a):null;const o=this.scale?Hc(this.gamma.read(),a):null;return EN(s,t,n,e,o,this.epsilon)}else{return EN(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)}};if(!e){return f()}const[h,d,p]=AN(s,this.gamma.read(),this.beta.read(),i,this.epsilon);const m=(t,n,e)=>{Wi((()=>{const s=1-e;const o=t.read();const r=tc(Xl(o,n),s);t.write(Xl(o,r))}))};const x=()=>{m(this.movingMean,d,this.momentum);m(this.movingVariance,p,this.momentum)};x();return h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:l$(this.betaInitializer),gammaInitializer:l$(this.gammaInitializer),movingMeanInitializer:l$(this.movingMeanInitializer),movingVarianceInitializer:l$(this.movingVarianceInitializer),betaRegularizer:dC(this.betaRegularizer),gammaRegularizer:dC(this.gammaRegularizer),betaConstraint:Q$(this.betaConstraint),gammaConstraint:Q$(this.gammaConstraint)};const n=super.getConfig();Object.assign(t,n);return t}}ON.className="BatchNormalization";Zp(ON);class FN extends S${constructor(t){if(t==null){t={}}super(t);this.axis=t.axis==null?-1:t.axis;if(typeof this.axis==="number"){if(!Number.isInteger(this.axis)){throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}}else if(Array.isArray(this.axis)){for(const t of this.axis){if(!Number.isInteger(t)){throw new Error(`Expected axis to be an array of integers, `+`but received ${JSON.stringify(this.axis)}`)}}}else{throw new Error(`Expected axis to be an integer or an array of integers, `+`but received ${JSON.stringify(this.axis)}`)}this.epsilon=t.epsilon==null?.001:t.epsilon;this.center=t.center==null?true:t.center;this.scale=t.scale==null?true:t.scale;this.betaInitializer=f$(t.betaInitializer||"zeros");this.gammaInitializer=f$(t.gammaInitializer||"ones");this.betaRegularizer=mC(t.betaRegularizer);this.gammaRegularizer=mC(t.gammaRegularizer);this.supportsMasking=true}build(t){t=m$(t);const n=t.length;if(typeof this.axis==="number"){this.axis=[this.axis]}for(let t=0;t<this.axis.length;++t){if(this.axis[t]<0){this.axis[t]+=n}}for(const t of this.axis){if(t<0||t>=n){throw new Error(`Invalid axis: ${t}`)}}if(this.axis.length!==Mw(this.axis).length){throw new Error(`Found duplicate axes in: ${this.axis}`)}const e=this.axis.map((n=>t[n]));const s=true;if(this.scale){this.gamma=this.addWeight("gamma",e,"float32",this.gammaInitializer,this.gammaRegularizer,s)}else{this.gamma=null}if(this.center){this.beta=this.addWeight("beta",e,"float32",this.betaInitializer,this.betaRegularizer,s)}else{this.beta=null}this.built=true}call(t,n){const e=p$(t);const s=e.shape;const o=s.length;return Wi((()=>{const t=true;let{mean:n,variance:r}=Nf(e,this.axis,t);const i=yw(1,o);for(const t of this.axis){i[t]=s[t]}const c=t=>{if(t!=null&&t.shape.length!==o){return Hc(t,i)}else{return t}};let a=this.scale?c(this.gamma.read()):null;let u=this.center?c(this.beta.read()):null;const l=[];const f=[];for(let t=0;t<o;++t){if(this.axis.indexOf(t)!==-1){l.push(s[t]);f.push(1)}else{l.push(1);f.push(s[t])}}n=al(n,l);r=al(r,l);if(a!=null){a=al(a,f)}if(u!=null){u=al(u,f)}return EN(e,n,r,u,a,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:l$(this.betaInitializer),gammaInitializer:l$(this.gammaInitializer),betaRegularizer:dC(this.betaRegularizer),gammaRegularizer:dC(this.gammaRegularizer)};const n=super.getConfig();Object.assign(t,n);return t}}FN.className="LayerNormalization";Zp(FN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _N(t,n,e){return Wi((()=>{if(t.rank!==4){throw new gw(`temporalPadding expects input tensor to be 4-D, but received a `+`${t.rank}-D tensor.`)}if(n==null){n=[[1,1],[1,1]]}if(n.length!==2||n[0].length!==2||n[1].length!==2){throw new gw("spatial2dPadding expects `padding` to be an Array of two Arrays, "+"each of which is an Array of two integers.")}if(e==null){e=gv()}if(e!=="channelsLast"&&e!=="channelsFirst"){throw new gw(`Unknown data format: ${e}. `+`Supported data formats are 'channelsLast' and 'channelsFirst.`)}let s;if(e==="channelsFirst"){s=[[0,0],[0,0],n[0],n[1]]}else{s=[[0,0],n[0],n[1],[0,0]]}return Ff(t,s)}))}class MN extends S${constructor(t){if(t==null){t={}}super(t);this.dataFormat=t.dataFormat==null?gv():t.dataFormat;if(t.padding==null){this.padding=[[1,1],[1,1]]}else if(typeof t.padding==="number"){this.padding=[[t.padding,t.padding],[t.padding,t.padding]]}else{t.padding=t.padding;if(t.padding.length!==2){throw new gw(`ZeroPadding2D expects padding to be a length-2 array, but `+`received a length-${t.padding.length} array.`)}let n;let e;if(typeof t.padding[0]==="number"){n=[t.padding[0],t.padding[0]];e=[t.padding[1],t.padding[1]]}else{t.padding=t.padding;if(t.padding[0].length!==2){throw new gw(`ZeroPadding2D expects height padding to be a length-2 array, `+`but received a length-${t.padding[0].length} array.`)}n=t.padding[0];if(t.padding[1].length!==2){throw new gw(`ZeroPadding2D expects width padding to be a length-2 array, `+`but received a length-${t.padding[1].length} array.`)}e=t.padding[1]}this.padding=[n,e]}this.inputSpec=[new y$({ndim:4})]}computeOutputShape(t){t=m$(t);let n;let e;if(this.dataFormat==="channelsFirst"){if(t[2]!=null&&t[2]>=0){n=t[2]+this.padding[0][0]+this.padding[0][1]}else{n=null}if(t[3]!=null&&t[3]>=0){e=t[3]+this.padding[1][0]+this.padding[1][1]}else{e=null}return[t[0],t[1],n,e]}else{if(t[1]!=null&&t[1]>=0){n=t[1]+this.padding[0][0]+this.padding[0][1]}else{n=null}if(t[2]!=null&&t[2]>=0){e=t[2]+this.padding[1][0]+this.padding[1][1]}else{e=null}return[t[0],n,e,t[3]]}}call(t,n){return Wi((()=>_N(p$(t),this.padding,this.dataFormat)))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}MN.className="ZeroPadding2D";Zp(MN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DN(t,n,e,s,o,r){return Wi((()=>{Qw(o);ev(r);nv(s);if(e==null){e=[1,1]}if(s==null){s="valid"}if(o==null){o=gv()}if(r==null){r="max"}t=NC(t,o);let i;const c=s==="same"?"same":"valid";if(r==="max"){i=uf(t,n,e,c)}else{i=qc(t,n,e,c)}if(o==="channelsFirst"){i=Od(i,[0,3,1,2])}return i}))}function LN(t,n,e,s,o,r){return Wi((()=>{Qw(o);ev(r);nv(s);if(e==null){e=[1,1,1]}if(s==null){s="valid"}if(o==null){o=gv()}if(r==null){r="max"}t=RC(t,o);let i;const c=s==="same"?"same":"valid";if(r==="max"){i=ff(t,n,e,c)}else{i=Kc(t,n,e,c)}if(o==="channelsFirst"){i=Od(i,[0,4,1,2,3])}return i}))}class zN extends S${constructor(t){if(t.poolSize==null){t.poolSize=2}super(t);if(typeof t.poolSize==="number"){this.poolSize=[t.poolSize]}else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]==="number"){this.poolSize=t.poolSize}else{throw new gw(`poolSize for 1D convolutional layer must be a number or an `+`Array of a single number, but received `+`${JSON.stringify(t.poolSize)}`)}Pw(this.poolSize,"poolSize");if(t.strides==null){this.strides=this.poolSize}else{if(typeof t.strides==="number"){this.strides=[t.strides]}else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]==="number"){this.strides=t.strides}else{throw new gw(`strides for 1D convolutional layer must be a number or an `+`Array of a single number, but received `+`${JSON.stringify(t.strides)}`)}}Pw(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;nv(this.padding);this.inputSpec=[new y$({ndim:3})]}computeOutputShape(t){t=m$(t);const n=kC(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);t=vv(p$(t),2);const e=this.poolingFunction(p$(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return rd(e,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides};const n=super.getConfig();Object.assign(t,n);return t}}class PN extends zN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return DN(t,n,e,s,o,"max")}}PN.className="MaxPooling1D";Zp(PN);class VN extends zN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return DN(t,n,e,s,o,"avg")}}VN.className="AveragePooling1D";Zp(VN);class BN extends S${constructor(t){if(t.poolSize==null){t.poolSize=[2,2]}super(t);this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize];if(t.strides==null){this.strides=this.poolSize}else if(Array.isArray(t.strides)){if(t.strides.length!==2){throw new gw(`If the strides property of a 2D pooling layer is an Array, `+`it is expected to have a length of 2, but received length `+`${t.strides.length}.`)}this.strides=t.strides}else{this.strides=[t.strides,t.strides]}Pw(this.poolSize,"poolSize");Pw(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;Qw(this.dataFormat);nv(this.padding);this.inputSpec=[new y$({ndim:4})]}computeOutputShape(t){t=m$(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1];let e=this.dataFormat==="channelsFirst"?t[3]:t[2];n=kC(n,this.poolSize[0],this.padding,this.strides[0]);e=kC(e,this.poolSize[1],this.padding,this.strides[1]);if(this.dataFormat==="channelsFirst"){return[t[0],t[1],n,e]}else{return[t[0],n,e,t[3]]}}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);return this.poolingFunction(p$(t),this.poolSize,this.strides,this.padding,this.dataFormat)}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class WN extends BN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return DN(t,n,e,s,o,"max")}}WN.className="MaxPooling2D";Zp(WN);class GN extends BN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return DN(t,n,e,s,o,"avg")}}GN.className="AveragePooling2D";Zp(GN);class UN extends S${constructor(t){if(t.poolSize==null){t.poolSize=[2,2,2]}super(t);this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize];if(t.strides==null){this.strides=this.poolSize}else if(Array.isArray(t.strides)){if(t.strides.length!==3){throw new gw(`If the strides property of a 3D pooling layer is an Array, `+`it is expected to have a length of 3, but received length `+`${t.strides.length}.`)}this.strides=t.strides}else{this.strides=[t.strides,t.strides,t.strides]}Pw(this.poolSize,"poolSize");Pw(this.strides,"strides");this.padding=t.padding==null?"valid":t.padding;this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;Qw(this.dataFormat);nv(this.padding);this.inputSpec=[new y$({ndim:5})]}computeOutputShape(t){t=m$(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1];let e=this.dataFormat==="channelsFirst"?t[3]:t[2];let s=this.dataFormat==="channelsFirst"?t[4]:t[3];n=kC(n,this.poolSize[0],this.padding,this.strides[0]);e=kC(e,this.poolSize[1],this.padding,this.strides[1]);s=kC(s,this.poolSize[2],this.padding,this.strides[2]);if(this.dataFormat==="channelsFirst"){return[t[0],t[1],n,e,s]}else{return[t[0],n,e,s,t[4]]}}call(t,n){return Wi((()=>{this.invokeCallHook(t,n);return this.poolingFunction(p$(t),this.poolSize,this.strides,this.padding,this.dataFormat)}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class HN extends UN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return LN(t,n,e,s,o,"max")}}HN.className="MaxPooling3D";Zp(HN);class jN extends UN{constructor(t){super(t)}poolingFunction(t,n,e,s,o){Qw(o);nv(s);return LN(t,n,e,s,o,"avg")}}jN.className="AveragePooling3D";Zp(jN);class qN extends S${constructor(t){super(t);this.inputSpec=[new y$({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new ww}}class XN extends qN{constructor(t){super(t||{})}call(t,n){return Wi((()=>{const n=p$(t);return mf(n,1)}))}}XN.className="GlobalAveragePooling1D";Zp(XN);class KN extends qN{constructor(t){super(t||{})}call(t,n){return Wi((()=>{const n=p$(t);return zu(n,1)}))}}KN.className="GlobalMaxPooling1D";Zp(KN);class JN extends S${constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat;Qw(this.dataFormat);this.inputSpec=[new y$({ndim:4})]}computeOutputShape(t){t=t;if(this.dataFormat==="channelsLast"){return[t[0],t[3]]}else{return[t[0],t[1]]}}call(t,n){throw new ww}getConfig(){const t={dataFormat:this.dataFormat};const n=super.getConfig();Object.assign(t,n);return t}}class YN extends JN{call(t,n){return Wi((()=>{const n=p$(t);if(this.dataFormat==="channelsLast"){return mf(n,[1,2])}else{return mf(n,[2,3])}}))}}YN.className="GlobalAveragePooling2D";Zp(YN);class ZN extends JN{call(t,n){return Wi((()=>{const n=p$(t);if(this.dataFormat==="channelsLast"){return zu(n,[1,2])}else{return zu(n,[2,3])}}))}}ZN.className="GlobalMaxPooling2D";Zp(ZN);
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QN extends S${constructor(t){super(t);this.layer=t.layer}build(t){this.built=true}get trainable(){if(this.layer!=null){return this.layer.trainable}else{return false}}set trainable(t){if(this.layer!=null){this.layer.trainable=t}}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}};const n=super.getConfig();Object.assign(t,n);return t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.layer!=null){this.layer.setFastWeightInitDuringBuild(t)}}static fromConfig(t,n,e={}){const s=n["layer"];const o=py(s,e);delete n["layer"];const r={layer:o};Object.assign(r,n);return new t(r)}}class tR extends QN{constructor(t){super(t);this.supportsMasking=true}build(t){t=m$(t);if(t.length<3){throw new gw(`TimeDistributed layer expects an input shape >= 3D, but received `+`input shape ${JSON.stringify(t)}`)}this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));if(!this.layer.built){this.layer.build(n);this.layer.built=true}super.build(t)}computeOutputShape(t){t=m$(t);const n=[t[0]].concat(t.slice(2));const e=this.layer.computeOutputShape(n);const s=t[1];return[e[0],s].concat(e.slice(1))}call(t,n){return Wi((()=>{t=p$(t);const e=(t,e)=>{const s=p$(this.layer.call(t,n));return[s,[]]};const s=UC(e,t,[],false,null,null,false,true);const o=s[1];return o}))}}tR.className="TimeDistributed";Zp(tR);function nR(t){Lw(Yw,"BidirectionalMergeMode",t)}const eR="concat";class sR extends QN{constructor(t){super(t);const n=t.layer.getConfig();const e={};e["className"]=t.layer.getClassName();e["config"]=n;this.forwardLayer=py(e);n["goBackwards"]=n["goBackwards"]===true?false:true;const s={};s["className"]=t.layer.getClassName();s["config"]=n;this.backwardLayer=py(s);this.forwardLayer.name="forward_"+this.forwardLayer.name;this.backwardLayer.name="backward_"+this.backwardLayer.name;this.mergeMode=t.mergeMode===undefined?eR:t.mergeMode;nR(this.mergeMode);if(t.weights){throw new ww("weights support is not implemented for Bidirectional layer yet.")}this._stateful=t.layer.stateful;this.returnSequences=t.layer.returnSequences;this.returnState=t.layer.returnState;this.supportsMasking=true;this._trainable=true;this.inputSpec=t.layer.inputSpec;this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t;if(this.forwardLayer!=null){this.forwardLayer.trainable=t}if(this.backwardLayer!=null){this.backwardLayer.trainable=t}}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length;const e=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,e));this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);if(!(Array.isArray(n)&&Array.isArray(n[0]))){n=[n]}n=n;let e;let s;let o;if(this.returnState){o=n.slice(1);e=n[0]}else{e=n[0]}e=e;if(this.mergeMode==="concat"){e[e.length-1]*=2;s=[e]}else if(this.mergeMode==null){s=[e,e.slice()]}else{s=[e]}if(this.returnState){if(this.mergeMode==null){return s.concat(o).concat(o.slice())}return[e].concat(o).concat(o.slice())}return Nw(s)}apply(t,n){let e=n==null?null:n["initialState"];let s=n==null?null:n["constants"];if(n==null){n={}}const o=GC(t,e,s,this.numConstants);t=o.inputs;e=o.initialState;s=o.constants;if(Array.isArray(t)){e=t.slice(1);t=t[0]}if((e==null||e.length===0)&&s==null){return super.apply(t,n)}const r=[];const i=[];if(e!=null){const t=e.length;if(t%2>0){throw new gw("When passing `initialState` to a Bidrectional RNN, "+"the state should be an Array containing the states of "+"the underlying RNNs.")}n["initialState"]=e;r.push(...e);const s=e.map((t=>new y$({shape:t.shape})));this.forwardLayer.stateSpec=s.slice(0,t/2);this.backwardLayer.stateSpec=s.slice(t/2);i.push(...s)}if(s!=null){throw new ww("Support for constants in Bidirectional layers is not "+"implemented yet.")}const c=r[0]instanceof k$;for(const t of r){if(t instanceof k$!==c){throw new gw("The initial state of a Bidirectional layer cannot be "+"specified as a mix of symbolic and non-symbolic tensors")}}if(c){const e=[t].concat(r);const s=this.inputSpec.concat(i);const o=this.inputSpec;this.inputSpec=s;const c=super.apply(e,n);this.inputSpec=o;return c}else{return super.apply(t,n)}}call(t,n){return Wi((()=>{const e=n["initialState"];let s;let o;if(e==null){s=this.forwardLayer.call(t,n);o=this.backwardLayer.call(t,n)}else{const r=e.slice(0,e.length/2);const i=e.slice(e.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:r}));o=this.backwardLayer.call(t,Object.assign(n,{initialState:i}))}let r;if(this.returnState){if(Array.isArray(s)){r=s.slice(1).concat(o.slice(1))}s=s[0];o=o[0]}if(this.returnSequences){o=$h(o,1)}let i;if(this.mergeMode==="concat"){i=Sv([s,o])}else if(this.mergeMode==="sum"){i=Xi(s,o)}else if(this.mergeMode==="ave"){i=tc(.5,Xi(s,o))}else if(this.mergeMode==="mul"){i=tc(s,o)}else if(this.mergeMode==null){i=[s,o]}if(this.returnState){if(this.mergeMode==null){return i.concat(r)}return[i].concat(r)}return i}))}resetStates(t){this.forwardLayer.resetStates();this.backwardLayer.resetStates()}build(t){rv(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)}));rv(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)}));this.built=true}computeMask(t,n){if(Array.isArray(n)){n=n[0]}let e;if(this.returnSequences){if(this.mergeMode==null){e=[n,n]}else{e=n}}else{if(this.mergeMode==null){e=[null,null]}else{e=null}}if(this.returnState){const t=this.forwardLayer.states;const n=t.map((t=>null));if(Array.isArray(e)){return e.concat(n).concat(n)}else{return[e].concat(n).concat(n)}}else{return e}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t);if(this.forwardLayer!=null){this.forwardLayer.setFastWeightInitDuringBuild(t)}if(this.backwardLayer!=null){this.backwardLayer.setFastWeightInitDuringBuild(t)}}getConfig(){const t={mergeMode:this.mergeMode};const n=super.getConfig();Object.assign(t,n);return t}static fromConfig(t,n){const e=py(n["layer"]);delete n["layer"];if(n["numConstants"]!=null){throw new ww(`Deserialization of a Bidirectional layer with numConstants `+`present is not supported yet.`)}const s=n;s["layer"]=e;return new t(s)}}sR.className="Bidirectional";Zp(sR);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oR extends S${constructor(t){super(t);this.scale=t.scale;if(t.offset){this.offset=t.offset}else{this.offset=0}}getConfig(){const t={scale:this.scale,offset:this.offset};const n=super.getConfig();Object.assign(t,n);return t}call(t,n){return Wi((()=>{t=p$(t);if(t.dtype!=="float32"){t=wv(t,"float32")}return Xi(tc(t,this.scale),this.offset)}))}}oR.className="Rescaling";Zp(oR);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:rR,cropAndResize:iR}=jp;class cR extends S${constructor(t){super(t);this.height=t.height;this.width=t.width}centerCrop(t,n,e,s,o,r,i,c){return Wi((()=>{let a;let u=false;const l=n/r;const f=e/i;const h=(s+n)/r;const d=(o+e)/i;const p=[l,f,h,d];const m=[];if(t.rank===3){u=true;a=cd([t])}else{a=t}for(let t=0;t<a.shape[0];t++){m.push(p)}const x=Lr(m,[m.length,4]);const b=fh(0,m.length,1,"int32");const g=[s,o];const w=iR(a,x,b,g,"nearest");if(u){return wv(p$(Ed(w)),c)}return wv(w,c)}))}upsize(t,n,e,s){return Wi((()=>{const o=rR(t,[n,e]);return wv(o,s)}))}call(t,n){return Wi((()=>{const n=p$(t);const e=n.dtype;const s=n.shape;const o=s[s.length-3];const r=s[s.length-2];let i=0;if(o!==this.height){i=Math.floor((o-this.height)/2)}let c=0;if(r!==this.width){c=Math.floor((r-this.width)/2);if(c===0){c=1}}if(i>=0&&c>=0){return this.centerCrop(n,i,c,this.height,this.width,o,r,e)}else{return this.upsize(t,this.height,this.width,e)}}))}getConfig(){const t={height:this.height,width:this.width};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=m$(t);const n=t.length-3;const e=t.length-2;t[n]=this.height;t[e]=this.width;return t}}cR.className="CenterCrop";Zp(cR);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aR(t,n,e,s){let o=p$(t);if(o.dtype!=="int32"){o=wv(o,"int32")}if(n==="int"){return o}const r=o.shape;if(o.rank===0){o=ol(o,-1)}if(n==="oneHot"){if(o.shape[o.shape.length-1]!==1){o=ol(o,-1)}}if(o.rank>2){throw new gw(`When outputMode is not int, maximum output rank is 2`+` Received outputMode ${n} and input shape ${r}`+` which would result in output rank ${o.rank}.`)}const i=["multiHot","oneHot"].includes(n);const c=o;let a;if(typeof s!=="undefined"&&n==="count"){a=su(c,s,e,i)}else{a=su(c,[],e,i)}if(n!=="tfIdf"){return a}if(s){return tc(a,s)}else{throw new gw(`When outputMode is 'tfIdf', weights must be provided.`)}}
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class uR extends S${constructor(t){super(t);this.numTokens=t.numTokens;if(t.outputMode){this.outputMode=t.outputMode}else{this.outputMode="multiHot"}}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=m$(t);if(t==null){return[this.numTokens]}if(this.outputMode==="oneHot"&&t[t.length-1]!==1){t.push(this.numTokens);return t}t[t.length-1]=this.numTokens;return t}call(t,n){return Wi((()=>{t=p$(t);if(t.dtype!=="int32"){t=wv(t,"int32")}let e;if(typeof n["countWeights"]!=="undefined"){if(this.outputMode!=="count"){throw new gw(`countWeights is not used when outputMode !== count.\n              Received countWeights=${n["countWeights"]}`)}e=p$(n["countWeights"])}const s=zu(t);const o=Vu(t);const r=xl(this.numTokens,s).bufferSync().get(0);const i=gl(o,0).bufferSync().get(0);if(!(r&&i)){throw new gw("Input values must be between 0 < values <="+` numTokens with numTokens=${this.numTokens}`)}return aR(t,this.outputMode,this.numTokens,e)}))}}uR.className="CategoryEncoding";Zp(uR);
/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lR=["bilinear","nearest"];const fR=new Set(lR);class hR extends S${constructor(t){super(t);this.height=t.height;this.width=t.width;if(t.interpolation){if(fR.has(t.interpolation)){this.interpolation=t.interpolation}else{throw new gw(`Invalid interpolation parameter: ${t.interpolation} is not implemented`)}}else{this.interpolation="bilinear"}this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){t=m$(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio};const n=super.getConfig();Object.assign(t,n);return t}call(t,n){return Wi((()=>{const n=[this.height,this.width];if(this.interpolation==="bilinear"){return jp.resizeBilinear(t,n,!this.cropToAspectRatio)}else if(this.interpolation==="nearest"){return jp.resizeNearestNeighbor(t,n,!this.cropToAspectRatio)}else{throw new Error(`Interpolation is ${this.interpolation} but only ${[...fR]} are supported`)}}))}}hR.className="Resizing";Zp(hR);
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dR{constructor(t){this.seed=t}next(){if(this.seed===undefined){return undefined}return this.seed++}}dR.className="RandomSeed";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pR extends S${constructor(t){super(t);this.randomGenerator=new dR(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed};const n=super.getConfig();Object.assign(t,n);return t}}pR.className="BaseRandomLayer";
/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const mR=["bilinear","nearest"];const xR=new Set(mR);class bR extends pR{constructor(t){super(t);const{factor:n,interpolation:e="bilinear"}=t;this.factor=n;if(Array.isArray(this.factor)&&this.factor.length===2){this.widthLower=this.factor[0];this.widthUpper=this.factor[1]}else if(!Array.isArray(this.factor)&&this.factor>0){this.widthLower=-this.factor;this.widthUpper=this.factor}else{throw new gw(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`)}if(this.widthLower<-1||this.widthUpper<-1){throw new gw(`factor must have values larger than -1. Got: ${this.factor}`)}if(this.widthUpper<this.widthLower){throw new gw(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `)}if(e){if(xR.has(e)){this.interpolation=e}else{throw new gw(`Invalid interpolation parameter: ${e} is not implemented`)}}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation};const n=super.getConfig();Object.assign(t,n);return t}computeOutputShape(t){t=m$(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return Wi((()=>{const n=p$(t);this.imgHeight=n.shape[n.shape.length-3];const e=n.shape[n.shape.length-2];this.widthFactor=lh([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*e;s=Math.round(s);const o=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return jp.resizeBilinear(t,o);case"nearest":return jp.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...xR]} are supported`)}}))}}bR.className="RandomWidth";Zp(bR);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gR=et();gR.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>false),(t=>{if(t){console.warn("Keep intermediate tensors is ON. This will print the values of all "+"intermediate tensors during model inference. Not all models "+"support this mode. For details, check e2e/benchmarks/ "+"model_config.js. This significantly impacts performance.")}}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var wR;(function(t){t[t["DT_INVALID"]=0]="DT_INVALID";t[t["DT_FLOAT"]=1]="DT_FLOAT";t[t["DT_DOUBLE"]=2]="DT_DOUBLE";t[t["DT_INT32"]=3]="DT_INT32";t[t["DT_UINT8"]=4]="DT_UINT8";t[t["DT_INT16"]=5]="DT_INT16";t[t["DT_INT8"]=6]="DT_INT8";t[t["DT_STRING"]=7]="DT_STRING";t[t["DT_COMPLEX64"]=8]="DT_COMPLEX64";t[t["DT_INT64"]=9]="DT_INT64";t[t["DT_BOOL"]=10]="DT_BOOL";t[t["DT_QINT8"]=11]="DT_QINT8";t[t["DT_QUINT8"]=12]="DT_QUINT8";t[t["DT_QINT32"]=13]="DT_QINT32";t[t["DT_BFLOAT16"]=14]="DT_BFLOAT16";t[t["DT_QINT16"]=15]="DT_QINT16";t[t["DT_QUINT16"]=16]="DT_QUINT16";t[t["DT_UINT16"]=17]="DT_UINT16";t[t["DT_COMPLEX128"]=18]="DT_COMPLEX128";t[t["DT_HALF"]=19]="DT_HALF";t[t["DT_RESOURCE"]=20]="DT_RESOURCE";t[t["DT_VARIANT"]=21]="DT_VARIANT";t[t["DT_UINT32"]=22]="DT_UINT32";t[t["DT_UINT64"]=23]="DT_UINT64";t[t["DT_FLOAT_REF"]=101]="DT_FLOAT_REF";t[t["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF";t[t["DT_INT32_REF"]=103]="DT_INT32_REF";t[t["DT_UINT8_REF"]=104]="DT_UINT8_REF";t[t["DT_INT16_REF"]=105]="DT_INT16_REF";t[t["DT_INT8_REF"]=106]="DT_INT8_REF";t[t["DT_STRING_REF"]=107]="DT_STRING_REF";t[t["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF";t[t["DT_INT64_REF"]=109]="DT_INT64_REF";t[t["DT_BOOL_REF"]=110]="DT_BOOL_REF";t[t["DT_QINT8_REF"]=111]="DT_QINT8_REF";t[t["DT_QUINT8_REF"]=112]="DT_QUINT8_REF";t[t["DT_QINT32_REF"]=113]="DT_QINT32_REF";t[t["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF";t[t["DT_QINT16_REF"]=115]="DT_QINT16_REF";t[t["DT_QUINT16_REF"]=116]="DT_QUINT16_REF";t[t["DT_UINT16_REF"]=117]="DT_UINT16_REF";t[t["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF";t[t["DT_HALF_REF"]=119]="DT_HALF_REF";t[t["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF";t[t["DT_VARIANT_REF"]=121]="DT_VARIANT_REF";t[t["DT_UINT32_REF"]=122]="DT_UINT32_REF";t[t["DT_UINT64_REF"]=123]="DT_UINT64_REF"})(wR||(wR={}));var vR;(function(t){(function(t){t[t["LEGACY"]=0]="LEGACY";t[t["V1"]=1]="V1";t[t["V2"]=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(vR||(vR={}));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var $R;(function(t){t[t["FAIL"]=0]="FAIL";t[t["SHORTEST"]=1]="SHORTEST";t[t["LONGEST"]=2]="LONGEST"})($R||($R={}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(t,n){if(!Array.isArray(t)){t=[t]}t.forEach((t=>{if(t!=null){m(t.dtype!=="complex64",(()=>`${n} does not support complex64 tensors in the CPU backend.`))}}))}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=Id;class CR extends a{nextDataId(){return CR.nextDataId++}constructor(){super();this.blockSize=48;this.firstUse=true;this.data=new c(this,Vi())}write(t,n,e){if(this.firstUse){this.firstUse=false;if(et().get("IS_NODE")){ks("\n============================\n"+"Hi, looks like you are running TensorFlow.js in "+"Node.js. To speed things up dramatically, install our node "+"backend, visit https://github.com/tensorflow/tfjs-node for more details. "+"\n============================")}}const s={id:this.nextDataId()};this.data.set(s,{values:t,dtype:e,refCount:1});return s}makeTensorInfo(t,n,e){let s;if(n==="string"&&e!=null&&e.length>0&&_(e[0])){const o=e.map((t=>Io(t)));s=this.write(o,t,n)}else{s=this.write(e,t,n)}return{dataId:s,shape:t,dtype:n}}refCount(t){if(this.data.has(t)){const n=this.data.get(t);return n.refCount}return 0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,e,s,o){this.data.set(t,{values:n,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:e}=this.data.get(t);if(n==="complex64"){const t=this.readSync(e.real.dataId);const n=this.readSync(e.imag.dataId);return vx(t,n)}return G(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string"){try{const e=n.map((t=>Ao(t)));return Fi(t.shape,t.dtype,e)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}}return Fi(t.shape,t.dtype,n)}makeOutput(t,n,e){return Vi().makeTensorFromTensorInfo(this.makeTensorInfo(n,e,t),this)}disposeData(t,n=false){if(this.data.has(t)){this.data.get(t).refCount--;if(!n&&this.data.get(t).refCount>0){return false}const{complexTensorInfos:e}=this.data.get(t);if(e!=null){this.disposeData(e.real.dataId,true);this.disposeData(e.imag.dataId,true)}this.data.delete(t)}return true}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=To();t();const e=To()-n;return{kernelMs:e}}memory(){return{unreliable:true,reasons:["The reported memory is an upper bound. Due to automatic garbage "+"collection, the true allocated memory may be less."]}}where(t){yR([t],"where");const n=this.readSync(t.dataId);return kR(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}CR.nextDataId=0;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e){n[e]=Math.abs(t[e])}return n}const RR=t=>{const{x:n}=t.inputs;const e=t.backend;yR(n,"abs");let s=new Float32Array(g(n.shape));const o=e.data.get(n.dataId).values;s=NR(o);return e.makeOutput(s,n.shape,n.dtype)};const SR={kernelName:ut,backendName:"cpu",kernelFunc:RR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(t){return(n,e,s,o,r)=>{const i=hu(n,e);const c=i.length;const a=V(i);const u=g(i);const l=S(r,u);const f=n.length;const h=e.length;const d=V(n);const p=V(e);const m=lu(n,i);const x=lu(e,i);if(m.length+x.length===0){for(let n=0;n<l.length;++n){l[n]=t(s[n%s.length],o[n%o.length])}}else{for(let n=0;n<l.length;++n){const e=K(n,c,a);const r=e.slice(-f);m.forEach((t=>r[t]=0));const i=X(r,f,d);const u=e.slice(-h);x.forEach((t=>u[t]=0));const b=X(u,h,p);l[n]=t(s[i],o[b])}}return[l,i]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(t){const{inputs:n,backend:e}=t;const{real:s,imag:o}=n;const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const c=e.makeTensorInfo(s.shape,"complex64");const a=e.data.get(c.dataId);a.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",r),imag:e.makeTensorInfo(o.shape,"float32",i)};return c}const IR={kernelName:Dt,backendName:"cpu",kernelFunc:TR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(t,n,e="float32"){if(e==="complex64"){const e=AR(t,n,"float32");const s=AR(t,n,"float32");return TR({inputs:{real:e,imag:s},backend:t})}const s=H(g(n),e);return t.makeTensorInfo(n,e,s)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OR(t){const{inputs:n,backend:e}=t;const{x:s}=n;e.incRef(s.dataId);return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const FR={kernelName:Rn,backendName:"cpu",kernelFunc:OR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.data.get(s.dataId).complexTensorInfos.real;const r=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,r)}const MR={kernelName:ve,backendName:"cpu",kernelFunc:_R};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(t,n,e,s){if(s==="int32"){const e=Int32Array.from(t);return[n,"int32",e]}if(s==="bool"){const s=Eo([0],e);const[o,r]=ER(((t,n)=>t!==n?1:0))(n,[],t,s,"bool");return[r,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function LR(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dtype:r}=s;if(r==="complex64"){if(o.dtype==="complex64"){return OR({inputs:{x:o},backend:e})}const t=AR(e,o.shape,o.dtype);const n=LR({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});const s=TR({inputs:{real:n,imag:t},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);return s}if(o.dtype==="complex64"){const t=_R({inputs:{input:o},backend:e});const n=LR({inputs:{x:t},backend:e,attrs:{dtype:r}});e.disposeIntermediateTensorInfo(t);return n}if(!A(o.dtype,r)){const t=OR({inputs:{x:o},backend:e});return{dataId:t.dataId,shape:t.shape,dtype:r}}const i=e.data.get(o.dataId).values;const[c,a,u]=DR(i,o.shape,o.dtype,r);return e.makeTensorInfo(c,a,u)}const zR={kernelName:Ft,backendName:"cpu",kernelFunc:LR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(t,n,e,s){if(e==null){return({inputs:e,backend:o})=>{const{a:r,b:i}=e;const c=o;yR([r,i],t);const a=c.data.get(r.dataId).values;const u=c.data.get(i.dataId).values;const l=r.dtype==="string"?nb(a):a;const f=r.dtype==="string"?nb(u):u;const h=s||r.dtype;const[d,p]=n(r.shape,i.shape,l,f,h);return c.makeTensorInfo(p,h,d)}}return({inputs:t,backend:o})=>{const{a:r,b:i}=t;const c=o;if(r.dtype==="complex64"||i.dtype==="complex64"){const t=LR({inputs:{x:r},backend:c,attrs:{dtype:"complex64"}});const n=c.data.get(t.dataId);const s=n.complexTensorInfos.real;const o=n.complexTensorInfos.imag;const a=c.data.get(s.dataId).values;const u=c.data.get(o.dataId).values;const l=LR({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}});const f=c.data.get(l.dataId);const h=f.complexTensorInfos.real;const d=f.complexTensorInfos.imag;const p=c.data.get(h.dataId).values;const m=c.data.get(d.dataId).values;const[x,b,g]=e(r.shape,i.shape,a,u,p,m);const w=c.makeTensorInfo(g,"float32",x);const v=c.makeTensorInfo(g,"float32",b);const $=TR({inputs:{real:w,imag:v},backend:c});c.disposeIntermediateTensorInfo(t);c.disposeIntermediateTensorInfo(l);c.disposeIntermediateTensorInfo(w);c.disposeIntermediateTensorInfo(v);return $}else{const t=c.data.get(r.dataId).values;const e=c.data.get(i.dataId).values;const o=s||r.dtype;const[a,u]=n(r.shape,i.shape,t,e,o);return c.makeTensorInfo(u,o,a)}}}function VR(t){return(n,e,s,o,r,i)=>{const c=hu(n,e);const a=g(c);const u=c.length;const l=V(c);const f=S("float32",a);const h=S("float32",a);const d=lu(n,c);const p=lu(e,c);const m=vx(s,o);const x=vx(r,i);const b=n.length;const w=V(n);const v=e.length;const $=V(e);if(d.length+p.length===0){for(let n=0;n<f.length;n++){const e=n%m.length;const s=n%x.length;const o=t(m[e*2],m[e*2+1],x[s*2],x[s*2+1]);f[n]=o.real;h[n]=o.imag}}else{for(let n=0;n<f.length;n++){const e=K(n,u,l);const s=e.slice(-b);d.forEach((t=>s[t]=0));const o=X(s,b,w);const r=e.slice(-v);p.forEach((t=>r[t]=0));const i=X(r,v,$);const c=t(m[o*2],m[o*2+1],x[i*2],x[i*2+1]);f[n]=c.real;h[n]=c.imag}}return[f,h,c]}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=ER(((t,n)=>t+n));const WR=VR(((t,n,e,s)=>({real:t+e,imag:n+s})));const GR=PR(ht,BR,WR);const UR={kernelName:ht,backendName:"cpu",kernelFunc:GR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(t,n,e,s,o){const r=g(s);const i=H(o,e);for(let e=0;e<t.length;e++){const s=t[e];if(s<0){throw new Error("Input x must be non-negative!")}if(s>=o){continue}if(r>0){i[s]+=n[e]}else{i[s]+=1}}return i}function jR(t,n,e,s=false){const o=t.shape[0];const r=t.shape[1];const i=Fi([o,e],n.dtype);for(let c=0;c<o;c++){for(let o=0;o<r;o++){const r=t.get(c,o);if(r<0){throw new Error("Input x must be non-negative!")}if(r>=e){continue}if(s){i.set(1,c,r)}else{if(n.size>0){i.set(i.get(c,r)+n.get(c,o),c,r)}else{i.set(i.get(c,r)+1,c,r)}}}}return i}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qR=ER(((t,n)=>t&n));const XR=PR(It,qR);const KR={kernelName:It,backendName:"cpu",kernelFunc:XR};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JR(t){return(n,e,s)=>{const o=E(e,n.length);for(let e=0;e<n.length;++e){o[e]=t(n[e],s)}return o}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(t,n,e){const s=JR(n);return ZR(t,s,e)}function ZR(t,n,e){return({inputs:s,attrs:o,backend:r})=>{const{x:i}=s;yR(i,t);const c=r;const a=c.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(a)){throw new Error("String tensor's value was not an instance of Array")}u=nb(a)}else{u=a}const l=e||i.dtype;const f=n(u,l,o);return c.makeTensorInfo(i.shape,l,f)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QR=JR((t=>Math.ceil(t)));const tS=ZR(_t,QR);const nS={kernelName:_t,backendName:"cpu",kernelFunc:tS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(t,n,e,s){const o=E(e,g(n));if(s&&e!=="string"){let n=0;t.forEach((t=>{const e=g(t.shape);o.set(t.vals,n);n+=e}))}else{let s=0;t.forEach((t=>{const r=e==="string"?nb(t.vals):t.vals;let i=0;for(let e=0;e<t.shape[0];++e){const c=e*n[1]+s;for(let n=0;n<t.shape[1];++n){o[c+n]=r[i++]}}s+=t.shape[1]}))}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sS=ER(((t,n)=>t===n?1:0));const oS=PR(hn,sS,null,"bool");const rS={kernelName:hn,backendName:"cpu",kernelFunc:oS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iS=JR((t=>Math.exp(t)));const cS=ZR(dn,iS,"float32");const aS={kernelName:dn,backendName:"cpu",kernelFunc:cS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uS=JR((t=>Math.expm1(t)));const lS=ZR(mn,uS);const fS={kernelName:mn,backendName:"cpu",kernelFunc:lS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hS=JR((t=>Math.floor(t)));const dS=ZR(wn,hS);const pS={kernelName:wn,backendName:"cpu",kernelFunc:dS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS=ER(((t,n)=>Math.floor(t/n)));const xS=PR(vn,mS,null,"int32");const bS={kernelName:vn,backendName:"cpu",kernelFunc:xS};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(t,n,e,s,o,r,i,c,a){const u=Fi([s,r],e);for(let e=0;e<s;e++){const s=[];let l=0;for(let n=0;n<o;n++){const r=t[e*o+n];l+=r*i[n];s.push(r)}if(l<0||l>=a/r){throw new Error(`Invalid indices: ${s} does not index into ${c}`)}for(let t=0;t<r;t++){u.values[e*r+t]=n.get(...n.indexToLoc(l*r+t))}}return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(t,n,e){const s=Fi(e,t.dtype);for(let e=0;e<s.size;++e){const o=s.indexToLoc(e);const r=o.slice();const i=r[0];const c=r[2];const a=n.locToIndex([i,c]);r[2]=n.values[a];const u=t.locToIndex(r);if(0<=u&&u<t.values.length){s.values[e]=t.values[u]}}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vS=ER(((t,n)=>t>n?1:0));const $S=PR(Cn,vS,null,"bool");const yS={kernelName:Cn,backendName:"cpu",kernelFunc:$S};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=ER(((t,n)=>t>=n?1:0));const CS=PR(Nn,kS,null,"bool");const NS={kernelName:Nn,backendName:"cpu",kernelFunc:CS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RS=ER(((t,n)=>t<n?1:0));const SS=PR(Fn,RS,null,"bool");const ES={kernelName:Fn,backendName:"cpu",kernelFunc:SS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TS=ER(((t,n)=>t<=n?1:0));const IS=PR(_n,TS,null,"bool");const AS={kernelName:_n,backendName:"cpu",kernelFunc:IS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(t,n,e){const s=(n-t)/(e-1);const o=H(e,"float32");o[0]=t;for(let t=1;t<o.length;t++){o[t]=o[t-1]+s}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FS=JR((t=>Math.log(t)));const _S=ZR(Dn,FS);const MS={kernelName:Dn,backendName:"cpu",kernelFunc:_S};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(t,n,e,s){const o=S(s,g(e));for(let e=0;e<o.length;++e){const s=e*n;let r=t[s];for(let e=0;e<n;++e){const n=t[s+e];if(Number.isNaN(n)||n>r){r=n}}o[e]=r}return o}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LS=ER(((t,n)=>Math.max(t,n)));const zS=PR(Hn,LS);const PS={kernelName:Hn,backendName:"cpu",kernelFunc:zS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VS=ER(((t,n)=>Math.min(t,n)));const BS=PR(Qn,VS);const WS={kernelName:Qn,backendName:"cpu",kernelFunc:BS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GS=ER(((t,n)=>t*n));const US=VR(((t,n,e,s)=>({real:t*e-n*s,imag:t*s+n*e})));const HS=PR(se,GS,US);const jS={kernelName:se,backendName:"cpu",kernelFunc:HS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(t,n,e){const s=Ro(-1,e);return GS([],n,s,t,e)}function XS(t){const{inputs:n,backend:e}=t;const{x:s}=n;yR(s,"neg");const o=e.data.get(s.dataId).values;const[r,i]=qS(o,s.shape,s.dtype);return e.makeTensorInfo(i,s.dtype,r)}const KS={kernelName:oe,backendName:"cpu",kernelFunc:XS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JS=ER(((t,n)=>t!==n?1:0));const YS=PR(re,JS,null,"bool");const ZS={kernelName:re,backendName:"cpu",kernelFunc:YS};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QS(t,n,e,s,o){const r=n.length;const i=g(n);const c=V(n);const a=V(o);const u=S(e,g(o));for(let n=0;n<i;++n){const e=K(n,r,c);const o=new Array(e.length);for(let t=0;t<o.length;t++){o[t]=e[s[t]]}const i=X(o,r,a);u[i]=t[n]}return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tE(t){const{inputs:n,attrs:e,backend:s}=t;const{x:o}=n;const{perm:r}=e;yR(o,"transpose");const i=o.shape.length;const c=new Array(i);for(let t=0;t<c.length;t++){c[t]=o.shape[r[t]]}const a=s.data.get(o.dataId).values;const u=QS(a,o.shape,o.dtype,r,c);const l=s.write(u,c,o.dtype);return{dataId:l,shape:c,dtype:o.dtype}}const nE={kernelName:hs,backendName:"cpu",kernelFunc:tE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(t,n,e,s){const[o,r]=Au(t,s);const i=ar(n,"int32");const c=H(g(o),i);const a=g(r);for(let t=0;t<c.length;++t){const n=t*a;let s=1;for(let t=0;t<a;++t){s*=e[n+t]}c[t]=s}return{outVals:c,outShape:o,outDtype:i}}function sE(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;yR(o,"prod");const c=o.shape.length;const a=N(r,o.shape);const u=_u(a,c);let l=a;let f=o;const h=[];if(u!=null){f=tE({inputs:{x:o},backend:e,attrs:{perm:u}});h.push(f);l=Du(l.length,c)}const d=e.data.get(f.dataId).values;const{outVals:p,outShape:m,outDtype:x}=eE(f.shape,f.dtype,d,l);let b=m;if(i){b=Ou(m,a)}h.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(b,x,p)}const oE={kernelName:me,backendName:"cpu",kernelFunc:sE};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rE(t,n,e){t.forEach(((t,s)=>{if(t<0||t>=e){const o=K(s,n.length,V(n)).join(",");throw new Error(`indices[${o}] = ${t} is not in [0, ${e})`)}}))}function iE(t,n){for(let e=0;e<t.length;++e){const s=t[e];const o=e===t.length-1?n:t[e+1].length;if(s.length===0){throw new Error("Ragged splits may not be empty")}if(s[0]<0){throw new Error("Ragged splits must be non-negative")}if(s[s.length-1]>o){throw new Error("Ragged splits must not point past values")}for(let t=1;t<s.length;++t){if(s[t-1]>s[t]){throw new Error("Ragged splits must be sorted in ascending order")}}}}function cE(t,n,e,s){const o=[];let r=0;const i=n.length-1+e.length;const c=new Array(i).fill(null).map((()=>[0]));iE(e,s);let a=1;for(let t=0;t<n.length-1;++t){a*=n[t];const e=n[t+1];for(let n=1;n<a+1;++n){c[t].push(n*e)}}for(let s=0;s<t.length;++s){let i=t[s];let a=t[s]+1;for(let t=0;t<e.length;++t){const s=e[t];const o=t+n.length-1;if(o>=0){const t=c[o];const n=t[t.length-1]-s[i];for(let t=i;t<a;++t){c[o].push(s[t+1]+n)}}i=s[i];a=s[a]}if(a!==i){o.push([i,a]);r+=a-i}}return{outSplits:c,valueSlices:o,numValues:r}}function aE(t){const n=[];for(let e=0;e<t.length;++e){const s=t[e].length;const o=E("int32",s);n.push(o);t[e].forEach(((t,n)=>o[n]=t))}return n}function uE(t,n){const e=t.slice(0,n);while(e.length<n){e.push(1)}for(let s=n;s<t.length;s++){e[n-1]*=t[s]}return e}function lE(t,n,e,s,o,r){const i=uE(n,2)[1];const c=uE(r,2)[1];let a=0;for(const n of e){for(let e=n[0];e<n[1];++e){for(let n=0;n<s;++n){o[a*c+n]=t[e*i+n]}++a}}}function fE(t,n,e,s,o){const r=n.slice();r[0]=o;const i=E(e,g(r));const c=t.length;const a=c===0?0:c/n[0];lE(t,n,s,a,i,r);return[i,r]}function hE(t,n,e,s,o,r,i,c){if(t.length===0){throw new Error("paramsNestedSplits must be non empty")}if(n[0].length===0){throw new Error("Split tensors must not be scalars")}const a=n[0][0]-1;rE(r,i,a);if(s.length===0){throw new Error("params.rank must be nonzero")}const u=s[0];const{outSplits:l,valueSlices:f,numValues:h}=cE(r,i,t,u);const d=aE(l);const p=fE(e,s,o,f,h);return[d,p[0],p[1]]}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dE=2147483647;function pE(t,n,e,s,o,r,i){if(n.length>1){throw new Error("starts must be a scalar or vector")}if(o.length>1){throw new Error("limits must be a scalar or vector")}if(i.length>1){throw new Error("deltas must be a scalar or vector")}const c=n.length===0;const a=o.length===0;const u=i.length===0;const l=[];if(!c){l.push(n[0])}if(!a){l.push(o[0])}if(!u){l.push(i[0])}for(let t=1;t<l.length;++t){if(l[t]!==l[t-1]){throw new Error("starts, limits, and deltas must have the same shape")}}const f=l.length===0?1:l[0];const h=E("int32",f+1);h[0]=0;for(let n=0;n<f;++n){const e=c?t[0]:t[n];const o=a?s[0]:s[n];const i=u?r[0]:r[n];if(i===0){throw new Error("Requires delta != 0")}let l;if(i>0&&o<e||i<0&&o>e){l=0}else{l=Math.ceil(Math.abs((o-e)/i));if(l>dE){throw new Error(`Requires ((limit - start) / delta) <= ${dE}`)}}h[n+1]=h[n]+l}const d=h[f];const p=E(e,d);let m=0;for(let n=0;n<f;++n){const e=h[n+1]-h[n];let s=c?t[0]:t[n];const o=u?r[0]:r[n];for(let t=0;t<e;++t){p[m++]=s;s+=o}}return[h,p]}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var mE=Qm;class xE{constructor(t,n,e,s,o,r,i,c,a,u){this.shape=t;this.shapeShape=n;this.values=e;this.valuesShape=s;this.valuesDType=o;this.defaultValue=r;this.defaultValueShape=i;this.rowPartitionValues=c;this.rowPartitionValuesShapes=a;this.rowPartitionTypes=nx(u);this.raggedRank=ex(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){if(this.rowPartitionTypes[0]===mE.FIRST_DIM_SIZE){return this.rowPartitionTypes[t+1]}else{return this.rowPartitionTypes[t]}}getRowPartitionTensor(t){if(this.rowPartitionTypes[0]===mE.FIRST_DIM_SIZE){return this.rowPartitionValues[t+1]}else{return this.rowPartitionValues[t]}}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case mE.VALUE_ROWIDS:return xE.getMaxWidthValueRowID(n);case mE.ROW_SPLITS:return xE.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${mE[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1){return 0}let e=0;for(let s=0;s<n-1;++s){const n=t[s+1]-t[s];if(n>e){e=n}}return e}static getMaxWidthValueRowID(t){const n=t.length;if(n===0){return 0}let e=0;let s=t[0];let o=0;for(let r=1;r<n;++r){const n=t[r];if(n!==s){s=n;o=Math.max(r-e,o);e=r}}return Math.max(n-e,o)}tensorShapeFromTensor(t,n,e=true){if(n.length===0){if(t[0]===-1){return[]}throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`)}return gE(t,e)}calculateOutputSize(t){const n=this.valuesShape;const e=this.defaultValueShape;sx(e,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape);const o=tx(this.raggedRank,s,n);const r=o;if(r[0]<0){r[0]=t}for(let t=1;t<=this.raggedRank;++t){if(r[t]<0){r[t]=this.getMaxWidth(t)}}return r}calculateFirstParentOutputIndex(t,n,e){const s=Math.min(t,e);const o=[];let r=0;for(let t=0;t<s;++t,r+=n){o.push(r)}for(let n=s;n<t;++n){o.push(-1)}m(o.length===t,(()=>"Final length of result must be equal to firstDimension."));return o}calculateOutputIndexRowSplit(t,n,e,s){const o=t.length;const r=[];for(let i=0;i<o-1;++i){const o=t[i+1]-t[i];let c=Math.min(s,o);let a=n[i];if(a===-1){c=0}for(let t=0;t<c;++t){r.push(a);a+=e}for(let t=0;t<o-c;++t){r.push(-1)}}if(o>0&&r.length!==t[o-1]){throw new Error("Invalid row split size.")}return r}calculateOutputIndexValueRowID(t,n,e,s){const o=t.length;const r=[];if(o===0){return[]}let i=0;let c=t[0];if(c>=n.length){throw new Error(`Got currentValueRowId=${c}, which is not less than ${n.length}`)}let a=n[c];r.push(a);for(let u=1;u<o;++u){const o=t[u];if(o===c){if(a>=0){++i;if(i<s){a+=e}else{a=-1}}}else{i=0;c=o;if(o>=n.length){throw new Error(`Got nextValueRowId=${o} which is not less than ${n.length}`)}a=n[o]}r.push(a)}if(r.length!==t.length){throw new Error("Invalid row ids.")}return r}calculateOutputIndex(t,n,e,s){const o=this.getRowPartitionTensor(t);const r=this.getRowPartitionTypeByDimension(t);switch(r){case mE.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,e,s);case mE.ROW_SPLITS:if(o.length-1>n.length){throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`)}return this.calculateOutputIndexRowSplit(o,n,e,s);default:throw new Error(`Unsupported partition type: ${mE[r]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0){throw new Error("No row_partition_types given.")}const n=this.rowPartitionTypes[0];switch(n){case mE.FIRST_DIM_SIZE:return t[0];case mE.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case mE.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${mE[n]}`)}}compute(){const t=this.rowPartitionValues[0];if(t.length<=0){throw new Error("Invalid first partition input. "+"Tensor requires at least one element.")}const n=this.getFirstDimensionSize();const e=this.calculateOutputSize(n);const s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let t=s.length-2;t>=0;--t){s[t]=s[t+1]*e[t+1]}const o=gE(e,false);const r=E(this.valuesDType,g(o));const i=s[0]*e[0];if(i>0){let t=this.calculateFirstParentOutputIndex(n,s[0],e[0]);for(let n=1;n<=this.raggedRank;++n){const o=this.calculateOutputIndex(n-1,t,s[n],e[n]);t=o}this.setOutput(this.raggedRank,t,r,o)}return[o,r]}setOutput(t,n,e,s){if(e.length===0){return}const o=this.values;const r=e;let i=s.slice();i=i.slice(t+1);const c=g(i);const a=n.length;let u=this.defaultValue;if(u.length!==c&&u.length!==1){const t=this.defaultValueShape;Wi((()=>{const n=Hc(u,t);const e=va(n,i);u=e.dataSync()}))}let l=0;let f=0;let h=0;for(let t=0;t<=a;++t){let s=t<a?n[t]:-1;if(s===h){++h;continue}if(f<h){const t=o.subarray(l*c);const n=r.subarray(f*c);const e=(h-f)*c;bE(n,t,e)}if(t>=a){const t=e.length;s=Math.floor(t/c)}if(s>h){if(this.defaultValue.length===1){r.subarray(h*c,s*c).fill(this.defaultValue[0]);h=s}else{while(s>h){const t=r.slice(h*c);bE(t,u,c);++h}}}if(s<0){l=t+1;f=h}else{l=t;f=h;h=f+1}}}}function bE(t,n,e){for(let s=0;s<e;s++){t[s]=n[s]}}function gE(t,n){const e=[];for(let s of t){if(s<0){if(!n){throw new Error(`Dimension ${s} must be >= 0`)}if(s<-1){throw new Error(`Dimension ${s} must be >= -1`)}s=-1}e.push(s)}return e}function wE(t,n,e,s,o,r,i,c,a,u){return new xE(t,n,e,s,o,r,i,c,a,u).compute()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vE(t,n,e,s){const o=t===n;const r=t<n&&e<0;const i=n<t&&e>1;if(o||r||i){return H(0,s)}const c=Math.abs(Math.ceil((n-t)/e));const a=H(c,s);if(n<t&&e===1){e=-1}a[0]=t;for(let t=1;t<a.length;t++){a[t]=a[t-1]+e}return a}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $E=JR((t=>1/Math.sqrt(t)));const yE=ZR(Ae,$E);const kE={kernelName:Ae,backendName:"cpu",kernelFunc:yE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(t,n,e,s,o,r,i,c,a,u){const l=[s/o,o];const f=t.values;const h=n.values;if(s===0){return Fi(e,n.dtype)}const d=a instanceof Xo?a:Fi(l,n.dtype);if(typeof a==="string"){d.values.fill(a)}else if(typeof a==="number"){d.values.fill(a)}else if(typeof a==="boolean"){d.values.fill(+a)}for(let t=0;t<r;t++){const r=[];let a=0;for(let n=0;n<i;n++){const e=f[t*i+n];r.push(e);a+=e*c[n]}if(a<0||a>=s/o){throw new Error(`Invalid indices: ${r} does not index into ${e}`)}for(let e=0;e<o;e++){if(u){d.values[a*o+e]+=h[t*o+e]}else{d.values[a*o+e]=n.rank===0?h[0]:h[t*o+e]}}}return d}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NE=JR((t=>1/(1+Math.exp(-t))));const RE=YR(Be,(t=>1/(1+Math.exp(-t))));const SE={kernelName:Be,backendName:"cpu",kernelFunc:RE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(t,n,e,s,o){const r=Vm(s,n,e);const i=g(e);const c=V(s);if(r){const e=Bm(n,c);if(o==="string"){return t.slice(e,e+i)}return t.subarray(e,e+i)}const a=o==="string"?nb(t):t;const u=Fi(s,o,a);const l=Fi(e,o);for(let t=0;t<l.size;++t){const e=l.indexToLoc(t);const s=e.map(((t,e)=>t+n[e]));l.set(u.get(...s),...e)}if(o==="string"){return eb(l.values)}return l.values}function TE(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,size:i}=s;yR(o,"slice");const[c,a]=Wm(o,r,i);Em(o,c,a);const u=e.data.get(o.dataId).values;const l=EE(u,c,a,o.shape,o.dtype);return e.makeTensorInfo(a,o.dtype,l)}const IE={kernelName:Le,backendName:"cpu",kernelFunc:TE};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(t,n,e,s,o,r,i){const c=n[0];const a=r[0];const u=new Array(a);const l=new Array(c);const f=n[1];if(a===0){if(c!==0){throw new Error(Px(c))}const t=E(e,0);const n=E(o,0);return[t,[0,f],n,u,l]}let h=true;let d=0;const p=new Array(a).fill(0);for(let n=0;n<c;++n){const e=t[n*f];if(e<0){throw new Error(Vx(n,e))}if(e>=a){throw new Error(Bx(n,e,a))}++p[e];h=h&&e>=d;d=e}let m=true;for(let t=0;t<a;++t){const n=p[t]===0;u[t]=n;m=m&&!n;p[t]=Math.max(p[t],1);if(t>0){p[t]+=p[t-1]}}if(m&&h){const n=t;const e=s;for(let t=0;t<c;++t){l[t]=t}return[n,[c,f],e,u,l]}else{const n=p[a-1];const r=E(e,n*f);const h=E(o,n);const d=new Array(a).fill(0);for(let n=0;n<c;++n){const e=t[n*f];const o=d[e];const i=(e===0?0:p[e-1])+o;d[e]++;for(let e=0;e<f;++e){r[i*f+e]=t[n*f+e]}h[i]=s[n];l[n]=i}for(let t=0;t<a;++t){const n=d[t];if(n===0){const n=t===0?0:p[t-1];r[n*f+0]=t;for(let t=1;t<f;++t){r[n*f+t]=0}h[n]=i}}return[r,[n,f],h,u,l]}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OE(t,n,e,s,o){const r=g(s);const i=n[0];const c=o.length;const a=[];let u=1;let l=-1;for(let t=0;t<c;++t){const n=o[t];if(n===-1){if(l!==-1){throw new Error(Wx(l,t))}l=t;a.push(1)}else{if(n<0){throw new Error(Gx(t,n))}u*=n;a.push(n)}}if(l!==-1){if(u<=0){throw new Error(Ux())}const t=Math.trunc(r/u);if(u*t!==r){throw new Error(Hx(s,a))}a[l]=t}const f=g(a);if(f!==r){throw new Error(jx(s,a))}const h=s.length;const d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t){d[t]=d[t+1]*s[t+1]}}const p=[];if(c>0){p[c-1]=1;for(let t=c-2;t>=0;--t){p[t]=p[t+1]*a[t+1]}}const m=E(e,i*c);for(let n=0;n<i;++n){let e=0;for(let s=0;s<h;++s){e+=t[n*h+s]*d[s]}for(let t=0;t<c;++t){m[n*c+t]=Math.trunc(e/p[t]);e%=p[t]}}return[m,[i,c],a]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FE(t,n,e,s,o,r=false,i=0){const c=s.length;const a=[n[0],t.length/n[0]];const u=a[1];const l=c>0?o[c-1]+1:0;const f=l;if(f<0){throw new Error(qx())}const h=n.slice();h[0]=f;const d=h.reduce(((t,n)=>t*n),1);const p=E(e,d);if(c===0){if(f>0){p.fill(i)}return[p,h]}if(f<=0){throw new Error(qx())}let m=0,x=1;let b=0;let g=o[m];while(true){let n=0;if(x<c){n=o[x];if(g===n){++x;continue}if(g>=n){throw new Error(Xx())}}if(g<0||g>=f){throw new Error(Kx(g,f))}if(g>b){p.fill(i,b*u,g*u)}for(let n=m;n<x;++n){const e=s[n];if(e<0||e>=a[0]){throw new Error(Jx(n,s[n],a[0]))}for(let n=0;n<u;n++){p[g*u+n]+=t[e*u+n]}}if(r){for(let t=0;t<u;t++){p[g*u+t]/=x-m}}m=x;++x;b=g+1;g=n;if(x>c){break}}if(b<f){p.fill(i,b*u,f*u)}return[p,h]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _E=JR((t=>Math.sqrt(t)));const ME=YR(Ge,(t=>Math.sqrt(t)));const DE={kernelName:Ge,backendName:"cpu",kernelFunc:ME};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LE=ER(((t,n)=>{const e=t-n;return e*e}));const zE=PR(Qe,LE);const PE={kernelName:Qe,backendName:"cpu",kernelFunc:zE};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VE=JR(((t,n)=>{const{pattern:e,replaceGlobal:s,rewrite:o}=n;return t.replace(new RegExp(e,s?"g":""),o)}));const BE=ZR(ns,VE);const WE={kernelName:ns,backendName:"cpu",kernelFunc:BE};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GE(t,n,e,s){const o=Fi(t,n.dtype);for(let t=0;t<o.size;t++){const r=o.indexToLoc(t);const i=new Array(r.length);for(let t=0;t<i.length;t++){i[t]=r[t]*e[t]+s[t]}o.set(n.get(...i),...r)}return o}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UE{constructor(t,n,e,s,o,r){this.separator=Io(t);this.nGramWidths=n;this.leftPad=Io(e);this.rightPad=Io(s);this.padWidth=o;this.preserveShort=r}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const e=this.getPadWidth(n);return Math.max(0,t+2*e-n+1)}createNGrams(t,n,e,s,o,r){for(let i=0;i<o;++i){const c=this.getPadWidth(r);const a=Math.max(0,c-i);const u=Math.max(0,c-(o-(i+1)));const l=r-(a+u);const f=n+(a>0?0:i-c);let h=0;h+=a*this.leftPad.length;for(let n=0;n<l;++n){h+=t[f+n].length}h+=u*this.rightPad.length;const d=a+u+l-1;h+=d*this.separator.length;e[s+i]=new Uint8Array(h);const p=e[s+i];let m=0;const x=t=>t.forEach((t=>p[m++]=t));for(let t=0;t<a;++t){x(this.leftPad);x(this.separator)}for(let n=0;n<l-1;++n){x(t[f+n]);x(this.separator)}if(l>0){x(t[f+l-1]);for(let t=0;t<u;++t){x(this.separator);x(this.rightPad)}}else{for(let t=0;t<u-1;++t){x(this.rightPad);x(this.separator)}x(this.rightPad)}}}compute(t,n){const e=t.length;const s=n.length;if(s>0){let t=n[0];if(t!==0){throw new Error(`First split value must be 0, got ${t}`)}for(let o=1;o<s;++o){let s=n[o]>=t;s=s&&n[o]<=e;if(!s){throw new Error(`Invalid split value ${n[o]}, must be in [${t}, ${e}]`)}t=n[o]}if(t!==e){throw new Error(`Last split value must be data size. Expected ${e}, got ${t}`)}}const o=s-1;const r=E("int32",s);if(e===0||s===0){const t=new Array(e);for(let t=0;t<=o;++t){r[t]=0}return[t,r]}r[0]=0;for(let t=1;t<=o;++t){const e=n[t]-n[t-1];let s=0;this.nGramWidths.forEach((t=>{s+=this.getNumNGrams(e,t)}));if(this.preserveShort&&e>0&&s===0){s=1}r[t]=r[t-1]+s}const i=new Array(r[o]);for(let e=0;e<o;++e){const s=n[e];let o=r[e];this.nGramWidths.forEach((r=>{const c=n[e+1]-n[e];const a=this.getNumNGrams(c,r);this.createNGrams(t,s,i,o,a,r);o+=a}));if(this.preserveShort&&o===r[e]){const r=n[e+1]-n[e];if(r===0){continue}const c=r+2*this.padWidth;const a=1;this.createNGrams(t,s,i,o,a,c)}}return[i,r]}}function HE(t,n,e,s,o,r,i,c){return new UE(e,s,o,r,i,c).compute(t,n)}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE(t,n,e,s){if(!t.length){return}if(n.length===0){for(let n=0;n<t.length;++n){s.push(t.subarray(n,n+1))}return}if(n.length===1){const o=n[0];let r=t.indexOf(o);while(r!==-1){const n=t.subarray(0,r);if(!e||n.length!==0){s.push(n)}t=t.subarray(r+1);r=t.indexOf(o)}if(!e||t.length!==0){s.push(t)}return}let o=0;for(let r=0;r<t.length+1;r++){if(r===t.length||n.indexOf(t[r])!==-1){const n=t.subarray(o,r);if(!e||n.length!==0){s.push(n)}o=r+1}}}function qE(t,n,e){const s=t.length;const o=[];let r=0;let i=0;const c=new Array(s);for(let a=0;a<s;++a){const s=o.length;jE(t[a],n,e,o);const u=o.length-s;c[a]=u;r+=u;i=Math.max(i,u)}const a=E("int32",r*2);const u=new Array(r);const l=[s,i];let f=0;for(let t=0;t<s;++t){for(let n=0;n<c[t];++n){a[f*2]=t;a[f*2+1]=n;u[f]=o[f];++f}}return[a,u,l]}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XE(t,n){const e=E("int32",t.length);for(let s=0;s<t.length;++s){e[s]=No(t[s]).modulo(n).getLowBitsUnsigned()}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE=ER(((t,n)=>t-n));const JE=VR(((t,n,e,s)=>({real:t-e,imag:n-s})));const YE=PR(is,KE,JE);const ZE={kernelName:is,backendName:"cpu",kernelFunc:YE};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++){e[s]=t.shape[s]*n[s]}const s=Fi(e,t.dtype);for(let n=0;n<s.values.length;++n){const e=s.indexToLoc(n);const o=new Array(t.rank);for(let n=0;n<o.length;n++){o[n]=e[n]%t.shape[n]}const r=t.locToIndex(o);s.values[n]=t.values[r]}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tT=(t,n)=>{const e=n.value-t.value;return e===0?t.index-n.index:e};function nT(t,n,e=0,s=t.length-1){while(s>e){if(s-e>600){const o=s-e+1;const r=n-e+1;const i=Math.log(o);const c=.5*Math.exp(2*i/3);const a=.5*Math.sqrt(i*c*(o-c)/o)*Math.sign(r-o/2);const u=Math.max(e,Math.floor(n-r*c/o+a));const l=Math.min(s,Math.floor(n+(o-r)*c/o+a));nT(t,n,u,l)}const o=t[n];let r=e;let i=s;d(t,e,n);if(tT(t[s],o)>0){d(t,e,s)}while(r<i){d(t,r,i);r++;i--;while(tT(t[r],o)<0){r=r+1}while(tT(t[i],o)>0){i=i-1}}if(tT(t[e],o)===0){d(t,e,i)}else{i=i+1;d(t,i,s)}if(i<=n){e=i+1}if(n<=i){s=i-1}}}function eT(t,n,e,s,o){const r=n[n.length-1];const[i,c]=[t.length/r,r];const a=S(e,i*s);const u=S("int32",i*s);for(let n=0;n<i;n++){const e=n*c;const r=t.subarray(e,e+c);let i=new Array(r.length);r.forEach(((t,n)=>i[n]={value:t,index:n}));if(s<i.length){nT(i,s);i=i.slice(0,s)}if(o){i.sort(tT)}const l=n*s;const f=a.subarray(l,l+s);const h=u.subarray(l,l+s);for(let t=0;t<s;t++){f[t]=i[t].value;h[t]=i[t].index}}const l=n.slice();l[l.length-1]=s;return[Fi(l,e,a),Fi(l,"int32",u)]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(t,n,e,s){const o=N(n,e)[0];const r=[1,e[0],1];for(let t=0;t<o;t++){r[0]*=e[t]}r[1]=e[o];for(let t=o+1;t<e.length;t++){r[2]*=e[t]}const i=new Map;const c=new Int32Array(e[o]);const a=new Xo(r,s,t);const u=[];const l=r[0]===1&&r[2]===1;for(let n=0;n<e[o];n++){let e;if(l){e=t[n].toString()}else{const t=[];for(let e=0;e<r[0];e++){for(let s=0;s<r[2];s++){t.push(a.get(e,n,s))}}e=t.join(",")}const s=i.get(e);if(s!=null){c[n]=s}else{const t=i.size;i.set(e,t);c[n]=t;u.push(n)}}const f=r.slice();f[1]=i.size;const h=new Xo(f,s);u.forEach(((t,n)=>{for(let e=0;e<r[0];e++){for(let s=0;s<r[2];s++){h.set(a.get(e,t,s),e,n,s)}}}));const d=e.slice();d[o]=f[1];return{outputValues:h.values,outputShape:d,indices:c}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=Object.freeze({__proto__:null,simpleAbsImpl:NR,addImpl:BR,bincountImpl:HR,bincountReduceImpl:jR,bitwiseAndImpl:qR,castImpl:DR,ceilImpl:QR,concatImpl:eS,equalImpl:sS,expImpl:iS,expm1Impl:uS,floorImpl:hS,floorDivImpl:mS,gatherNdImpl:gS,gatherV2Impl:wS,greaterImpl:vS,greaterEqualImpl:kS,lessImpl:RS,lessEqualImpl:TS,linSpaceImpl:OS,logImpl:FS,maxImpl:DS,maximumImpl:LS,minimumImpl:VS,multiplyImpl:GS,negImpl:qS,notEqualImpl:JS,prodImpl:eE,raggedGatherImpl:hE,raggedRangeImpl:pE,raggedTensorToTensorImpl:wE,rangeImpl:vE,rsqrtImpl:$E,scatterImpl:CE,sigmoidImpl:NE,sliceImpl:EE,sparseFillEmptyRowsImpl:AE,sparseReshapeImpl:OE,sparseSegmentReductionImpl:FE,sqrtImpl:_E,squaredDifferenceImpl:LE,staticRegexReplaceImpl:VE,stridedSliceImpl:GE,stringNGramsImpl:HE,stringSplitImpl:qE,stringToHashBucketFastImpl:XE,subImpl:KE,tileImpl:QE,topKImpl:eT,transposeImpl:QS,uniqueImpl:sT});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Hi("cpu",(()=>new CR),1);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rT=YR(un,(t=>t>=0?t:Math.exp(t)-1));const iT={kernelName:un,backendName:"cpu",kernelFunc:rT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{alpha:r}=s;yR([o],"leakyRelu");const i=g(o.shape);const c=e.data.get(o.dataId).values;const a=S("float32",i);for(let t=0;t<c.length;t++){a[t]=c[t]<0?r*c[t]:c[t]}return e.makeTensorInfo(o.shape,"float32",a)}const aT={kernelName:On,backendName:"cpu",kernelFunc:cT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uT=ER(((t,n)=>t<0?n*t:t));function lT(t){const{inputs:n,backend:e}=t;const{x:s,alpha:o}=n;yR([s,o],"prelu");const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const[c,a]=uT(s.shape,o.shape,r,i,"float32");return e.makeTensorInfo(a,"float32",c)}const fT={kernelName:pe,backendName:"cpu",kernelFunc:lT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=YR(ye,(t=>Math.max(0,t)));const dT={kernelName:ye,backendName:"cpu",kernelFunc:hT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pT=YR(Ee,(t=>Math.min(Math.max(0,t),6)));const mT={kernelName:Ee,backendName:"cpu",kernelFunc:pT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(t,n,e,s,o){if(e==="linear"){return OR({inputs:{x:n},backend:t})}else if(e==="relu"){return hT({inputs:{x:n},backend:t})}else if(e==="elu"){return rT({inputs:{x:n},backend:t})}else if(e==="relu6"){return pT({inputs:{x:n},backend:t})}else if(e==="prelu"){return lT({inputs:{x:n,alpha:s},backend:t})}else if(e==="leakyrelu"){return cT({inputs:{x:n},backend:t,attrs:{alpha:o}})}else if(e==="sigmoid"){return RE({inputs:{x:n},backend:t})}throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{shape:r}=s;const i=g(o.shape);const c=C(r,i);const a=g(c);m(i===a,(()=>`The new shape (${c}) has ${a} elements and the old `+`shape (${o.shape}) has ${i} elements. The new shape and old `+`shape must have the same number of elements.`));e.incRef(o.dataId);const u=e.data.get(o.dataId);if(u.complexTensorInfos!=null){const t=u.complexTensorInfos.real;const n=u.complexTensorInfos.imag;t.shape=c;n.shape=c}return{dataId:o.dataId,shape:c,dtype:o.dtype}}const gT={kernelName:ke,backendName:"cpu",kernelFunc:bT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r}=n;const{transposeA:i,transposeB:c}=s;yR([o,r],"matMul");const a=o.shape.length;const u=r.shape.length;const l=i?o.shape[a-2]:o.shape[a-1];const f=c?r.shape[u-1]:r.shape[u-2];const h=i?o.shape[a-1]:o.shape[a-2];const d=c?r.shape[u-2]:r.shape[u-1];const p=o.shape.slice(0,-2);const x=r.shape.slice(0,-2);const b=g(p);const w=g(x);const v=hu(o.shape.slice(0,-2),r.shape.slice(0,-2));const $=v.concat([h,d]);m(l===f,(()=>`Error in matMul: inner shapes (${l}) and (`+`${f}) of Tensors with shapes ${o.shape} and `+`${r.shape} and transposeA=${i}`+` and transposeB=${c} must match.`));const y=i?[b,l,h]:[b,h,l];const k=c?[w,d,f]:[w,f,d];const C=bT({inputs:{x:o},backend:e,attrs:{shape:y}});const N=bT({inputs:{x:r},backend:e,attrs:{shape:k}});const R=i?C.shape[1]:C.shape[2];const S=i?C.shape[2]:C.shape[1];const E=c?N.shape[1]:N.shape[2];const T=Math.max(b,w);const I=e.data.get(C.dataId).values;const A=e.data.get(N.dataId).values;const O=V(C.shape);const F=V(N.shape);const[_,M,D]=i?[O[0],1,O[1]]:[O[0],O[1],1];const[L,z,P]=c?[1,F[1],F[0]]:[F[1],1,F[0]];const B=S*E;const W=Fi([T,S,E],C.dtype);const G=W.values;const U=e.blockSize;for(let t=0;t<T;t++){const n=t%b;const e=t%w;for(let s=0;s<S;s+=U){const o=Math.min(s+U,S);for(let r=0;r<E;r+=U){const i=Math.min(r+U,E);for(let c=0;c<R;c+=U){const a=Math.min(c+U,R);for(let u=s;u<o;u++){for(let s=r;s<i;s++){let o=0;for(let t=c;t<a;t++){const r=I[n*_+u*M+t*D];const i=A[t*L+s*z+e*P];o+=r*i}G[t*B+(u*E+s)]+=o}}}}}}e.disposeIntermediateTensorInfo(C);e.disposeIntermediateTensorInfo(N);return e.makeTensorInfo($,W.dtype,W.values)}const vT={kernelName:St,backendName:"cpu",kernelFunc:wT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $T(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r,bias:i,preluActivationWeights:c}=n;const{transposeA:a,transposeB:u,activation:l,leakyreluAlpha:f}=s;let h;let d;let p;const m=[];const x=wT({inputs:{a:o,b:r},attrs:{transposeA:a,transposeB:u},backend:e});h=x;if(i){d=GR({inputs:{a:h,b:i},backend:e});m.push(h);h=d}if(l){p=xT(e,h,l,c,f);m.push(h);h=p}for(const t of m){e.disposeIntermediateTensorInfo(t)}return h}const yT={kernelName:vs,backendName:"cpu",kernelFunc:$T};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kT=YR(lt,(t=>Math.acos(t)));const CT={kernelName:lt,backendName:"cpu",kernelFunc:kT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NT=YR(ft,(t=>Math.acosh(t)));const RT={kernelName:ft,backendName:"cpu",kernelFunc:NT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(t){const{inputs:n,backend:e}=t;const s=n;yR(n,"addN");const o=s.map((t=>e.data.get(t.dataId).values));const r=Fi(s[0].shape,s[0].dtype);const i=r.values;for(let t=0;t<s.length;t++){const n=o[t];for(let t=0;t<i.length;t++){i[t]+=n[t]}}return e.makeTensorInfo(r.shape,r.dtype,r.values)}const ET={kernelName:dt,backendName:"cpu",kernelFunc:ST};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;yR(o,"all");const c=N(r,o.shape);let a=c;const u=_u(a,o.shape.length);let l=o;if(u!=null){l=tE({inputs:{x:o},backend:e,attrs:{perm:u}});a=Du(a.length,o.shape.length)}Fu("all",a,l.shape.length);const[f,h]=Au(l.shape,a);const d=g(h);const p=H(g(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];e=e&&s}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=Ou(f,c);const n=bT({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const IT={kernelName:pt,backendName:"cpu",kernelFunc:TT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;yR(o,"any");const c=N(r,o.shape);let a=c;const u=_u(a,o.shape.length);let l=o;if(u!=null){l=tE({inputs:{x:o},backend:e,attrs:{perm:u}});a=Du(a.length,o.shape.length)}Fu("any",a,l.shape.length);const[f,h]=Au(l.shape,a);const d=g(h);const p=H(g(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];e=e||s}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=Ou(f,c);const n=bT({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const OT={kernelName:mt,backendName:"cpu",kernelFunc:AT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;yR(o,"argMax");let i=N(r,o.shape);const c=_u(i,o.shape.length);let a=o;const u=[];if(c!=null){a=tE({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=Du(i.length,a.shape.length)}i=[i[0]];Fu("argMax",i,a.shape.length);const[l,f]=Au(a.shape,i);const h=g(l);const d=H(h,"int32");const p=g(f);const m=e.data.get(a.dataId).values;for(let t=0;t<d.length;++t){const n=t*p;let e=m[n];let s=0;for(let t=0;t<p;++t){const o=m[n+t];if(o>e){e=o;s=t}}d[t]=s}u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(l,"int32",d)}const _T={kernelName:xt,backendName:"cpu",kernelFunc:FT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;yR(o,"argMin");let i=N(r,o.shape);const c=_u(i,o.shape.length);let a=o;const u=[];if(c!=null){a=tE({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=Du(i.length,a.shape.length)}i=[i[0]];Fu("argMin",i,a.shape.length);const[l,f]=Au(a.shape,i);const h=g(l);const d=H(h,"int32");const p=g(f);const m=e.data.get(a.dataId).values;for(let t=0;t<d.length;++t){const n=t*p;let e=m[n];let s=0;for(let t=0;t<p;++t){const o=m[n+t];if(o<e){e=o;s=t}}d[t]=s}u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(l,"int32",d)}const DT={kernelName:bt,backendName:"cpu",kernelFunc:MT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LT=YR(gt,(t=>Math.asin(t)));const zT={kernelName:gt,backendName:"cpu",kernelFunc:LT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PT=YR(wt,(t=>Math.asinh(t)));const VT={kernelName:wt,backendName:"cpu",kernelFunc:PT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BT=YR(vt,(t=>Math.atan(t)));const WT={kernelName:vt,backendName:"cpu",kernelFunc:BT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GT=ER(((t,n)=>Math.atan2(t,n)));const UT=PR(yt,GT);const HT={kernelName:yt,backendName:"cpu",kernelFunc:UT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jT=YR($t,(t=>Math.atanh(t)));const qT={kernelName:$t,backendName:"cpu",kernelFunc:jT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XT(t,n,e,s,o,r){const i=o.strideHeight;const c=o.strideWidth;const a=o.dilationHeight;const u=o.dilationWidth;const l=o.effectiveFilterHeight;const f=o.effectiveFilterWidth;const h=o.padInfo.top;const d=o.padInfo.left;const p=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const m=Fi(o.outShape,e);const x=m.values;const b=o.outShape[1]*o.outShape[2]*o.outShape[3];const g=o.outShape[2]*o.outShape[3];const w=o.outShape[3];for(let n=0;n<o.batchSize;++n){const e=n*b;const m=n*s[0];for(let n=0;n<o.inChannels;++n){for(let b=0;b<o.outHeight;++b){const v=b*i-h;const $=Math.max(0,v);const y=Math.min(o.inHeight,l+v);const k=e+b*g;for(let e=0;e<o.outWidth;++e){const i=e*c-d;const l=Math.max(0,i);const h=Math.min(o.inWidth,f+i);let b=p;let g=0;let v=0;for(let e=$;e<y;e+=a){const o=m+e*s[1];for(let e=l;e<h;e+=u){const i=o+e*s[2];const c=t[i+n];if(r==="max"&&c>b){b=c}else if(r==="avg"){g+=c;v++}}if(isNaN(b)){break}}const C=k+e*w+n;x[C]=r==="avg"?g/v:b}}}}return m}function KT(t,n,e,s,o=false,r=false){const i=Fi(s.outShape,"int32");const c=s.strideHeight;const a=s.strideWidth;const u=s.dilationHeight;const l=s.dilationWidth;const f=s.effectiveFilterHeight;const h=s.effectiveFilterWidth;const d=s.padInfo.top;const p=s.padInfo.left;const m=Fi(n,e,t);for(let t=0;t<s.batchSize;++t){for(let n=0;n<s.inChannels;++n){for(let e=0;e<s.outHeight;++e){const x=e*c-d;let b=x;while(b<0){b+=u}const g=Math.min(s.inHeight,f+x);for(let c=0;c<s.outWidth;++c){const f=c*a-p;let d=f;while(d<0){d+=l}const w=Math.min(s.inWidth,h+f);let v=Number.NEGATIVE_INFINITY;let $=-1;for(let e=b;e<g;e+=u){const i=e-x;for(let c=d;c<w;c+=l){const a=c-f;const u=m.get(t,e,c,n);if(u>v){v=u;if(o){$=r?((t*s.inHeight+e)*s.inWidth+c)*s.inChannels+n:(e*s.inWidth+c)*s.inChannels+n}else{$=i*h+a}}}}i.set($,t,e,c,n)}}}}return i}function JT(t,n,e,s,o,r){const i=o.strideDepth;const c=o.strideHeight;const a=o.strideWidth;const u=o.dilationDepth;const l=o.dilationHeight;const f=o.dilationWidth;const h=o.effectiveFilterDepth;const d=o.effectiveFilterHeight;const p=o.effectiveFilterWidth;const m=o.padInfo.front;const x=o.padInfo.top;const b=o.padInfo.left;const g=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const w=Fi(o.outShape,e);const v=w.values;const $=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4];const y=o.outShape[2]*o.outShape[3]*o.outShape[4];const k=o.outShape[3]*o.outShape[4];const C=o.outShape[4];for(let n=0;n<o.batchSize;++n){const e=n*$;const w=n*s[0];for(let n=0;n<o.inChannels;++n){for(let $=0;$<o.outDepth;++$){const N=$*i-m;let R=N;while(R<0){R+=u}const S=Math.min(o.inDepth,h+N);const E=e+$*y;for(let e=0;e<o.outHeight;++e){const i=e*c-x;let h=i;while(h<0){h+=l}const m=Math.min(o.inHeight,d+i);const $=E+e*k;for(let e=0;e<o.outWidth;++e){const i=e*a-b;let c=i;while(c<0){c+=f}const d=Math.min(o.inWidth,p+i);const x=$+e*C;let y=g;let k=0;let N=0;for(let e=R;e<S;e+=u){const o=w+e*s[1];for(let e=h;e<m;e+=l){const i=o+e*s[2];for(let e=c;e<d;e+=f){const o=i+e*s[3];const c=t[o+n];if(r==="max"&&c>y){y=c}else if(r==="avg"){k+=c;N++}if(isNaN(y)){break}}if(isNaN(y)){break}}if(isNaN(y)){break}}const E=x+n;v[E]=r==="avg"?k/Math.max(N,1):y}}}}}return w}function YT(t,n){const e=Fi(n.outShape,"int32");const s=n.strideDepth;const o=n.strideHeight;const r=n.strideWidth;const i=n.dilationDepth;const c=n.dilationHeight;const a=n.dilationWidth;const u=n.effectiveFilterDepth;const l=n.effectiveFilterHeight;const f=n.effectiveFilterWidth;const h=n.padInfo.front;const d=n.padInfo.top;const p=n.padInfo.left;for(let m=0;m<n.batchSize;++m){for(let x=0;x<n.inChannels;++x){for(let b=0;b<n.outDepth;++b){const g=b*s-h;let w=g;while(w<0){w+=i}const v=Math.min(n.inDepth,u+g);for(let s=0;s<n.outHeight;++s){const u=s*o-d;let h=u;while(h<0){h+=c}const $=Math.min(n.inHeight,l+u);for(let o=0;o<n.outWidth;++o){const d=o*r-p;let y=d;while(y<0){y+=a}const k=Math.min(n.inWidth,f+d);let C=Number.NEGATIVE_INFINITY;let N=-1;for(let n=w;n<v;n+=i){const e=n-g;for(let s=h;s<$;s+=c){const o=s-u;for(let r=y;r<k;r+=a){const i=r-d;const c=t.get(m,n,s,r,x);if(c>=C){C=c;N=e*l*f+o*l+i}}}}e.set(N,m,b,s,o,x)}}}}}return e}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;yR(o,"avgPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;m(Vc(i,u),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=Rc(o.shape,r,i,u,c,a);let f;if(l.filterWidth===1&&l.filterHeight===1&&w(l.inShape,l.outShape)){f=OR({inputs:{x:o},backend:e})}else{const t=e.data.get(o.dataId).values;const n=V(o.shape);const s=XT(t,o.shape,o.dtype,n,l,"avg");f=e.makeTensorInfo(l.outShape,o.dtype,s.values)}return f}const QT={kernelName:kt,backendName:"cpu",kernelFunc:ZT};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;yR(o,"avgPool3d");const l=Sc(o.shape,r,i,1,c,a,u);const f=e.data.get(o.dataId).values;const h=JT(f,o.shape,o.dtype,V(o.shape),l,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}const nI={kernelName:Nt,backendName:"cpu",kernelFunc:tI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const{filterSize:i,strides:c,pad:a,dimRoundingMode:u}=s;yR([o,r],"avgPool3DGrad");const l=Sc(r.shape,i,c,1,a,u);const f=l.strideDepth;const h=l.strideHeight;const d=l.strideWidth;const p=l.filterDepth;const m=l.filterHeight;const x=l.filterWidth;const b=l.dilationDepth;const g=l.dilationHeight;const w=l.dilationWidth;const v=l.effectiveFilterDepth;const $=l.effectiveFilterHeight;const y=l.effectiveFilterWidth;const k=v-1-l.padInfo.front;const C=y-1-l.padInfo.left;const N=$-1-l.padInfo.top;const R=Fi(r.shape,"float32");const S=1/(p*m*x);const E=e.bufferSync(o);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inDepth;++e){for(let s=0;s<l.inHeight;++s){for(let o=0;o<l.inWidth;++o){const r=e-k;const i=s-N;const c=o-C;let a=0;for(let e=0;e<v;e+=b){const s=(r+e)/f;if(s<0||s>=l.outDepth||Math.floor(s)!==s){continue}for(let e=0;e<$;e+=g){const o=(i+e)/h;if(o<0||o>=l.outHeight||Math.floor(o)!==o){continue}for(let e=0;e<y;e+=w){const r=(c+e)/d;if(r<0||r>=l.outWidth||Math.floor(r)!==r){continue}const i=E.get(t,s,o,r,n);a+=i}}}R.set(a*S,t,e,s,o,n)}}}}}return e.makeTensorInfo(R.shape,R.dtype,R.values)}const sI={kernelName:Rt,backendName:"cpu",kernelFunc:eI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;yR([o,r],"avgPoolGrad");const{filterSize:c,strides:a,pad:u}=s;const l=Rc(i.shape,c,a,1,u);const f=l.strideHeight;const h=l.strideWidth;const d=l.filterHeight;const p=l.filterWidth;const m=l.dilationHeight;const x=l.dilationWidth;const b=l.effectiveFilterHeight;const g=l.effectiveFilterWidth;const w=g-1-l.padInfo.left;const v=b-1-l.padInfo.top;const $=Fi(i.shape,"float32");const y=1/(d*p);const k=e.data.get(o.dataId).values;const C=Fi(o.shape,"float32",k);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inHeight;++e){for(let s=0;s<l.inWidth;++s){const o=e-v;const r=s-w;let i=0;for(let e=0;e<b;e+=m){const s=(o+e)/f;if(s<0||s>=l.outHeight||Math.floor(s)!==s){continue}for(let e=0;e<g;e+=x){const o=(r+e)/h;if(o<0||o>=l.outWidth||Math.floor(o)!==o){continue}const c=C.get(t,s,o,n);i+=c}}$.set(i*y,t,e,s,n)}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const rI={kernelName:Ct,backendName:"cpu",kernelFunc:oI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,scale:r,offset:i,mean:c,variance:a}=n;m(c.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));m(i==null||c.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));m(r==null||c.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));yR([o,c,a,r,i],"batchNorm");let{varianceEpsilon:u}=s;if(u==null){u=.001}const l=e.data.get(o.dataId).values;const f=e.data.get(c.dataId).values;const h=e.data.get(a.dataId).values;const d=r?e.data.get(r.dataId).values:new Float32Array([1]);const p=i?e.data.get(i.dataId).values:new Float32Array([0]);const x=new Float32Array(l.length);const b=p.length;const g=d.length;const w=h.length;const v=f.length;let $=0;let y=0;let k=0;let C=0;for(let t=0;t<l.length;++t){x[t]=p[$++]+(l[t]-f[y++])*d[k++]/Math.sqrt(h[C++]+u);if($>=b){$=0}if(y>=v){y=0}if(k>=g){k=0}if(C>=w){C=0}}return e.makeTensorInfo(o.shape,o.dtype,x)}const cI={kernelName:$n,backendName:"cpu",kernelFunc:iI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,crops:i}=s;yR([o],"batchToSpaceND");const c=r.reduce(((t,n)=>t*n));const a=cx(o.shape,r,c);const u=ax(a.length,r.length);const l=ux(o.shape,r,c);const f=lx(i,r.length);const h=fx(l,i,r.length);const d=bT({inputs:{x:o},backend:e,attrs:{shape:a}});const p=tE({inputs:{x:d},backend:e,attrs:{perm:u}});const m=bT({inputs:{x:p},backend:e,attrs:{shape:l}});const x=TE({inputs:{x:m},backend:e,attrs:{begin:f,size:h}});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);return x}const uI={kernelName:Et,backendName:"cpu",kernelFunc:aI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i}=s;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const u=HR(c,a,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,u)}const fI={kernelName:Tt,backendName:"cpu",kernelFunc:lI};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(t){const{inputs:n,backend:e}=t;const{s0:s,s1:o}=n;const r=e.data.get(s.dataId).values;const i=e.data.get(o.dataId).values;const c=hu(Array.from(r),Array.from(i));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const dI={kernelName:Ot,backendName:"cpu",kernelFunc:hI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pI=YR(Mt,((t,n)=>{const e=n;if(t>e.clipValueMax){return e.clipValueMax}return t<e.clipValueMin?e.clipValueMin:t}));const mI={kernelName:Mt,backendName:"cpu",kernelFunc:pI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xI=t=>{const{x:n}=t.inputs;const e=t.backend;const s=new Float32Array(g(n.shape));const o=e.data.get(n.dataId);const r=o.complexTensorInfos.real;const i=o.complexTensorInfos.imag;const c=e.data.get(r.dataId).values;const a=e.data.get(i.dataId).values;for(let t=0;t<c.length;t++){const n=c[t];const e=a[t];s[t]=Math.hypot(n,e)}return e.makeOutput(s,n.shape,"float32")};const bI={kernelName:Lt,backendName:"cpu",kernelFunc:xI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.data.get(s.dataId).complexTensorInfos.imag;const r=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,r)}const wI={kernelName:En,backendName:"cpu",kernelFunc:gI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vI(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;const r=N(o,n[0].shape)[0];const i=n.map((t=>t.shape));Ym(i,r);let c=Zm(n.map((t=>t.shape)),r);if(g(c)===0){return e.makeTensorInfo(c,n[0].dtype,[])}const a=n.filter((t=>g(t.shape)>0));if(a.length===1){return OR({inputs:{x:a[0]},backend:e})}if(a[0].dtype==="complex64"){const t=a.map((t=>_R({inputs:{input:t},backend:e})));const n=a.map((t=>gI({inputs:{input:t},backend:e})));const s=vI({inputs:t,backend:e,attrs:{axis:r}});const o=vI({inputs:n,backend:e,attrs:{axis:r}});const i=TR({inputs:{real:s,imag:o},backend:e});t.forEach((t=>e.disposeIntermediateTensorInfo(t)));n.forEach((t=>e.disposeIntermediateTensorInfo(t)));e.disposeIntermediateTensorInfo(s);e.disposeIntermediateTensorInfo(o);return i}const u=a.map((t=>{const n=g(t.shape.slice(r));const s=[-1,n];return bT({inputs:{x:t},backend:e,attrs:{shape:s}})}));const l=u.map((t=>({vals:e.data.get(t.dataId).values,shape:t.shape})));c=Zm(u.map((t=>t.shape)),1);const f=u[0].shape[0]===1;const h=eS(l,c,n[0].dtype,f);const d=Zm(a.map((t=>t.shape)),r);const p=e.makeTensorInfo(d,n[0].dtype,h);u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return p}const $I={kernelName:zt,backendName:"cpu",kernelFunc:vI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dataFormat:a,dilations:u,dimRoundingMode:l}=s;yR([o,r],"conv2d");const f=Wc(a);const h=Ec(o.shape,r.shape,i,u,c,l,false,f);const d=h.filterHeight;const p=h.filterWidth;const m=h.dilationHeight;const x=h.dilationWidth;const b=h.padInfo.left;const g=h.padInfo.top;const w=h.dataFormat==="channelsLast";const v=new Xo(h.outShape,o.dtype);const $=V(o.shape);const y=V(r.shape);const k=$[0];const C=w?$[1]:$[2];const N=w?$[2]:1;const R=w?1:$[1];const S=v.strides[0];const E=w?v.strides[1]:v.strides[2];const T=w?v.strides[2]:1;const I=w?1:v.strides[1];const A=e.data.get(o.dataId).values;const O=e.data.get(r.dataId).values;const F=v.values;for(let t=0;t<h.batchSize;++t){const n=t*k;const e=t*S;for(let t=0;t<h.outHeight;++t){const s=e+t*E;const o=t*h.strideHeight-g;for(let t=0;t<d;++t){const e=o+t*m;if(e<0||e>=h.inHeight){continue}const r=t*y[0];const i=n+e*C;for(let t=0;t<h.outWidth;++t){const n=s+t*T;const e=t*h.strideWidth-b;for(let t=0;t<p;++t){const s=e+t*x;if(s<0||s>=h.inWidth){continue}const o=r+t*y[1];const c=i+s*N;let a=o;for(let t=0;t<h.inChannels;++t){const e=A[c+t*R];for(let t=0;t<h.outChannels;++t){F[n+t*I]+=e*O[a+t]}a+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,F)}const kI={kernelName:Pt,backendName:"cpu",kernelFunc:yI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,dataFormat:a,dimRoundingMode:u,filterShape:l}=s;yR([o,r],"conv2dBackpropFilter");const f=Wc(a);const h=Ec(o.shape,l,i,1,c,u,false,f);const{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:x}=h;const b=h.dataFormat==="channelsLast";const g=new Xo(h.filterShape,"float32");const w=h.padInfo.left;const v=h.padInfo.top;const $=e.data.get(o.dataId).values;const y=e.data.get(r.dataId).values;const k=new Xo(o.shape,o.dtype,$);const C=new Xo(r.shape,r.dtype,y);for(let t=0;t<m;++t){const n=Math.max(0,Math.ceil((v-t)/d));const e=Math.min(h.outHeight,(h.inHeight+v-t)/d);for(let s=0;s<x;++s){const o=Math.max(0,Math.ceil((w-s)/p));const r=Math.min(h.outWidth,(h.inWidth+w-s)/p);for(let i=0;i<h.inChannels;++i){for(let c=0;c<h.outChannels;++c){let a=0;for(let u=0;u<h.batchSize;++u){for(let l=n;l<e;++l){const n=t+l*d-v;for(let t=o;t<r;++t){const e=s+t*p-w;if(b){a+=k.get(u,n,e,i)*C.get(u,l,t,c)}else{a+=k.get(u,i,n,e)*C.get(u,c,l,t)}}}}g.set(a,t,s,i,c)}}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const NI={kernelName:Vt,backendName:"cpu",kernelFunc:CI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{inputShape:i,strides:c,pad:a,dataFormat:u,dimRoundingMode:l}=s;yR([o,r],"conv2dBackpropInput");const f=V(r.shape);const h=V(o.shape);let d=Wc(u);const p=Ec(i,r.shape,c,1,a,l,false,d);const m=new Xo(p.inShape,"float32");const x=m.values;const b=e.data.get(o.dataId).values;const g=e.data.get(r.dataId).values;const[w,v,$]=f;const{batchSize:y,filterHeight:k,filterWidth:C,inChannels:N,inHeight:R,inWidth:S,outChannels:E,outHeight:T,outWidth:I,strideHeight:A,strideWidth:O}=p;d=p.dataFormat;const F=k-1-p.padInfo.top;const _=C-1-p.padInfo.left;const M=d==="channelsLast";const D=m.strides[0];const L=M?m.strides[1]:m.strides[2];const z=M?m.strides[2]:1;const P=M?1:m.strides[1];const B=h[0];const W=M?h[1]:h[2];const G=M?h[2]:1;const U=M?1:h[1];for(let t=0;t<y;++t){for(let n=0;n<N;++n){for(let e=0;e<R;++e){const s=e-F;const o=Math.max(0,Math.ceil(s/A));const r=Math.min(T,(k+s)/A);for(let i=0;i<S;++i){const c=i-_;const a=Math.max(0,Math.ceil(c/O));const u=Math.min(I,(C+c)/O);let l=0;for(let e=o;e<r;++e){const o=e*A-s;for(let s=a;s<u;++s){const r=s*O-c;const i=B*t+W*e+G*s;const a=w*(k-1-o)+v*(C-1-r)+$*n;for(let t=0;t<E;++t){const n=b[i+U*t];const e=g[a+t];l+=n*e}}}const f=D*t+L*e+z*i+P*n;x[f]=l}}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const SI={kernelName:Bt,backendName:"cpu",kernelFunc:RI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;yR([o,r],"conv3d");const u=Tc(o.shape,r.shape,i,a,c);const{filterDepth:l,filterHeight:f,filterWidth:h,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:x}=u;const b=x.front;const g=x.left;const w=x.top;const v=new Xo(u.outShape,o.dtype);const $=e.data.get(o.dataId).values;const y=e.data.get(r.dataId).values;const k=v.values;const C=V(o.shape);const N=V(r.shape);for(let t=0;t<u.batchSize;++t){const n=t*C[0];const e=t*v.strides[0];for(let t=0;t<u.outDepth;++t){const s=e+t*v.strides[1];const o=t*u.strideDepth-b;for(let t=0;t<l;++t){const e=o+t*d;if(e<0||e>=u.inDepth){continue}const r=t*N[0];const i=n+e*C[1];for(let t=0;t<u.outHeight;++t){const n=s+t*v.strides[2];const e=t*u.strideHeight-w;for(let t=0;t<f;++t){const s=e+t*p;if(s<0||s>=u.inHeight){continue}const o=r+t*N[1];const c=i+s*C[2];for(let t=0;t<u.outWidth;++t){const e=n+t*u.outChannels;const s=t*u.strideWidth-g;for(let t=0;t<h;++t){const n=s+t*m;if(n<0||n>=u.inWidth){continue}const r=o+t*N[2];const i=c+n*u.inChannels;let a=r;for(let t=0;t<u.inChannels;++t){const n=$[i+t];for(let t=0;t<u.outChannels;++t){k[e+t]+=n*y[a+t]}a+=u.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const TI={kernelName:Wt,backendName:"cpu",kernelFunc:EI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,filterShape:a}=s;yR([o,r],"conv3dBackpropFilterV2");const u=V(o.shape);const l=V(r.shape);const f=Tc(o.shape,a,i,1,c);const h=f.strideDepth;const d=f.strideHeight;const p=f.strideWidth;const m=f.filterDepth;const x=f.filterHeight;const b=f.filterWidth;const g=new Xo(f.filterShape,"float32");const w=g.values;const[v,$,y,k]=g.strides;const C=e.data.get(r.dataId).values;const[N,R,S,E]=l;const T=e.data.get(o.dataId).values;const[I,A,O,F]=u;const _=f.padInfo.front;const M=f.padInfo.left;const D=f.padInfo.top;for(let t=0;t<m;++t){const n=Math.max(0,Math.ceil((_-t)/h));const e=Math.min(f.outDepth,(f.inDepth+_-t)/h);const s=t*v;for(let o=0;o<x;++o){const r=Math.max(0,Math.ceil((D-o)/d));const i=Math.min(f.outHeight,(f.inHeight+D-o)/d);const c=o*$+s;for(let s=0;s<b;++s){const a=Math.max(0,Math.ceil((M-s)/p));const u=Math.min(f.outWidth,(f.inWidth+M-s)/p);const l=s*y+c;for(let c=0;c<f.inChannels;++c){const m=c*k+l;for(let l=0;l<f.outChannels;++l){let x=0;for(let m=0;m<f.batchSize;++m){const f=m*I;const b=m*N;for(let m=n;m<e;++m){const n=t+m*h-_;const e=n*A+f;const g=m*R+b;for(let t=r;t<i;++t){const n=o+t*d-D;const r=n*O+e;const i=t*S+g;for(let t=a;t<u;++t){const n=s+t*p-M;const e=n*F+r;const o=t*E+i;x+=T[e+c]*C[o+l]}}}}w[m+l]=x}}}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const AI={kernelName:Gt,backendName:"cpu",kernelFunc:II};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{pad:i,strides:c,inputShape:a}=s;yR([o],"conv3dBackpropInputV2");const u=V(o.shape);const l=V(r.shape);const f=Tc(a,r.shape,c,1,i);const h=new Xo(f.inShape,"float32");const d=h.values;const[p,m,x,b]=h.strides;const g=e.data.get(o.dataId).values;const[w,v,$,y]=u;const k=e.data.get(r.dataId).values;const[C,N,R,S]=l;const{batchSize:E,filterDepth:T,filterHeight:I,filterWidth:A,inChannels:O,inDepth:F,inHeight:_,inWidth:M,outChannels:D,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:W,strideWidth:G}=f;const U=T-1-f.padInfo.front;const H=I-1-f.padInfo.top;const j=A-1-f.padInfo.left;for(let t=0;t<E;++t){for(let n=0;n<O;++n){for(let e=0;e<F;++e){const s=e-U;const o=Math.max(0,Math.ceil(s/B));const r=Math.min(L,(T+s)/B);for(let i=0;i<_;++i){const c=i-H;const a=Math.max(0,Math.ceil(c/W));const u=Math.min(z,(I+c)/W);for(let l=0;l<M;++l){const f=l-j;const h=Math.max(0,Math.ceil(f/G));const E=Math.min(P,(A+f)/G);let O=0;for(let e=o;e<r;++e){const o=e*B-s;for(let s=a;s<u;++s){const r=s*W-c;for(let i=h;i<E;++i){const c=i*G-f;const a=w*t+v*e+$*s+y*i;const u=C*(T-1-o)+N*(I-1-r)+R*(A-1-c)+S*n;for(let t=0;t<D;++t){const n=g[a+t];const e=k[u+t];O+=n*e}}}}d[p*t+m*e+x*i+b*l+n]=O}}}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}const FI={kernelName:Ut,backendName:"cpu",kernelFunc:OI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _I=YR(Ht,(t=>Math.cos(t)));const MI={kernelName:Ht,backendName:"cpu",kernelFunc:_I};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DI=YR(jt,(t=>Math.cosh(t)));const LI={kernelName:jt,backendName:"cpu",kernelFunc:DI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o,boxes:r,boxInd:i}=n;const{cropSize:c,method:a,extrapolationValue:u}=s;const[l,f,h,d]=o.shape;const p=r.shape[0];const[m,x]=c;const b=Fi([p,m,x,d],"float32");const g=e.data.get(r.dataId).values;const w=e.data.get(i.dataId).values;const v=e.data.get(o.dataId).values;const $=V(o.shape);const y=V(b.shape);for(let t=0;t<p;t++){const n=t*4;const e=g[n];const s=g[n+1];const o=g[n+2];const r=g[n+3];const i=w[t];if(i>=l){continue}const c=m>1?(o-e)*(f-1)/(m-1):0;const p=x>1?(r-s)*(h-1)/(x-1):0;for(let n=0;n<m;n++){const l=m>1?e*(f-1)+n*c:.5*(e+o)*(f-1);if(l<0||l>f-1){for(let e=0;e<x;e++){for(let s=0;s<d;s++){const o=s+e*y[2]+n*y[1]+t*y[0];b.values[o]=u}}continue}if(a==="bilinear"){const e=Math.floor(l);const o=Math.ceil(l);const c=l-e;for(let a=0;a<x;a++){const l=x>1?s*(h-1)+a*p:.5*(s+r)*(h-1);if(l<0||l>h-1){for(let e=0;e<d;e++){const s=e+a*y[2]+n*y[1]+t*y[0];b.values[s]=u}continue}const f=Math.floor(l);const m=Math.ceil(l);const g=l-f;for(let s=0;s<d;s++){let r=s+f*$[2]+e*$[1]+i*$[0];const u=v[r];r=s+m*$[2]+e*$[1]+i*$[0];const l=v[r];r=s+f*$[2]+o*$[1]+i*$[0];const h=v[r];r=s+m*$[2]+o*$[1]+i*$[0];const d=v[r];const p=u+(l-u)*g;const x=h+(d-h)*g;r=s+a*y[2]+n*y[1]+t*y[0];b.values[r]=p+(x-p)*c}}}else{for(let e=0;e<x;++e){const o=x>1?s*(h-1)+e*p:.5*(s+r)*(h-1);if(o<0||o>h-1){for(let s=0;s<d;s++){const o=s+e*y[2]+n*y[1]+t*y[0];b.values[o]=u}continue}const c=Math.round(o);const a=Math.round(l);for(let s=0;s<d;s++){const o=s+c*$[2]+a*$[1]+i*$[0];const r=s+e*y[2]+n*y[1]+t*y[0];b.values[r]=v[o]}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const PI={kernelName:Kt,backendName:"cpu",kernelFunc:zI};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;yR(o,"cumprod");const a=_u([r],o.shape.length);let u=o;if(a!=null){u=tE({inputs:{x:o},backend:e,attrs:{perm:a}})}const l=Du(1,o.shape.length)[0];if(l!==u.shape.length-1){throw new Error(`backend.cumprod in CPU expects an inner-most `+`axis=${u.shape.length-1} but got axis=${l}`)}const f=ar(u.dtype,"int32");const h=U(g(u.shape),f);const d=e.data.get(u.dataId).values;const p=u.shape[u.shape.length-1];const m=c?(t,n)=>t+p-n-1:(t,n)=>t+n;for(let t=0;t<d.length;t+=p){for(let n=0;n<p;n++){const e=m(t,n);if(n===0){h[e]=i?1:d[e]}else{const s=m(t,n-1);h[e]=i?d[s]*h[s]:d[e]*h[s]}}}const x=e.makeTensorInfo(u.shape,f,h);if(a!=null){const t=Mu(a);const n=tE({inputs:{x},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(x);e.disposeIntermediateTensorInfo(u);return n}return x}const BI={kernelName:qt,backendName:"cpu",kernelFunc:VI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;yR(o,"cumsum");const a=_u([r],o.shape.length);let u=o;if(a!=null){u=tE({inputs:{x:o},backend:e,attrs:{perm:a}})}const l=Du(1,o.shape.length)[0];if(l!==u.shape.length-1){throw new Error(`backend.cumsum in CPU expects an inner-most `+`axis=${u.shape.length-1} but got axis=${l}`)}const f=ar(u.dtype,"int32");const h=H(g(u.shape),f);const d=e.data.get(u.dataId).values;const p=u.shape[u.shape.length-1];const m=c?(t,n)=>t+p-n-1:(t,n)=>t+n;for(let t=0;t<d.length;t+=p){for(let n=0;n<p;n++){const e=m(t,n);if(n===0){h[e]=i?0:d[e]}else{const s=m(t,n-1);h[e]=i?d[s]+h[s]:d[e]+h[s]}}}const x=e.makeTensorInfo(u.shape,f,h);if(a!=null){const t=Mu(a);const n=tE({inputs:{x},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(x);e.disposeIntermediateTensorInfo(u);return n}return x}const GI={kernelName:Xt,backendName:"cpu",kernelFunc:WI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i,binaryOutput:c}=s;if(o.shape.length===1){const t=e.data.get(o.dataId).values;const n=e.data.get(r.dataId).values;const s=HR(t,n,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,s)}else if(o.shape.length===2){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=jR(t,n,i,c);return e.makeTensorInfo(s.shape,r.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank`+`${o.shape.length}.`)}const HI={kernelName:Jt,backendName:"cpu",kernelFunc:UI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockSize:r,dataFormat:i}=s;m(i==="NHWC",(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const c=o.shape[0];const a=o.shape[1];const u=o.shape[2];const l=o.shape[3];const f=a*r;const h=u*r;const d=l/(r*r);const p=e.data.get(o.dataId).values;const x=new Float32Array(c*f*h*d);let b=0;for(let t=0;t<c;++t){for(let n=0;n<f;++n){const e=Math.floor(n/r);const s=n%r;for(let n=0;n<h;++n){const o=Math.floor(n/r);const i=n%r;const c=(s*r+i)*d;for(let n=0;n<d;++n){const s=n+c;const r=s+l*(o+u*(e+a*t));x[b++]=p[r]}}}}return e.makeTensorInfo([c,f,h,d],o.dtype,x)}const qI={kernelName:Yt,backendName:"cpu",kernelFunc:jI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a,dimRoundingMode:u}=s;yR([o,r],"depthwiseConv2DNative");const l=V(o.shape);const f=V(r.shape);let h=a;if(h==null){h=[1,1]}m(Vc(i,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${i} and dilations '${h}'`));const d=Ec(o.shape,r.shape,i,h,c,u,true);const{filterHeight:p,filterWidth:x,dilationHeight:b,dilationWidth:g,padInfo:w}=d;const v=w.left;const $=w.top;const y=d.outChannels/d.inChannels;const k=new Xo(d.outShape,o.dtype);const C=e.data.get(o.dataId).values;const N=e.data.get(r.dataId).values;const R=k.values;for(let t=0;t<d.batchSize;++t){const n=t*l[0];const e=t*k.strides[0];for(let t=0;t<d.outHeight;++t){const s=e+t*k.strides[1];const o=t*d.strideHeight-$;for(let t=0;t<p;++t){const e=o+t*b;if(e<0||e>=d.inHeight){continue}const r=t*f[0];const i=n+e*l[1];for(let t=0;t<d.outWidth;++t){const n=s+t*k.strides[2];const e=t*d.strideWidth-v;for(let t=0;t<x;++t){const s=e+t*g;if(s<0||s>=d.inWidth){continue}const o=r+t*f[1];const c=i+s*d.inChannels;let a=n;let u=o;for(let t=0;t<d.inChannels;++t){const n=C[c+t];for(let t=0;t<y;++t){R[a+t]+=n*N[u+t]}a+=y;u+=y}}}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const KI={kernelName:Zt,backendName:"cpu",kernelFunc:XI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JI(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,filterShape:l}=s;yR([o,r],"depthwiseConv2dNativeBackpropFilter");const f=Ec(o.shape,l,i,c,a,u,true);const{strideHeight:h,strideWidth:d,filterHeight:p,filterWidth:m}=f;const x=new Xo(f.filterShape,"float32");const b=f.padInfo.left;const g=f.padInfo.top;const w=f.outChannels/f.inChannels;const v=e.data.get(o.dataId).values;const $=new Xo(o.shape,o.dtype,v);const y=e.data.get(r.dataId).values;const k=new Xo(r.shape,r.dtype,y);for(let t=0;t<p;++t){const n=Math.max(0,Math.ceil((g-t)/h));const e=Math.min(f.outHeight,(f.inHeight+g-t)/h);for(let s=0;s<m;++s){const o=Math.max(0,Math.ceil((b-s)/d));const r=Math.min(f.outWidth,(f.inWidth+b-s)/d);for(let i=0;i<f.outChannels;++i){const c=Math.trunc(i/w);const a=i%w;let u=0;for(let a=0;a<f.batchSize;++a){for(let l=n;l<e;++l){const n=t+l*h-g;for(let t=o;t<r;++t){const e=s+t*d-b;u+=$.get(a,n,e,c)*k.get(a,l,t,i)}}}x.set(u,t,s,c,a)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const YI={kernelName:Qt,backendName:"cpu",kernelFunc:JI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZI(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,inputShape:l}=s;yR([o,r],"depthwiseConv2DNativeBackpropInput");const f=V(o.shape);const h=V(r.shape);const d=Ec(l,r.shape,i,c,a,u,true);const p=new Xo(d.inShape,"float32");const m=p.values;const[x,b,g]=p.strides;const w=e.data.get(o.dataId).values;const[v,$,y]=f;const k=e.data.get(r.dataId).values;const[C,N,R]=h;const{batchSize:S,filterHeight:E,filterWidth:T,inChannels:I,inHeight:A,inWidth:O,outChannels:F,outHeight:_,outWidth:M,strideHeight:D,strideWidth:L}=d;const z=E-1-d.padInfo.top;const P=T-1-d.padInfo.left;const B=F/I;for(let t=0;t<S;++t){for(let n=0;n<I;++n){for(let e=0;e<A;++e){const s=e-z;const o=Math.max(0,Math.ceil(s/D));const r=Math.min(_,(E+s)/D);for(let i=0;i<O;++i){const c=i-P;const a=Math.max(0,Math.ceil(c/L));const u=Math.min(M,(T+c)/L);let l=0;for(let e=o;e<r;++e){const o=e*D-s;for(let s=a;s<u;++s){const r=s*L-c;const i=v*t+$*e+y*s;const a=C*(E-1-o)+N*(T-1-r)+R*n;for(let t=0;t<B;++t){const e=n*B+t;const s=w[i+e];const o=k[a+t];l+=s*o}}}m[x*t+b*e+g*i+n]=l}}}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}const QI={kernelName:tn,backendName:"cpu",kernelFunc:ZI};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=g(s.shape);const r=e.data.get(s.dataId).values;const i=Fi([o,o],s.dtype);const c=i.values;for(let t=0;t<r.length;t++){c[t*o+t]=r[t]}const a=[...s.shape,...s.shape];return e.makeTensorInfo(a,i.dtype,i.values)}const nA={kernelName:nn,backendName:"cpu",kernelFunc:tA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eA={kernelName:en,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o}=t;const{strides:r,pad:i,dilations:c}=e;const a=n;const u=a.data.get(s.dataId).values;const l=s.shape.length;const f=a.data.get(o.dataId).values;const h=o.shape.length;const{batchSize:d,inHeight:p,inWidth:m,inChannels:x,outHeight:b,outWidth:w,padInfo:v,strideHeight:$,strideWidth:y,filterHeight:k,filterWidth:C,dilationHeight:N,dilationWidth:R,outShape:S}=Nc(s.shape,o.shape,r,i,"NHWC",c);const T=g(S);const I=S.length;const A=E(s.dtype,T);for(let t=0;t<d;++t){for(let n=0;n<b;++n){const e=n*$-v.top;for(let r=0;r<w;++r){const i=r*y-v.left;for(let c=0;c<x;++c){let a=Number.MIN_SAFE_INTEGER;for(let n=0;n<k;++n){const r=e+n*N;if(r>=0&&r<p){for(let e=0;e<C;++e){const d=i+e*R;if(d>=0&&d<m){const i=X([t,r,d,c],l,V(s.shape));const p=X([n,e,c],h,V(o.shape));const m=u[i]+f[p];if(m>a){a=m}}}}}const d=X([t,n,r,c],I,V(S));A[d]=a}}}}const O=a.write(Eo(A,s.dtype),S,s.dtype);return{dataId:O,shape:S,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sA={kernelName:on,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o,dy:r}=t;const{strides:i,pad:c,dilations:a}=e;const u=n;const l=W(s.shape,u.data.get(s.dataId).values);const f=W(o.shape,u.data.get(o.dataId).values);const{batchSize:h,inHeight:d,inWidth:p,inChannels:x,outHeight:b,outWidth:g,padInfo:w,strideHeight:v,strideWidth:$,filterHeight:y,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:R}=Nc(s.shape,o.shape,i,c,"NHWC",a);m(r.rank===R.length,(()=>`Error in ${on}, dy `+`must have the same rank as output ${R.length}, but got `+`${r.rank}`));const S=W(R,u.data.get(r.dataId).values);const E=j(o.shape,o.dtype);for(let t=0;t<h;++t){for(let n=0;n<b;++n){const e=n*v-w.top;for(let s=0;s<g;++s){const o=s*$-w.left;for(let r=0;r<x;++r){let i=Number.MIN_SAFE_INTEGER;let c=0;let a=0;for(let n=0;n<y;++n){const s=e+n*C;if(s>=0&&s<d){for(let e=0;e<k;++e){const u=o+e*N;if(u>=0&&u<p){const o=l[t][s][u][r]+f[n][e][r];if(o>i){i=o;c=n;a=e}}}}}E[c][a][r]+=S[t][n][s][r]}}}}const T=u.write(Eo(E,s.dtype),o.shape,o.dtype);return{dataId:T,shape:o.shape,dtype:o.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oA={kernelName:sn,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:s,filter:o,dy:r}=t;const{strides:i,pad:c,dilations:a}=e;const u=n;const l=W(s.shape,u.data.get(s.dataId).values);const f=W(o.shape,u.data.get(o.dataId).values);const{batchSize:h,inHeight:d,inWidth:p,inChannels:x,outHeight:b,outWidth:g,padInfo:w,strideHeight:v,strideWidth:$,filterHeight:y,filterWidth:k,dilationHeight:C,dilationWidth:N,outShape:R}=Nc(s.shape,o.shape,i,c,"NHWC",a);m(r.rank===R.length,(()=>`Error in ${sn}, dy `+`must have the same rank as output ${R.length}, but got `+`${r.rank}`));const S=W(R,u.data.get(r.dataId).values);const E=j(s.shape,s.dtype);for(let t=0;t<h;++t){for(let n=0;n<b;++n){const e=n*v-w.top;for(let s=0;s<g;++s){const o=s*$-w.left;for(let r=0;r<x;++r){let i=Number.MIN_SAFE_INTEGER;let c=e<0?0:e;let a=o<0?0:o;for(let n=0;n<y;++n){const s=e+n*C;if(s>=0&&s<d){for(let e=0;e<k;++e){const u=o+e*N;if(u>=0&&u<p){const o=l[t][s][u][r]+f[n][e][r];if(o>i){i=o;c=s;a=u}}}}}E[t][c][a][r]+=S[t][n][s][r]}}}}const T=u.write(Eo(E,s.dtype),s.shape,s.dtype);return{dataId:T,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o}=n;const{canvas:r,options:i}=s;const{contextOptions:c,imageOptions:a}=i||{};const u=(a===null||a===void 0?void 0:a.alpha)||1;const l=(c===null||c===void 0?void 0:c.contextType)||"2d";if(l!=="2d"){throw new Error(`Context type ${c.contextType} is not supported by the CPU backend.`)}const f=r.getContext(l,(c===null||c===void 0?void 0:c.contextAttributes)||{});if(f==null){throw new Error(`Could not get the context with ${l} type.`)}const[h,d]=o.shape.slice(0,2);const p=o.shape.length===2?1:o.shape[2];const m=e.data.get(o.dataId).values;const x=o.dtype==="float32"?255:1;const b=new Uint8ClampedArray(d*h*4);for(let t=0;t<h*d;++t){const n=[0,0,0,255*u];for(let e=0;e<p;e++){const s=m[t*p+e];if(o.dtype==="float32"){if(s<0||s>1){throw new Error(`Tensor values for a float32 Tensor must be in the `+`range [0 - 1] but encountered ${s}.`)}}else if(o.dtype==="int32"){if(s<0||s>255){throw new Error(`Tensor values for a int32 Tensor must be in the `+`range [0 - 255] but encountered ${s}.`)}}if(p===1){n[0]=s*x;n[1]=s*x;n[2]=s*x}else{n[e]=s*x}}const e=t*4;b[e+0]=Math.round(n[0]);b[e+1]=Math.round(n[1]);b[e+2]=Math.round(n[2]);b[e+3]=Math.round(n[3])}r.width=d;r.height=h;const g=new ImageData(b,d,h);f.putImageData(g,0,0);return o}const iA={kernelName:rn,backendName:"cpu",kernelFunc:rA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;yR(o,"sum");let c;if(o.dtype==="bool"){c=LR({inputs:{x:o},backend:e,attrs:{dtype:"int32"}})}else{c=OR({inputs:{x:o},backend:e})}const a=c.shape.length;const u=N(r,c.shape);const l=_u(u,a);let f=u;let h=c;if(l!=null){h=tE({inputs:{x:c},backend:e,attrs:{perm:l}});f=Du(f.length,a)}Fu("sum",f,h.shape.length);const[d,p]=Au(h.shape,f);const m=ar(h.dtype,"int32");let x=AR(e,d,m);const b=g(p);const w=e.data.get(x.dataId).values;const v=e.data.get(h.dataId).values;for(let t=0;t<w.length;++t){const n=t*b;let e=0;for(let t=0;t<b;++t){e+=v[n+t]}w[t]=e}if(i){const t=Ou(x.shape,u);const n=x;x=bT({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(n)}e.disposeIntermediateTensorInfo(c);if(l!=null){e.disposeIntermediateTensorInfo(h)}return x}const aA={kernelName:Ue,backendName:"cpu",kernelFunc:cA};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(t){const{inputs:n,backend:e,attrs:s}=t;const{equation:o}=s;const r=n;const{allDims:i,summedDims:c,idDims:a}=Ox(o,r.length);_x(i.length,a,r);const{path:u,steps:l}=Mx(c,a);const f=l.length;let h=null;let d=i.length;const p=[];for(let t=0;t<f;++t){for(const n of l[t]){const{permutationIndices:t,expandDims:s}=Fx(d,a[n]);let o;if(Dx(t)){o=r[n]}else{o=tE({inputs:{x:r[n]},backend:e,attrs:{perm:t}});p.push(o)}const i=o.shape.slice();for(let t=0;t<s.length;++t){i.splice(s[t],0,1)}if(!w(o.shape,i)){o=bT({inputs:{x:o},backend:e,attrs:{shape:i}});p.push(o)}if(h===null){h=o}else{h=HS({inputs:{a:o,b:h},backend:e});p.push(h)}}if(t<f-1){if(u[t]>=0){h=cA({inputs:{x:h},backend:e,attrs:{axis:u[t]-(i.length-d),keepDims:false}});p.push(h)}d--}}for(const t of p){if(t===h){continue}e.disposeIntermediateTensorInfo(t)}return h}const lA={kernelName:an,backendName:"cpu",kernelFunc:uA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fA(t){const{inputs:n,backend:e}=t;const{dy:s,y:o}=n;yR([s,o],"eluGrad");const r=new Float32Array(g(o.shape));const i=e.data.get(o.dataId).values;const c=e.data.get(s.dataId).values;for(let t=0;t<i.length;++t){const n=i[t];if(n>=0){r[t]=c[t]}else{r[t]=c[t]*(n+1)}}return e.makeTensorInfo(o.shape,"float32",r)}const hA={kernelName:ln,backendName:"cpu",kernelFunc:fA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dA=px;const pA=mx;const mA=xx;const xA=bx;const bA=gx;const gA=wx;const wA=YR(fn,(t=>{const n=Math.sign(t);const e=Math.abs(t);const s=1/(1+dA*e);return n*(1-((((gA*s+bA)*s+xA)*s+mA)*s+pA)*s*Math.exp(-e*e))}));const vA={kernelName:fn,backendName:"cpu",kernelFunc:wA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $A(t){const{inputs:n,backend:e,attrs:s}=t;const{input:o}=n;const{dim:r}=s;const i=o.shape.length;const c=o.shape.slice();let a=r;if(r<0){m(-(i+1)<=r,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`));a=i+r+1}c.splice(a,0,1);return bT({inputs:{x:o},backend:e,attrs:{shape:c}})}const yA={kernelName:pn,backendName:"cpu",kernelFunc:$A};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kA=ER(((t,n)=>t/n));const CA=PR(cn,kA);const NA={kernelName:cn,backendName:"cpu",kernelFunc:CA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(t,n,e){const s=t.shape;const o=s[0];const r=s[1];const i=e.data.get(t.dataId);const c=i.complexTensorInfos.real;const a=i.complexTensorInfos.imag;const u=[o,r];const l=g(u);const f=S("float32",l);const h=S("float32",l);for(let t=0;t<o;t++){const s=TE({inputs:{x:c},backend:e,attrs:{begin:[t,0],size:[1,r]}});const o=TE({inputs:{x:a},backend:e,attrs:{begin:[t,0],size:[1,r]}});const i=TR({inputs:{real:s,imag:o},backend:e});const{real:u,imag:l}=SA(i,n,e);const d=vx(u,l);for(let n=0;n<r;n++){const e=Cx(d,n);f[t*r+n]=e.real;h[t*r+n]=e.imag}e.disposeIntermediateTensorInfo(s);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(i)}const d=e.makeTensorInfo(u,"float32",f);const p=e.makeTensorInfo(u,"float32",h);const m=TR({inputs:{real:d,imag:p},backend:e});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);return m}function SA(t,n,e){const s=g(t.shape);const o=e.data.get(t.dataId);const r=e.data.get(o.complexTensorInfos.real.dataId).values;const i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(EA(s)){const o=TA(r,i,s,n,e);const c=[t.shape[0],t.shape[1]];if(n){const t=e.makeTensorInfo(c,"float32",o.real);const n=e.makeTensorInfo(c,"float32",o.imag);const r=e.makeTensorInfo([],"float32",Ro(s,"float32"));const i=OR({inputs:{x:r},backend:e});const a=NA.kernelFunc({inputs:{a:t,b:r},backend:e});const u=NA.kernelFunc({inputs:{a:n,b:i},backend:e});const l=e.data.get(a.dataId).values;const f=e.data.get(u.dataId).values;e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(r);e.disposeIntermediateTensorInfo(i);e.disposeIntermediateTensorInfo(a);e.disposeIntermediateTensorInfo(u);return{real:l,imag:f}}return o}else{const t=vx(r,i);const e=IA(t,s,n);return $x(e)}}function EA(t){return(t&t-1)===0}function TA(t,n,e,s,o){if(e===1){return{real:t,imag:n}}const r=vx(t,n);const i=e/2;const c=yx(r);const a=c.real;const u=c.imag;const l=[a.length];const f=o.makeTensorInfo(l,"float32",a);const h=o.makeTensorInfo(l,"float32",u);const d=TR({inputs:{real:f,imag:h},backend:o});const p=kx(r);const m=p.real;const x=p.imag;const b=[m.length];const g=o.makeTensorInfo(b,"float32",m);const w=o.makeTensorInfo(b,"float32",x);const v=TR({inputs:{real:g,imag:w},backend:o});const $=TA(a,u,i,s,o);const y=$.real;const k=$.imag;const C=[y.length];const N=o.makeTensorInfo(C,"float32",y);const R=o.makeTensorInfo(C,"float32",k);const S=TR({inputs:{real:N,imag:R},backend:o});const E=TA(m,x,i,s,o);const T=E.real;const I=E.imag;const A=[T.length];const O=o.makeTensorInfo(A,"float32",T);const F=o.makeTensorInfo(A,"float32",I);const _=TR({inputs:{real:O,imag:F},backend:o});const M=Rx(e,s);const D=[M.real.length];const L=o.makeTensorInfo(D,"float32",M.real);const z=o.makeTensorInfo(D,"float32",M.imag);const P=TR({inputs:{real:L,imag:z},backend:o});const V=HS({inputs:{a:P,b:_},backend:o});const B=GR({inputs:{a:S,b:V},backend:o});const W=YE({inputs:{a:S,b:V},backend:o});const G=_R({inputs:{input:B},backend:o});const U=_R({inputs:{input:W},backend:o});const H=gI({inputs:{input:B},backend:o});const j=gI({inputs:{input:W},backend:o});const q=vI({inputs:[G,U],backend:o,attrs:{axis:0}});const X=vI({inputs:[H,j],backend:o,attrs:{axis:0}});const K=o.data.get(q.dataId).values;const J=o.data.get(X.dataId).values;o.disposeIntermediateTensorInfo(f);o.disposeIntermediateTensorInfo(h);o.disposeIntermediateTensorInfo(d);o.disposeIntermediateTensorInfo(g);o.disposeIntermediateTensorInfo(w);o.disposeIntermediateTensorInfo(v);o.disposeIntermediateTensorInfo(N);o.disposeIntermediateTensorInfo(R);o.disposeIntermediateTensorInfo(S);o.disposeIntermediateTensorInfo(O);o.disposeIntermediateTensorInfo(F);o.disposeIntermediateTensorInfo(_);o.disposeIntermediateTensorInfo(L);o.disposeIntermediateTensorInfo(z);o.disposeIntermediateTensorInfo(P);o.disposeIntermediateTensorInfo(V);o.disposeIntermediateTensorInfo(B);o.disposeIntermediateTensorInfo(W);o.disposeIntermediateTensorInfo(G);o.disposeIntermediateTensorInfo(H);o.disposeIntermediateTensorInfo(U);o.disposeIntermediateTensorInfo(j);o.disposeIntermediateTensorInfo(q);o.disposeIntermediateTensorInfo(X);return{real:K,imag:J}}function IA(t,n,e){const s=new Float32Array(n*2);for(let o=0;o<n;o++){let r=0;let i=0;for(let s=0;s<n;s++){const c=Sx(o*s,n,e);const a=Cx(t,s);r+=a.real*c.real-a.imag*c.imag;i+=a.real*c.imag+a.imag*c.real}if(e){r/=n;i/=n}Nx(s,r,i,o)}return s}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=g(s.shape);const r=s.shape[s.shape.length-1];const i=o/r;const c=bT({inputs:{x:s},backend:e,attrs:{shape:[i,r]}});const a=RA(c,false,e);const u=bT({inputs:{x:a},backend:e,attrs:{shape:s.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(a);return u}const OA={kernelName:xn,backendName:"cpu",kernelFunc:AA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FA(t){const{backend:n,attrs:e}=t;const{shape:s,value:o,dtype:r}=e;const i=r||L(o);const c=E(i,g(s));MA(c,o,i);return n.makeTensorInfo(s,i,c)}const _A={kernelName:bn,backendName:"cpu",kernelFunc:FA};function MA(t,n,e){if(e==="string"){t.fill(n)}else{t.fill(n)}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DA={kernelName:gn,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const o=e;const r=S(s.dtype,g(s.shape));const[i,c,a,u]=s.shape;const l=o.data.get(s.dataId).values;for(let t=0;t<i;t++){const n=t*a*c*u;for(let t=0;t<c;t++){const e=t*(a*u);for(let t=0;t<a;t++){const s=t*u;for(let o=0;o<u;o++){const i=Math.round(a-t-1);const c=n+e+s+o;let f=l[c];if(i>=0&&i<a){const t=i*u;const s=n+e+t+o;f=l[s]}r[c]=f}}}}const f=o.write(r,s.shape,s.dtype);return{dataId:f,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;let m=yI({inputs:{x:o,filter:r},backend:e,attrs:{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h}});if(i){const t=m;if(l==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const t=bT({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});m=GR({inputs:{a:m,b:t},backend:e});e.disposeIntermediateTensorInfo(t)}else{m=GR({inputs:{a:m,b:i},backend:e})}e.disposeIntermediateTensorInfo(t)}if(d){const t=m;if(l==="NCHW"&&d==="prelu"&&c.shape.length===1&&c.shape[0]!==1){const t=bT({inputs:{x:c},backend:e,attrs:{shape:[c.shape[0],1,1]}});m=xT(e,m,d,t,p);e.disposeIntermediateTensorInfo(t)}else{m=xT(e,m,d,c,p)}e.disposeIntermediateTensorInfo(t)}return m}const zA={kernelName:$s,backendName:"cpu",kernelFunc:LA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;let m=XI({inputs:{x:o,filter:r},backend:e,attrs:{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h}});if(i){const t=m;m=GR({inputs:{a:m,b:i},backend:e});e.disposeIntermediateTensorInfo(t)}if(d){const t=m;m=xT(e,m,d,c,p);e.disposeIntermediateTensorInfo(t)}return m}const VA={kernelName:ys,backendName:"cpu",kernelFunc:PA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(t){const{inputs:n,backend:e}=t;const{params:s,indices:o}=n;const r=g(s.shape);const i=o.shape;const c=i[i.length-1];const[a,u,l,f]=Nm(s,o);if(u===0){return e.makeTensorInfo(a,s.dtype,[])}const h=e.data.get(o.dataId).values;const d=e.bufferSync(s);const p=gS(h,d,s.dtype,u,c,l,f,s.shape,r);return e.makeTensorInfo(a,s.dtype,p.values)}const WA={kernelName:kn,backendName:"cpu",kernelFunc:BA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,indices:r}=n;const{axis:i,batchDims:c}=s;yR([o,r],"gatherV2");const a=N(i,o.shape)[0];const u=e.data.get(r.dataId).values;const l=o.shape[a];for(let t=0;t<u.length;++t){const n=u[t];m(n<=l-1&&n>=0,(()=>`GatherV2: the index value ${n} is not in [0, ${l-1}]`))}let f=c;if(c==null){f=0}const h=g(r.shape);const d=Qx(o,r,a,f);const p=bT({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}});const x=bT({inputs:{x:r},backend:e,attrs:{shape:[d.batchSize,h/d.batchSize]}});const b=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];const w=e.bufferSync(x);const v=e.bufferSync(p);const $=wS(v,w,b);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(x);return e.makeTensorInfo(d.outputShape,$.dtype,$.values)}const UA={kernelName:yn,backendName:"cpu",kernelFunc:GA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=g(s.shape);const r=s.shape[s.shape.length-1];const i=o/r;const c=bT({inputs:{x:s},backend:e,attrs:{shape:[i,r]}});const a=RA(c,true,e);const u=bT({inputs:{x:a},backend:e,attrs:{shape:s.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(a);return u}const jA={kernelName:Sn,backendName:"cpu",kernelFunc:HA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qA=YR(Tn,(t=>Number.isFinite(t)?1:0),"bool");const XA={kernelName:Tn,backendName:"cpu",kernelFunc:qA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KA=YR(In,(t=>Math.abs(t)===Infinity?1:0),"bool");const JA={kernelName:In,backendName:"cpu",kernelFunc:KA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YA=YR(An,(t=>Number.isNaN(t)?1:0),"bool");const ZA={kernelName:An,backendName:"cpu",kernelFunc:YA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,num:r}=e;const i=OS(s,o,r);return n.makeTensorInfo([i.length],"float32",i)}const tO={kernelName:Mn,backendName:"cpu",kernelFunc:QA};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nO=YR(Ln,(t=>Math.log1p(t)));const eO={kernelName:Ln,backendName:"cpu",kernelFunc:nO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO=ER(((t,n)=>t&&n));const oO=PR(zn,sO,null,"bool");const rO={kernelName:zn,backendName:"cpu",kernelFunc:oO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO=YR(Pn,(t=>t?0:1),"bool");const cO={kernelName:Pn,backendName:"cpu",kernelFunc:iO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aO=ER(((t,n)=>t||n));const uO=PR(Vn,aO,null,"bool");const lO={kernelName:Vn,backendName:"cpu",kernelFunc:uO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=s;yR(o,"LRN");const u=o.shape[3];const l=u-1;const f=e.data.get(o.dataId).values;const h=g(o.shape);const d=new Float32Array(h);function p(t){const n=t%u;let e=t-n+Math.max(0,n-r);const s=t-n+Math.min(n+r,l);let o=0;for(;e<=s;e++){const t=f[e];o+=t*t}return o}for(let t=0;t<h;t++){const n=p(t);const e=f[t]*Math.pow(i+c*n,-a);d[t]=e}return e.makeTensorInfo(o.shape,o.dtype,d)}const hO={kernelName:Wn,backendName:"cpu",kernelFunc:fO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,y:r,dy:i}=n;const{depthRadius:c,bias:a,alpha:u,beta:l}=s;yR(i,"LRNGrad");const f=g(i.shape);const h=i.shape[3];const d=e.data.get(i.dataId).values;const p=e.data.get(o.dataId).values;const m=e.data.get(r.dataId).values;const x=new Float32Array(f);const b=f;for(let t=0;t<b;t++){const n=t%h;const e=t-n+Math.max(0,n-c);const s=t-n+Math.min(h,n+c+1);let o=0;for(let t=e;t<s;t++){o+=Math.pow(p[t],2)}o=u*o+a;for(let n=e;n<s;n++){let e=-2*u*l*p[n]*m[t]/o;if(t===n){e+=Math.pow(o,-l)}e*=d[t];x[n]+=e}}return e.makeTensorInfo(i.shape,o.dtype,x)}const pO={kernelName:Gn,backendName:"cpu",kernelFunc:dO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reductionIndices:r,keepDims:i}=s;const c=e;let a=o.shape;const u=a.length;const l=N(r,a);let f=l;const h=_u(f,u);let d=c.data.get(o.dataId).values;if(h!=null){const t=new Array(u);for(let n=0;n<t.length;n++){t[n]=a[h[n]]}d=QS(d,a,o.dtype,h,t);f=Du(f.length,u);a=t}yR(o,"max");Fu("max",f,u);const[p,m]=Au(a,f);const x=g(m);const b=DS(d,x,p,o.dtype);const w=c.write(b,p,o.dtype);let v=p;if(i){const t=Ou(p,l);v=t}return{dataId:w,shape:v,dtype:o.dtype}}const xO={kernelName:Un,backendName:"cpu",kernelFunc:mO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;yR(o,"maxPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;m(Vc(i,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=Rc(o.shape,r,i,u,c,a);let f;if(l.filterWidth===1&&l.filterHeight===1&&w(l.inShape,l.outShape)){f=OR({inputs:{x:o},backend:e})}else{const t=e.data.get(o.dataId).values;const n=V(o.shape);const s=XT(t,o.shape,o.dtype,n,l,"max");f=e.makeTensorInfo(l.outShape,o.dtype,s.values)}return f}const gO={kernelName:jn,backendName:"cpu",kernelFunc:bO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;yR(o,"maxPool3d");const l=Sc(o.shape,r,i,1,c,a,u);const f=e.data.get(o.dataId).values;const h=JT(f,o.shape,o.dtype,V(o.shape),l,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}const vO={kernelName:Xn,backendName:"cpu",kernelFunc:wO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $O(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const{filterSize:i,strides:c,pad:a,dimRoundingMode:u}=s;yR([o,r],"maxPool3DGrad");const l=Sc(r.shape,i,c,1,a,u);const f=e.bufferSync(r);const h=YT(f,l);const d=l.strideDepth;const p=l.strideHeight;const m=l.strideWidth;const x=l.dilationDepth;const b=l.dilationHeight;const g=l.dilationWidth;const w=l.effectiveFilterDepth;const v=l.effectiveFilterHeight;const $=l.effectiveFilterWidth;const y=w-1-l.padInfo.front;const k=$-1-l.padInfo.left;const C=v-1-l.padInfo.top;const N=Fi(r.shape,"float32");const R=e.bufferSync(o);for(let t=0;t<l.batchSize;++t){for(let n=0;n<l.inChannels;++n){for(let e=0;e<l.inDepth;++e){for(let s=0;s<l.inHeight;++s){for(let o=0;o<l.inWidth;++o){const r=e-y;const i=s-C;const c=o-k;let a=0;for(let e=0;e<w;e+=x){const s=(r+e)/d;if(s<0||s>=l.outDepth||Math.floor(s)!==s){continue}for(let o=0;o<v;o+=b){const r=(i+o)/p;if(r<0||r>=l.outHeight||Math.floor(r)!==r){continue}for(let i=0;i<$;i+=g){const u=(c+i)/m;if(u<0||u>=l.outWidth||Math.floor(u)!==u){continue}const f=w*v*$-1-h.get(t,s,r,u,n);const d=e*v*$+o*$+i;const p=f===d?1:0;if(p===0){continue}const x=R.get(t,s,r,u,n);a+=x*p}}}N.set(a,t,e,s,o,n)}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const yO={kernelName:Kn,backendName:"cpu",kernelFunc:$O};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r,output:i}=n;const c=r;yR([r,i],"maxPoolGrad");const{filterSize:a,strides:u,pad:l,dimRoundingMode:f}=s;const h=Rc(c.shape,a,u,1,l,f);const d=e.data.get(c.dataId).values;const p=Fi(h.outShape,c.dtype,KT(d,c.shape,c.dtype,h).values);const m=h.strideHeight;const x=h.strideWidth;const b=h.dilationHeight;const g=h.dilationWidth;const w=h.effectiveFilterHeight;const v=h.effectiveFilterWidth;const $=v-1-h.padInfo.left;const y=w-1-h.padInfo.top;const k=Fi(c.shape,"float32");const C=e.data.get(o.dataId).values;const N=Fi(o.shape,"float32",C);for(let t=0;t<h.batchSize;++t){for(let n=0;n<h.inChannels;++n){for(let e=0;e<h.inHeight;++e){for(let s=0;s<h.inWidth;++s){const o=e-y;const r=s-$;let i=0;for(let e=0;e<w;e+=b){const s=(o+e)/m;if(s<0||s>=h.outHeight||Math.floor(s)!==s){continue}for(let o=0;o<v;o+=g){const c=(r+o)/x;if(c<0||c>=h.outWidth||Math.floor(c)!==c){continue}const a=w*v-1-p.get(t,s,c,n);const u=e*v+o;const l=a===u?1:0;if(l===0){continue}const f=N.get(t,s,c,n);i+=f*l}}k.set(i,t,e,s,n)}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}const CO={kernelName:qn,backendName:"cpu",kernelFunc:kO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NO(t,n,e,s,o){const r=V(n);const i=XT(t,n,e,r,o,"max");const c=KT(t,n,e,o,true,s);return[i.values,c.values]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RO={kernelName:Jn,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{filterSize:o,strides:r,pad:i,includeBatchInIndex:c}=n;const a=e;yR(s,"MaxPoolWithArgmax");const u=a.data.get(s.dataId).values;const l=Rc(s.shape,o,r,[1,1],i);const[f,h]=NO(u,s.shape,s.dtype,c,l);const d=a.write(f,l.outShape,s.dtype);const p=a.write(h,l.outShape,s.dtype);return[{dataId:d,shape:l.outShape,dtype:s.dtype},{dataId:p,shape:l.outShape,dtype:"int32"}]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=N(r,o.shape);const a=Au(o.shape,c);const u=a[1];const l=g(u);const f=[];const h=e.makeTensorInfo([],"float32",new Float32Array([l]));f.push(h);const d=LR({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});f.push(d);const p=CA({inputs:{a:d,b:h},backend:e});f.push(p);const m=cA({inputs:{x:p},backend:e,attrs:{axis:r,keepDims:i}});f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return m}const EO={kernelName:Yn,backendName:"cpu",kernelFunc:SO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;yR(o,"min");const c=N(r,o.shape);let a=c;const u=_u(a,o.shape.length);let l=o;if(u!=null){l=tE({inputs:{x:o},backend:e,attrs:{perm:u}});a=Du(a.length,o.shape.length)}Fu("min",a,l.shape.length);const[f,h]=Au(l.shape,a);const d=g(h);const p=H(g(f),l.dtype);const m=e.data.get(l.dataId).values;for(let t=0;t<p.length;++t){const n=t*d;let e=m[n];for(let t=0;t<d;++t){const s=m[n+t];if(Number.isNaN(s)||s<e){e=s}}p[t]=e}if(u!=null){e.disposeIntermediateTensorInfo(l)}const x=e.makeTensorInfo(f,l.dtype,p);if(i){const t=Ou(f,c);const n=bT({inputs:{x},backend:e,attrs:{shape:t}});e.disposeIntermediateTensorInfo(x);return n}return x}const IO={kernelName:Zn,backendName:"cpu",kernelFunc:TO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,mode:i}=s;yR(o,"mirrorPad");const c=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));const a=r.map((t=>t[0]));const u=r.map(((t,n)=>t[0]+o.shape[n]));const l=i==="reflect"?0:1;const f=e.data.get(o.dataId).values;const h=o.shape.length;const d=V(o.shape);const p=g(c);const m=c.length;const x=V(c);const b=S(o.dtype,p);for(let t=0;t<p;t++){let n=K(t,m,x);for(let t=0;t<m;t++){if(n[t]<a[t]){n[t]=a[t]*2-n[t]-l}else if(n[t]>=u[t]){n[t]=(u[t]-1)*2-n[t]+l}}n=n.map(((t,n)=>t-a[n]));const e=X(n,h,d);b[t]=f[e]}const w=e.write(b,c,o.dtype);return{dataId:w,shape:c,dtype:o.dtype}}const OO={kernelName:te,backendName:"cpu",kernelFunc:AO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FO=ER(((t,n)=>{const e=t%n;if(t<0&&n<0||t>=0&&n>=0){return e}else{return(e+n)%n}}));const _O=PR(ne,FO);const MO={kernelName:ne,backendName:"cpu",kernelFunc:_O};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{dim:r}=s;const i=o.shape.length;let c=r;if(c===-1){c=i-1}if(c!==i-1){throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${i} and dim was ${c}`)}const a=N([c],o.shape);const u=mO({inputs:{x:o},backend:e,attrs:{reductionIndices:a,keepDims:false}});const l=Ou(u.shape,a);const f=bT({inputs:{x:u},backend:e,attrs:{shape:l}});const h=YE({inputs:{a:o,b:f},backend:e});const d=cS({inputs:{x:h},backend:e});const p=cA({inputs:{x:d},backend:e,attrs:{axis:a,keepDims:false}});const m=bT({inputs:{x:p},backend:e,attrs:{shape:l}});const x=CA({inputs:{a:d,b:m},backend:e});e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);return x}const LO={kernelName:qe,backendName:"cpu",kernelFunc:DO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{numSamples:r,seed:i,normalized:c}=s;yR(o,"multinomial");const a=c?o:DO({inputs:{logits:o},backend:e,attrs:{dim:-1}});const u=a.shape[0];const l=a.shape[1];const f=e.data.get(a.dataId).values;const h=[u,r];const d=H(g(h),"int32");for(let t=0;t<u;++t){const n=t*l;const e=new Float32Array(l-1);e[0]=f[n];for(let t=1;t<e.length;++t){e[t]=e[t-1]+f[n+t]}const s=oh.alea(i.toString());const o=t*r;for(let t=0;t<r;++t){const n=s();d[o+t]=e.length;for(let s=0;s<e.length;s++){if(n<e[s]){d[o+t]=s;break}}}}if(!c){e.disposeIntermediateTensorInfo(a)}return e.makeTensorInfo(h,"int32",d)}const PO={kernelName:ee,backendName:"cpu",kernelFunc:zO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO=dp;function BO(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a}=s;yR(o,"NonMaxSuppression");const u=e.data.get(o.dataId).values;const l=e.data.get(r.dataId).values;const{selectedIndices:f}=VO(u,l,i,c,a);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const WO={kernelName:ie,backendName:"cpu",kernelFunc:BO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO=pp;function UO(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,padToMaxOutputSize:u}=s;yR(o,"NonMaxSuppressionPadded");const l=e.data.get(o.dataId).values;const f=e.data.get(r.dataId).values;const{selectedIndices:h,validOutputs:d}=GO(l,f,i,c,a,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}const HO={kernelName:ce,backendName:"cpu",kernelFunc:UO};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO=mp;function qO(t){const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,softNmsSigma:u}=s;yR(o,"NonMaxSuppressionWithScore");const l=e.data.get(o.dataId).values;const f=e.data.get(r.dataId).values;const h=i;const d=c;const p=a;const m=u;const{selectedIndices:x,selectedScores:b}=jO(l,f,h,d,p,m);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const XO={kernelName:ae,backendName:"cpu",kernelFunc:qO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KO(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o}=n;const{dtype:r,depth:i,onValue:c,offValue:a}=s;yR(o,"oneHot");const u=g(o.shape);const l=new Float32Array(u*i);l.fill(a);const f=e.data.get(o.dataId).values;for(let t=0;t<u;++t){if(f[t]>=0&&f[t]<i){l[t*i+f[t]]=c}}return e.makeTensorInfo([...o.shape,i],r,l)}const JO={kernelName:le,backendName:"cpu",kernelFunc:KO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YO(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("zerosLike is not supported for string tensors")}else if(s.dtype==="complex64"){const t=_R({inputs:{input:s},backend:e});const n=YO({inputs:{x:t},backend:e});const o=gI({inputs:{input:s},backend:e});const r=YO({inputs:{x:o},backend:e});const i=TR({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return FA({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}}const ZO={kernelName:xs,backendName:"cpu",kernelFunc:YO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QO(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("onesLike is not supported for string tensors")}else if(s.dtype==="complex64"){const t=_R({inputs:{input:s},backend:e});const n=QO({inputs:{x:t},backend:e});const o=gI({inputs:{input:s},backend:e});const r=YO({inputs:{x:o},backend:e});const i=TR({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return FA({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}}const tF={kernelName:ue,backendName:"cpu",kernelFunc:QO};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;if(n.length===1){return $A({inputs:{input:n[0]},backend:e,attrs:{dim:o}})}const r=n[0].shape;const i=n[0].dtype;n.forEach((t=>{x(r,t.shape,"All tensors passed to stack must have matching shapes");m(i===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=[];const a=n.map((t=>{const n=$A({inputs:{input:t},backend:e,attrs:{dim:o}});c.push(n);return n}));const u=vI({inputs:a,backend:e,attrs:{axis:o}});c.forEach((t=>e.disposeIntermediateTensorInfo(t)));return u}const eF={kernelName:fe,backendName:"cpu",kernelFunc:nF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,constantValue:i}=s;yR(o,"pad");const c=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));const a=r.map((t=>t[0]));const u=e.data.get(o.dataId).values;const l=g(o.shape);const f=o.shape.length;const h=V(o.shape);const d=g(c);const p=c.length;const m=V(c);const x=S(o.dtype,d);if(i!==0){x.fill(i)}for(let t=0;t<l;t++){const n=K(t,f,h);const e=n.map(((t,n)=>t+a[n]));const s=X(e,p,m);x[s]=u[t]}const b=e.write(x,c,o.dtype);return{dataId:b,shape:c,dtype:o.dtype}}const oF={kernelName:he,backendName:"cpu",kernelFunc:sF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rF=ER(((t,n)=>Math.pow(t,n)));const iF=PR(de,rF);const cF={kernelName:de,backendName:"cpu",kernelFunc:iF};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(t){const{inputs:n,backend:e,attrs:s}=t;const{paramsNestedSplits:o,paramsDenseValues:r,indices:i}=n;const c=o.map((t=>e.data.get(t.dataId).values));const a=o.map((t=>t.shape));const u=e.data.get(r.dataId).values;const l=e.data.get(i.dataId).values;const[f,h,d]=hE(c,a,u,r.shape,r.dtype,l,i.shape);const p=f.map((t=>e.makeTensorInfo([t.length],"int32",t)));const m=e.makeTensorInfo(d,r.dtype,h);return p.concat([m])}const uF={kernelName:xe,backendName:"cpu",kernelFunc:aF};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(t){const{inputs:n,backend:e}=t;const{starts:s,limits:o,deltas:r}=n;const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=pE(i,s.shape,s.dtype,c,o.shape,a,r.shape);const f=e.makeTensorInfo([u.length],"int32",u);const h=e.makeTensorInfo([l.length],s.dtype,l);return[f,h]}const fF={kernelName:be,backendName:"cpu",kernelFunc:lF};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(t){const{inputs:n,backend:e,attrs:s}=t;const{shape:o,values:r,defaultValue:i,rowPartitionTensors:c}=n;const{rowPartitionTypes:a}=s;const u=e.data.get(o.dataId).values;const l=e.data.get(r.dataId).values;const f=e.data.get(i.dataId).values;const h=c.map((t=>e.data.get(t.dataId).values));const d=c.map((t=>t.shape));const[p,m]=wE(u,o.shape,l,r.shape,r.dtype,f,i.shape,h,d,a);return e.makeTensorInfo(p,r.dtype,m)}const dF={kernelName:ge,backendName:"cpu",kernelFunc:hF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,dtype:r,step:i}=e;const c=vE(s,o,i,r);return n.makeTensorInfo([c.length],r,c)}const mF={kernelName:we,backendName:"cpu",kernelFunc:pF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xF=YR($e,(t=>1/t));const bF={kernelName:$e,backendName:"cpu",kernelFunc:xF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;yR(o,"resizeBilinear");const a=V(o.shape);const[u,l]=c;const[f,h,d,p]=o.shape;const m=e.data.get(o.dataId).values;const x=new Float32Array(g([f,u,l,p]));const b=[r&&u>1?h-1:h,r&&l>1?d-1:d];const w=[r&&u>1?u-1:u,r&&l>1?l-1:l];let v=0;const $=b[0]/w[0];const y=b[1]/w[1];for(let t=0;t<f;t++){for(let n=0;n<u;n++){let e;if(i){e=$*(n+.5)-.5}else{e=$*n}const s=Math.max(0,Math.floor(e));const o=e-s;const r=Math.min(h-1,Math.ceil(e));const c=t*a[0]+s*a[1];const u=t*a[0]+r*a[1];for(let t=0;t<l;t++){let n;if(i){n=y*(t+.5)-.5}else{n=y*t}const e=Math.max(0,Math.floor(n));const s=n-e;const r=Math.min(d-1,Math.ceil(n));const l=c+e*a[2];const f=u+e*a[2];const h=c+r*a[2];const b=u+r*a[2];for(let t=0;t<p;t++){const n=m[l+t];const e=m[f+t];const r=m[h+t];const i=m[b+t];const c=n+(r-n)*s;const a=e+(i-e)*s;const u=c+(a-c)*o;x[v++]=u}}}}return e.makeTensorInfo([f,u,l,p],"float32",x)}const wF={kernelName:Re,backendName:"cpu",kernelFunc:gF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;yR([r,o],"resizeBilinearGrad");const c=V(o.shape);const[a,u,l,f]=o.shape;const[,h,d]=r.shape;const p=new Float32Array(a*u*l*f);const m=[i&&h>1?u-1:u,i&&d>1?l-1:l];const x=[i&&h>1?h-1:h,i&&d>1?d-1:d];const b=m[0]/x[0];const g=m[1]/x[1];const w=e.data.get(r.dataId).values;let v=0;for(let t=0;t<a;t++){const n=t*c[0];for(let t=0;t<h;t++){const e=t*b;const s=Math.floor(e);const o=Math.min(Math.ceil(e),u-1);const r=n+s*c[1];const i=n+o*c[1];const a=e-s;const h=1-a;for(let t=0;t<d;t++){const n=t*g;const e=Math.floor(n);const s=Math.min(Math.ceil(n),l-1);const o=n-e;const u=1-o;const d=r+e*c[2];const m=r+s*c[2];const x=i+e*c[2];const b=i+s*c[2];const $=h*u;const y=h*o;const k=a*u;const C=a*o;for(let t=0;t<f;t++){const n=w[v++];p[d+t]+=n*$;p[m+t]+=n*y;p[x+t]+=n*k;p[b+t]+=n*C}}}}return e.makeTensorInfo([a,l,u,f],"float32",p)}const $F={kernelName:Se,backendName:"cpu",kernelFunc:vF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;yR(o,"resizeNearestNeighbor");const a=V(o.shape);const[u,l]=c;const[f,h,d,p]=o.shape;const m=e.data.get(o.dataId).values;const x=new Float32Array(f*u*l*p);const b=[r&&u>1?h-1:h,r&&l>1?d-1:d];const g=[r&&u>1?u-1:u,r&&l>1?l-1:l];const w=b[0]/g[0];const v=b[1]/g[1];let $=0;for(let t=0;t<f;t++){const n=t*a[0];for(let t=0;t<u;t++){const e=i?w*(t+.5):w*t;let s=Math.min(h-1,r?Math.round(e):Math.floor(e));if(i){s=Math.max(0,s)}const o=n+s*a[1];for(let t=0;t<l;t++){const n=i?v*(t+.5):v*t;let e=Math.min(d-1,r?Math.round(n):Math.floor(n));if(i){e=Math.max(0,e)}const s=o+e*a[2];for(let t=0;t<p;t++){const n=m[s+t];x[$++]=n}}}}return e.makeTensorInfo([f,u,l,p],o.dtype,x)}const kF={kernelName:Ce,backendName:"cpu",kernelFunc:yF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;yR([r,o],"resizeNearestNeighborGrad");const c=V(o.shape);const a=V(r.shape);const[u,l,f,h]=o.shape;const[,d,p]=r.shape;const m=new Float32Array(u*l*f*h);const x=e.data.get(r.dataId).values;const b=[i&&d>1?l-1:l,i&&p>1?f-1:f];const g=[i&&d>1?d-1:d,i&&p>1?p-1:p];const w=b[0]/g[0];const v=b[1]/g[1];const $=1/w;const y=1/v;const k=Math.ceil($)*2+2;const C=Math.ceil(y)*2+2;for(let t=0;t<u;t++){const n=t*c[0];for(let t=0;t<l;t++){const e=n+t*c[1];const s=Math.floor(t*$);const o=Math.floor(s-k/2);for(let s=0;s<f;s++){const r=e+s*c[2];const u=Math.floor(s*y);const b=Math.floor(u-C/2);for(let e=0;e<h;e++){let c=0;for(let r=0;r<k;r++){const u=r+o;if(u<0||u>=d){continue}const h=n+u*a[1];const m=u*w;const g=Math.min(l-1,i?Math.round(m):Math.floor(m));if(t!==g){continue}for(let t=0;t<C;t++){const n=t+b;if(n<0||n>=p){continue}const o=h+n*a[2];const r=n*v;const u=Math.min(f-1,i?Math.round(r):Math.floor(r));if(s===u){c+=x[o+e]}}}m[r+e]=c}}}}return e.makeTensorInfo(o.shape,o.dtype,m)}const NF={kernelName:Ne,backendName:"cpu",kernelFunc:CF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dims:r}=s;yR(o,"reverse");const i=o.shape.length;const c=N(r,o.shape);if(i===0){return OR({inputs:{x:o},backend:e})}const a=new Xo(o.shape,o.dtype);const u=e.bufferSync(o);for(let t=0;t<a.size;t++){const n=a.indexToLoc(t);const e=n.slice();c.forEach((t=>e[t]=o.shape[t]-1-e[t]));a.set(u.get(...e),...n)}return e.makeTensorInfo(a.shape,a.dtype,a.values)}const SF={kernelName:Te,backendName:"cpu",kernelFunc:RF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EF={kernelName:ws,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const{radians:o,fillValue:r,center:i}=n;const c=e;const a=S(s.dtype,g(s.shape));const[u,l,f,h]=s.shape;const[d,p]=ix(i,l,f);const m=255;const x=Math.sin(o);const b=Math.cos(o);const w=c.data.get(s.dataId).values;for(let t=0;t<u;t++){const n=t*f*l*h;for(let t=0;t<l;t++){const e=t*(f*h);for(let s=0;s<f;s++){const o=s*h;for(let i=0;i<h;i++){const c=[u,t,s,i];const g=c[2];const v=c[1];let $=(g-d)*b-(v-p)*x;let y=(g-d)*x+(v-p)*b;$=Math.round($+d);y=Math.round(y+p);let k=r;if(typeof r!=="number"){if(i===3){k=m}else{k=r[i]}}if($>=0&&$<f&&y>=0&&y<l){const t=y*(f*h);const e=$*h;const s=n+t+e+i;k=w[s]}const C=n+e+o+i;a[C]=k}}}}const v=c.write(a,s.shape,s.dtype);return{dataId:v,shape:s.shape,dtype:s.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=YR(Ie,(t=>{const n=Math.floor(t);if(t-n<.5){return Math.floor(t)}else if(t-n>.5){return Math.ceil(t)}else{if(n%2===0){return n}else{return n+1}}}));const IF={kernelName:Ie,backendName:"cpu",kernelFunc:TF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o,updates:r}=n;const{shape:i}=s;const{sliceRank:c,numUpdates:a,sliceSize:u,strides:l,outputSize:f}=gd(r,o,i);const h=true;const d=e.bufferSync(o);const p=e.bufferSync(r);const m=CE(d,p,i,f,u,a,c,l,0,h);return e.makeTensorInfo(i,m.dtype,m.values)}const OF={kernelName:Oe,backendName:"cpu",kernelFunc:AF};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(t,n){let e=0;let s=t.length;let o=0;while(e<s){o=Math.floor((e+s)/2);if(t[o]<n){e=o+1}else{s=o}}return s}function _F(t,n){let e=0;let s=t.length;let o=0;while(e<s){o=Math.floor((e+s)/2);if(t[o]<=n){e=o+1}else{s=o}}return s}function MF(t,n,e,s,o,r){const i=E("int32",e*o);for(let c=0;c<e;++c){const e=t.slice(c*s,(c+1)*s);const a=c*o;for(let t=0;t<o;++t){i[a+t]=r==="left"?FF(e,n[t+a]):_F(e,n[t+a])}}return i}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(t){const{inputs:n,backend:e,attrs:s}=t;const{sortedSequence:o,values:r}=n;const{side:i}=s;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const u=MF(c,a,o.shape[0],o.shape[1],r.shape[1],i);return e.makeTensorInfo(r.shape,"int32",u)}const LF={kernelName:_e,backendName:"cpu",kernelFunc:DF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(t){const{inputs:n,backend:e}=t;const{condition:s,t:o,e:r}=n;yR([s,o,r],"select");const i=s.shape.length;const c=e.data.get(s.dataId).values;const a=e.data.get(o.dataId).values;const u=e.data.get(r.dataId).values;const l=ar(o.dtype,r.dtype);const f=H(g(o.shape),l);let h=0;const d=i===0||i>1||o.shape.length===1?1:g(o.shape.slice(1));for(let t=0;t<c.length;t++){for(let n=0;n<d;n++){if(c[t]===1){f[h++]=a[t]}else{f[h++]=u[t]}}}return e.makeTensorInfo(o.shape,l,f)}const PF={kernelName:Me,backendName:"cpu",kernelFunc:zF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=hx;const BF=dx;const WF=YR(De,(t=>{if(t>=0){return BF*t}else{return VF*(Math.exp(t)-1)}}));const GF={kernelName:De,backendName:"cpu",kernelFunc:WF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=YR(Ve,(t=>{if(t<0){return-1}else if(t>0){return 1}else{return 0}}));const HF={kernelName:Ve,backendName:"cpu",kernelFunc:UF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=YR(ze,(t=>Math.sin(t)));const qF={kernelName:ze,backendName:"cpu",kernelFunc:jF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XF=YR(Pe,(t=>Math.sinh(t)));const KF={kernelName:Pe,backendName:"cpu",kernelFunc:XF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JF=1.1920928955078125e-7;const YF=Math.log(JF)+2;const ZF=YR(We,(t=>{const n=t>-YF;const e=t<YF;const s=Math.exp(t);let o;if(e){o=s}else if(n){o=t}else{o=Math.log(1+s)}return o}));const QF={kernelName:We,backendName:"cpu",kernelFunc:ZF};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,paddings:i}=s;yR([o],"spaceToBatchND");const c=g(r);const a=[[0,0]];a.push(...i);for(let t=1+r.length;t<o.shape.length;++t){a.push([0,0])}const u=oF.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:a,constantValue:0}});const l=cx(u.shape,r,c,false);const f=ax(l.length,r.length,false);const h=ux(u.shape,r,c,false);const d={x:u};const p={shape:l};const m=bT({inputs:d,backend:e,attrs:p});const x={x:m};const b={perm:f};const w=tE({inputs:x,backend:e,attrs:b});const v={x:w};const $={shape:h};const y=bT({inputs:v,backend:e,attrs:$});e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(w);return y}const n_={kernelName:He,backendName:"cpu",kernelFunc:t_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(t){const{inputs:n,backend:e}=t;const{indices:s,values:o,denseShape:r,defaultValue:i}=n;if(r.shape.length!==1){throw new Error(`Dense shape must be a vector, saw:\n        ${r.shape}`)}if(s.shape.length!==2){throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Values must be a vector, saw:\n        ${o.shape}`)}if(i.shape.length!==0){throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`)}const c=e.data.get(s.dataId).values;const a=e.data.get(o.dataId).values;const u=e.data.get(r.dataId).values;const l=e.data.get(i.dataId).values[0];const[f,h,d,p,m]=AE(c,s.shape,s.dtype,a,o.dtype,u,l);return[e.makeTensorInfo(h,s.dtype,f),e.makeTensorInfo([h[0]],o.dtype,d),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map((t=>Number(t))))),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const s_={kernelName:Xe,backendName:"cpu",kernelFunc:e_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_(t){const{inputs:n,backend:e}=t;const{inputIndices:s,inputShape:o,newShape:r}=n;if(s.shape.length!==2){throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Input shape should be a vector but received shape\n        ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Target shape should be a vector but received shape ${r.shape}`)}const i=Array.from(e.data.get(o.dataId).values);const c=e.data.get(s.dataId).values;const a=Array.from(e.data.get(r.dataId).values);const[u,l,f]=OE(c,s.shape,s.dtype,i,a);return[e.makeTensorInfo(l,s.dtype,u),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const r_={kernelName:Ke,backendName:"cpu",kernelFunc:o_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n          ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n          ${r.shape}`)}if(o.shape[0]!==r.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=FE(i,s.shape,s.dtype,c,a,true);return e.makeTensorInfo(l,s.dtype,u)}const c_={kernelName:Je,backendName:"cpu",kernelFunc:i_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n         ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n         ${r.shape}`)}if(o.shape[0]!==r.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=e.data.get(s.dataId).values;const c=e.data.get(o.dataId).values;const a=e.data.get(r.dataId).values;const[u,l]=FE(i,s.shape,s.dtype,c,a);return e.makeTensorInfo(l,s.dtype,u)}const u_={kernelName:Ye,backendName:"cpu",kernelFunc:a_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(t){const{inputs:n,backend:e,attrs:s}=t;const{sparseIndices:o,sparseValues:r,defaultValue:i}=n;const{outputShape:c}=s;const{sliceRank:a,numUpdates:u,sliceSize:l,strides:f,outputSize:h}=gd(r,o,c);const d=false;const p=e.bufferSync(o);let m;switch(r.dtype){case"bool":{const t=e.bufferSync(r);const n=Boolean(e.data.get(i.dataId).values[0]);m=CE(p,t,c,h,l,u,a,f,n,d);break}case"float32":{const t=e.bufferSync(r);const n=e.data.get(i.dataId).values[0];m=CE(p,t,c,h,l,u,a,f,n,d);break}case"int32":{const t=e.bufferSync(r);const n=e.data.get(i.dataId).values[0];m=CE(p,t,c,h,l,u,a,f,n,d);break}case"string":{const t=e.bufferSync(r);const n=Ao(e.data.get(i.dataId).values[0]);m=CE(p,t,c,h,l,u,a,f,n,d);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return e.makeTensorInfo(c,m.dtype,m.values)}const f_={kernelName:Ze,backendName:"cpu",kernelFunc:l_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{numOrSizeSplits:r,axis:i}=s;const c=N(i,o.shape)[0];const a=zx(o,r,c);const u=new Array(o.shape.length).fill(0);const l=o.shape.slice();return a.map((t=>{const n=[...l];n[c]=t;const s=TE({inputs:{x:o},backend:e,attrs:{begin:u,size:n}});u[c]+=t;return s}))}const d_={kernelName:je,backendName:"cpu",kernelFunc:h_};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p_={kernelName:ts,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t;const s=n;yR(e,"square");const o=s.data.get(e.dataId).values;const r=new Float32Array(o.length);for(let t=0;t<o.length;++t){const n=o[t];r[t]=n*n}const i=s.write(r,e.shape,e.dtype);return{dataId:i,shape:e.shape,dtype:e.dtype}}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_=YR(bs,((t,n)=>{const e=n;if(isNaN(t)){return NaN}else{return t>0?1:e.alpha}}));const x_={kernelName:bs,backendName:"cpu",kernelFunc:m_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,end:i,strides:c,beginMask:a,endMask:u,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:h}=s;yR(o,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:x,sliceDim0:b,isSimpleSlice:g,begin:w,end:v,strides:$}=Gm(o.shape,r,i,c,a,u,l,f,h);let y;if(x){y=bT({inputs:{x:o},backend:e,attrs:{shape:p}})}else if(b||g){m(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const t=Im(w,v,$);const n=TE({inputs:{x:o},backend:e,attrs:{begin:w,size:t}});y=bT({inputs:{x:n},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(n)}else{const t=e.bufferSync(o);const n=GE(d,t,$,w);y=e.makeTensorInfo(p,n.dtype,n.values)}return y}const g_={kernelName:es,backendName:"cpu",kernelFunc:b_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(t){const{inputs:n,backend:e,attrs:s}=t;const{separator:o,nGramWidths:r,leftPad:i,rightPad:c,padWidth:a,preserveShortSequences:u}=s;const{data:l,dataSplits:f}=n;const h=e.data.get(l.dataId).values;const d=e.data.get(f.dataId).values;const[p,m]=HE(h,d,o,r,i,c,a,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(f.shape,"int32",m)]}const v_={kernelName:ss,backendName:"cpu",kernelFunc:w_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(t){const{inputs:n,backend:e,attrs:s}=t;const{skipEmpty:o}=s;const{input:r,delimiter:i}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(r.shape.length!==1){throw new Error(`Input must be a vector, got shape: ${r.shape}`)}if(i.shape.length!==0){throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`)}const c=e.data.get(r.dataId).values;const a=e.data.get(i.dataId).values[0];const[u,l,f]=qE(c,a,o);const h=l.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const y_={kernelName:os,backendName:"cpu",kernelFunc:$_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(t){const{inputs:n,backend:e,attrs:s}=t;const{numBuckets:o}=s;const{input:r}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(o<=0){throw new Error(`Number of buckets must be at least 1`)}const i=e.data.get(r.dataId).values;const c=XE(i,o);return e.makeTensorInfo(r.shape,"int32",c)}const C_={kernelName:rs,backendName:"cpu",kernelFunc:k_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_=YR(cs,(t=>Math.tan(t)));const R_={kernelName:cs,backendName:"cpu",kernelFunc:N_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S_=YR(as,(t=>Math.tanh(t)));const E_={kernelName:as,backendName:"cpu",kernelFunc:S_};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_(t){const{inputs:n,backend:e}=t;const{tensor:s,indices:o,updates:r}=n;const{sliceRank:i,numUpdates:c,sliceSize:a,strides:u,outputSize:l}=gd(r,o,s.shape);const f=false;const h=e.bufferSync(o);const d=e.bufferSync(r);const p=e.bufferSync(s);const m=CE(h,d,s.shape,l,a,c,i,u,p,f);return e.makeTensorInfo(s.shape,m.dtype,m.values)}const I_={kernelName:Fe,backendName:"cpu",kernelFunc:T_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reps:r}=s;yR(o,"tile");const i=QE(e.bufferSync(o),r);return e.makeTensorInfo(i.shape,i.dtype,i.values)}const O_={kernelName:us,backendName:"cpu",kernelFunc:A_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{k:r,sorted:i}=s;yR(o,"topk");const c=e.data.get(o.dataId).values;const[a,u]=eT(c,o.shape,o.dtype,r,i);return[e.makeTensorInfo(a.shape,a.dtype,a.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}const __={kernelName:ls,backendName:"cpu",kernelFunc:F_};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(t){const{inputs:n,attrs:e,backend:s}=t;const{image:o,transforms:r}=n;const{interpolation:i,fillMode:c,fillValue:a,outputShape:u}=e;const[l,f,h,d]=o.shape;const[p,m]=u!=null?u:[f,h];const x=[l,p,m,d];const b=V(o.shape);const w=b[0];const v=b[1];const $=b[2];const y=V(x);const k=y[0];const C=y[1];const N=y[2];const R=S(o.dtype,g(x));R.fill(a);const E=s.data.get(o.dataId).values;const T=s.data.get(r.dataId).values;for(let t=0;t<l;++t){const n=r.shape[0]===1?T:T.subarray(t*8,t*8+8);for(let e=0;e<p;++e){for(let s=0;s<m;++s){for(let o=0;o<d;++o){let r;const u=n[6]*s+n[7]*e+1;if(u===0){continue}const l=(n[0]*s+n[1]*e+n[2])/u;const d=(n[3]*s+n[4]*e+n[5])/u;const p=L_(l,h,c);const m=L_(d,f,c);switch(i){case"nearest":r=G_(E,f,h,w,v,$,t,m,p,o,a);break;case"bilinear":r=U_(E,f,h,w,v,$,t,m,p,o,a);break;default:throw new Error(`Error in Transform: Expect 'nearest' or `+`'bilinear', but got ${i}`)}const x=t*k+e*C+s*N+o;R[x]=r}}}return s.makeTensorInfo(x,o.dtype,R)}const I=s.write(R,x,o.dtype);return{dataId:I,shape:o.shape,dtype:o.dtype}}const D_={kernelName:fs,backendName:"cpu",kernelFunc:M_};function L_(t,n,e){switch(e){case"reflect":return z_(t,n);case"wrap":return P_(t,n);case"nearest":return B_(t,n);case"constant":default:return V_(t)}}function z_(t,n){let e=t;if(e<0){if(n<=1){e=0}else{const t=2*n;if(e<t){e=t*Math.trunc(-e/t)+e}e=e<-n?e+t:-e-1}}else if(e>n-1){if(n<=1){e=0}else{const t=2*n;e-=t*Math.trunc(e/t);if(e>=n){e=t-e-1}}}return f(0,e,n-1)}function P_(t,n){let e=t;if(e<0){if(n<=1){e=0}else{const t=n-1;e+=n*(Math.trunc(-e/t)+1)}}else if(e>n-1){if(n<=1){e=0}else{const t=n-1;e-=n*Math.trunc(e/t)}}return f(0,e,n-1)}function V_(t,n){return t}function B_(t,n){return f(0,t,n-1)}function W_(t,n,e,s,o,r,i,c,a,u,l){const f=i*s+c*o+a*r+u;if(0<=c&&c<n&&0<=a&&a<e){return t[f]}else{return l}}function G_(t,n,e,s,o,r,i,c,a,u,l){const f=Math.round(c);const h=Math.round(a);return W_(t,n,e,s,o,r,i,f,h,u,l)}function U_(t,n,e,s,o,r,i,c,a,u,l){const f=Math.floor(c);const h=Math.floor(a);const d=f+1;const p=h+1;const m=(p-a)*W_(t,n,e,s,o,r,i,f,h,u,l)+(a-h)*W_(t,n,e,s,o,r,i,f,p,u,l);const x=(p-a)*W_(t,n,e,s,o,r,i,d,h,u,l)+(a-h)*W_(t,n,e,s,o,r,i,d,p,u,l);return(d-c)*m+(c-f)*x}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(t){const{inputs:n,attrs:e,backend:s}=t;const{axis:o}=e;const{x:r}=n;yR(r,"unique");const i=s.data.get(r.dataId).values;const{outputValues:c,outputShape:a,indices:u}=sT(i,o,r.shape,r.dtype);return[s.makeTensorInfo(a,r.dtype,c),s.makeTensorInfo([u.length],"int32",u)]}const j_={kernelName:ds,backendName:"cpu",kernelFunc:H_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(t){const{inputs:n,backend:e,attrs:s}=t;const{value:o}=n;let{axis:r}=s;if(r<0){r+=o.shape.length}const i=o.shape.length;const c=o.shape[r];const a=new Array(i-1);let u=0;for(let t=0;t<i;t++){if(t!==r){a[u++]=o.shape[t]}}const l=new Array(i).fill(0);const f=o.shape.slice();f[r]=1;const h=new Array(c);for(let t=0;t<h.length;t++){l[r]=t;const n=TE({inputs:{x:o},backend:e,attrs:{begin:l,size:f}});h[t]=bT({inputs:{x:n},backend:e,attrs:{shape:a}});e.disposeIntermediateTensorInfo(n)}return h}const X_={kernelName:ps,backendName:"cpu",kernelFunc:q_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K_(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,segmentIds:r}=n;const{numSegments:i}=s;yR(o,"unsortedSegmentSum");const c=o.shape.length;const a=r.shape.length;const u=[];const l=[];const f=c-a;let h=r;for(let t=0;t<f;++t){const n=$A({inputs:{input:h},backend:e,attrs:{dim:t+1}});h=n;l.push(n)}for(let t=0;t<i;++t){const n=Ro(t,"int32");const s=e.makeTensorInfo([],"int32",n);const r=oS({inputs:{a:s,b:h},backend:e});const i=LR({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});const c=HS({inputs:{a:i,b:o},backend:e});const a=cA({inputs:{x:c},backend:e,attrs:{axis:0,keepDims:false}});u.push(a);l.push(s);l.push(r);l.push(i);l.push(c);l.push(a)}const d=nF({inputs:u,backend:e,attrs:{axis:0}});l.forEach((t=>e.disposeIntermediateTensorInfo(t)));return d}const J_={kernelName:ms,backendName:"cpu",kernelFunc:K_};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y_=[yT,SR,CT,RT,UR,ET,IT,OT,_T,DT,zT,VT,WT,HT,qT,QT,nI,sI,rI,vT,cI,uI,fI,KR,dI,zR,nS,mI,IR,bI,$I,kI,NI,SI,TI,AI,FI,MI,LI,PI,BI,GI,HI,qI,KI,YI,QI,nA,eA,sA,oA,iA,lA,iT,hA,rS,vA,aS,yA,fS,OA,_A,DA,pS,bS,zA,VA,WA,UA,yS,NS,FR,jA,wI,XA,JA,ZA,aT,ES,AS,tO,MS,eO,rO,cO,lO,hO,pO,xO,PS,gO,vO,yO,CO,RO,EO,IO,WS,OO,MO,PO,jS,KS,WO,HO,XO,ZS,JO,tF,eF,oF,cF,fT,oE,uF,fF,dF,mF,MR,NA,bF,dT,mT,gT,wF,$F,kF,NF,SF,EF,IF,kE,OF,LF,PF,GF,SE,HF,qF,KF,IE,LO,QF,n_,s_,r_,c_,u_,f_,d_,DE,p_,PE,WE,x_,g_,v_,y_,C_,ZE,aA,R_,E_,I_,O_,__,D_,nE,j_,X_,J_,ZO];for(const t of Y_){Is(t)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_={};const Q_={alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true};function tM(t,n){Z_[t]=n}function nM(t,n){if(!(t in Z_)||n!=null){const e=sM(t,n);if(e!==null){Z_[t]=e}else{console.log("Could not get context for WebGL version",t);return null}}const e=Z_[t];if(e==null||e.isContextLost()){delete Z_[t];return nM(t)}e.disable(e.DEPTH_TEST);e.disable(e.STENCIL_TEST);e.disable(e.BLEND);e.disable(e.DITHER);e.disable(e.POLYGON_OFFSET_FILL);e.disable(e.SAMPLE_COVERAGE);e.enable(e.SCISSOR_TEST);e.enable(e.CULL_FACE);e.cullFace(e.BACK);return Z_[t]}function eM(t){if(!et().getBool("IS_SAFARI")&&typeof OffscreenCanvas!=="undefined"&&t===2){return new OffscreenCanvas(300,150)}else if(typeof document!=="undefined"){return document.createElement("canvas")}else{throw new Error("Cannot create a canvas in this context")}}function sM(t,n){if(t!==1&&t!==2){throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")}const e=n==null?eM(t):n;e.addEventListener("webglcontextlost",(n=>{n.preventDefault();delete Z_[t]}),false);if(et().getBool("SOFTWARE_WEBGL_ENABLED")){Q_.failIfMajorPerformanceCaveat=false}if(t===1){return e.getContext("webgl",Q_)||e.getContext("experimental-webgl",Q_)}return e.getContext("webgl2",Q_)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oM;(function(t){t[t["DENSE"]=0]="DENSE";t[t["SHARED_BATCH"]=1]="SHARED_BATCH"})(oM||(oM={}));var rM;(function(t){t[t["RENDER"]=0]="RENDER";t[t["UPLOAD"]=1]="UPLOAD";t[t["PIXELS"]=2]="PIXELS";t[t["DOWNLOAD"]=3]="DOWNLOAD"})(rM||(rM={}));var iM;(function(t){t[t["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16";t[t["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32";t[t["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE";t[t["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32";t[t["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"})(iM||(iM={}));function cM(t,n){return[n,t]}function aM(t,n){return t*n}function uM(t){const n=g(t);const e=Math.ceil(n/4);return $(e)}function lM(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function fM(t,n){const[e,s]=lM(t,n);return e*s*4}function hM(t,n){const e=t;let s;let o;let r;let i;let c;let a;let u;let l;let f;let h;if(et().getNumber("WEBGL_VERSION")===2){s=e.R32F;o=e.R16F;r=e.RGBA16F;i=e.RGBA32F;c=e.RED;u=4;l=1;f=e.HALF_FLOAT;h=e.FLOAT;a=e.RGBA8}else{s=t.RGBA;o=t.RGBA;r=t.RGBA;i=e.RGBA;c=t.RGBA;u=4;l=4;f=n!=null?n.HALF_FLOAT_OES:null;h=t.FLOAT;a=t.RGBA}return{internalFormatFloat:s,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:i,textureFormatFloat:c,downloadTextureFormat:a,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:f,textureTypeFloat:h}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dM(t,n){const e=n();if(et().getBool("DEBUG")){pM(t)}return e}function pM(t){const n=t.getError();if(n!==t.NO_ERROR){throw new Error("WebGL Error: "+gM(t,n))}}const mM=5.96e-8;const xM=65504;function bM(t){if(et().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||mM<Math.abs(t)&&Math.abs(t)<xM){return true}return false}function gM(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function wM(t,n){return BM(t,(()=>t.getExtension(n)),'Extension "'+n+'" not supported on this browser.')}function vM(t,n){const e=BM(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");dM(t,(()=>t.shaderSource(e,n)));dM(t,(()=>t.compileShader(e)));if(t.getShaderParameter(e,t.COMPILE_STATUS)===false){console.log(t.getShaderInfoLog(e));throw new Error("Failed to compile vertex shader.")}return e}function $M(t,n){const e=BM(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");dM(t,(()=>t.shaderSource(e,n)));dM(t,(()=>t.compileShader(e)));if(et().get("ENGINE_COMPILE_ONLY")){return e}if(t.getShaderParameter(e,t.COMPILE_STATUS)===false){kM(n,t.getShaderInfoLog(e));throw new Error("Failed to compile fragment shader.")}return e}const yM=/ERROR: [0-9]+:([0-9]+):/g;function kM(t,n){const e=yM.exec(n);if(e==null){console.log(`Couldn't parse line number in error: ${n}`);console.log(t);return}const s=+e[1];const o=t.split("\n");const r=o.length.toString().length+2;const i=o.map(((t,n)=>y((n+1).toString(),r)+t));let c=0;for(let t=0;t<i.length;t++){c=Math.max(i[t].length,c)}const a=i.slice(0,s-1);const u=i.slice(s-1,s);const l=i.slice(s);console.log(a.join("\n"));console.log(n.split("\n")[0]);console.log(`%c ${y(u[0],c)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717");console.log(l.join("\n"))}function CM(t){return BM(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}function NM(t,n){dM(t,(()=>t.linkProgram(n)));if(et().get("ENGINE_COMPILE_ONLY")){return}if(t.getProgramParameter(n,t.LINK_STATUS)===false){console.log(t.getProgramInfoLog(n));throw new Error("Failed to link vertex and fragment shaders.")}}function RM(t,n){dM(t,(()=>t.validateProgram(n)));if(t.getProgramParameter(n,t.VALIDATE_STATUS)===false){console.log(t.getProgramInfoLog(n));throw new Error("Shader program validation failed.")}}function SM(t,n){const e=BM(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");dM(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,e)));dM(t,(()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)));return e}function EM(t,n){const e=BM(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");dM(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)));dM(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)));return e}function TM(t){return BM(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}function IM(t,n){const e=et().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0){const e=`[${t}x${n}]`;throw new Error("Requested texture size "+e+" is invalid.")}if(t>e||n>e){const s=`[${t}x${n}]`;const o=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+o+".")}}function AM(t){return BM(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function OM(t,n,e,s,o,r,i){const c=t.getAttribLocation(n,e);if(c===-1){return false}dM(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,s)));dM(t,(()=>t.vertexAttribPointer(c,o,t.FLOAT,false,r,i)));dM(t,(()=>t.enableVertexAttribArray(c)));return true}function FM(t,n,e){WM(t,e);dM(t,(()=>t.activeTexture(t.TEXTURE0+e)));dM(t,(()=>t.bindTexture(t.TEXTURE_2D,n)))}function _M(t,n,e){return BM(t,(()=>t.getUniformLocation(n,e)),'uniform "'+e+'" not present in program.')}function MM(t,n,e){return t.getUniformLocation(n,e)}function DM(t,n,e,s){dM(t,(()=>FM(t,n,s)));dM(t,(()=>t.uniform1i(e,s)))}function LM(t,n,e){dM(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e)));dM(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)))}function zM(t,n){dM(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n)));dM(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function PM(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE){throw new Error("Error binding framebuffer: "+VM(t,n))}}function VM(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function BM(t,n,e){const s=dM(t,(()=>n()));if(s==null){throw new Error(e)}return s}function WM(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;const s=n+t.TEXTURE0;if(s<t.TEXTURE0||s>e){const t=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${t}.`)}}function GM(t,n=2){return g(t.slice(0,t.length-n))}function UM(t){if(t.length===0){throw Error("Cannot get rows and columns of an empty shape array.")}return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function HM(t){let n=[1,1,1];const e=t.length===0||t.length===1&&t[0]===1;if(!e){n=[GM(t),...UM(t)]}return n}function jM(t,n=false){let e=et().getNumber("WEBGL_MAX_TEXTURE_SIZE");let s=et().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(s===Infinity&&et().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")){s=e/2}if(n){e=e*2;s=s*2;t=t.map(((n,e)=>e>=t.length-2?h(t[e]):t[e]));if(t.length===1){t=[2,t[0]]}}if(t.length!==2){const n=R(t);t=n.newShape}let o=g(t);let r=null;if(t.length<=1&&o<=e){r=[1,o]}else if(t.length===2&&t[0]<=e&&t[1]<=e){r=t}else if(t.length===3&&t[0]*t[1]<=e&&t[2]<=e){r=[t[0]*t[1],t[2]]}else if(t.length===3&&t[0]<=e&&t[1]*t[2]<=e){r=[t[0],t[1]*t[2]]}else if(t.length===4&&t[0]*t[1]*t[2]<=e&&t[3]<=e){r=[t[0]*t[1]*t[2],t[3]]}else if(t.length===4&&t[0]<=e&&t[1]*t[2]*t[3]<=e){r=[t[0],t[1]*t[2]*t[3]]}const i=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(n?2:1)&&Math.min(...r)>0;if(r==null||i){if(n){const n=GM(t);let e=2,s=2;if(t.length){[e,s]=UM(t)}o=n*(e/2)*(s/2);r=$(o).map((t=>t*2))}else{r=$(o)}}return r}function qM(t){return t%2===0}function XM(t,n){t=t.slice(-2);n=n.slice(-2);if(w(t,n)){return true}if(!t.length||!n.length){return true}if(t[0]===0||t[1]===0||n[0]===0||n[1]===0){return true}if(t.length!==n.length){const e=t[t.length-1];const s=n[n.length-1];if(e===s){return true}if(qM(e)&&qM(s)&&(t[0]===1||n[0]===1)){return true}}return t[1]===n[1]&&qM(t[0])&&qM(n[0])}let KM;let JM;function YM(t){if(KM==null){const n=nM(t);KM=n.getParameter(n.MAX_TEXTURE_SIZE)}return KM}function ZM(t){if(JM==null){const n=nM(t);JM=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,JM)}function QM(t){if(t===0){return 0}let n;const e=nM(t);if(tD(e,"EXT_disjoint_timer_query_webgl2")&&t===2){n=2}else if(tD(e,"EXT_disjoint_timer_query")){n=1}else{n=0}return n}function tD(t,n){const e=t.getExtension(n);return e!=null}function nD(t){try{const n=nM(t);if(n!=null){return true}}catch(t){console.log("Error when getting WebGL context: ",t);return false}return false}function eD(t){if(t===0){return false}const n=nM(t);if(t===1){if(!tD(n,"OES_texture_float")){return false}}else{if(!tD(n,"EXT_color_buffer_float")){return false}}const e=oD(n);return e}function sD(t){if(t===0){return false}const n=nM(t);if(t===1){if(!tD(n,"OES_texture_float")){return false}if(!tD(n,"WEBGL_color_buffer_float")){return false}}else{if(tD(n,"EXT_color_buffer_float")){return oD(n)}const t="EXT_color_buffer_half_float";if(tD(n,t)){const e=n.getExtension(t);return rD(n,e)}return false}const e=oD(n);return e}function oD(t){const n=hM(t);const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const s=1;const o=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,s,o,0,n.textureFormatFloat,n.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.bindTexture(t.TEXTURE_2D,null);t.bindFramebuffer(t.FRAMEBUFFER,null);t.deleteTexture(e);t.deleteFramebuffer(r);return i}function rD(t,n){const e=hM(t,n);const s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s);const o=1;const r=1;t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,o,r,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i);t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const c=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.bindTexture(t.TEXTURE_2D,null);t.bindFramebuffer(t.FRAMEBUFFER,null);t.deleteTexture(s);t.deleteFramebuffer(i);return c}function iD(t){if(t!==2){return false}const n=nM(t);const e=n.fenceSync!=null;return e}function cD(t,n){if(!Array.isArray(t)){t=[t]}t.forEach((t=>{if(t!=null){m(t.dtype!=="complex64",(()=>`${n} does not support complex64 tensors `+"in the WebGL backend."))}}))}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD=et();aD.registerFlag("HAS_WEBGL",(()=>aD.getNumber("WEBGL_VERSION")>0));aD.registerFlag("WEBGL_VERSION",(()=>{if(nD(2)){return 2}else if(nD(1)){return 1}return 0}));aD.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>false));aD.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>aD.get("WEBGL_VERSION")===2));aD.registerFlag("WEBGL_CPU_FORWARD",(()=>true));aD.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>false));aD.registerFlag("WEBGL_PACK",(()=>aD.getBool("HAS_WEBGL")));aD.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_CLIP",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_REDUCE",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_LAZILY_UNPACK",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_CONV_IM2COL",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>aD.getBool("WEBGL_PACK")));aD.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>YM(aD.getNumber("WEBGL_VERSION"))));aD.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>ZM(aD.getNumber("WEBGL_VERSION"))));aD.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=aD.getNumber("WEBGL_VERSION");if(t===0){return 0}return QM(t)}));aD.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>aD.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Cr()));aD.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>eD(aD.getNumber("WEBGL_VERSION"))));aD.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>aD.getBool("WEBGL_FORCE_F16_TEXTURES")?false:aD.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")));aD.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>sD(aD.getNumber("WEBGL_VERSION"))));aD.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>iD(aD.getNumber("WEBGL_VERSION"))));aD.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>{const t=aD.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return t?4:0}));aD.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(!(typeof t==="number")){throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+`got ${t}.`)}if(t<0&&t!==-1){throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never `+`delete) or at least 0, but got ${t}.`)}}));aD.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Cr()?1:-1),(t=>{if(!(typeof t==="number")){throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+`${t}.`)}if(t<0&&t!==-1){throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never `+`manual flush) or at least 0, but got ${t}.`)}}));aD.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128));aD.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>false));aD.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5));aD.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));aD.registerFlag("WEBGL_EXP_CONV",(()=>false));aD.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>aD.getBool("IS_TEST")));aD.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>Infinity));aD.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>false));aD.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>false));aD.registerFlag("ENGINE_COMPILE_ONLY",(()=>false));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(){let t;let n;let e;let s;let o;let r;let i;let c;let a;let u;if(et().getNumber("WEBGL_VERSION")===2){t="#version 300 es";n="in";e="out";s="in";o="texture";r="outputColor";i="out vec4 outputColor;";c=et().getBool("WEBGL2_ISNAN_CUSTOM")?`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `:"";a=``;u=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}else{t="";n="attribute";e="varying";s="varying";o="texture2D";r="gl_FragColor";i="";c=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;a=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;u=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}return{version:t,attribute:n,varyingVs:e,varyingFs:s,texture2D:o,output:r,defineOutput:i,defineSpecialNaN:c,defineSpecialInf:a,defineRound:u}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lD(t,n,e="index"){const s=V(n);return s.map(((n,o)=>{const r=`int ${t[o]} = ${e} / ${n}`;const i=o===s.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${n}`:`index -= ${t[o]} * ${n}`;return`${r}; ${i};`})).join("")}function fD(t,n,e="index"){const s=V(n);return s.map(((n,o)=>{const r=`int ${t[o]} = ${e} / outShapeStrides[${o}]`;const i=o===s.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${r}; ${i};`})).join("")}function hD(t,n){const e=t.length;const s=t.map((t=>`${n}[${t}]`));const o=new Array(e-1);o[e-2]=s[e-1];for(let t=e-3;t>=0;--t){o[t]=`(${o[t+1]} * ${s[t+1]})`}return o}function dD(t,n,e="index"){const s=t.map(((t,n)=>n));const o=hD(s,n);return o.map(((n,s)=>{const r=`int ${t[s]} = ${e} / ${o[s]}`;const i=s===o.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${o[s]}`:`index -= ${t[s]} * ${o[s]}`;return`${r}; ${i};`})).join("")}function pD(t){const n=V(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function mD(){return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}const xD=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const{getBroadcastDims:bD}=sb;function gD(t,n,e){const s=[];t.forEach((t=>{const n=g(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform){s.push(`uniform float ${t.name}${n>1?`[${n}]`:""};`)}else{s.push(`uniform sampler2D ${t.name};`);s.push(`uniform int offset${t.name};`)}if(e.enableShapeUniforms){const{uniformShape:n}=iL(e.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(n.length){case 1:s.push(`uniform int ${t.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${t.name}Shape;`);break}s.push(`uniform ivec2 ${t.name}TexShape;`)}}));if(e.enableShapeUniforms){switch(n.logicalShape.length){case 1:s.push(`uniform int outShape;`);break;case 2:s.push(`uniform ivec2 outShape;`);s.push(`uniform int outShapeStrides;`);break;case 3:s.push(`uniform ivec3 outShape;`);s.push(`uniform ivec2 outShapeStrides;`);break;case 4:s.push(`uniform ivec4 outShape;`);s.push(`uniform ivec3 outShapeStrides;`);break}s.push(`uniform ivec2 outTexShape;`)}if(e.customUniforms){e.customUniforms.forEach((t=>{s.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)}))}const o=s.join("\n");const r=t.map((t=>$D(t,n,e.packedInputs,e.enableShapeUniforms))).join("\n");const i=n.texShape;const c=uD();const a=CD(c);let u;let l;let f=SD(c);if(n.isPacked){u=yD(n.logicalShape,i,e.enableShapeUniforms);l=RD(c)}else{u=kD(n.logicalShape,i,e.enableShapeUniforms);l=ND(c)}if(e.packedInputs){f+=AD}const h=[f,a,l,o,u,r,e.userCode].join("\n");return h}function wD(t,n=false){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return HD(t,n);case 1:return qD(t,n);case 2:return KD(t,n);case 3:return YD(t,n);case 4:return QD(t,n);case 5:return tL(t);case 6:return nL(t);default:throw new Error(`${e.length}-D input sampling`+` is not yet supported`)}}function vD(t,n){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return UD(t);case 1:return jD(t,n);case 2:return XD(t,n);case 3:return JD(t,n);default:return ZD(t,n)}}function $D(t,n,e=false,s){let o="";if(e){o+=vD(t,s)}else{o+=wD(t,s)}const r=t.shapeInfo.logicalShape;const i=n.logicalShape;if(r.length<=i.length){if(e){o+=sL(t,n)}else{o+=oL(t,n)}}return o}function yD(t,n,e){switch(t.length){case 0:return OD();case 1:return FD(t,n,e);case 2:return BD(t,n,e);case 3:return MD(t,n,e);default:return LD(t,n,e)}}function kD(t,n,e){switch(t.length){case 0:return OD();case 1:return _D(t,n,e);case 2:return WD(t,n,e);case 3:return DD(t,n,e);case 4:return zD(t,n,e);case 5:return PD(t,n);case 6:return VD(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function CD(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}function ND(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}function RD(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}function SD(t){const n=`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${ED}\n    ${TD}\n    ${ID}\n  `;return n}const ED=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const TD=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const ID=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const AD=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function OD(){return`\n    int getOutputCoords() {\n      return 0;\n    }\n  `}function FD(t,n,e){const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(s[0]===1){if(e){return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    `}return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `}if(s[1]===1){if(e){return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    `}return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `}if(e){return`\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  `}return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}function _D(t,n,e){if(n[0]===1){if(e){return`\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    `}return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `}if(n[1]===1){if(e){return`\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    `}return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `}if(e){return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  `}return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}function MD(t,n,e){if(e){return`\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];const o=Math.ceil(t[2]/2);const r=o*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function DD(t,n,e){if(e){const n=fD(["r","c","d"],t);return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${n}\n    return ivec3(r, c, d);\n  }\n`}const s=lD(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}function LD(t,n,e){if(e){return`\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `}const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];const o=Math.ceil(t[t.length-1]/2);const r=o*Math.ceil(t[t.length-2]/2);let i=r;let c=``;let a="b, r, c";for(let n=2;n<t.length-1;n++){i*=t[t.length-n-1];c=`\n      int b${n} = index / ${i};\n      index -= b${n} * ${i};\n    `+c;a=`b${n}, `+a}return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${c}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}function zD(t,n,e){if(e){const n=fD(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}const s=lD(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}function PD(t,n){const e=lD(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function VD(t,n){const e=lD(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function BD(t,n,e){const s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(w(t,n)){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `}const o=Math.ceil(t[1]/2);if(e){return`\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function WD(t,n,e){if(w(t,n)){if(e){return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `}if(t[1]===1){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}if(t[0]===1){if(e){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}if(e){return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}function GD(t){return`offset${t}`}function UD(t){const n=t.name;const e="get"+n.charAt(0).toUpperCase()+n.slice(1);const s=uD();return`\n    vec4 ${e}() {\n      return ${s.texture2D}(${n}, halfCR);\n    }\n  `}function HD(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform){return`float ${s}() {return ${e};}`}const[o,r]=t.shapeInfo.texShape;if(o===1&&r===1){return`\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `}const i=GD(e);if(n){return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}const[c,a]=t.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${c}, ${a}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}function jD(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=t.shapeInfo.texShape;const r=uD();if(n){return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}const i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}function qD(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform){return`\n      float ${s}(int index) {\n        ${eL(t)}\n      }\n    `}const o=t.shapeInfo.texShape;const r=o[0];const i=o[1];if(i===1&&r===1){return`\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `}const c=GD(e);if(i===1){if(n){return`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `}return`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${r}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(r===1){if(n){return`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `}return`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(n){return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${c});\n      return sampleTexture(${e}, uv);\n    }\n  `}return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${i}, index + ${c});\n      return sampleTexture(${e}, uv);\n    }\n  `}function XD(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;const i=r[0];const c=r[1];const a=uD();if(r!=null&&w(e,r)){if(n){return`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${a.texture2D}(${s}, uv);\n      }\n    `}return`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${i}.0);\n\n        return ${a.texture2D}(${s}, uv);\n      }\n    `}if(n){return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `}const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];const l=Math.ceil(e[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);\n      return ${a.texture2D}(${s}, uv);\n    }\n  `}function KD(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;if(r!=null&&w(e,r)){if(n){return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}const t=r[0];const e=r[1];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${e}.0, ${t}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}const{newShape:i,keptDims:c}=R(e);const a=i;if(a.length<e.length){const e=cL(t,a);const s=["row","col"];return`\n      ${wD(e,n)}\n      float ${o}(int row, int col) {\n        return ${o}(${aL(s,c)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${eL(t)}\n      }\n    `}const u=r[0];const l=r[1];const f=GD(s);if(l===1){if(n){return`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}if(u===1){if(n){return`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `}if(n){return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${f};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${f};\n    vec2 uv = uvFromFlat(${u}, ${l}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}function JD(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=t.shapeInfo.texShape;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(e[0]===1){const s=e.slice(1);const r=[1,2];const i=cL(t,s);const c=["b","row","col"];return`\n        ${vD(i,n)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${aL(c,r)});\n        }\n      `}const c=uD();if(n){return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `}const a=i[0];const u=i[1];const l=Math.ceil(e[2]/2);const f=l*Math.ceil(e[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${u}, ${f}, ${l}, b, row, col);\n      return ${c.texture2D}(${s}, uv);\n    }\n  `}function YD(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=e[1]*e[2];const i=e[2];const{newShape:c,keptDims:a}=R(e);const u=c;if(u.length<e.length){const e=cL(t,u);const s=["row","col","depth"];return`\n        ${wD(e,n)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${aL(s,a)});\n        }\n      `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${i}, 1)));\n        ${eL(t)}\n      }\n    `}const l=t.shapeInfo.texShape;const f=l[0];const h=l[1];const d=t.shapeInfo.flatOffset;if(h===r&&d==null){if(n){return`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${f}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `}if(h===i&&d==null){if(n){return`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${f}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}const p=GD(s);if(n){return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `}return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${i} + depth + ${p};\n        vec2 uv = uvFromFlat(${f}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}function ZD(t,n){const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=uD();if(n){return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);\n    }\n  `}const r=t.shapeInfo.logicalShape;const i=r.length;const c=t.shapeInfo.texShape;const a=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];const u=a[0];const l=a[1];const f=Math.ceil(r[i-1]/2);let h=f*Math.ceil(r[i-2]/2);let d=`int b, int row, int col`;let p=`b * ${h} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<i-1;t++){d=`int b${t}, `+d;h*=r[i-t-1];p=`b${t} * ${h} + `+p}return`\n    vec4 ${s}(${d}) {\n      int index = ${p};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}function QD(t,n){const e=t.shapeInfo.logicalShape;const s=t.name;const o="get"+s.charAt(0).toUpperCase()+s.slice(1);const r=e[3];const i=e[2]*r;const c=e[1]*i;const{newShape:a,keptDims:u}=R(e);if(a.length<e.length){const e=cL(t,a);const s=["row","col","depth","depth2"];return`\n      ${wD(e,n)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${aL(s,u)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${c}, ${i}, ${r}, 1)));\n        ${eL(t)}\n      }\n    `}const l=t.shapeInfo.flatOffset;const f=t.shapeInfo.texShape;const h=f[0];const d=f[1];const p=`int stride2 = ${s}Shape[3];`;const m=`int stride1 = ${s}Shape[2] * stride2;`;const x=`int stride0 = ${s}Shape[1] * stride1;`;if(d===c&&l==null){if(n){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `}if(d===r&&l==null){if(n){return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `}return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `}const b=GD(s);if(n){return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${x}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `}return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${i} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `}function tL(t){const n=t.shapeInfo.logicalShape;const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const o=n[4];const r=n[3]*o;const i=n[2]*r;const c=n[1]*i;const{newShape:a,keptDims:u}=R(n);if(a.length<n.length){const n=cL(t,a);const e=["row","col","depth","depth2","depth3"];return`\n      ${wD(n)}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${aL(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${i}, ${r}, ${o})) +\n          depth3;\n        ${eL(t)}\n      }\n    `}const l=t.shapeInfo.flatOffset;const f=t.shapeInfo.texShape;const h=f[0];const d=f[1];if(d===c&&l==null){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${r}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(d===o&&l==null){return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}const p=GD(e);return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${i} + depth * ${r} +\n          depth2 * ${o} + depth3 + ${p};\n      vec2 uv = uvFromFlat(${h}, ${d}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}function nL(t){const n=t.shapeInfo.logicalShape;const e=t.name;const s="get"+e.charAt(0).toUpperCase()+e.slice(1);const{newShape:o,keptDims:r}=R(n);if(o.length<n.length){const n=cL(t,o);const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${wD(n)}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${aL(e,r)});\n      }\n    `}const i=n[5];const c=n[4]*i;const a=n[3]*c;const u=n[2]*a;const l=n[1]*u;if(t.shapeInfo.isUniform){return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${u}, ${a}, ${c})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${eL(t)}\n      }\n    `}const f=t.shapeInfo.flatOffset;const h=t.shapeInfo.texShape;const d=h[0];const p=h[1];if(p===l&&f==null){return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${a}, ${c}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}if(p===i&&f==null){return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `}const m=GD(e);return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${u} + depth * ${a} +\n          depth2 * ${c} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}function eL(t){const n=t.name;const e=g(t.shapeInfo.logicalShape);if(e<2){return`return ${n};`}return`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function sL(t,n){const e=t.name;const s=e.charAt(0).toUpperCase()+e.slice(1);const o="get"+s+"AtOutCoords";const r=t.shapeInfo.logicalShape.length;const i=n.logicalShape.length;const c=bD(t.shapeInfo.logicalShape,n.logicalShape);const a=rL(i);const u=i-r;let l;const f=["x","y","z","w","u","v"];if(r===0){l=""}else if(i<2&&c.length>=1){l="coords = 0;"}else{l=c.map((t=>`coords.${f[t+u]} = 0;`)).join("\n")}let h="";if(i<2&&r>0){h="coords"}else{h=t.shapeInfo.logicalShape.map(((t,n)=>`coords.${f[n+u]}`)).join(", ")}let d=`return outputValue;`;const p=g(t.shapeInfo.logicalShape);const m=p===1;const x=g(n.logicalShape);const b=x===1;if(r===1&&!m&&!b){d=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `}else if(m&&!b){if(i===1){d=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `}else{d=`\n        return vec4(outputValue.x);\n      `}}else if(c.length){const t=r-2;const n=r-1;if(c.indexOf(t)>-1&&c.indexOf(n)>-1){d=`return vec4(outputValue.x);`}else if(c.indexOf(t)>-1){d=`return vec4(outputValue.x, outputValue.y, `+`outputValue.x, outputValue.y);`}else if(c.indexOf(n)>-1){d=`return vec4(outputValue.xx, outputValue.zz);`}}return`\n    vec4 ${o}() {\n      ${a} coords = getOutputCoords();\n      ${l}\n      vec4 outputValue = get${s}(${h});\n      ${d}\n    }\n  `}function oL(t,n){const e=t.name;const s=e.charAt(0).toUpperCase()+e.slice(1);const o="get"+s+"AtOutCoords";const r=n.texShape;const i=t.shapeInfo.texShape;const c=t.shapeInfo.logicalShape.length;const a=n.logicalShape.length;if(!t.shapeInfo.isUniform&&c===a&&t.shapeInfo.flatOffset==null&&w(i,r)){return`\n      float ${o}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `}const u=rL(a);const l=bD(t.shapeInfo.logicalShape,n.logicalShape);const f=a-c;let h;const d=["x","y","z","w","u","v"];if(c===0){h=""}else if(a<2&&l.length>=1){h="coords = 0;"}else{h=l.map((t=>`coords.${d[t+f]} = 0;`)).join("\n")}let p="";if(a<2&&c>0){p="coords"}else{p=t.shapeInfo.logicalShape.map(((t,n)=>`coords.${d[n+f]}`)).join(", ")}return`\n    float ${o}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${s}(${p});\n    }\n  `}function rL(t){if(t<=1){return"int"}else if(t===2){return"ivec2"}else if(t===3){return"ivec3"}else if(t===4){return"ivec4"}else if(t===5){return"ivec5"}else if(t===6){return"ivec6"}else{throw Error(`GPU for rank ${t} is not yet supported`)}}function iL(t,n,e){const{newShape:s,keptDims:o}=R(n);const r=n.length;const i=t&&r===3&&n[0]===1;const c=i?n.slice(1):s;const a=!t&&r>1&&!w(n,e)&&s.length<r||i;const u=a?c:n;return{useSqueezeShape:a,uniformShape:u,keptDims:o}}function cL(t,n){const e=JSON.parse(JSON.stringify(t));e.shapeInfo.logicalShape=n;return e}function aL(t,n){return n.map((n=>t[n])).join(", ")}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uL(t,n,e,s){const o=e.map(((t,e)=>{const s={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:t.isUniform?false:t.texData.isPacked,flatOffset:null};if(t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0){s.flatOffset=t.texData.slice.flatOffset}return{name:n.variableNames[e],shapeInfo:s}}));const r=o.map((t=>t.shapeInfo));const i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:false,isPacked:s.texData.isPacked,flatOffset:null};const c=gD(o,i,n);const a=$M(t.gl,c);const u=t.createProgram(a);if(!et().get("ENGINE_COMPILE_ONLY")){t.buildVao(u);return Object.assign({program:n,fragmentShader:a,source:c,webGLProgram:u,inShapeInfos:r,outShapeInfo:i},lL(t,n,u))}else{return{program:n,fragmentShader:a,source:c,webGLProgram:u,inShapeInfos:r,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}}}function lL(t,n,e){const s=[];const o=[];let r;let i;let c;let a=null;let u=null;u=t.getUniformLocation(e,"NAN",false);if(et().getNumber("WEBGL_VERSION")===1){a=t.getUniformLocation(e,"INFINITY",false)}const l=false;for(const o of n.variableNames){const r={name:o,uniform:t.getUniformLocation(e,o,l),offset:t.getUniformLocation(e,`offset${o}`,l)};if(n.enableShapeUniforms){r.shape=t.getUniformLocation(e,`${o}Shape`,l);r.texShape=t.getUniformLocation(e,`${o}TexShape`,l)}s.push(r)}if(n.enableShapeUniforms){r=t.getUniformLocation(e,"outShape",l);c=t.getUniformLocation(e,"outShapeStrides",l);i=t.getUniformLocation(e,"outTexShape",l)}if(n.customUniforms){for(const s of n.customUniforms){o.push(t.getUniformLocation(e,s.name,l))}}return{variablesLocations:s,customUniformLocations:o,infLoc:a,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:c,outTexShapeLocation:i}}function fL(t,n){if(t.length!==n.length){throw Error(`Binary was compiled with ${t.length} inputs, but `+`was executed with ${n.length} inputs`)}t.forEach(((t,e)=>{const s=t.logicalShape;const o=n[e];const r=o.shape;if(!w(s,r)){throw Error(`Binary was compiled with different shapes than `+`the current args. Shapes ${s} and ${r} must match`)}if(t.isUniform&&o.isUniform){return}const i=t.texShape;const c=o.isUniform?null:o.texData.texShape;if(!w(i,c)){throw Error(`Binary was compiled with different texture shapes than the`+` current args. Shape ${i} and ${c} must match`)}}))}function hL(t,n,e,s,o){if(!n.program.enableShapeUniforms){fL(n.inShapeInfos,e);fL([n.outShapeInfo],[s])}const r=s.texData.texture;const i=s.texData.texShape;if(s.texData.isPacked){t.setOutputPackedMatrixTexture(r.texture,i[0],i[1])}else{t.setOutputMatrixTexture(r.texture,i[0],i[1])}t.setProgram(n.webGLProgram);t.bindVertexArray(n.webGLProgram.vao);if(et().getNumber("WEBGL_VERSION")===1){if(n.infLoc!==null){t.gl.uniform1f(n.infLoc,Infinity)}}if(n.nanLoc!==null){t.gl.uniform1f(n.nanLoc,NaN)}for(let s=0;s<e.length;++s){const o=e[s];const{uniform:r,offset:i,shape:c,texShape:a}=n.variablesLocations[s];if(c){const{uniformShape:e}=iL(n.program.packedInputs,o.shape,o.texData.texShape);switch(e.length){case 1:t.gl.uniform1iv(c,new Int32Array(e));break;case 2:t.gl.uniform2iv(c,new Int32Array(e));break;case 3:t.gl.uniform3iv(c,new Int32Array(e));break;case 4:t.gl.uniform4iv(c,new Int32Array(e));break}}if(a){t.gl.uniform2i(a,o.texData.texShape[0],o.texData.texShape[1])}if(r==null){continue}if(o.isUniform){if(g(o.shape)<2){t.gl.uniform1f(r,o.uniformValues[0])}else{let n=o.uniformValues;if(!(n instanceof Float32Array)){n=new Float32Array(n)}t.gl.uniform1fv(r,n)}continue}if(o.texData.slice!=null&&i!=null){t.gl.uniform1i(i,o.texData.slice.flatOffset)}t.setInputMatrixTexture(o.texData.texture.texture,r,s)}const c=n.outShapeLocation;if(c){switch(s.shape.length){case 1:t.gl.uniform1iv(c,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(c,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(c,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(c,new Int32Array(s.shape));break}}if(n.outShapeStridesLocation){const e=V(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(e));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(e));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(e));break}}if(n.outTexShapeLocation){t.gl.uniform2i(n.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1])}if(n.program.customUniforms&&o){for(let e=0;e<n.program.customUniforms.length;++e){const s=n.program.customUniforms[e];const r=n.customUniformLocations[e];const i=o[e];if(s.type==="float"){t.gl.uniform1fv(r,i)}else if(s.type==="vec2"){t.gl.uniform2fv(r,i)}else if(s.type==="vec3"){t.gl.uniform3fv(r,i)}else if(s.type==="vec4"){t.gl.uniform4fv(r,i)}else if(s.type==="int"){t.gl.uniform1iv(r,i)}else if(s.type==="ivec2"){t.gl.uniform2iv(r,i)}else if(s.type==="ivec3"){t.gl.uniform3iv(r,i)}else if(s.type==="ivec4"){t.gl.uniform4iv(r,i)}else{throw Error(`uniform type ${s.type} is not supported yet.`)}}}t.executeProgram()}function dL(t,n,e){let s="";n.concat(e).forEach((n=>{const o=n.texData!=null&&n.texData.slice!=null&&n.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!n.isUniform){const r=n.texData.texShape;const{useSqueezeShape:i,uniformShape:c,keptDims:a}=iL(t.packedInputs,n.shape,r);let u="",l="",f="";if(c.length===1&&t.packedInputs){const t=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];u=`${t[0]>1}_${t[1]>1}`}else if(c.length===2&&!t.packedInputs){l=`${c[0]>1}_${c[1]>1}`}else if(c.length>2&&!t.packedInputs){const t=V(c);f=`${t[0]===r[1]}_${t[t.length-1]===r[1]}`}const h=n.shape.length;const d=c.length===2&&w(n.shape,r);const p=g(n.shape)===1;const m=lu(n.shape,e.shape);const x=!t.packedInputs&&h===e.shape.length&&w(r,e.texData.texShape);const b=t.packedInputs||c.length>2?"":`${r[0]>1}_${r[1]>1}`;s+=`${h}_${x}_${i?a:""}_${c.length}_${p}_${m}_${d}_${u}_${l}_${f}_${b}_${o}`}else{const t=n.isUniform?"uniform":n.texData.texShape;s+=`${n.shape}_${t}_${o}`}}));const o=t.userCode;let r=t.constructor.name;r+="_"+s+"_"+o+`${et().getNumber("WEBGL_VERSION")}`;return r}function pL(t){return et().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mL{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outPackingScheme=oM.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=uD();this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?fD(["r","c","d"],t):lD(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xL{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outPackingScheme=oM.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=uD();this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?fD(["r","c","d"],t):lD(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bL{constructor(t){this.variableNames=["A"];this.outTexUsage=rM.DOWNLOAD;const n=uD();this.outputShape=t;this.userCode=`\n      ${xD}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${n.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gL{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outTexUsage=rM.DOWNLOAD;const n=uD();this.outputShape=t;this.userCode=`\n      ${xD}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${n.output} = encode_float(x);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wL={R:0,G:1,B:2,A:3};class vL{constructor(t,n=false,e="RGBA"){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=uD();this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);let o=`result`;if(n){o=`floor(result * 255. + 0.5)`}let r="";for(let t=0;t<e.length;t++){const n=e[t];r+=`\n          if(offset == ${t}) {\n            result = values[${wL[n]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?mD():pD(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${e.length});\n\n        flatIndex = idiv(flatIndex, ${e.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${r}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $L{constructor(t,n=false){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=uD();this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);let s="";let o="result";if(n){o="floor(result * 255. + 0.5)"}for(let n=0;n<=1;n++){for(let o=0;o<=1;o++){const r=n*2+o;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${o};\n          if (localCoords[1] + ${n} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${n};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${e.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${r}] = values[0];\n            } else if (offset == 1) {\n              result[${r}] = values[1];\n            } else if (offset == 2) {\n              result[${r}] = values[2];\n            } else {\n              result[${r}] = values[3];\n            }\n          }\n        }\n        `}}this.userCode=`\n        ${this.enableShapeUniforms?mD():pD(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${e.output} = ${o};\n        }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(t){const n=uD();const e=`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return vM(t,e)}function kL(t){const n=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return SM(t,n)}function CL(t){const n=new Uint16Array([0,1,2,2,1,3]);return EM(t,n)}function NL(t,n,e,s,o,r){IM(n,e);const i=TM(t);const c=t.TEXTURE_2D;dM(t,(()=>t.bindTexture(c,i)));dM(t,(()=>t.texParameteri(c,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)));dM(t,(()=>t.texParameteri(c,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)));dM(t,(()=>t.texParameteri(c,t.TEXTURE_MIN_FILTER,t.NEAREST)));dM(t,(()=>t.texParameteri(c,t.TEXTURE_MAG_FILTER,t.NEAREST)));if(et().getNumber("WEBGL_VERSION")===1){dM(t,(()=>t.texImage2D(c,0,s,n,e,0,o,r,null)))}else{dM(t,(()=>t.texStorage2D(c,1,s,n,e)))}dM(t,(()=>t.bindTexture(t.TEXTURE_2D,null)));return{texture:i,texShape:[e,n]}}function RL(t){return t.internalFormatFloat}function SL(t,n,e,s){const[o,r]=cM(n,e);return NL(t,o,r,RL(s),s.textureFormatFloat,t.FLOAT)}function EL(t){return t.internalFormatHalfFloat}function TL(t,n,e,s){const[o,r]=cM(n,e);return NL(t,o,r,EL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function IL(t){return t.downloadTextureFormat}function AL(t,n,e,s){const[o,r]=cM(n,e);return NL(t,o,r,IL(s),t.RGBA,t.UNSIGNED_BYTE)}function OL(t){return t.internalFormatPackedFloat}function FL(t,n,e,s){const[o,r]=lM(n,e);return NL(t,o,r,OL(s),t.RGBA,t.FLOAT)}function _L(t){return t.internalFormatPackedHalfFloat}function ML(t,n,e,s){const[o,r]=lM(n,e);return NL(t,o,r,_L(s),t.RGBA,s.textureTypeHalfFloat)}function DL(t,n,e){const s=0;const o=3*4;const r=3*4+2*4;dM(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,e)));const i=OM(t,n,"clipSpacePos",e,3,r,s);return i&&OM(t,n,"uv",e,2,r,o)}function LL(t,n,e,s,o,r){dM(t,(()=>t.bindTexture(t.TEXTURE_2D,n)));let i,c,a;if(o instanceof Uint8Array){i=new Uint8Array(e*s*4);c=t.UNSIGNED_BYTE;a=t.RGBA}else{i=new Float32Array(e*s*4);c=t.FLOAT;a=r.internalFormatPackedFloat}i.set(o);if(et().getNumber("WEBGL_VERSION")===2){dM(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,s,t.RGBA,c,i)))}else{dM(t,(()=>t.texImage2D(t.TEXTURE_2D,0,a,e,s,0,t.RGBA,c,i)))}dM(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function zL(t,n,e){dM(t,(()=>t.bindTexture(t.TEXTURE_2D,n)));if(e.data instanceof Uint8Array){if(et().getNumber("WEBGL_VERSION")===2){dM(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)))}else{dM(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)))}}else{if(et().getNumber("WEBGL_VERSION")===2){dM(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)))}else{dM(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)))}}dM(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function PL(t,n,e,s){const o=t.createBuffer();dM(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o)));const r=4;const i=4;const c=r*i*n*e;dM(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,c,t.STREAM_READ)));dM(t,(()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)));dM(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)));return o}function VL(t,n,e){const s=t;const o=new Float32Array(e);s.bindBuffer(s.PIXEL_PACK_BUFFER,n);s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,o);s.bindBuffer(s.PIXEL_PACK_BUFFER,null);return o}function BL(t,n,e,s){const[o,r]=cM(n,e);const i=4;const c=new Uint8Array(aM(n*e,i));dM(t,(()=>t.readPixels(0,0,o,r,s.downloadTextureFormat,t.UNSIGNED_BYTE,c)));return new Float32Array(c.buffer)}function WL(t,n,e,s,o,r,i,c){const a=t;const u=new Float32Array(fM(r,i));a.bindBuffer(a.PIXEL_PACK_BUFFER,n);a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,u);a.bindBuffer(a.PIXEL_PACK_BUFFER,null);return u}function GL(t,n,e){const s=new Float32Array(n*e*4);dM(t,(()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,s)));return s}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UL{constructor(t){this.outputTexture=null;this.program=null;this.disposed=false;this.itemsToPoll=[];const n=et().getNumber("WEBGL_VERSION");if(t!=null){this.gl=t;tM(n,t)}else{this.gl=nM(n)}t=this.gl;if(et().getNumber("WEBGL_VERSION")===2){const n=t;this.createVertexArray=()=>dM(n,(()=>n.createVertexArray()));this.bindVertexArray=t=>dM(n,(()=>n.bindVertexArray(t)));this.deleteVertexArray=t=>dM(n,(()=>n.deleteVertexArray(t)));this.getVertexArray=()=>dM(n,(()=>n.getParameter(n.VERTEX_ARRAY_BINDING)))}else if(t!=null){const n=t.getExtension("OES_vertex_array_object");if(n==null){throw new Error("All WebGL1 implementations are expected to offer"+" OES_vertex_array_object.")}this.createVertexArray=()=>dM(t,(()=>n.createVertexArrayOES()));this.bindVertexArray=e=>dM(t,(()=>n.bindVertexArrayOES(e)));this.deleteVertexArray=e=>dM(t,(()=>n.deleteVertexArrayOES(e)));this.getVertexArray=()=>dM(t,(()=>t.getParameter(n.VERTEX_ARRAY_BINDING_OES)))}let e="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile");if(et().getNumber("WEBGL_VERSION")===1){const t="OES_texture_float";const n="OES_texture_half_float";this.textureFloatExtension=wM(this.gl,t);if(tD(this.gl,n)){this.textureHalfFloatExtension=wM(this.gl,n)}else if(et().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support half float textures, yet the "+"environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}this.colorBufferFloatExtension=this.gl.getExtension(e);if(tD(this.gl,s)){this.colorBufferHalfFloatExtension=wM(this.gl,s)}else if(et().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support color renderable half floats, yet "+"the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}}else{e="EXT_color_buffer_float";if(tD(this.gl,e)){this.colorBufferFloatExtension=this.gl.getExtension(e)}else if(tD(this.gl,s)){this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}else{throw new Error("GL context does not support color renderable floats")}}this.vertexBuffer=kL(this.gl);this.indexBuffer=CL(this.gl);this.framebuffer=AM(this.gl);this.textureConfig=hM(this.gl,this.textureHalfFloatExtension)}get debug(){return et().getBool("DEBUG")}dispose(){if(this.disposed){return}if(this.program!=null){console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram."+" This is probably a resource leak, delete the program with "+"GPGPUContext.deleteProgram before disposing.")}if(this.outputTexture!=null){console.warn("Disposing a GPGPUContext that still has a bound output matrix "+"texture.  This is probably a resource leak, delete the output "+"matrix texture with GPGPUContext.deleteMatrixTexture before "+"disposing.")}const t=this.gl;dM(t,(()=>t.finish()));dM(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null)));dM(t,(()=>t.deleteFramebuffer(this.framebuffer)));dM(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null)));dM(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)));dM(t,(()=>t.deleteBuffer(this.indexBuffer)));this.disposed=true}createFloat32MatrixTexture(t,n){this.throwIfDisposed();return SL(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){this.throwIfDisposed();return TL(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){this.throwIfDisposed();return AL(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed();zL(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,e,s){this.throwIfDisposed();LL(this.gl,t,n,e,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){this.throwIfDisposed();return ML(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){this.throwIfDisposed();return FL(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed();if(this.outputTexture===t){zM(this.gl,this.framebuffer);this.outputTexture=null}dM(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,e){return this.downloadMatrixDriver(t,(()=>BL(this.gl,n,e,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,n,e,s,o,r){return WL(this.gl,t,n,e,s,o,r)}downloadFloat32MatrixFromBuffer(t,n){return VL(this.gl,t,n)}createBufferFromTexture(t,n,e){this.bindTextureToFrameBuffer(t);const s=PL(this.gl,n,e);this.unbindTextureToFrameBuffer();return s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n;let e;if(et().getBool("WEBGL_FENCE_API_ENABLED")){const s=t;const o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush();e=()=>{const t=s.clientWaitSync(o,0,0);return t===s.ALREADY_SIGNALED||t===s.CONDITION_SATISFIED};n=o}else if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){n=this.beginQuery();this.endQuery();e=()=>this.isQueryAvailable(n,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}else{e=()=>true}return{query:n,isFencePassed:e}}downloadMatrixFromPackedTexture(t,n,e){return this.downloadMatrixDriver(t,(()=>GL(this.gl,n,e)))}createProgram(t){this.throwIfDisposed();const n=this.gl;if(this.vertexShader==null){this.vertexShader=yL(n)}const e=CM(n);dM(n,(()=>n.attachShader(e,this.vertexShader)));dM(n,(()=>n.attachShader(e,t)));NM(n,e);const s=Object.assign(e,{vao:this.createVertexArray()});if(this.debug){RM(n,s)}return s}buildVao(t){this.setProgram(t);this.bindVertexArray(t.vao);const n=this.gl;dM(n,(()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)));DL(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed();if(t===this.program){this.program=null}if(t!=null){dM(this.gl,(()=>this.gl.deleteProgram(t)));this.deleteVertexArray(t.vao)}}setProgram(t){this.throwIfDisposed();this.program=t;if(this.program!=null){if(this.debug){RM(this.gl,this.program)}}dM(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,n,e=true){this.throwIfDisposed();if(e){return _M(this.gl,t,n)}else{return MM(this.gl,t,n)}}getAttributeLocation(t,n){this.throwIfDisposed();return dM(this.gl,(()=>this.gl.getAttribLocation(t,n)))}getUniformLocationNoThrow(t,n){this.throwIfDisposed();return this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,e){this.throwIfDisposed();this.throwIfNoProgram();DM(this.gl,t,n,e)}setOutputMatrixTexture(t,n,e){this.setOutputMatrixTextureDriver(t,e,n)}setOutputPackedMatrixTexture(t,n,e){this.throwIfDisposed();const[s,o]=lM(n,e);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,n,e,s){this.setOutputMatrixWriteRegionDriver(e,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,e,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){if(this.program!=null){RM(this.gl,this.program)}PM(this.gl)}executeProgram(){this.throwIfDisposed();this.throwIfNoProgram();const t=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!");this.debugValidate()}dM(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed();dM(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){if(this.disjointQueryTimerExtension==null){this.disjointQueryTimerExtension=wM(this.gl,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")}return this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();const e=t.createQuery();t.beginQuery(n.TIME_ELAPSED_EXT,e);return e}const t=this.getQueryTimerExtensionWebGL1();const n=t.createQueryEXT();t.beginQueryEXT(t.TIME_ELAPSED_EXT,n);return n}endQuery(){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){await k((()=>this.disposed||this.isQueryAvailable(t,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))));return this.getQueryTime(t,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0){return null}if(n===2){const n=this.gl;const e=n.getQueryParameter(t,n.QUERY_RESULT);return e/1e6}else{const n=this.getQueryTimerExtensionWebGL1();const e=n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT);return e/1e6}}isQueryAvailable(t,n){if(n===0){return true}if(n===2){const n=this.gl;const e=this.getQueryTimerExtensionWebGL2();const s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);if(this.disjoint==null){this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)}return s&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1();const e=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);if(this.disjoint==null){this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)}return e&&!this.disjoint}}pollFence(t){return new Promise((n=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>n()))}))}pollItems(){const t=HL(this.itemsToPoll.map((t=>t.isDoneFn)));for(let n=0;n<=t;++n){const{resolveFn:t}=this.itemsToPoll[n];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){this.itemsToPoll.push({isDoneFn:t,resolveFn:n});if(this.itemsToPoll.length>1){return}let e=undefined;if("setTimeoutCustom"in et().platform){e=et().platform.setTimeoutCustom.bind(et().platform)}k((()=>{this.pollItems();return this.itemsToPoll.length===0}),(()=>0),null,e)}bindTextureToFrameBuffer(t){this.throwIfDisposed();LM(this.gl,t,this.framebuffer);if(this.debug){PM(this.gl)}}unbindTextureToFrameBuffer(){if(this.outputTexture!=null){LM(this.gl,this.outputTexture,this.framebuffer);if(this.debug){PM(this.gl)}}else{zM(this.gl,this.framebuffer)}}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const e=n();this.unbindTextureToFrameBuffer();return e}setOutputMatrixTextureDriver(t,n,e){this.throwIfDisposed();const s=this.gl;LM(s,t,this.framebuffer);if(this.debug){PM(s)}this.outputTexture=t;dM(s,(()=>s.viewport(0,0,n,e)));dM(s,(()=>s.scissor(0,0,n,e)))}setOutputMatrixWriteRegionDriver(t,n,e,s){this.throwIfDisposed();dM(this.gl,(()=>this.gl.scissor(t,n,e,s)))}throwIfDisposed(){if(this.disposed){throw new Error("Attempted to use disposed GPGPUContext.")}}throwIfNoProgram(){if(this.program==null){throw new Error("No GPU program is currently set.")}}}function HL(t){let n=0;for(;n<t.length;++n){const e=t[n]();if(!e){break}}return n-1}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:jL,bincountImpl:qL,bincountReduceImpl:XL,bitwiseAndImpl:KL,castImpl:JL,ceilImpl:YL,concatImpl:ZL,equalImpl:QL,expImpl:tz,expm1Impl:nz,floorImpl:ez,gatherNdImpl:sz,gatherV2Impl:oz,greaterImpl:rz,greaterEqualImpl:iz,lessImpl:cz,lessEqualImpl:az,linSpaceImpl:uz,logImpl:lz,maxImpl:fz,maximumImpl:hz,minimumImpl:dz,multiplyImpl:pz,negImpl:mz,notEqualImpl:xz,prodImpl:bz,raggedGatherImpl:gz,raggedRangeImpl:wz,raggedTensorToTensorImpl:vz,rangeImpl:$z,rsqrtImpl:yz,scatterImpl:kz,sigmoidImpl:Cz,simpleAbsImpl:Nz,sliceImpl:Rz,sparseFillEmptyRowsImpl:Sz,sparseReshapeImpl:Ez,sparseSegmentReductionImpl:Tz,sqrtImpl:Iz,staticRegexReplaceImpl:Az,stridedSliceImpl:Oz,stringNGramsImpl:Fz,stringSplitImpl:_z,stringToHashBucketFastImpl:Mz,subImpl:Dz,tileImpl:Lz,topKImpl:zz,transposeImpl:Pz,uniqueImpl:Vz}=oT;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bz(t,n){return["x","y","z","w","u","v"].slice(0,n).map((n=>`${t}.${n}`))}function Wz(t,n){if(n===1){return[t]}return Bz(t,n)}function Gz(t,n){if(t===1){return"rc"}let e="";for(let s=0;s<t;s++){e+=n[s];if(s<t-1){e+=","}}return e}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uz{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outputShape=t;this.rank=t.length;this.enableShapeUniforms=pL(this.outputShape.length);if(this.rank===0){this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `}else{const t=Wz("rc",this.rank);const n=rL(this.rank);const e=this.getOutOfBoundsCondition(t);const s=this.getSetup(t);const o=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${e}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const n=[];for(let e=0;e<=1;e++){for(let s=0;s<=1;s++){let o=`${e===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let n=2;n<this.rank;n++){o=`${t[t.length-1-n]},`+o}n.push(o)}}return n}getOutOfBoundsCondition(t){if(this.rank===1){return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`}let n="";for(let e=this.rank-2;e<this.rank;e++){n+=`${t[e]} >= ${this.enableShapeUniforms?`outShape[${e}]`:this.outputShape[e]}`;if(e<this.rank-1){n+="||"}}return n}getSetup(t){if(this.rank===1){return""}const n=t.slice(-2);const e=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1];const s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${n[0]};\n      int c = ${n[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${e};\n      bool rEdge = rp1 >= ${s};\n    `}getOutput(t){const n=this.getSourceCoordsArr(t);if(this.rank===1){const t=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${t} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${n[0]}),\n            cEdge ? 0. : getA(${n[1]}),\n            rEdge ? 0. : getA(${n[2]}),\n            rEdge || cEdge ? 0. : getA(${n[3]})`}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hz{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);let e=``;for(let t=0;t<4;t++){let n=`thisRC = rc;`;if(t%2===1){n+=`thisRC.z += 1;`}if(t>1){n+=`thisRC.y += 1;`}e+=`\n        ${n}\n        ${t>0?`if(thisRC.y < rows && thisRC.z < cols){`:""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}this.userCode=`\n      ${jz(n,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?mD():pD(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${e}\n\n        setOutput(result);\n      }\n    `}}function jz(t,n){const e=n?dD(["r","c","d"],"inputShape"):lD(["r","c","d"],t);return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e}\n      return ivec3(r, c, d);\n    }\n  `}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz{constructor(t){this.gpgpu=t;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.usedTextures={};this.logEnabled=false}acquireTexture(t,n,e){const s=Zz(n,e);const o=Qz(t,s,e);if(!(o in this.freeTextures)){this.freeTextures[o]=[]}if(!(o in this.usedTextures)){this.usedTextures[o]=[]}const r=Kz(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,e);if(this.freeTextures[o].length>0){this.numFreeTextures--;this.numUsedTextures++;this._numBytesFree-=r;this.log();const t=this.freeTextures[o].pop();this.usedTextures[o].push(t);return t}let i;if(s===iM.PACKED_2X2_FLOAT32){i=this.gpgpu.createPackedMatrixTexture(t[0],t[1])}else if(s===iM.PACKED_2X2_FLOAT16){i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1])}else if(s===iM.UNPACKED_FLOAT32){i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1])}else if(s===iM.UNPACKED_FLOAT16){i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1])}else if(s===iM.PACKED_4X1_UNSIGNED_BYTE){i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])}this.usedTextures[o].push(i);this.numUsedTextures++;this._numBytesAllocated+=r;this.log();return i}releaseTexture(t,n,e,s){if(this.freeTextures==null){return}const o=Zz(e,s);const r=Qz(n,o,s);if(!(r in this.freeTextures)){this.freeTextures[r]=[]}const i=Kz(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,s);const c=et().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");if(c!==-1&&this._numBytesAllocated>c){this.gpgpu.deleteMatrixTexture(t.texture);this._numBytesAllocated-=i}else{this.freeTextures[r].push(t);this.numFreeTextures++;this._numBytesFree+=i}this.numUsedTextures--;const a=this.usedTextures[r];const u=a&&a.indexOf(t);if(u==null||u<0){throw new Error("Cannot release a texture that was never provided by this "+"texture manager")}a[u]=a[a.length-1];a.pop();this.log()}log(){if(!this.logEnabled){return}const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`);console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null){return}for(const t in this.freeTextures){this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}))}for(const t in this.usedTextures){this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}))}this.freeTextures=null;this.usedTextures=null;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0}}function Xz(t,n){const e=t;if(n===e.R32F){return 4}else if(n===e.R16F){return 2}else if(n===e.RGBA32F){return 16}else if(n===t.RGBA){return 16}else if(n===e.RGBA16F){return 8}else if(n===e.RGBA8){return 4}throw new Error(`Unknown internal format ${n}`)}function Kz(t,n,e,s,o){const r=Jz(n,s);let i;if(o){const[n,e]=lM(t[0],t[1]);i=n*e}else{const[n,e]=cM(t[0],t[1]);i=n*e}const c=Xz(e,r);return i*c}function Jz(t,n){switch(t){case iM.PACKED_2X2_FLOAT32:return OL(n);case iM.PACKED_2X2_FLOAT16:return _L(n);case iM.UNPACKED_FLOAT32:return RL(n);case iM.UNPACKED_FLOAT16:return EL(n);case iM.PACKED_4X1_UNSIGNED_BYTE:return IL(n);default:throw new Error(`Unknown physical texture type ${t}`)}}function Yz(t){if(et().getBool("WEBGL_RENDER_FLOAT32_ENABLED")){if(t){return iM.PACKED_2X2_FLOAT32}return iM.UNPACKED_FLOAT32}if(t){return iM.PACKED_2X2_FLOAT16}return iM.UNPACKED_FLOAT16}function Zz(t,n){if(t===rM.UPLOAD){return iM.PACKED_2X2_FLOAT32}else if(t===rM.RENDER||t==null){return Yz(n)}else if(t===rM.DOWNLOAD||t===rM.PIXELS){return iM.PACKED_4X1_UNSIGNED_BYTE}throw new Error(`Unknown logical texture type ${t}`)}function Qz(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tP{constructor(t,n){this.variableNames=["A"];this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);this.userCode=`\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const nP=`if (isnan(x)) return x;`;const eP=`return x;`;const sP=`return abs(x);`;const oP=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const rP=nP+`\n  return (x < 0.0) ? 0.0 : x;\n`;const iP=nP+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const cP="return x;";const aP=`return 1.0 / (1.0 + exp(-1.0 * x));`
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */;const uP=`return x;`;const lP=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const fP=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const hP=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const dP=`return 1.0 / (1.0 + exp(-1.0 * x));`;class pP{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mP{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);const n=t.length;const e=Wz("rc",n);const s=rL(n);const o=Gz(n,e);const r=e.slice(-2);const i=n<=1?"rc":`vec2(${r.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP=Id;const bP=1e-7;const gP=1e-4;const wP={};function vP(t){if(t in wP){return wP[t]}wP[t]={};return wP[t]}const $P=et().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");const yP=600;function kP(){if(et().global.screen==null){return 1024}return et().global.screen.height*et().global.screen.width*window.devicePixelRatio*yP/1024/1024}class CP extends a{nextDataId(){return CP.nextDataId++}constructor(t){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=false;this.pendingDeletes=0;this.disposed=false;if(!et().getBool("HAS_WEBGL")){throw new Error("WebGL is not supported on this device")}let n;if(t!=null){if(t instanceof UL){n=t}else{const e=nM(et().getNumber("WEBGL_VERSION"),t);n=new UL(e)}this.binaryCache={};this.gpgpuCreatedLocally=false}else{const t=nM(et().getNumber("WEBGL_VERSION"));n=new UL(t);this.binaryCache=vP(et().getNumber("WEBGL_VERSION"));this.gpgpuCreatedLocally=true}this.gpgpu=n;this.canvas=this.gpgpu.gl.canvas;this.textureManager=new qz(this.gpgpu);this.numMBBeforeWarning=kP();this.texData=new c(this,Vi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,e,s,o,r){const i=this.makeTensorInfo(n,e);const c=this.texData.get(i.dataId);c.isPacked=false;c.texture={texture:t,texShape:[s,o]};c.texShape=[s,o];const a=HM(n);const u=new vL(a,false,r);const l=this.runWebGLProgram(u,[i],e,[[s,o]]);l.shape=n;c.texture=null;this.disposeIntermediateTensorInfo(i);return l.dataId}write(t,n,e){if(et().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||et().getBool("DEBUG")){this.checkNumericalProblems(t)}if(e==="complex64"&&t!=null){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}const s={id:this.nextDataId()};this.texData.set(s,{shape:n,dtype:e,values:t,usage:rM.UPLOAD,refCount:1});return s}refCount(t){if(this.texData.has(t)){const n=this.texData.get(t);return n.refCount}return 0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,e,s,o){if(et().getBool("DEBUG")){this.checkNumericalProblems(n)}if(s==="complex64"){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}this.texData.set(t,{shape:e,dtype:s,values:n,usage:rM.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t);const{values:e,dtype:s,complexTensorInfos:o,slice:r,shape:i,isPacked:c}=n;if(r!=null){let n;if(c){n=new pP(i,cP)}else{n=new tP(i,cP)}const e=this.runWebGLProgram(n,[{dataId:t,shape:i,dtype:s}],s);const o=this.readSync(e.dataId);this.disposeIntermediateTensorInfo(e);return o}if(e!=null){return this.convertAndCacheOnCPU(t)}if(s==="string"){return e}const a=this.activeTimers!=null;let u;if(a){u=To()}let l;if(s==="complex64"){const t=this.readSync(o.real.dataId);const n=this.readSync(o.imag.dataId);l=vx(t,n)}else{l=this.getValuesFromTexture(t)}if(a){this.downloadWaitMs+=To()-u}return this.convertAndCacheOnCPU(t,l)}async read(t){if(this.pendingRead.has(t)){const n=this.pendingRead.get(t);return new Promise((t=>n.push(t)))}const n=this.texData.get(t);const{values:e,shape:s,slice:o,dtype:r,complexTensorInfos:i,isPacked:c}=n;if(o!=null){let n;if(c){n=new pP(s,cP)}else{n=new tP(s,cP)}const e=this.runWebGLProgram(n,[{dataId:t,shape:s,dtype:r}],r);const o=this.read(e.dataId);this.disposeIntermediateTensorInfo(e);return o}if(e!=null){return this.convertAndCacheOnCPU(t)}if(et().getBool("DEBUG")){if(!et().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&et().getNumber("WEBGL_VERSION")===2){throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and `+`WEBGL_VERSION=2 not yet supported.`)}}let a=null;let u;if(r!=="complex64"&&et().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const n=this.texData.get(u.dataId);a=this.gpgpu.createBufferFromTexture(n.texture.texture,...uM(s))}this.pendingRead.set(t,[]);if(r!=="complex64"){await this.gpgpu.createAndWaitForFence()}let l;if(r==="complex64"){const t=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);const n=t[0];const e=t[1];l=vx(n,e)}else if(a==null){l=this.getValuesFromTexture(t)}else{const t=g(s);l=this.gpgpu.downloadFloat32MatrixFromBuffer(a,t)}if(u!=null){this.disposeIntermediateTensorInfo(u)}if(a!=null){const t=this.gpgpu.gl;dM(t,(()=>t.deleteBuffer(a)))}const f=this.convertAndCacheOnCPU(t,l);const h=this.pendingRead.get(t);this.pendingRead.delete(t);h.forEach((t=>t(f)));if(this.pendingDisposal.has(t)){this.pendingDisposal.delete(t);if(this.disposeData(t)){Vi().removeDataId(t,this)}this.pendingDeletes--}return f}readToGPU(t,n={}){const e=this.texData.get(t);const{values:s,shape:o,slice:r,dtype:i,isPacked:c,texture:a}=e;if(i==="complex64"){throw new Error("Does not support reading texture for complex64 dtype.")}if(r!=null){let e;if(c){e=new pP(o,cP)}else{e=new tP(o,cP)}const s=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:i}],i);const r=this.readToGPU(s,n);this.disposeIntermediateTensorInfo(s);return r}if(a==null){if(s!=null){throw new Error("Data is not on GPU but on CPU.")}else{throw new Error("There is no data on GPU or CPU.")}}const u=this.decode(t,n.customTexShape);const l=Vi().makeTensorFromTensorInfo(u);const f=this.texData.get(u.dataId);return Object.assign({tensorRef:l},f.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string"){try{const e=n.map((t=>Ao(t)));return Fi(t.shape,t.dtype,e)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}}return Fi(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t==null){return}for(let n=0;n<t.length;n++){const e=t[n];if(!bM(e)){if(et().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")){throw Error(`The value ${e} cannot be represented with your `+`current settings. Consider enabling float32 rendering: `+`'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`)}throw Error(`The value ${e} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:n,dtype:e,isPacked:s}=this.texData.get(t);const o=g(n);if(et().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const e=this.decode(t);const s=this.texData.get(e.dataId);const r=this.gpgpu.downloadMatrixFromPackedTexture(s.texture.texture,...uM(n)).subarray(0,o);this.disposeIntermediateTensorInfo(e);return r}const r=et().getBool("WEBGL_PACK")&&s===true;const i=r?HM(n):n;const c=r?new gL(i):new bL(i);const a=this.runWebGLProgram(c,[{shape:i,dtype:e,dataId:t}],"float32");const u=this.texData.get(a.dataId);const l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,o);this.disposeIntermediateTensorInfo(a);return l}timerAvailable(){return et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers;const e=[];let s=false;if(this.programTimersStack==null){this.programTimersStack=e;s=true}else{this.activeTimers.push(e)}this.activeTimers=e;t();const o=Fo(this.activeTimers.map((t=>t.query))).filter((t=>t!=null));const r=Fo(this.activeTimers.map((t=>t.name))).filter((t=>t!=null));this.activeTimers=n;if(s){this.programTimersStack=null}const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(o);i["kernelMs"]=p(t);i["getExtraProfileInfo"]=()=>t.map(((t,n)=>({name:r[n],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else{i["kernelMs"]={error:"WebGL query timers are not supported in this environment."}}this.uploadWaitMs=0;this.downloadWaitMs=0;return i})()}memory(){return{unreliable:false,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.beginQuery()}return{startMs:To(),endMs:null}}endTimer(t){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){this.gpgpu.endQuery();return t}t.endMs=To();return t}async getQueryTime(t){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.waitForQueryAndGetTime(t)}const n=t;return n.endMs-n.startMs}disposeData(t,n=false){if(this.pendingDisposal.has(t)){return false}if(!this.texData.has(t)){return true}if(n){this.texData.get(t).refCount=0}else{this.texData.get(t).refCount--}if(!n&&this.texData.get(t).refCount>0){return false}if(this.pendingRead.has(t)){this.pendingDisposal.add(t);this.pendingDeletes++;return false}this.releaseGPUData(t);const{complexTensorInfos:e}=this.texData.get(t);if(e!=null){this.disposeData(e.real.dataId,n);this.disposeData(e.imag.dataId,n)}this.texData.delete(t);return true}releaseGPUData(t){const{texture:n,dtype:e,texShape:s,usage:o,isPacked:r,slice:i}=this.texData.get(t);const c=i&&i.origDataId||t;const a=this.dataRefCount.get(c);if(a>1){this.dataRefCount.set(c,a-1)}else{this.dataRefCount.delete(c);if(n!=null){this.numBytesInGPU-=this.computeBytes(s,e);this.textureManager.releaseTexture(n,s,o,r)}}const u=this.texData.get(t);u.texture=null;u.texShape=null;u.isPacked=false;u.slice=null}getTexture(t){this.uploadToGPU(t);return this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=$P){return et().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>this.texData.get(t.dataId).texture==null&&g(t.shape)<n))}getGPGPUContext(){return this.gpgpu}where(t){ks("tf.where() in webgl locks the UI thread. "+"Call tf.whereAsync() instead");const n=t.dataSync();return xP(t.shape,n)}packedUnaryOp(t,n,e){const s=new pP(t.shape,n);const o=this.compileAndRun(s,[t],e);return Vi().makeTensorFromTensorInfo(o)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const n=Nz(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,n)}if(et().getBool("WEBGL_PACK_UNARY_OPERATIONS")){return this.packedUnaryOp(t,sP,t.dtype)}const n=new tP(t.shape,sP);const e=this.compileAndRun(n,[t]);return Vi().makeTensorFromTensorInfo(e)}makeTensorInfo(t,n,e){let s;if(n==="string"&&e!=null&&e.length>0&&_(e[0])){const o=e.map((t=>Io(t)));s=this.write(o,t,n)}else{s=this.write(e,t,n)}this.texData.get(s).usage=null;return{dataId:s,shape:t,dtype:n}}makeOutput(t,n,e){return Vi().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}unpackTensor(t){const n=new mP(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new Uz(t.shape);const e=true;return this.runWebGLProgram(n,[t],t.dtype,null,e)}packedReshape(t,n){const e=[GM(t.shape),...UM(t.shape)];const s={dtype:t.dtype,shape:e,dataId:t.dataId};const o=[GM(n),...UM(n)];const r=new Hz(o,e);const i=true;const c=[e];const a=this.runWebGLProgram(r,[s],t.dtype,c,i);return{dataId:a.dataId,shape:n,dtype:a.dtype}}decode(t,n){const e=this.texData.get(t);const{isPacked:s,shape:o,dtype:r}=e;if(n!=null){const t=g(o);const e=n[0]*n[1]*4;m(t<=e,(()=>"customTexShape is too small. "+"Row * Column * 4 should be equal or larger than the "+"size of the tensor data."))}const i=HM(o);let c;if(s){c=new xL(i)}else{c=new mL(i)}const a=true;const u=[n!=null?n:uM(i)];const l=this.runWebGLProgram(c,[{shape:i,dtype:r,dataId:t}],r,u,a,n);return{dtype:r,shape:o,dataId:l.dataId}}runWebGLProgram(t,n,e,s,o=false,r){const i=this.makeTensorInfo(t.outputShape,e);const c=this.texData.get(i.dataId);if(t.packedOutput){c.isPacked=true}if(t.outPackingScheme===oM.DENSE){const n=r!=null?r:uM(t.outputShape);c.texShape=n.map((t=>t*2))}if(t.outTexUsage!=null){c.usage=t.outTexUsage}if(g(i.shape)===0){c.values=S(i.dtype,0);return i}const a=[];const u=n.map((n=>{if(n.dtype==="complex64"){throw new Error(`GPGPUProgram does not support complex64 input. For complex64 `+`dtypes, please separate the program into real and imaginary `+`parts.`)}let e=this.texData.get(n.dataId);if(e.texture==null){if(!t.packedInputs&&g(n.shape)<=et().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")){return{shape:n.shape,texData:null,isUniform:true,uniformValues:e.values}}if(t.packedInputs){e.isPacked=true;e.shape=n.shape}}this.uploadToGPU(n.dataId);if(!!e.isPacked!==!!t.packedInputs){n=e.isPacked?this.unpackTensor(n):this.packTensor(n);a.push(n);e=this.texData.get(n.dataId)}else if(e.isPacked&&!XM(e.shape,n.shape)){const t=n;const s=n.shape;n.shape=e.shape;n=this.packedReshape(n,s);a.push(n);e=this.texData.get(n.dataId);t.shape=s}return{shape:n.shape,texData:e,isUniform:false}}));this.uploadToGPU(i.dataId);const l={shape:i.shape,texData:c,isUniform:false};const f=dL(t,u,l);const h=this.getAndSaveBinary(f,(()=>uL(this.gpgpu,t,u,l)));const d=this.activeTimers!=null;let p;if(d){p=this.startTimer()}if(!et().get("ENGINE_COMPILE_ONLY")){hL(this.gpgpu,h,u,l,s)}a.forEach((t=>this.disposeIntermediateTensorInfo(t)));if(d){p=this.endTimer(p);this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(p)})}const m=et().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=To();if(t-this.lastGlFlushTime>m){this.gpgpu.gl.flush();this.lastGlFlushTime=t}}if(!et().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&o===false){const t=this.unpackTensor(i);this.disposeIntermediateTensorInfo(i);return t}return i}compileAndRun(t,n,e,s,o=false){e=e||n[0].dtype;const r=this.runWebGLProgram(t,n,e,s,o);return r}getAndSaveBinary(t,n){if(!(t in this.binaryCache)){this.binaryCache[t]=n()}return this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed){return}if(!et().getBool("IS_TEST")){const t=Object.keys(this.binaryCache);t.forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram);delete this.binaryCache[t]}))}this.textureManager.dispose();if(this.canvas!=null&&(typeof HTMLCanvasElement!=="undefined"&&this.canvas instanceof HTMLCanvasElement)){this.canvas.remove()}else{this.canvas=null}if(this.gpgpuCreatedLocally){this.gpgpu.program=null;this.gpgpu.dispose()}this.disposed=true}floatPrecision(){if(this.floatPrecisionValue==null){this.floatPrecisionValue=Wi((()=>{if(!et().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=et().getBool("DEBUG");et().set("DEBUG",false);const n=this.abs(Gu(1e-8)).dataSync()[0];et().set("DEBUG",t);if(n>0){return 32}}return 16}))}return this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?bP:gP}uploadToGPU(t){const n=this.texData.get(t);const{shape:e,dtype:s,values:o,texture:r,usage:i,isPacked:c}=n;if(r!=null){return}const a=this.activeTimers!=null;let u;if(a){u=To()}let l=n.texShape;if(l==null){l=jM(e,c);n.texShape=l}if(o!=null){const t=HM(e);let r;let i=l[1],f=l[0];const h=o instanceof Uint8Array||o instanceof Uint8ClampedArray;if(c||!h){[i,f]=lM(l[0],l[1])}if(c){r=new $L(t,h)}else{r=new vL(t,h)}const d=h?[f,i]:l;const p=this.makeTensorInfo(d,s);const m=this.texData.get(p.dataId);if(h){m.usage=rM.PIXELS}else{m.usage=rM.UPLOAD}m.texShape=d;this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,f,o);const x=[[f,i]];const b=true;const g=this.runWebGLProgram(r,[p],s,x,b);const w=this.texData.get(g.dataId);n.texShape=w.texShape;n.isPacked=w.isPacked;n.usage=w.usage;if(!et().get("ENGINE_COMPILE_ONLY")){n.texture=w.texture;n.values=null;this.texData.delete(g.dataId)}else{this.disposeData(g.dataId)}this.disposeIntermediateTensorInfo(p);if(a){this.uploadWaitMs+=To()-u}}else{const t=this.acquireTexture(l,i,s,c);n.texture=t}}convertAndCacheOnCPU(t,n){const e=this.texData.get(t);const{dtype:s}=e;if(n!=null){e.values=NP(n,s)}return e.values}acquireTexture(t,n,e,s){this.numBytesInGPU+=this.computeBytes(t,e);if(!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=true;console.warn(`High memory usage in GPU: ${t} MB, `+`most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*O(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache)){this.checkCompletion_(t)}}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache)){t.push(this.checkCompletionAsync_(n))}return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const e=new Promise((t=>{try{this.checkCompletion_(n);t(true)}catch(t){throw t}}));t.push(e)}return Promise.all(t)}}async checkCompletionAsync_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)){return this.checkCompletion_(t)}else{await Jm();return this.checkCompletionAsync_(t)}}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===false){console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram));if(this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===false){kM(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader));throw new Error("Failed to compile fragment shader.")}throw new Error("Failed to link vertex and fragment shaders.")}return true}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:e,infLoc:s,nanLoc:o,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:c}=lL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n;t.customUniformLocations=e;t.infLoc=s;t.nanLoc=o;t.outShapeLocation=r;t.outShapeStridesLocation=i;t.outTexShapeLocation=c}}createTensorFromGPUData(t,n,e){t.channels=t.channels||"RGBA";const{texture:s,height:o,width:r,channels:i}=t;const c=Vi().backend;if(!c.gpgpu.gl.isTexture(s)){throw new Error(`The texture is invalid. Also, please make sure the texture and `+`the TFJS WebGL backend are using the same canvas. If you want to `+`use your own custom canvas, you have to create and use the custom `+`TFJS WebGL backend created from the canvas through `+`'new tf.MathBackendWebGL(customCanvas)'.`)}const a=c.writeTexture(s,n,e,o,r,i);return Vi().makeTensorFromDataId(a,n,e,c)}}CP.nextDataId=0;function NP(t,n){if(n==="float32"||n==="complex64"){return t}else if(n==="int32"||n==="bool"){const e=n==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let n=0;n<e.length;++n){e[n]=Math.round(t[n])}return e}else{throw new Error(`Unknown dtype ${n}`)}}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */if(Nr()){Hi("webgl",(()=>new CP),2)}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RP=`\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;class SP{constructor(t,n,e){this.variableNames=["A","B"];this.outputShape=hu(n,e);this.enableShapeUniforms=pL(this.outputShape.length);this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP=`\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`;class TP{constructor(t,n,e,s=false){this.variableNames=["A","B"];this.supportsBroadcasting=true;this.packedInputs=true;this.packedOutput=true;this.outputShape=hu(n,e);const o=this.outputShape.length;this.enableShapeUniforms=pL(o);let r="";if(s){if(o===0||g(this.outputShape)===1){r=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `}else{const t=rL(o);r=`\n          ${t} coords = getOutputCoords();\n        `;if(o===1){if(this.enableShapeUniforms){r+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}else{r+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}}else{const t=Wz("coords",o);if(this.enableShapeUniforms){r+=`\n            bool nextRowOutOfBounds =\n              (${t[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${t[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}else{r+=`\n            bool nextRowOutOfBounds =\n              (${t[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${t[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${r}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IP(t){const{inputs:n,backend:e}=t;const{x:s}=n;e.incRef(s.dataId);return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const AP={kernelName:Rn,backendName:"webgl",kernelFunc:IP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(t){const{inputs:n,backend:e}=t;const{real:s,imag:o}=n;const r=e.makeTensorInfo(s.shape,"complex64");const i=e.texData.get(r.dataId);const c=IP({inputs:{x:s},backend:e});const a=IP({inputs:{x:o},backend:e});i.complexTensorInfos={real:c,imag:a};return r}const FP={kernelName:Dt,backendName:"webgl",kernelFunc:OP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P=`return (a < 0.) ? b * a : a;`;const MP=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function DP(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{alpha:r}=s;const i=e.makeTensorInfo([],"float32",Ro(r,"float32"));const c=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TP(MP,o.shape,i.shape):new SP(_P,o.shape,i.shape);const a=e.runWebGLProgram(c,[o,i],"float32");e.disposeIntermediateTensorInfo(i);return a}const LP={kernelName:On,backendName:"webgl",kernelFunc:DP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zP=`return (a < 0.) ? b * a : a;`;const PP=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function VP(t){const{inputs:n,backend:e}=t;const{x:s,alpha:o}=n;const r=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TP(PP,s.shape,o.shape):new SP(zP,s.shape,o.shape);return e.runWebGLProgram(r,[s,o],"float32")}const BP={kernelName:pe,backendName:"webgl",kernelFunc:VP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WP=`if (isnan(x)) return x;`;function GP({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:s}){return({inputs:o,backend:r})=>{const{x:i}=o;const c=r;const a=s||i.dtype;if(c.shouldExecuteOnCPU([i])&&e!=null){const t=c.texData.get(i.dataId);const n=e(t.values,a);return c.makeTensorInfo(i.shape,a,n)}const u=et().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&n!=null;let l;if(u){l=new pP(i.shape,n)}else{l=new tP(i.shape,t)}return c.runWebGLProgram(l,[i],a)}}function UP({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=false,supportsComplex:s=false,cpuKernelImpl:o,dtype:r}){return({inputs:i,backend:c})=>{const{a,b:u}=i;const l=c;if(s&&a.dtype==="complex64"){const n=l.texData.get(a.dataId);const e=l.texData.get(u.dataId);const[s,o]=[[n.complexTensorInfos.real,e.complexTensorInfos.real],[n.complexTensorInfos.imag,e.complexTensorInfos.imag]].map((n=>{const[e,s]=n;const o={dataId:e.dataId,dtype:e.dtype,shape:a.shape};const r={dataId:s.dataId,dtype:s.dtype,shape:u.shape};const i=new SP(t,a.shape,u.shape);return l.runWebGLProgram(i,[o,r],ar(e.dtype,s.dtype))}));const r=OP({inputs:{real:s,imag:o},backend:l});l.disposeIntermediateTensorInfo(s);l.disposeIntermediateTensorInfo(o);return r}const f=r||ar(a.dtype,u.dtype);if((a.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([a,u]))&&o!=null){const t=l.texData.get(a.dataId).values;const n=l.texData.get(u.dataId).values;const e=a.dtype==="string"?nb(t):t;const s=a.dtype==="string"?nb(n):n;const[r,i]=o(a.shape,u.shape,e,s,f);const c=l.makeTensorInfo(i,f);const h=l.texData.get(c.dataId);h.values=r;return c}const h=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&n!=null;let d;if(h){d=new TP(n,a.shape,u.shape,e)}else{d=new SP(t,a.shape,u.shape)}return l.runWebGLProgram(d,[a,u],f)}}function HP(t,n=false){if(t==="linear"){if(n){return uP}return eP}else if(t==="relu"){if(n){return fP}return rP}else if(t==="elu"){if(n){return lP}return oP}else if(t==="relu6"){if(n){return hP}return iP}else if(t==="prelu"){if(n){return PP}return zP}else if(t==="leakyrelu"){if(n){return MP}return _P}else if(t==="sigmoid"){if(n){return dP}return aP}throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jP{constructor(t,n,e,s=false,o=false,r=false,i=null,c=false,a=false){this.variableNames=["matrixA","matrixB"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.enableShapeUniforms=pL(this.outputShape.length);const u=s?t[1]:t[2];const l=Math.ceil(u/2);const f=s?"i * 2, rc.y":"rc.y, i * 2";const h=o?"rc.z, i * 2":"i * 2, rc.z";const d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];const p=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",x="";if(i){if(c){m=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`}else if(a){m=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`}else{m=`vec4 activation(vec4 x) {\n          ${i}\n        }`}x=`result = activation(result);`}const b=r?"result += getBiasAtOutCoords();":"";if(r){this.variableNames.push("bias")}if(c){this.variableNames.push("preluActivationWeights")}if(a){this.variableNames.push("leakyreluAlpha")}let g="rc.x";let w="rc.x";if(t[0]<n[0]){g=`imod(rc.x, ${t[0]})`}else if(n[0]<t[0]){w=`imod(rc.x, ${n[0]})`}this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${g};\n        int batchB = ${w};\n        for (int i = 0; i < ${l}; i++) {\n          vec4 a = getMatrixA(batchA, ${f});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${x}\n\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qP={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class XP{constructor(t,n,e){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=hu(n,e);this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KP="return a * b;";function JP(t){const{inputs:n,backend:e}=t;const{a:s,b:o}=n;const r=ar(s.dtype,o.dtype);if(s.dtype==="complex64"){const t=e.texData.get(s.dataId);const n=e.texData.get(o.dataId);const r=new XP(qP.REAL,s.shape,o.shape);const i=new XP(qP.IMAG,s.shape,o.shape);const c=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:o.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:o.shape}];const a=e.runWebGLProgram(r,c,"float32");const u=e.runWebGLProgram(i,c,"float32");const l=OP({inputs:{real:a,imag:u},backend:e});e.disposeIntermediateTensorInfo(a);e.disposeIntermediateTensorInfo(u);return l}if(e.shouldExecuteOnCPU([s,o])){const t=e.texData.get(s.dataId);const n=e.texData.get(o.dataId);const[i,c]=pz(s.shape,o.shape,t.values,n.values,r);const a=e.makeTensorInfo(c,r);const u=e.texData.get(a.dataId);u.values=i;return a}let i;if(et().getBool("WEBGL_PACK_BINARY_OPERATIONS")){i=new TP(KP,s.shape,o.shape)}else{i=new SP(KP,s.shape,o.shape)}return e.runWebGLProgram(i,[s,o],r)}const YP={kernelName:se,backendName:"webgl",kernelFunc:JP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZP(t,n,e){const s=[GM(t.shape),...UM(t.shape)];const o={dtype:t.dtype,shape:s,dataId:t.dataId};const r=[GM(n),...UM(n)];const i=new Hz(r,s);const c=true;const a=[s];const u=e.runWebGLProgram(i,[o],t.dtype,a,c);return{dataId:u.dataId,shape:n,dtype:u.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{shape:r}=s;const i=e;const c=g(o.shape);const a=C(r,c);const u=g(a);m(c===u,(()=>`The new shape (${a}) has ${u} elements and the old `+`shape (${o.shape}) has ${c} elements. The new shape and old `+`shape must have the same number of elements.`));const l=i.texData.get(o.dataId);if(l.isPacked&&!XM(o.shape,a)&&!(l.texture!==null&&XM(l.shape,a))){return ZP(o,a,i)}i.incRef(o.dataId);return{dataId:o.dataId,shape:a,dtype:o.dtype}}const tV={kernelName:ke,backendName:"webgl",kernelFunc:QP};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nV{constructor(t,n){this.variableNames=["x"];const{windowSize:e,batchSize:s,inSize:o,outSize:r}=t;this.outputShape=[s,r];const i=Math.floor(e/4)*4;const c=e%4;let a=`sumValue += dot(values, ones);`;if(n!=null){const t=1/n;a=`sumValue += dot(values * ${v(t)?t.toPrecision(2):t}, ones);`}let u="";if(o%e>0){u=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `}this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${a}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${c===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${a}\n        } else if (${c===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${a}\n        } else if (${c===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${a}\n        }\n        setOutput(sumValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eV{constructor(t,n){this.variableNames=["x"];const{windowSize:e,batchSize:s,inSize:o,outSize:r}=t;this.outputShape=[s,r];let i="0.0";let c=``;if(n==="prod"){i="1.0"}else if(n==="min"){i="1.0 / 1e-20";c=`min`}else if(n==="max"){i="-1.0 / 1e-20";c=`max`}let a=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="sum"){a=`sumValue`}else if(n==="prod"){a=`prodValue`}else if(n==="all"){a=`allValue`}else if(n==="any"){a=`anyValue`}const u=Math.floor(e/4)*4;const l=e%4;let f=`\n      if (${n==="sum"}) {\n        sumValue += dot(values, ones);\n      } else if (${n==="prod"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${c}(values, minMaxValue);\n        if (${n==="min"} || ${n==="max"}) {\n          minMaxValue = ${c}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;let h=`vec4`;if(n==="all"){i="1.0";f=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;h=`bvec4`}else if(n==="any"){i="0.0";f=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;h=`bvec4`}let d="";if(o%e>0){d=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `}this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${l===1}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${l===2}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${l===3}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${f}\n        }\n        setOutput(${a});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(t){const n=[];while(n.length===0||n[n.length-1].outSize!==1){const e=n.length?n[n.length-1].outSize:t[1];const s=rx(e);n.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return n}function oV(t,n,e,s){const o=sV(t.shape);let r=t;for(let i=0;i<o.length;i++){const{inSize:c,windowSize:a,outSize:u}=o[i];let l;let f;if(e==="mean"){l=i===0?new nV({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u},c):new nV({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u})}else{l=new eV({windowSize:a,inSize:c,batchSize:t.shape[0],outSize:u},e)}f=r;r=s.runWebGLProgram(l,[r],n);if(f.dataId!==t.dataId){s.disposeIntermediateTensorInfo(f)}}return r}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rV{constructor(t,n){this.variableNames=["A"];const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[n[s]]}this.outputShape=e;this.rank=e.length;const s=rL(this.rank);const o=iV(n);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}function iV(t){const n=t.length;if(n>6){throw Error(`Transpose for rank ${n} is not yet supported`)}const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"];const s=new Array(n);for(let n=0;n<t.length;n++){s[t[n]]=e[n]}return s.join()}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cV{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[n[s]]}this.outputShape=e;this.rank=e.length;if(this.rank>6){throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`)}const s=rL(this.rank);const o=Bz("rc",this.rank);const r=new Array(this.rank);for(let t=0;t<n.length;t++){r[n[t]]=o[t]}const i=`vec2(${r.slice(-2).join()})`;const c=`++${o[this.rank-1]} < ${e[this.rank-1]}`;const a=`getChannel(getA(${r.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${a};\n      if(${c}) {\n        result[1] = ${a};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${e[this.rank-2]}) {\n        result[2] = ${a};\n        if(${c}) {\n          result[3] = ${a};\n        }\n      }\n      setOutput(result);\n    }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(t,n,e){const s=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cV(t.shape,n):new rV(t.shape,n);return e.runWebGLProgram(s,[t],t.dtype)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(t,n,e,s){const o=n;const r=t.shape.length;const i=N(o,t.shape);let c=i;const a=_u(c,r);const u=a!=null;let l=t;if(u){l=aV(t,a,s);c=Du(c.length,r)}Fu("sum",c,r);const[f,h]=Au(l.shape,c);let d=f;if(e){d=Ou(f,i)}const p=g(h);const m=g(t.shape);const x=m/p;const b=QP({inputs:{x:l},attrs:{shape:[x,p]},backend:s});const w=ur(t.dtype);const v=oV(b,w,"sum",s);const $=QP({inputs:{x:v},attrs:{shape:d},backend:s});s.disposeIntermediateTensorInfo(b);s.disposeIntermediateTensorInfo(v);if(u){s.disposeIntermediateTensorInfo(l)}return $}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;return uV(o,r,i,e)}const fV={kernelName:Ue,backendName:"webgl",kernelFunc:lV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{perm:r}=s;const i=e;const c=o.shape.length;const a=new Array(c);for(let t=0;t<a.length;t++){a[t]=o.shape[r[t]]}let u;if(i.shouldExecuteOnCPU([o])){const t=i.texData.get(o.dataId);const n=t.values;const e=Pz(n,o.shape,o.dtype,r,a);u=i.makeTensorInfo(a,o.dtype);const s=i.texData.get(u.dataId);s.values=e}else{u=aV(o,r,i)}return u}const dV={kernelName:hs,backendName:"webgl",kernelFunc:hV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pV=1e3;function mV({a:t,b:n,transposeA:e,transposeB:s,backend:o,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:a=null}){const u=t.shape.length;const l=n.shape.length;const f=e?t.shape[u-2]:t.shape[u-1];const h=s?n.shape[l-1]:n.shape[l-2];const d=e?t.shape[u-1]:t.shape[u-2];const p=s?n.shape[l-2]:n.shape[l-1];const x=t.shape.slice(0,-2);const b=n.shape.slice(0,-2);const w=g(x);const v=g(b);const $=hu(t.shape.slice(0,-2),n.shape.slice(0,-2));const y=$.concat([d,p]);m(f===h,(()=>`Error in matMul: inner shapes (${f}) and (`+`${h}) of Tensors with shapes ${t.shape} and `+`${n.shape} and transposeA=${e}`+` and transposeB=${s} must match.`));const k=e?[w,f,d]:[w,d,f];const C=s?[v,p,h]:[v,h,p];const N=QP({inputs:{x:t},backend:o,attrs:{shape:k}});const R=QP({inputs:{x:n},backend:o,attrs:{shape:C}});const S=[N,R];const E=Math.max(w,v);const T=e?N.shape[1]:N.shape[2];const I=r!=null;const A=i!=null;const O=a==="leakyrelu";const F=a!=null?HP(a,true):null;const _=I||A||O||F!=null;let M;if((d===1||p===1)&&T>pV&&_===false){let t=N;let n=R;if(e){t=hV({inputs:{x:N},backend:o,attrs:{perm:[0,2,1]}});S.push(t)}if(s){n=hV({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}});S.push(n)}const r=p!==1;const i=p===1;let c=t;if(r){c=QP({inputs:{x:t},backend:o,attrs:{shape:[E,T,1]}});S.push(c)}const a=p===1?2:1;let u=n;if(i){u=QP({inputs:{x:n},backend:o,attrs:{shape:[E,1,T]}});S.push(u)}const l=JP({inputs:{a:c,b:u},backend:o});M=lV({inputs:{x:l},backend:o,attrs:{axis:a,keepDims:true}});S.push(l)}else{const a=ar(t.dtype,n.dtype);const u=new jP(k,C,[E,d,p],e,s,I,F,A,O);const l=[N,R];if(r!=null){l.push(r)}if(A){l.push(i)}if(O){const t=o.makeTensorInfo([],"float32",Ro(c,"float32"));l.push(t);S.push(t)}M=o.runWebGLProgram(u,l,a)}const D=QP({inputs:{x:M},backend:o,attrs:{shape:y}});S.push(M);for(const t of S){o.disposeIntermediateTensorInfo(t)}return D}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r,bias:i,preluActivationWeights:c}=n;const{transposeA:a,transposeB:u,activation:l,leakyreluAlpha:f}=s;return mV({a:o,b:r,transposeA:a,transposeB:u,backend:e,bias:i,preluActivationWeights:c,leakyreluAlpha:f,activation:l})}const bV={kernelName:vs,backendName:"webgl",kernelFunc:xV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gV=`return abs(x);`;function wV(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const t=e.texData.get(s.dataId);const n=Nz(t.values);return e.makeTensorInfo(s.shape,s.dtype,n)}let o;if(et().getBool("WEBGL_PACK_UNARY_OPERATIONS")){o=new pP(s.shape,gV)}else{o=new tP(s.shape,gV)}return e.runWebGLProgram(o,[s],s.dtype)}const vV={kernelName:ut,backendName:"webgl",kernelFunc:wV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $V=nP+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`;const yV=GP({opSnippet:$V});const kV={kernelName:lt,backendName:"webgl",kernelFunc:yV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CV=nP+`\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`;const NV=GP({opSnippet:CV});const RV={kernelName:ft,backendName:"webgl",kernelFunc:NV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SV="return a + b;";const EV=UP({opSnippet:SV,packedOpSnippet:SV,supportsComplex:true,cpuKernelImpl:jL});const TV={kernelName:ht,backendName:"webgl",kernelFunc:EV};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IV{constructor(t,n){this.outputShape=[];this.outputShape=t;this.variableNames=n.map(((t,n)=>`T${n}`));const e=[];this.variableNames.forEach((t=>{e.push(`float v${t} = get${t}AtOutCoords();`)}));const s=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${e.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AV{constructor(t,n){this.outputShape=[];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.variableNames=n.map(((t,n)=>`T${n}`));const e=[];this.variableNames.forEach((t=>{e.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const s=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${e.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(t){const{inputs:n,backend:e}=t;const s=n;if(s.length===1){return IP({inputs:{x:s[0]},backend:e})}if(s.length>et().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2);const n=OV({inputs:s.slice(0,t),backend:e});const o=OV({inputs:s.slice(t),backend:e});return OV({inputs:[n,o],backend:e})}const o=s.map((t=>t.dtype)).reduce(((t,n)=>ar(t,n)));const r=s.map((t=>t.shape));const i=et().getBool("WEBGL_PACK");const c=i?new AV(s[0].shape,r):new IV(s[0].shape,r);return e.runWebGLProgram(c,s,o)}const FV={kernelName:dt,backendName:"webgl",kernelFunc:OV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _V(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=N(r,o.shape);let u=a;const l=_u(u,c);let f=o;if(l!=null){f=hV({inputs:{x:o},backend:e,attrs:{perm:l}});u=Du(u.length,c)}Fu("all",u,c);const[h,d]=Au(f.shape,u);const p=g(d);const m=QP({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=oV(m,m.dtype,"all",e);let b;if(i){const t=Ou(h,a);b=QP({inputs:{x},backend:e,attrs:{shape:t}})}else{b=QP({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const MV={kernelName:pt,backendName:"webgl",kernelFunc:_V};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=N(r,o.shape);let u=a;const l=_u(u,c);let f=o;if(l!=null){f=hV({inputs:{x:o},backend:e,attrs:{perm:l}});u=Du(u.length,c)}Fu("any",u,c);const[h,d]=Au(f.shape,u);const p=g(d);const m=QP({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=oV(m,m.dtype,"any",e);let b;if(i){const t=Ou(h,a);b=QP({inputs:{x},backend:e,attrs:{shape:t}})}else{b=QP({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const LV={kernelName:mt,backendName:"webgl",kernelFunc:DV};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zV{constructor(t,n,e){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:r}=t;if(!e){this.variableNames.push("bestIndicesA")}this.outputShape=[o,r];const i=n==="max"?">":"<";const c=e?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${c};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PV{constructor(t,n,e,s){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;m(t.length>2,(()=>`Packed arg${e.charAt(0).toUpperCase()+e.slice(1)} supports only inputs with rank above 2.`));const o=t[t.length-1];const r=Math.ceil(o/n);this.outputShape=t.slice(0,-1);if(r>1){this.outputShape.push(r)}if(!s){this.variableNames.push("bestIndicesA")}const i=this.outputShape;const c=i.length;const a=rL(c);const u=Wz("coords",c);let l;let f;if(r===1){f=c+1;const t=rL(f);l=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[c-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[c-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[c-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[c-2]};`}else{f=c;l=`\n        ${a} sourceLocR = coords;\n        ++${u[c-1]};\n        ${a} sourceLocG = coords;\n        ++${u[c-2]};\n        ${a} sourceLocA = coords;\n        --${u[c-1]};\n        ${a} sourceLocB = coords;\n        --${u[c-2]};`}const h=["x","y","z","w","u","v"].slice(0,f);const d="."+h[f-1];const p=h.map((t=>"int "+t));const x=Wz("sourceLocR",f-1).concat("inIdx.r");const b=Wz("sourceLocG",f-1).concat("inIdx.g");const g=Wz("sourceLocB",f-1).concat("inIdx.b");const w=Wz("sourceLocA",f-1).concat("inIdx.a");const v=e==="max"?"greaterThan":"lessThan";const $=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${w.join()})));`;const y=`vec4(\n            getAChannel(${x.join()}),\n            hasNextCol ? getAChannel(${b.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`;const k=s?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${a} coords = getOutputCoords();\n        bool hasNextCol = ${u[c-1]} < ${i[c-1]-1};\n        bool hasNextRow = ${u[c-2]} < ${i[c-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${n};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${y};\n\n        for (int i = 0; i < ${n}; i++) {\n          inIdx = srcIdx;\n          ${$}\n          vec4 candidate = ${y};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(t,n,e,s=null){let o=n.shape[0];let r=n.shape[1];if(s!=null){o=s.shape[0];r=s.shape[1]}const i=rx(r);const c={windowSize:i,inSize:r,batchSize:o,outSize:Math.ceil(r/i)};const a=new zV(c,e,s==null);const u=[n];if(s!=null){u.push(s)}const l=t.runWebGLProgram(a,u,"int32");if(l.shape[1]===1){return l}const f=VV(t,n,e,l);t.disposeIntermediateTensorInfo(l);return f}function BV(t,n,e,s=null){const o=s!=null?s.shape:n.shape;const r=o[o.length-1];const i=rx(r);const c=new PV(o,i,e,s==null);const a=s==null?[n]:[n,s];const u=t.runWebGLProgram(c,a,"int32");if(u.shape.length===n.shape.length){const s=BV(t,n,e,u);t.disposeIntermediateTensorInfo(u);return s}return u}function WV(t,n,e,s){const o=[e];Fu("arg"+s.charAt(0).toUpperCase()+s.slice(1),o,n.shape.length);if(!et().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const e=[];const r=t.texData.get(n.dataId);const i=r!==null&&r.isPacked;let c=n;if(i){c=t.unpackTensor(n);e.push(c)}const[a,u]=Au(c.shape,o);const l=g(u);const f=QP({inputs:{x:c},backend:t,attrs:{shape:[-1,l]}});e.push(f);const h=VV(t,f,s);e.push(h);const d=QP({inputs:{x:h},backend:t,attrs:{shape:a}});e.forEach((n=>t.disposeIntermediateTensorInfo(n)));return d}return BV(t,n,s)}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GV(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;let i=N(r,o.shape);const c=_u(i,o.shape.length);let a=o;const u=[];if(c!=null){a=hV({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=Du(i.length,a.shape.length)}Fu("argMax",[i[0]],a.shape.length);const l=WV(e,a,i[0],"max");u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const UV={kernelName:xt,backendName:"webgl",kernelFunc:GV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r}=s;let i=N(r,o.shape);const c=_u(i,o.shape.length);let a=o;const u=[];if(c!=null){a=hV({inputs:{x:o},backend:e,attrs:{perm:c}});u.push(a);i=Du(i.length,a.shape.length)}Fu("argMin",[i[0]],a.shape.length);const l=WV(e,a,i[0],"min");u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const jV={kernelName:bt,backendName:"webgl",kernelFunc:HV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qV=nP+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`;const XV=GP({opSnippet:qV});const KV={kernelName:gt,backendName:"webgl",kernelFunc:XV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JV=nP+`return log(x + sqrt(x * x + 1.0));`;const YV=GP({opSnippet:JV});const ZV={kernelName:wt,backendName:"webgl",kernelFunc:YV};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QV=nP+`\n  return atan(x);\n`;const tB=GP({opSnippet:QV});const nB={kernelName:vt,backendName:"webgl",kernelFunc:tB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eB=RP+`\n  return atan(a, b);\n`;const sB=`\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+EP+`\n  return result;\n`;const oB=UP({opSnippet:eB,packedOpSnippet:sB});const rB={kernelName:yt,backendName:"webgl",kernelFunc:oB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iB=nP+`\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`;const cB=GP({opSnippet:iB});const aB={kernelName:$t,backendName:"webgl",kernelFunc:cB};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uB{constructor(t,n,e,s=false,o=false){this.variableNames=["x"];if(n==="avg"&&e){throw new Error("Cannot compute positions for average pool.")}const r=t.filterWidth;const i=t.strideHeight;const c=t.strideWidth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.effectiveFilterHeight;const f=t.effectiveFilterWidth;const h=t.padInfo.top;const d=t.padInfo.left;this.outputShape=t.outShape;const p=n==="avg";const m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`;const x=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let b="0.0";if(!p){b="-1.0 / 1e-20"}if(e){const n=">=";this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${c});\n        const ivec2 pads = ivec2(${h}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${n} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?m:x:`wR * ${f} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}const g="max";let w=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="avg"){w=`avgValue / max(count, 1.0)`}const v=Math.floor(r/4)*4;const $=r%4;const y=`\n      if (${p}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${g}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${c});\n      const ivec2 pads = ivec2(${h}, ${d});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${a}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${y}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${$===1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${y}\n          } else if (${$===2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${y}\n          } else if (${$===3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${y}\n          }\n        }\n        setOutput(${w});\n      }\n    `}}class lB{constructor(t,n,e,s=false,o=false){this.variableNames=["x"];if(n==="avg"&&e){throw new Error("Cannot compute positions for average pool.")}const r=t.filterWidth;const i=t.strideDepth;const c=t.strideHeight;const a=t.strideWidth;const u=t.dilationDepth;const l=t.dilationHeight;const f=t.dilationWidth;const h=t.effectiveFilterDepth;const d=t.effectiveFilterHeight;const p=t.effectiveFilterWidth;const m=t.padInfo.front;const x=t.padInfo.top;const b=t.padInfo.left;this.outputShape=t.outShape;const g=n==="avg";let w="0.0";if(!g){w="-1.0 / 1e-20"}if(e){const n=">=";this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${c}, ${a});\n        const ivec3 pads = ivec3(${m}, ${x}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${p};\n                  wC += ${f}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${n} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${p} +\n                      wR * ${p} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}const v="max";let $=`${n}(${n}(${n}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(n==="avg"){$=`avgValue / max(count, 1.0)`}const y=Math.floor(r/4)*4;const k=r%4;const C=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${v}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${c}, ${a});\n      const ivec3 pads = ivec3(${m}, ${x}, ${b});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${y}; wC += 4) {\n              int xC = xCCorner + wC * ${f};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${f}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${y};\n            if (${k===1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${k===2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${k===3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n        }\n        setOutput(${$});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;cD(o,"avgPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;m(Vc(i,u),(()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=Rc(o.shape,r,i,u,c,a);if(l.filterWidth===1&&l.filterHeight===1&&w(l.inShape,l.outShape)){return IP({inputs:{x:o},backend:e})}const f=new uB(l,"avg",false);return e.runWebGLProgram(f,[o],"float32")}const hB={kernelName:kt,backendName:"webgl",kernelFunc:fB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dimRoundingMode:a,dataFormat:u}=s;const l=[1,1,1];const f=Sc(o.shape,r,i,l,c,a,u);const h=new lB(f,"avg",false);return e.runWebGLProgram(h,[o],"float32")}const pB={kernelName:Nt,backendName:"webgl",kernelFunc:dB};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mB{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=t.dilationHeight;const i=t.dilationWidth;const c=t.effectiveFilterHeight;const a=t.effectiveFilterWidth;const u=c-1-t.padInfo.top;const l=a-1-t.padInfo.left;const f=1/(n*e);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${l});\n      const float avgMultiplier = float(${f});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c};\n            wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xB{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;const n=t.filterDepth;const e=t.filterHeight;const s=t.filterWidth;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=t.dilationDepth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.effectiveFilterDepth;const f=t.effectiveFilterHeight;const h=t.effectiveFilterWidth;const d=l-1-t.padInfo.front;const p=f-1-t.padInfo.top;const m=h-1-t.padInfo.left;const x=1/(n*e*s);this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${p}, ${m});\n      const float avgMultiplier = float(${x});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n            wD += ${c}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${f};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;const{filterSize:c,strides:a,pad:u,dimRoundingMode:l}=s;const f=[1,1,1];const h=Sc(i.shape,c,a,f,u,l);const d=new xB(h);return e.runWebGLProgram(d,[o],i.dtype)}const gB={kernelName:Rt,backendName:"webgl",kernelFunc:bB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;cD([o,r],"avgPoolGrad");const{filterSize:c,strides:a,pad:u}=s;const l=Rc(i.shape,c,a,1,u);const f=new mB(l);return e.runWebGLProgram(f,[o],i.dtype)}const vB={kernelName:Ct,backendName:"webgl",kernelFunc:wB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(t){const{inputs:n,backend:e,attrs:s}=t;const{a:o,b:r}=n;const{transposeA:i,transposeB:c}=s;return mV({a:o,b:r,transposeA:i,transposeB:c,backend:e})}const yB={kernelName:St,backendName:"webgl",kernelFunc:$B};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kB{constructor(t,n,e,s,o,r){this.outputShape=[];this.variableNames=["x","mean","variance"];hu(t,n);hu(t,e);let i="0.0";if(s!=null){hu(t,s);this.variableNames.push("offset");i="getOffsetAtOutCoords()"}let c="1.0";if(o!=null){hu(t,o);this.variableNames.push("scale");c="getScaleAtOutCoords()"}this.outputShape=t;this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${c};\n        float inv = scale * inversesqrt(variance + float(${r}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CB{constructor(t,n,e,s,o,r){this.packedInputs=true;this.packedOutput=true;this.variableNames=["x","mean","variance"];hu(t,n);hu(t,e);let i="vec4(0.0)";if(s!=null){hu(t,s);this.variableNames.push("offset");i="getOffsetAtOutCoords()"}let c="vec4(1.0)";if(o!=null){hu(t,o);this.variableNames.push("scale");c="getScaleAtOutCoords()"}this.outputShape=t;this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${c};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${r}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NB=({inputs:t,backend:n,attrs:e})=>{const{x:s,mean:o,variance:r,offset:i,scale:c}=t;m(o.shape.length===r.shape.length,(()=>"Batch normalization gradient requires mean and variance to have "+"equal ranks."));m(i==null||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have "+"equal ranks."));m(c==null||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have "+"equal ranks."));let{varianceEpsilon:a}=e;if(a==null){a=.001}const u=[s,o,r];let l=null;if(i!=null){l=i.shape;u.push(i)}let f=null;if(c!=null){f=c.shape;u.push(c)}const h=et().getBool("WEBGL_PACK_NORMALIZATION")?new CB(s.shape,o.shape,r.shape,l,f,a):new kB(s.shape,o.shape,r.shape,l,f,a);const d=n.runWebGLProgram(h,u,u[0].dtype);return d};const RB={kernelName:$n,backendName:"webgl",kernelFunc:NB};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SB{constructor(t){this.variableNames=["source"];this.outputShape=t;this.rank=t.length;const n=rL(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=TB(this.rank);let s;const o=t.map(((t,n)=>`sourceLoc.${EB[n]} = start[${n}] + coords.${EB[n]};`));s=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${o.join("\n")}\n      `;this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${e}));\n      }\n    `}}const EB=["x","y","z","w","u","v"];function TB(t){if(t===1){return"sourceLoc"}else if(t<=6){return EB.slice(0,t).map((t=>"sourceLoc."+t)).join(",")}else{throw Error(`Slicing for rank ${t} is not yet supported`)}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IB{constructor(t){this.variableNames=["source"];this.packedInputs=true;this.packedOutput=true;this.outputShape=t;this.rank=t.length;this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=rL(this.rank);const e=Wz("coords",this.rank);const s=Wz("sourceLoc",this.rank);const o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`;const r=`getChannel(getSource(${s.join()}), ${o})`;const i=`\n      result.x = ${r};\n      if (++${e[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${r};\n        --${s[this.rank-1]};\n      }\n    `;const c=this.rank===1?"":`\n      --${e[this.rank-1]};\n      if (++${e[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${r};\n        if (++${e[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${r};\n        }\n      }\n    `;const a=this.rank<=4?`sourceLoc = coords +\n            ${n}(${t.map(((t,n)=>`start[${n}]`)).join()});`:t.map(((t,n)=>`${s[n]} = ${e[n]} + start[${n}];`)).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${a}\n        vec4 result = vec4(0.);\n        ${i}\n        ${c}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(t,n,e,s){const o=s.texData.get(t.dataId);const r=s.makeTensorInfo(e,t.dtype);const i=s.texData.get(r.dataId);Object.assign(i,o);i.refCount=1;i.shape=e;i.dtype=t.dtype;let c=Bm(n,V(t.shape));if(o.slice){c+=o.slice.flatOffset}i.slice={flatOffset:c,origDataId:o.slice&&o.slice.origDataId||t.dataId};const a=s.dataRefCount.get(i.slice.origDataId)||1;s.dataRefCount.set(i.slice.origDataId,a+1);return r}function OB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,size:i}=s;const[c,a]=Wm(o,r,i);Em(o,c,a);if(g(a)===0){return e.makeTensorInfo(a,o.dtype,[])}if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){const t=e.texData.get(o.dataId);const n=Rz(t.values,c,a,o.shape,o.dtype);return e.makeTensorInfo(a,o.dtype,n)}const{isPacked:u}=e.texData.get(o.dataId);const l=Vm(o.shape,c,a);if(u||!l){const t=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IB(a):new SB(a);const n=[c];return e.runWebGLProgram(t,[o],o.dtype,n)}e.uploadToGPU(o.dataId);return AB(o,c,a,e)}const FB={kernelName:Le,backendName:"webgl",kernelFunc:OB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _B=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,crops:i}=s;m(o.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not "+"implemented yet"));const c=r.reduce(((t,n)=>t*n));const a=cx(o.shape,r,c);const u=ax(a.length,r.length);const l=ux(o.shape,r,c);const f=lx(i,r.length);const h=fx(l,i,r.length);const d=[];const p=QP({inputs:{x:o},backend:e,attrs:{shape:a}});const x=hV({inputs:{x:p},backend:e,attrs:{perm:u}});const b=QP({inputs:{x},backend:e,attrs:{shape:l}});const g=OB({inputs:{x:b},backend:e,attrs:{begin:f,size:h}});d.push(p);d.push(x);d.push(b);d.forEach((t=>e.disposeIntermediateTensorInfo(t)));return g};const MB={kernelName:Et,backendName:"webgl",kernelFunc:_B};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i}=s;const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const u=qL(c,a,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,u)}const LB={kernelName:Tt,backendName:"webgl",kernelFunc:DB};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zB=`\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n`;const PB=`\n  return float(int(a.r) & int(b.r));\n`;function VB(t){const{inputs:n,backend:e}=t;const{a:s,b:o}=n;const r=et().getBool("WEBGL_PACK_BINARY_OPERATIONS");const i=et().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,o])||i===1){const t=e.texData.get(s.dataId).values;const n=e.texData.get(o.dataId).values;const[r,i]=KL(s.shape,o.shape,t,n,s.dtype);const c=e.makeTensorInfo(i,s.dtype);const a=e.texData.get(c.dataId);a.values=r;return c}let c;if(r){c=new TP(zB,s.shape,o.shape,false)}else{c=new SP(PB,s.shape,o.shape)}return e.runWebGLProgram(c,[s,o],s.dtype)}const BB={kernelName:It,backendName:"webgl",kernelFunc:VB};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(t){const{inputs:n,backend:e}=t;const{s0:s,s1:o}=n;const r=e.readSync(s.dataId);const i=e.readSync(o.dataId);const c=hu(Array.from(r),Array.from(i));return e.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const GB={kernelName:Ot,backendName:"webgl",kernelFunc:WB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UB=`return float(a != b);`;const HB=UP({opSnippet:UB,cpuKernelImpl:xz,dtype:"bool"});const jB={kernelName:re,backendName:"webgl",kernelFunc:HB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.texData.get(s.dataId);return IP({inputs:{x:o.complexTensorInfos.real},backend:e})}const XB={kernelName:ve,backendName:"webgl",kernelFunc:qB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KB=`return float(int(x));`;function JB(t,n){const e=new tP(t.shape,KB);const s=n.runWebGLProgram(e,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dtype:r}=s;if(r==="complex64"){if(o.dtype==="complex64"){return IP({inputs:{x:o},backend:e})}const t=xf(o.shape);const n=YB({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});const s=OP({inputs:{real:n,imag:t},backend:e});t.dispose();e.disposeIntermediateTensorInfo(n);return s}if(o.dtype==="complex64"){const t=qB({inputs:{input:o},backend:e});const n=YB({inputs:{x:t},backend:e,attrs:{dtype:r}});e.disposeIntermediateTensorInfo(t);return n}if(!A(o.dtype,r)){const t=IP({inputs:{x:o},backend:e});return{dataId:t.dataId,shape:t.shape,dtype:r}}if(e.shouldExecuteOnCPU([o])){const t=e.texData.get(o.dataId).values;const[n,s,i]=JL(t,o.shape,o.dtype,r);return e.makeTensorInfo(n,s,i)}if(r==="int32"){return JB(o,e)}if(r==="bool"){const t=e.makeTensorInfo([],"bool",S("bool",1));const n={a:o,b:t};const s=HB({inputs:n,backend:e});e.disposeIntermediateTensorInfo(t);return s}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${r}`)}const ZB={kernelName:Ft,backendName:"webgl",kernelFunc:YB};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QB=`return ceil(x);`;const tW=GP({opSnippet:QB,packedOpSnippet:QB,cpuKernelImpl:YL});const nW={kernelName:_t,backendName:"webgl",kernelFunc:tW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eW{constructor(t){this.variableNames=["A"];this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t;this.userCode=`\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sW{constructor(t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t;this.userCode=`\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{clipValueMin:r,clipValueMax:i}=s;let c;if(et().getBool("WEBGL_PACK_CLIP")){c=new sW(o.shape)}else{c=new eW(o.shape)}const a=[[r],[i]];return e.runWebGLProgram(c,[o],o.dtype,a)}const rW={kernelName:Mt,backendName:"webgl",kernelFunc:oW};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iW{constructor(t){this.variableNames=["real","imag"];this.outputShape=t;this.userCode=`\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cW(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}function aW(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=e.texData.get(s.dataId);const r=new iW(s.shape);const i=[cW(s,o.complexTensorInfos.real),cW(s,o.complexTensorInfos.imag)];return e.runWebGLProgram(r,i,i[0].dtype)}const uW={kernelName:Lt,backendName:"webgl",kernelFunc:aW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lW{constructor(t){this.outputShape=[];this.outputShape=Zm(t,1);this.variableNames=t.map(((t,n)=>`T${n}`));const n=new Array(t.length-1);n[0]=t[0][1];for(let e=1;e<n.length;e++){n[e]=n[e-1]+t[e][1]}const e=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<n.length;t++){const s=n[t-1];e.push(`else if (yC < ${n[t]}) `+`setOutput(getT${t}(yR, yC-${s}));`)}const s=n.length;const o=n[n.length-1];e.push(`else setOutput(getT${s}(yR, yC-${o}));`);this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${e.join("\n        ")}\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fW{constructor(t,n){this.packedInputs=true;this.packedOutput=true;this.outputShape=[];this.outputShape=Zm(t,n);const e=this.outputShape;const s=e.length;const o=rL(s);const r=Wz("coords",s);const i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map(((t,n)=>`T${n}`));const c=new Array(t.length-1);c[0]=t[0][n];for(let e=1;e<c.length;e++){c[e]=c[e-1]+t[e][n]}const a=i[n];const u=i.slice(-2);const l=i.join();let f=`if (${a} < ${c[0]}) {\n        return getChannel(\n            getT0(${l}), vec2(${u.join()}));\n        }`;for(let t=1;t<c.length;t++){const n=c[t-1];f+=`\n        if (${a} < ${c[t]}  && ${a} >= ${c[t-1]}) {\n          return getChannel(\n            getT${t}(${hW(i,a,n)}),\n            vec2(${hW(u,a,n)}));\n        }`}const h=c.length;const d=c[c.length-1];f+=`\n        return getChannel(\n          getT${h}(${hW(i,a,d)}),\n          vec2(${hW(u,a,d)}));`;this.userCode=`\n      float getValue(${i.map((t=>"int "+t))}) {\n        ${f}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${r}), 0., 0., 0.);\n\n        ${r[s-1]} = ${r[s-1]} + 1;\n        if (${r[s-1]} < ${e[s-1]}) {\n          result.g = getValue(${r});\n        }\n\n        ${r[s-2]} = ${r[s-2]} + 1;\n        if (${r[s-2]} < ${e[s-2]}) {\n          result.a = getValue(${r});\n        }\n\n        ${r[s-1]} = ${r[s-1]} - 1;\n        if (${r[s-2]} < ${e[s-2]} &&\n            ${r[s-1]} < ${e[s-1]}) {\n          result.b = getValue(${r});\n        }\n        setOutput(result);\n      }\n    `}}function hW(t,n,e){const s=t.indexOf(n);const o=t.map(((t,n)=>{if(n===s){return`${t} - ${e}`}else{return t}}));return o.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(t){const{inputs:n,backend:e}=t;const{input:s}=n;const o=e.texData.get(s.dataId);return IP({inputs:{x:o.complexTensorInfos.imag},backend:e})}const pW={kernelName:En,backendName:"webgl",kernelFunc:dW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(t,n,e){const s=t[0].dtype;if(s==="complex64"){const s=t.map((t=>qB({inputs:{input:t},backend:e})));const o=t.map((t=>dW({inputs:{input:t},backend:e})));const r=mW(s,n,e);const i=mW(o,n,e);const c=OP({inputs:{real:r,imag:i},backend:e});s.forEach((t=>e.disposeIntermediateTensorInfo(t)));o.forEach((t=>e.disposeIntermediateTensorInfo(t)));e.disposeIntermediateTensorInfo(r);e.disposeIntermediateTensorInfo(i);return c}let o=e.shouldExecuteOnCPU(t);if(s==="string"){o=true}if(o){const o=t.map((t=>{const s=g(t.shape.slice(n));const o=[-1,s];return QP({inputs:{x:t},backend:e,attrs:{shape:o}})}));const r=o.map((t=>({vals:e.readSync(t.dataId),shape:t.shape})));const i=Zm(o.map((t=>t.shape)),1);const c=o[0].shape[0]===1;const a=ZL(r,i,s,c);const u=Zm(t.map((t=>t.shape)),n);const l=e.makeTensorInfo(u,s,a);o.forEach((t=>e.disposeIntermediateTensorInfo(t)));return l}const r=t.filter((t=>g(t.shape)>0));const i=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const n=i?new tP(t[0].shape,cP):new pP(t[0].shape,cP);return e.runWebGLProgram(n,t,s)}const c=et().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>c){const t=[];for(let s=0;s<r.length;s+=c){const o=r.slice(s,s+c);t.push(mW(o,n,e))}const s=mW(t,n,e);for(const n of t){e.disposeIntermediateTensorInfo(n)}return s}if(i){const t=new fW(r.map((t=>t.shape)),n);return e.runWebGLProgram(t,r,s)}const{tensors2D:a,outShape:u}=xW(r,n,e);const l=new lW(a.map((t=>t.shape)));const f=e.runWebGLProgram(l,a,s);a.forEach((t=>e.disposeIntermediateTensorInfo(t)));const h=QP({inputs:{x:f},attrs:{shape:u},backend:e});e.disposeIntermediateTensorInfo(f);return h}function xW(t,n,e){const s=Zm(t.map((t=>t.shape)),n);const o=t.map((t=>QP({inputs:{x:t},attrs:{shape:[-1,g(t.shape.slice(n))]},backend:e})));return{tensors2D:o,outShape:s}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;const r=N(o,n[0].shape)[0];const i=n.map((t=>t.shape));Ym(i,r);const c=Zm(n.map((t=>t.shape)),r);if(g(c)===0){return e.makeTensorInfo(c,n[0].dtype,[])}const a=n.filter((t=>g(t.shape)>0));if(a.length===1){return IP({inputs:{x:a[0]},backend:e})}return mW(a,r,e)}const gW={kernelName:zt,backendName:"webgl",kernelFunc:bW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wW{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.outputShape=t.outShape;const r=t.padInfo.top;const i=t.padInfo.left;const c=t.strideHeight;const a=t.strideWidth;const u=t.dilationHeight;const l=t.dilationWidth;const f=t.filterHeight;const h=t.filterWidth;const d=Math.floor(t.inChannels/4)*4;const p=t.inChannels%4;const m=t.dataFormat==="channelsLast";const x=m?1:2;const b=m?2:3;const g=m?3:1;let w="",v="";if(e){if(s){w=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){w=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{w=`\n          float activation(float x) {\n            ${e}\n          }\n        `}v=`result = activation(result);`}const $=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${c}, ${a});\n      const ivec2 pads = ivec2(${r}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${g}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${x}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${f}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${l};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${p===1}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${p===2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${p===3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${v}\n        setOutput(result);\n      }\n    `}}class vW{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;const n=t.padInfo.front;const e=t.padInfo.top;const s=t.padInfo.left;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=t.dilationDepth;const a=t.dilationHeight;const u=t.dilationWidth;const l=t.filterDepth;const f=t.filterHeight;const h=t.filterWidth;const d=Math.floor(t.inChannels/4)*4;const p=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${r}, ${i});\n      const ivec3 pads = ivec3(${n}, ${e}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${l}; wF++) {\n          int xF = xFCorner + wF * ${c};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f}; wR++) {\n            int xR = xRCorner + wR * ${a};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${d}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${p===1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${d}) *\n                  getW(wF, wR, wC, ${d}, d2);\n              } else if (${p===2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${p===3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1),\n                  getX(batch, xF, xR, xC, ${d} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2),\n                  getW(wF, wR, wC, ${d} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $W{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=pL(this.outputShape.length);const r=t.padInfo.left;const i=t.strideWidth;const c=t.dilationWidth;const a=t.filterHeight;const u=t.filterWidth;const l=u;let f=`\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;for(let t=0;t<u;t++){f+=`\n           vec4 xTexelC${t*2};\n           int xTexelC${t*2}Ready;\n           vec4 xTexelC${t*2+1};\n           int xTexelC${t*2+1}Ready;\n           vec4 xC${t};`}f+=`\n     for (int r = 0; r < ${a}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let t=0;t<u;t++){f+=`\n           xTexelC${t*2} = vec4(0.0);\n           xTexelC${t*2}Ready = 0;\n           xTexelC${t*2+1} = vec4(0.0);\n           xTexelC${t*2+1}Ready = 0;\n           xC${t} = vec4(0.0);`}f+=`\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;for(let n=0;n<(l+1)/2;n++){const e=n*2;f+=`\n           xC = xCCorner + ${e*c};\n           `;if(i===1){if(e<u){if(r%2===1){f+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n               `;if(c===1&&e>0){f+=`\n                 xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                 `}else{f+=`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                   } else {\n                     xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                   }\n                   `}}else{f+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 xC${e} = xTexelC${e};\n                 `}if(e+1<u){const t=r%2===0?h(c):c;if(c%2===0&&r%2===1||c%2!==0&&r%2!==1){f+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                     xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${e+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${e+1}Ready = 1;\n                   }\n                   `;if(c>1){f+=`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                     } else {\n                      xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                     }\n                     `}else{f+=`\n                     xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                     `}}else{if(t===1){f+=`\n                     xC${e+1} = xTexelC${e};\n                     `}else{f+=`\n                     xCOffset = xC + ${t};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                       xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${e+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${e+1}Ready = 1;\n                     }\n\n                     xC${e+1} = xTexelC${e+1};\n                     `}}}}}else{if(e<u){if(r%2===1){f+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                   xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${e+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${e+1}Ready = 1;\n                 }\n\n                 xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n               `;if(e+1<u){f+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                 `}}else{f+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                   xTexelC${e} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${e}.zw = vec2(0.0);\n                   }\n                   xTexelC${e}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                   xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${e+1}.zw = vec2(0.);\n                   }\n                   xTexelC${e+1}Ready = 1;\n                 }\n\n                 xC${e} = vec4(\n                   xTexelC${e}.xy, xTexelC${e+1}.xy);\n               `;if(e+1<u){f+=`\n                   xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                 `}}}}if(e<u){f+=`\n             wTexel = getW(r, ${e}, d1, d2);\n             dotProd += xC${e}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${e}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `;if(e+1<u){f+=`\n               wTexel = getW(r, ${e+1}, d1, d2);\n               dotProd += xC${e+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${e+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `}}}f+=`\n     }\n   `;f+=`\n     }\n   `;f+=`\n     }\n   `;let d="",p="";if(e){if(s){d=`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${e}\n         }`}else if(o){d=`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${e}\n         }`}else{d=`vec4 activation(vec4 x) {\n           ${e}\n         }`}p=`result = activation(result);`}const m=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${f}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yW{constructor(t,n){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];this.outputShape=t;this.enableShapeUniforms=pL(this.outputShape.length);const{dataFormat:e}=n;const s=uD();const o=e==="channelsLast";const r=o?1:2;const i=o?2:3;const c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let a=``;for(let t=0;t<=1;t++){for(let n=0;n<=1;n++){a+=`\n          blockIndex = rc.z + ${n};\n          pos = rc.y + ${t};\n\n          ${c}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${r}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${t*2+n}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${t*2+n}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `}}this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${a}\n\n        ${s.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(t,n){const e=t.length;if(e>=3){return n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]}else if(!n&&e===1&&t[0]>1){return[t[0],1]}else{return null}}function CW({x:t,filter:n,convInfo:e,backend:s,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:i=0,activation:c=null}){const a=t.shape;const u=s.texData.get(t.dataId);const l=e.inChannels;const f=a[0]*a[1]*a[2];const h=e.outChannels;const d=e.dataFormat==="channelsLast";const p=false;const x=false;let b;const g=[];if(r!=null){const t=kW(r.shape,d);if(t!=null){r=QP({inputs:{x:r},backend:s,attrs:{shape:t}});g.push(r)}}if(o!=null){const t=kW(o.shape,d);if(t!=null){o=QP({inputs:{x:o},backend:s,attrs:{shape:t}});g.push(o)}}const v=(f===1||h===1)&&l>pV;const $=!v&&u.isPacked&&d&&u.texture!=null&&a[2]%2!==0&&w(u.shape.slice(-3),a.slice(-3));if($){const l=a[0]*a[1]*(a[2]+1);const f={dataId:t.dataId,shape:[1,l,e.inChannels],dtype:t.dtype};const h=u.shape;u.shape=u.shape.slice();u.shape[u.shape.length-2]++;m(XM(u.shape,f.shape),(()=>`packed reshape ${u.shape} to ${f.shape} isn't free`));const d=QP({inputs:{x:n},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});g.push(d);const w=mV({a:f,b:d,backend:s,transposeA:p,transposeB:x,bias:o,activation:c,preluActivationWeights:r,leakyreluAlpha:i});const v=s.texData.get(w.dataId);m(v.isPacked,(()=>"batchMatMul result is expected to be packed"));u.shape=h;v.shape=e.outShape;b=IP({inputs:{x:w},backend:s});b.shape=e.outShape;g.push(w)}else{const a=e.outHeight*e.outWidth;const u=QP({inputs:{x:t},backend:s,attrs:{shape:d?[e.batchSize,a,e.inChannels]:[e.batchSize,e.inChannels,a]}});const l=QP({inputs:{x:n},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});const f=mV({a:d?u:l,b:d?l:u,transposeA:!d,transposeB:x,backend:s,bias:o,activation:c,preluActivationWeights:r,leakyreluAlpha:i});b=QP({inputs:{x:f},backend:s,attrs:{shape:e.outShape}});g.push(u);g.push(l);g.push(f)}for(const t of g){s.disposeIntermediateTensorInfo(t)}return b}function NW({x:t,filter:n,convInfo:e,backend:s,bias:o=null,preluActivationWeights:r=null,leakyreluAlpha:i=0,activation:c=null}){const{filterWidth:a,filterHeight:u,inChannels:l,outWidth:f,outHeight:h,dataFormat:d}=e;const p=d==="channelsLast";const m=a*u*l;const x=h*f;const b=[e.batchSize,m,x];const w=true;const v=false;const $=[];if(r!=null){const t=kW(r.shape,p);if(t!=null){r=QP({inputs:{x:r},backend:s,attrs:{shape:t}});$.push(r)}}if(o!=null){const t=kW(o.shape,p);if(t!=null){o=QP({inputs:{x:o},backend:s,attrs:{shape:t}});$.push(o)}}const y=QP({inputs:{x:n},backend:s,attrs:{shape:[1,m,g(n.shape)/m]}});$.push(y);const k=new yW(b,e);const C=[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]];const N=s.runWebGLProgram(k,[t],"float32",C);const R=QP({inputs:{x:N},backend:s,attrs:{shape:b}});$.push(N);$.push(R);const S=o!=null;const E=r!=null;const T=c==="leakyrelu";const I=c?HP(c,true):null;const A=new jP(p?R.shape:y.shape,p?y.shape:R.shape,p?[e.batchSize,x,e.outChannels]:[e.batchSize,e.outChannels,x],w,v,S,I,E,T);const O=p?[R,y]:[y,R];if(o){O.push(o)}if(E){O.push(r)}if(T){const t=s.makeTensorInfo([],"float32",Ro(i,"float32"));O.push(t);$.push(t)}const F=s.runWebGLProgram(A,O,"float32");const _=QP({inputs:{x:F},backend:s,attrs:{shape:e.outShape}});$.push(F);for(const t of $){s.disposeIntermediateTensorInfo(t)}return _}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dataFormat:a,dilations:u,dimRoundingMode:l}=s;const f=Wc(a);const h=Ec(o.shape,r.shape,i,u,c,l,false,f);let d;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID")){d=CW({x:o,filter:r,convInfo:h,backend:e})}else if(h.strideWidth<=2&&f==="channelsLast"&&et().getBool("WEBGL_EXP_CONV")){const t=new $W(h);const n=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];d=e.runWebGLProgram(t,[o,r],"float32",n)}else if(et().getBool("WEBGL_CONV_IM2COL")){d=NW({x:o,filter:r,convInfo:h,backend:e})}else{const t=new wW(h);d=e.runWebGLProgram(t,[o,r],"float32")}const p=QP({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});e.disposeIntermediateTensorInfo(d);return p}const SW={kernelName:Pt,backendName:"webgl",kernelFunc:RW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EW{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.padInfo.top;const o=t.padInfo.left;const r=t.dataFormat==="channelsLast";this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${s};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${e} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${r?`float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class TW{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=t.dataFormat==="channelsLast";const i=n-1-t.padInfo.top;const c=e-1-t.padInfo.left;const a=r?1:2;const u=r?2:3;const l=r?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${l}];\n\n        ivec2 dyCorner = ivec2(coords[${a}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${e} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class IW{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideDepth;const e=t.strideHeight;const s=t.strideWidth;const o=t.padInfo.front;const r=t.padInfo.top;const i=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${n} - ${o};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${e} - ${r};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${s} - ${i};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class AW{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterDepth;const e=t.filterHeight;const s=t.filterWidth;const o=t.strideDepth;const r=t.strideHeight;const i=t.strideWidth;const c=n-1-t.padInfo.front;const a=e-1-t.padInfo.top;const u=s-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${a}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${n}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${n} - 1 - wF;\n\n          for (int wR = 0; wR < ${e}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${e} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,dataFormat:a,dimRoundingMode:u,filterShape:l}=s;const f=Wc(a);const h=Ec(o.shape,l,i,1,c,u,false,f);const d=new EW(h);return e.runWebGLProgram(d,[o,r],"float32")}const FW={kernelName:Vt,backendName:"webgl",kernelFunc:OW};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _W{constructor(t){this.variableNames=["dy","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"strides",type:"vec2"}];this.outputShape=t.inShape;this.enableShapeUniforms=pL(this.outputShape.length);const n=t.filterHeight;const e=t.filterWidth;const s=n-1-t.padInfo.top;const o=e-1-t.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            int wCPerm = ${e} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{inputShape:i,strides:c,pad:a,dataFormat:u,dimRoundingMode:l}=s;const f=Wc(u);const h=Ec(i,r.shape,c,1,a,l,false,f);if(et().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const t=[[h.strideHeight,h.strideWidth]];const n=new _W(h);return e.runWebGLProgram(n,[o,r],"float32",t)}else{const t=new TW(h);return e.runWebGLProgram(t,[o,r],"float32")}}const DW={kernelName:Bt,backendName:"webgl",kernelFunc:MW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;const u=Tc(o.shape,r.shape,i,a,c);const l=new vW(u);return e.runWebGLProgram(l,[o,r],"float32")}const zW={kernelName:Wt,backendName:"webgl",kernelFunc:LW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PW(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,pad:c,filterShape:a}=s;const u=Tc(o.shape,a,i,1,c);const l=new IW(u);return e.runWebGLProgram(l,[o,r],"float32")}const VW={kernelName:Gt,backendName:"webgl",kernelFunc:PW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BW(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{pad:i,strides:c,inputShape:a}=s;const u=Tc(a,r.shape,c,1,i);const l=new AW(u);return e.runWebGLProgram(l,[o,r],"float32")}const WW={kernelName:Ut,backendName:"webgl",kernelFunc:BW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=WP+`\n  return cos(x);\n`;const UW=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${EP}\n  return result;\n`;const HW=GP({opSnippet:GW,packedOpSnippet:UW});const jW={kernelName:Ht,backendName:"webgl",kernelFunc:HW};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qW=`\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;const XW=GP({opSnippet:qW});const KW={kernelName:jt,backendName:"webgl",kernelFunc:XW};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JW{constructor(t,n,e,s,o){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];const[r,i,c,a]=t;const[u]=n;const[l,f]=e;this.outputShape=[u,l,f,a];const h=s==="bilinear"?1:0;const[d,p]=[`${i-1}.0`,`${c-1}.0`];const[m,x,b]=l>1?[`${(i-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`];const[g,w,v]=f>1?[`${(c-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${p} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${p}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${g});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${r}) {\n          return;\n        }\n\n        float height_scale = ${x};\n        float width_scale = ${w};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YW=t=>{const{inputs:n,backend:e,attrs:s}=t;const{image:o,boxes:r,boxInd:i}=n;const{cropSize:c,method:a,extrapolationValue:u}=s;const l=new JW(o.shape,r.shape,c,a,u);return e.runWebGLProgram(l,[o,r,i],"float32")};const ZW={kernelName:Kt,backendName:"webgl",kernelFunc:YW};var QW;(function(t){t["Prod"]="*";t["Sum"]="+"})(QW||(QW={}));class tG{constructor(t,n,e,s){this.op=t;this.outputShape=n;this.variableNames=["x"];this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length;const r=this.op===QW.Prod?"1.0":"0.0";const i=e?r:`getX(${nG(o,"coords",this.op)})`;const c=this.outputShape[this.outputShape.length-1];let a="";let u="";if(e){a=s?`end != ${c-1}`:"end != 0";u=s?"end + 1":"end - 1"}else{a=s?`end + pow2 < ${c}`:"end >= pow2";u=s?"end + pow2":"end - pow2"}this.userCode=`\n      void main() {\n        ${rL(o)} coords = getOutputCoords();\n        int end = ${eG(o,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${u};\n          ${eG(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${nG(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function nG(t,n,e){if(t===1){return`${n}`}else if(t===2){return`${n}.x, ${n}.y`}else if(t===3){return`${n}.x, ${n}.y, ${n}.z`}else if(t===4){return`${n}.x, ${n}.y, ${n}.z, ${n}.w`}else{throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}}function eG(t,n,e){if(t===1){return`${n}`}else if(t===2){return`${n}.y`}else if(t===3){return`${n}.z`}else if(t===4){return`${n}.w`}else{throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sG(t,n,e,s,o,r){const i=n.shape.length;const c=_u([s],i);let a=n;if(c!=null){a=hV({inputs:{x:n},backend:e,attrs:{perm:c}})}const u=Du(1,i)[0];if(u!==i-1){throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} `+`but got axis=${s}`)}const l=a.shape[u];let f=IP({inputs:{x:a},backend:e});for(let n=0;n<=Math.ceil(Math.log2(l))-1;n++){const s=new tG(t,a.shape,false,r);const o=[[n]];const i=f;f=e.runWebGLProgram(s,[f],f.dtype,o);e.disposeIntermediateTensorInfo(i)}if(o){const n=new tG(t,a.shape,o,r);const s=f;f=e.runWebGLProgram(n,[f],f.dtype);e.disposeIntermediateTensorInfo(s)}if(c!=null){const t=Mu(c);const n=hV({inputs:{x:f},backend:e,attrs:{perm:t}});e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(a);return n}return f}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;return sG(QW.Prod,o,e,r,i,c)}const rG={kernelName:qt,backendName:"webgl",kernelFunc:oG};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,exclusive:i,reverse:c}=s;return sG(QW.Sum,o,e,r,i,c)}const cG={kernelName:Xt,backendName:"webgl",kernelFunc:iG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,weights:r}=n;const{size:i,binaryOutput:c}=s;if(o.shape.length===1){const t=e.readSync(o.dataId);const n=e.readSync(r.dataId);const s=qL(t,n,r.dtype,r.shape,i);return e.makeTensorInfo([i],r.dtype,s)}else if(o.shape.length===2){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=XL(t,n,i,c);return e.makeTensorInfo(s.shape,r.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank`+`${o.shape.length}.`)}const uG={kernelName:Jt,backendName:"webgl",kernelFunc:aG};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lG{constructor(t,n,e){this.variableNames=["x"];this.outputShape=[];this.outputShape=t;this.blockSize=n;this.dataFormat=e;this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${n};\n      int offset_h = imod(h, ${n});\n      int in_w = w / ${n};\n      int offset_w = imod(w, ${n});\n      int offset_d = (offset_h * ${n} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){if(this.dataFormat==="NHWC"){return`coords[1]`}else{return`coords[2]`}}getWidthCoordString(){if(this.dataFormat==="NHWC"){return`coords[2]`}else{return`coords[3]`}}getDepthCoordString(){if(this.dataFormat==="NHWC"){return`coords[3]`}else{return`coords[1]`}}getOutputDepthSize(){if(this.dataFormat==="NHWC"){return this.outputShape[3]}else{return this.outputShape[1]}}getInputSamplingString(){if(this.dataFormat==="NHWC"){return`getX(b, in_h, in_w, in_d)`}else{return`getX(b, in_d, in_h, in_w)`}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockSize:r,dataFormat:i}=s;const c=o.shape[0];const a=i==="NHWC"?o.shape[1]:o.shape[2];const u=i==="NHWC"?o.shape[2]:o.shape[3];const l=i==="NHWC"?o.shape[3]:o.shape[1];const f=a*r;const h=u*r;const d=l/(r*r);const p=i==="NHWC"?[c,f,h,d]:[c,d,f,h];const m=new lG(p,r,i);return e.runWebGLProgram(m,[o],o.dtype)}const hG={kernelName:Yt,backendName:"webgl",kernelFunc:fG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dG{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=pL(this.outputShape.length);const r=t.filterHeight;const i=t.filterWidth;const c=t.outChannels/t.inChannels;let a="",u="";if(e){if(s){a=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){a=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{a=`\n          float activation(float x) {\n            ${e}\n          }\n        `}u=`result = activation(result);`}const l=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${a}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${c};\n        int q = d2 - d1 * ${c};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${r}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${l}\n        ${u}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pG{constructor(t,n=false,e=null,s=false,o=false){this.variableNames=["x","W"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape;this.enableShapeUniforms=pL(this.outputShape.length);const r=t.outChannels/t.inChannels;const i=t.padInfo.left;const c=t.strideWidth;const a=t.dilationWidth;const u=t.filterHeight;const l=t.filterWidth;const f=l;let d=`\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;for(let t=0;t<l;t++){d+=`\n          vec4 xTexelC${t*2};\n          int xTexelC${t*2}Ready;\n          vec4 xTexelC${t*2+1};\n          int xTexelC${t*2+1}Ready;\n          vec4 xC${t};`}d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let t=0;t<l;t++){d+=`\n          xTexelC${t*2} = vec4(0.0);\n          xTexelC${t*2}Ready = 0;\n          xTexelC${t*2+1} = vec4(0.0);\n          xTexelC${t*2+1}Ready = 0;\n          xC${t} = vec4(0.0);`}d+=`\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;for(let t=0;t<(f+1)/2;t++){const n=t*2;d+=`\n          xC = xCCorner + ${n*a};\n          `;if(c===1){if(n<l){if(i%2===1){d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `;if(a===1&&n>0){d+=`\n                xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `}else{d+=`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `}}else{d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${n} = xTexelC${n};\n                `}if(n+1<l){const t=i%2===0?h(a):a;if(a%2===0&&i%2===1||a%2!==0&&i%2!==1){d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                    xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${n+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+1}Ready = 1;\n                  }\n                  `;if(a>1){d+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                    } else {\n                     xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                    }\n                    `}else{d+=`\n                    xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                    `}}else{if(t===1){d+=`\n                    xC${n+1} = xTexelC${n};\n                    `}else{d+=`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                      xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${n+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+1}Ready = 1;\n                    }\n\n                    xC${n+1} = xTexelC${n+1};\n                    `}}}}}else{if(n<l){if(i%2===1){d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n              `;if(n+1<l){d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                `}}else{d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+1}.xy);\n              `;if(n+1<l){d+=`\n                  xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                `}}}}if(n<l){d+=`\n            wTexel = getW(r, ${n}, d1, q);\n            dotProd += xC${n} * vec4(wTexel.xz, wTexel.xz);\n          `;if(n+1<l){d+=`\n              wTexel = getW(r, ${n+1}, d1, q);\n              dotProd += xC${n+1} * vec4(wTexel.xz, wTexel.xz);\n            `}}}d+=`\n    }\n  `;d+=`\n      }\n    `;let p="",m="";if(e){if(s){p=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`}else if(o){p=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`}else{p=`vec4 activation(vec4 x) {\n          ${e}\n        }`}m=`result = activation(result);`}const x=n?"result += getBiasAtOutCoords();":"";if(n){this.variableNames.push("bias")}if(s){this.variableNames.push("preluActivationWeights")}if(o){this.variableNames.push("leakyreluAlpha")}this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${r};\n        int q = d2 - d1 * ${r};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${x}\n        ${m}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a,dimRoundingMode:u}=s;let l=a;if(l==null){l=[1,1]}m(Vc(i,l),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${i} and dilations '${l}'`));const f=Ec(o.shape,r.shape,i,l,c,u,true);let h;if(et().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1){h=new pG(f)}else{h=new dG(f)}const d=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return e.runWebGLProgram(h,[o,r],"float32",d)}const xG={kernelName:Zt,backendName:"webgl",kernelFunc:mG};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bG{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.padInfo.top;const o=t.padInfo.left;const r=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${r} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${s};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${e} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gG{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;const n=t.filterHeight;const e=t.filterWidth;const s=t.strideHeight;const o=t.strideWidth;const r=n-1-t.padInfo.top;const i=e-1-t.padInfo.left;const c=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${e}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${e} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${c}; dm++) {\n              int d2 = d1 * ${c} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,dy:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,filterShape:l}=s;const f=Ec(o.shape,l,i,c,a,u,true);const h=new bG(f);return e.runWebGLProgram(h,[o,r],"float32")}const vG={kernelName:Qt,backendName:"webgl",kernelFunc:wG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $G(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,filter:r}=n;const{strides:i,dilations:c,pad:a,dimRoundingMode:u,inputShape:l}=s;const f=Ec(l,r.shape,i,c,a,u,true);const h=new gG(f);return e.runWebGLProgram(h,[o,r],"float32")}const yG={kernelName:tn,backendName:"webgl",kernelFunc:$G};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kG{constructor(t){this.variableNames=["X"];this.outputShape=[t,t];this.userCode=`\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CG(t){const{inputs:n,backend:e}=t;const{x:s}=n;const o=[...s.shape,...s.shape];const r=g(s.shape);const i=QP({inputs:{x:s},backend:e,attrs:{shape:[r]}});const c=new kG(r);const a=e.runWebGLProgram(c,[i],i.dtype);const u=QP({inputs:{x:a},backend:e,attrs:{shape:o}});e.disposeIntermediateTensorInfo(i);e.disposeIntermediateTensorInfo(a);return u}const NG={kernelName:nn,backendName:"webgl",kernelFunc:CG};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RG{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;const{inHeight:n,inWidth:e,padInfo:s,strideHeight:o,strideWidth:r,filterHeight:i,filterWidth:c,dilationHeight:a,dilationWidth:u}=t;const{top:l,left:f}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${r});\n      const ivec2 pads = ivec2(${l}, ${f});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${a};\n\n          if (hIn >= 0 && hIn < ${n}) {\n            for (int w = 0; w < ${c}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${e}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SG(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r}=n;const{strides:i,pad:c,dilations:a}=s;const u=Nc(o.shape,r.shape,i,c,"NHWC",a);let l;const f=new RG(u);l=e.runWebGLProgram(f,[o,r],"float32");const h=QP({inputs:{x:l},backend:e,attrs:{shape:u.outShape}});e.disposeIntermediateTensorInfo(l);return h}const EG={kernelName:en,backendName:"webgl",kernelFunc:SG};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(t){const{inputs:n,backend:e,attrs:s}=t;const{equation:o}=s;const r=n;const{allDims:i,summedDims:c,idDims:a}=Ox(o,r.length);_x(i.length,a,r);const{path:u,steps:l}=Mx(c,a);const f=l.length;let h=null;let d=i.length;const p=[];for(let t=0;t<f;++t){for(const n of l[t]){const{permutationIndices:t,expandDims:s}=Fx(d,a[n]);let o;if(Dx(t)){o=r[n]}else{o=hV({inputs:{x:r[n]},backend:e,attrs:{perm:t}});p.push(o)}const i=o.shape.slice();for(let t=0;t<s.length;++t){i.splice(s[t],0,1)}if(!w(o.shape,i)){o=QP({inputs:{x:o},backend:e,attrs:{shape:i}});p.push(o)}if(h===null){h=o}else{h=JP({inputs:{a:o,b:h},backend:e});p.push(h)}}if(t<f-1){if(u[t]>=0){h=lV({inputs:{x:h},backend:e,attrs:{axis:u[t]-(i.length-d),keepDims:false}});p.push(h)}d--}}for(const t of p){if(t===h){continue}e.disposeIntermediateTensorInfo(t)}return h}const IG={kernelName:an,backendName:"webgl",kernelFunc:TG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AG=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const OG=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const FG=GP({opSnippet:AG,packedOpSnippet:OG});const _G={kernelName:un,backendName:"webgl",kernelFunc:FG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MG=`return (b >= 0.0) ? a : a * (b + 1.0);`;const DG=`\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;const LG=t=>{const{inputs:n,backend:e}=t;const{dy:s,y:o}=n;const r=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new TP(DG,s.shape,o.shape):new SP(MG,s.shape,o.shape);return e.runWebGLProgram(r,[s,o],s.dtype)};const zG={kernelName:ln,backendName:"webgl",kernelFunc:LG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG=`\n  return vec4(equal(a, b));\n`;const VG=`return float(a == b);`;const BG=UP({opSnippet:VG,packedOpSnippet:PG,dtype:"bool",cpuKernelImpl:QL});const WG={kernelName:hn,backendName:"webgl",kernelFunc:BG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${px};\n  float a1 = ${mx};\n  float a2 = ${xx};\n  float a3 = ${bx};\n  float a4 = ${gx};\n  float a5 = ${wx};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`;const UG=GP({opSnippet:GG});const HG={kernelName:fn,backendName:"webgl",kernelFunc:UG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jG=WP+`\n  return exp(x);\n`;const qG=`\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const XG=GP({opSnippet:jG,packedOpSnippet:qG,cpuKernelImpl:tz,dtype:"float32"});const KG={kernelName:dn,backendName:"webgl",kernelFunc:XG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JG(t){const{inputs:n,attrs:e,backend:s}=t;const{dim:o}=e;const{input:r}=n;const i=r.shape.length;const c=r.shape.slice();let a=o;if(o<0){m(-(i+1)<=o,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`));a=i+o+1}c.splice(a,0,1);return QP({inputs:{x:r},backend:s,attrs:{shape:c}})}const YG={kernelName:pn,backendName:"webgl",kernelFunc:JG};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG=`return exp(x) - 1.0;`;const QG=GP({opSnippet:ZG,packedOpSnippet:ZG,cpuKernelImpl:nz});const tU={kernelName:mn,backendName:"webgl",kernelFunc:QG};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nU{constructor(t,n,e){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const o=e?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`;const r=e?`${s}.0`:"1.0";let i;if(t==="real"){i="return real * expR - imag * expI;"}else if(t==="imag"){i="return real * expI + imag * expR;"}else{throw new Error(`FFT component must be either "real" or "imag", got ${t}.`)}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${r};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(t,n,e){const s=e.texData.get(t.dataId);const o=g(t.shape);const r=t.shape[t.shape.length-1];const i=o/r;const c=QP({inputs:{x:t},backend:e,attrs:{shape:[i,r]}});const a=c.shape;const u=new nU("real",a,n);const l=new nU("imag",a,n);const f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:a},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:a}];const h=e.runWebGLProgram(u,f,"float32");const d=e.runWebGLProgram(l,f,"float32");const p=OP({inputs:{real:h,imag:d},backend:e});e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);const m=QP({inputs:{x:p},backend:e,attrs:{shape:t.shape}});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(p);return m}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(t){const{inputs:n,backend:e}=t;const{input:s}=n;return eU(s,false,e)}const oU={kernelName:xn,backendName:"webgl",kernelFunc:sU};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rU{constructor(t,n){this.outputShape=[];this.customUniforms=[{name:"value",type:"float"}];this.variableNames=["x"];this.outputShape=t;this.userCode=`\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(t){const{backend:n,attrs:e}=t;const{shape:s,value:o}=e;let{dtype:r}=e;r=r||L(o);if(r==="string"){const t=E(r,g(s));t.fill(o);return n.makeTensorInfo(s,r,t)}else{const t=new rU(s,o);const e=[[o]];return n.runWebGLProgram(t,[],r,e)}}const cU={kernelName:bn,backendName:"webgl",kernelFunc:iU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aU{constructor(t){this.variableNames=["Image"];this.outputShape=[];const n=t[2];this.outputShape=t;this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${n} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${n}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uU={kernelName:gn,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t;const s=n;const o=new aU(e.shape);const r=s.runWebGLProgram(o,[e],e.dtype);return r}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lU=`return floor(x);`;const fU=GP({opSnippet:lU,packedOpSnippet:lU,cpuKernelImpl:ez});const hU={kernelName:wn,backendName:"webgl",kernelFunc:fU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dU=`\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`;const pU=`\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`;const mU=UP({opSnippet:dU,packedOpSnippet:pU,dtype:"int32"});const xU={kernelName:vn,backendName:"webgl",kernelFunc:mU};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bU{constructor(t){this.variableNames=["A"];const n=uD();const[e,s]=t;this.outputShape=t;this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${e}.0);\n\n        vec4 values = ${n.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gU{constructor(t){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;const n=uD();const[e,s]=t;this.outputShape=t;this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${e}.0);\n            vec4 values = ${n.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${n.output} = result;\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wU={kernelName:gs,backendName:"webgl",kernelFunc:yU};let vU;let $U=et().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function yU(t){const{inputs:n,backend:e,attrs:s}=t;let{pixels:o}=n;const{numChannels:r}=s;const i=typeof HTMLVideoElement!=="undefined"&&o instanceof HTMLVideoElement;const c=typeof HTMLImageElement!=="undefined"&&o instanceof HTMLImageElement;const[a,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height];const l=[u,a];const f=[u,a,r];if(c||i){const t=et().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");if(vU==null||t!==$U){$U=t;vU=document.createElement("canvas").getContext("2d",{willReadFrequently:$U})}vU.canvas.width=a;vU.canvas.height=u;vU.drawImage(o,0,0,a,u);o=vU.canvas}const h=e.makeTensorInfo(l,"int32");e.texData.get(h.dataId).usage=rM.PIXELS;e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),o);const d=et().getBool("WEBGL_PACK")?new gU(f):new bU(f);const p=e.runWebGLProgram(d,[h],"int32");e.disposeData(h.dataId);return p}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dataFormat:l,dilations:f,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s;const m=Wc(l);const x=Ec(o.shape,r.shape,a,f,u,h,false,m);let b;const g=[];const w=i!=null;const v=c!=null;const $=d==="leakyrelu";const y=()=>{const t=[o,r];const n=(t,n)=>{if(n==="NCHW"&&t.shape.length===1&&t.shape[0]!==1){const n=QP({inputs:{x:t},backend:e,attrs:{shape:[t.shape[0],1,1]}});g.push(n);return n}return t};if(w){t.push(n(i,l))}if(v){t.push(n(c,l))}if($){const n=e.makeTensorInfo([],"float32",Ro(p,"float32"));t.push(n);g.push(n)}return t};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID")){b=CW({x:o,filter:r,convInfo:x,backend:e,bias:i,activation:d,preluActivationWeights:c,leakyreluAlpha:p})}else if(x.strideWidth<=2&&m==="channelsLast"&&et().getBool("WEBGL_EXP_CONV")){const t=d?HP(d,true):null;const n=new $W(x,w,t,v,$);const s=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]];const o=y();b=e.runWebGLProgram(n,o,"float32",s)}else if(et().getBool("WEBGL_CONV_IM2COL")){b=NW({x:o,filter:r,convInfo:x,backend:e,bias:i,activation:d,preluActivationWeights:c,leakyreluAlpha:p})}else{const t=d?HP(d,false):null;const n=new wW(x,w,t,v,$);const s=y();b=e.runWebGLProgram(n,s,"float32")}const k=QP({inputs:{x:b},backend:e,attrs:{shape:x.outShape}});g.push(b);g.forEach((t=>e.disposeIntermediateTensorInfo(t)));return k}const CU={kernelName:$s,backendName:"webgl",kernelFunc:kU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,filter:r,bias:i,preluActivationWeights:c}=n;const{strides:a,pad:u,dilations:l,dimRoundingMode:f,activation:h,leakyreluAlpha:d}=s;const p=[];let x=l;if(x==null){x=[1,1]}m(Vc(a,x),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${a} and dilations '${x}'`));const b=Ec(o.shape,r.shape,a,x,u,f,true);const g=et().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1;const w=h?HP(h,g):null;const v=[o,r];const $=i!=null;const y=c!=null;const k=h==="leakyrelu";if($){v.push(i)}if(y){v.push(c)}if(k){const t=e.makeTensorInfo([],"float32",Ro(d,"float32"));v.push(t);p.push(t)}let C;if(g){C=new pG(b,$,w,y,k)}else{C=new dG(b,$,w,y,k)}const N=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]];const R=e.runWebGLProgram(C,v,"float32",N);p.forEach((t=>e.disposeIntermediateTensorInfo(t)));return R}const RU={kernelName:ys,backendName:"webgl",kernelFunc:NU};class SU{constructor(t,n,e,s){this.sliceDim=t;this.strides=n;this.paramsShape=s;this.variableNames=["x","indices"];this.outputShape=e;const o=rL(e.length);let r=`\n    int index;`;for(let t=0;t<this.sliceDim;t++){r+=`\n          index = round(getIndices(coords[0], ${t}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[t]};\n          flattenIndex += index * ${this.strides[t]};`}this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${r}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(t){const{inputs:n,backend:e}=t;const{params:s,indices:o}=n;const r=o.shape;const i=r[r.length-1];const c=g(s.shape);const[a,u,l,f]=Nm(s,o);const h=QP({inputs:{x:o},backend:e,attrs:{shape:[u,i]}});const d=QP({inputs:{x:s},backend:e,attrs:{shape:[g(s.shape)/l,l]}});if(e.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const t=e.readSync(o.dataId);const n=e.bufferSync(s);const r=sz(t,n,s.dtype,u,i,l,f,s.shape,c);return e.makeTensorInfo(a,s.dtype,r.values)}const p=new SU(i,f,[u,l],s.shape);const m=e.runWebGLProgram(p,[d,h],d.dtype);const x=QP({inputs:{x:m},backend:e,attrs:{shape:a}});e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(m);return x}const TU={kernelName:kn,backendName:"webgl",kernelFunc:EU};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IU{constructor(t,n){this.variableNames=["A","indices"];this.outputShape=n;this.rank=n.length;const e=rL(this.rank);const s=AU(t);this.userCode=`\n      void main() {\n        ${e} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function AU(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"];const s=[];for(let n=0;n<t.length;n++){if(n===2){s.push("index")}else{s.push(`${e[n]}`)}}return s.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,indices:r}=n;const{axis:i,batchDims:c}=s;const a=N(i,o.shape)[0];if(et().get("DEBUG")){const t=e.readSync(r.dataId);const n=o.shape[a];for(let e=0;e<t.length;++e){const s=t[e];m(s<=n-1&&s>=0,(()=>`GatherV2: the index value ${s} is not in [0, ${n-1}]`))}}const u=Qx(o,r,a,c);const l=g(r.shape);const f=[];const h=QP({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}});const d=QP({inputs:{x:r},backend:e,attrs:{shape:[u.batchSize,l/u.batchSize]}});f.push(h);f.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([o,r])||o.dtype==="string"){const t=e.bufferSync(d);const n=e.bufferSync(h);const s=oz(n,t,p);f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return e.makeTensorInfo(u.outputShape,s.dtype,s.values)}const x=new IU(h.shape,p);const b=e.runWebGLProgram(x,[h,d],h.dtype);f.push(b);const w=QP({inputs:{x:b},backend:e,attrs:{shape:u.outputShape}});f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return w}const FU={kernelName:yn,backendName:"webgl",kernelFunc:OU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _U=`return float(a > b);`;const MU=`\n  return vec4(greaterThan(a, b));\n`;const DU=UP({opSnippet:_U,packedOpSnippet:MU,cpuKernelImpl:rz,dtype:"bool"});const LU={kernelName:Cn,backendName:"webgl",kernelFunc:DU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zU=`return float(a >= b);`;const PU=`\n  return vec4(greaterThanEqual(a, b));\n`;const VU=UP({opSnippet:zU,packedOpSnippet:PU,dtype:"bool",cpuKernelImpl:iz});const BU={kernelName:Nn,backendName:"webgl",kernelFunc:VU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(t){const{inputs:n,backend:e}=t;const{input:s}=n;return eU(s,true,e)}const GU={kernelName:Sn,backendName:"webgl",kernelFunc:WU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UU=`return float(!isnan(x) && !isinf(x));`;const HU=GP({opSnippet:UU,dtype:"bool"});const jU={kernelName:Tn,backendName:"webgl",kernelFunc:HU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qU=`return float(isinf(x));`;const XU=GP({opSnippet:qU,dtype:"bool"});const KU={kernelName:In,backendName:"webgl",kernelFunc:XU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JU=`return float(isnan(x));`;const YU=GP({opSnippet:JU,dtype:"bool"});const ZU={kernelName:An,backendName:"webgl",kernelFunc:YU};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QU=`return float(a < b);`;const tH=`\n  return vec4(lessThan(a, b));\n`;const nH=UP({opSnippet:QU,packedOpSnippet:tH,cpuKernelImpl:cz,dtype:"bool"});const eH={kernelName:Fn,backendName:"webgl",kernelFunc:nH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sH=`return float(a <= b);`;const oH=`\n  return vec4(lessThanEqual(a, b));\n`;const rH=UP({opSnippet:sH,packedOpSnippet:oH,cpuKernelImpl:az,dtype:"bool"});const iH={kernelName:_n,backendName:"webgl",kernelFunc:rH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(t){const{backend:n,attrs:e}=t;const{start:s,stop:o,num:r}=e;const i=uz(s,o,r);return n.makeTensorInfo([i.length],"float32",i)}const aH={kernelName:Mn,backendName:"webgl",kernelFunc:cH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uH=WP+`\n  return x < 0.0 ? 0./0. : log(x);\n`;const lH=`\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n`;const fH=GP({opSnippet:uH,packedOpSnippet:lH,cpuKernelImpl:lz});const hH={kernelName:Dn,backendName:"webgl",kernelFunc:fH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dH=WP+`\n  return log(1.0 + x);\n`;const pH=GP({opSnippet:dH});const mH={kernelName:Ln,backendName:"webgl",kernelFunc:pH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xH=`return float(a >= 1.0 && b >= 1.0);`;const bH=`\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`;const gH=UP({opSnippet:xH,packedOpSnippet:bH,dtype:"bool"});const wH={kernelName:zn,backendName:"webgl",kernelFunc:gH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vH=`return float(!(x >= 1.0));`;const $H=GP({opSnippet:vH});const yH={kernelName:Pn,backendName:"webgl",kernelFunc:$H};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kH=`return float(a >= 1.0 || b >= 1.0);`;const CH=`\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`;const NH=UP({opSnippet:kH,packedOpSnippet:CH,dtype:"bool"});const RH={kernelName:Vn,backendName:"webgl",kernelFunc:NH};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SH{constructor(t,n,e,s,o){this.variableNames=["x"];this.outputShape=[];const r=n;const i=t[3]-1;this.outputShape=t;let c;const a=`float(${e}) + float(${s}) * sum`;if(o===.5){c=`inversesqrt(${a})`}else if(o===1){c=`1.0/(${a})`}else{c=`exp(log(${a}) * float(-${o}));`}this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${r}; j <= ${r}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${c};\n        setOutput(val);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EH{constructor(t,n,e,s,o){this.variableNames=["x"];this.outputShape=[];this.packedInputs=true;this.packedOutput=true;const r=n;const i=t[3]-1;this.outputShape=t;let c;const a=`float(${e}) + float(${s}) * sum`;if(o===.5){c=`inversesqrt(${a})`}else if(o===1){c=`1.0/(${a})`}else{c=`exp(log(${a}) * float(-${o}));`}this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${r};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${r}; j <= ${r}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${c};\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TH=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{depthRadius:r,bias:i,alpha:c,beta:a}=s;const u=et().getBool("WEBGL_PACK_NORMALIZATION")?new EH(o.shape,r,i,c,a):new SH(o.shape,r,i,c,a);return e.runWebGLProgram(u,[o],o.dtype)};const IH={kernelName:Wn,backendName:"webgl",kernelFunc:TH};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AH{constructor(t,n,e,s,o){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=t;this.depth=t[3];this.depthRadius=n;this.bias=e;this.alpha=s;this.beta=o;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${e});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OH=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o,y:r,dy:i}=n;const{depthRadius:c,bias:a,alpha:u,beta:l}=s;const f=new AH(o.shape,c,a,u,l);return e.runWebGLProgram(f,[o,r,i],o.dtype)};const FH={kernelName:Gn,backendName:"webgl",kernelFunc:OH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(t,n,e,s){const o=g(n);const r=g(t.shape);const i=r/o;const c=QP({inputs:{x:t},attrs:{shape:[i,o]},backend:s});const a=oV(c,t.dtype,"max",s);const u=QP({inputs:{x:a},attrs:{shape:e},backend:s});s.disposeIntermediateTensorInfo(c);s.disposeIntermediateTensorInfo(a);return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MH(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reductionIndices:r,keepDims:i}=s;const c=o.shape.length;const a=N(r,o.shape);let u=a;const l=_u(u,c);const f=l!=null;const h=e.shouldExecuteOnCPU([o]);let d=o;if(f){if(h){const t=e.texData.get(d.dataId);const n=t.values;const s=new Array(c);for(let t=0;t<s.length;t++){s[t]=o.shape[l[t]]}const r=Pz(n,o.shape,o.dtype,l,s);d=e.makeTensorInfo(s,o.dtype);const i=e.texData.get(d.dataId);i.values=r}else{d=aV(o,l,e)}u=Du(u.length,c)}Fu("max",u,c);const[p,m]=Au(d.shape,u);let x=p;if(i){x=Ou(p,a)}let b;if(h){const t=e.texData.get(d.dataId);const n=t.values;const s=fz(n,g(m),x,o.dtype);b=e.makeTensorInfo(x,o.dtype);const r=e.texData.get(b.dataId);r.values=s}else{b=_H(d,m,x,e)}if(f){e.disposeIntermediateTensorInfo(d)}return b}const DH={kernelName:Un,backendName:"webgl",kernelFunc:MH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LH=RP+`\n  return max(a, b);\n`;const zH=`\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+EP+`\n  return result;\n`;const PH=UP({opSnippet:LH,packedOpSnippet:zH,cpuKernelImpl:hz});const VH={kernelName:Hn,backendName:"webgl",kernelFunc:PH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BH(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;cD(o,"maxPool");const{filterSize:r,strides:i,pad:c,dimRoundingMode:a}=s;const u=1;m(Vc(i,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${i} and dilations '${u}'`));const l=Rc(o.shape,r,i,u,c,a);if(l.filterWidth===1&&l.filterHeight===1&&w(l.inShape,l.outShape)){return IP({inputs:{x:o},backend:e})}const f=new uB(l,"max",false);return e.runWebGLProgram(f,[o],o.dtype)}const WH={kernelName:jn,backendName:"webgl",kernelFunc:BH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{filterSize:r,strides:i,pad:c,dataFormat:a,dimRoundingMode:u}=s;const l=[1,1,1];const f=Sc(o.shape,r,i,l,c,u,a);const h=new lB(f,"max",false);return e.runWebGLProgram(h,[o],o.dtype)}const UH={kernelName:Xn,backendName:"webgl",kernelFunc:GH};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HH{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;const n=t.strideHeight;const e=t.strideWidth;const s=t.dilationHeight;const o=t.effectiveFilterHeight;const r=t.effectiveFilterWidth;const i=o-1-t.padInfo.top;const c=r-1-t.padInfo.left;const a=o*r-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${n}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${r} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jH{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;const n=t.strideDepth;const e=t.strideHeight;const s=t.strideWidth;const o=t.dilationDepth;const r=t.dilationHeight;const i=t.dilationWidth;const c=t.effectiveFilterDepth;const a=t.effectiveFilterHeight;const u=t.effectiveFilterWidth;const l=c-1-t.padInfo.front;const f=a-1-t.padInfo.top;const h=u-1-t.padInfo.left;const d=c*a*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${l}, ${f}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${n}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${a};\n              wR += ${r}) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${a} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qH(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r}=n;const i=r;const{filterSize:c,strides:a,pad:u,dimRoundingMode:l}=s;const f=[1,1,1];const h=Sc(i.shape,c,a,f,u,l);const d=new lB(h,"max",true);const p=e.runWebGLProgram(d,[i],i.dtype);const m=new jH(h);const x=e.runWebGLProgram(m,[o,p],i.dtype);e.disposeIntermediateTensorInfo(p);return x}const XH={kernelName:Kn,backendName:"webgl",kernelFunc:qH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KH(t){const{inputs:n,backend:e,attrs:s}=t;const{dy:o,input:r,output:i}=n;const c=r;cD([r,i],"maxPoolGrad");const{filterSize:a,strides:u,pad:l,dimRoundingMode:f}=s;const h=Rc(c.shape,a,u,1,l,f);const d=true;const p=new uB(h,"max",d);const m=e.runWebGLProgram(p,[c],c.dtype);const x=new HH(h);const b=e.runWebGLProgram(x,[o,m],c.dtype);e.disposeIntermediateTensorInfo(m);return b}const JH={kernelName:qn,backendName:"webgl",kernelFunc:KH};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YH(t,n,e,s){let o=new uB(e,"max",false);const r=s.runWebGLProgram(o,[t],"float32");o=new uB(e,"max",true,true,n);const i=s.runWebGLProgram(o,[t],"float32");return[r,i]}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZH={kernelName:Jn,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{filterSize:o,strides:r,pad:i,includeBatchInIndex:c}=n;const a=e;m(s.shape.length===4,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));const u=[1,1];m(Vc(r,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${r} and dilations '${u}'`));const l=Rc(s.shape,o,r,u,i);const[f,h]=YH(s,c,l,a);return[f,h]}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QH(t,n,e,s){const o=g(n);const r=g(t.shape);const i=r/o;const c=QP({inputs:{x:t},attrs:{shape:[i,o]},backend:s});const a=oV(c,"float32","mean",s);const u=QP({inputs:{x:a},attrs:{shape:e},backend:s});s.disposeIntermediateTensorInfo(c);s.disposeIntermediateTensorInfo(a);return u}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tj={kernelName:Yn,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:s}=t;const{keepDims:o,axis:r}=n;const i=e;const c=s.shape.length;const a=N(r,s.shape);let u=a;const l=_u(u,c);const f=l!=null;const h=i.shouldExecuteOnCPU([s]);const d=[];let p=s;if(f){if(h){const t=i.texData.get(p.dataId);const n=t.values;const e=new Array(c);for(let t=0;t<e.length;t++){e[t]=s.shape[l[t]]}const o=Pz(n,s.shape,s.dtype,l,e);p=i.makeTensorInfo(e,s.dtype);const r=i.texData.get(p.dataId);r.values=o}else{p=aV(s,l,i)}d.push(p);u=Du(u.length,c)}Fu("sum",u,c);const[m,x]=Au(p.shape,u);let b=m;if(o){b=Ou(m,a)}const g=QH(p,x,b,i);for(const t of d){i.disposeIntermediateTensorInfo(t)}return g}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=N(r,o.shape);let u=a;const l=_u(u,c);let f=o;if(l!=null){f=hV({inputs:{x:o},backend:e,attrs:{perm:l}});u=Du(u.length,o.shape.length)}Fu("min",u,c);const[h,d]=Au(f.shape,u);const p=g(d);const m=QP({inputs:{x:f},backend:e,attrs:{shape:[-1,p]}});const x=oV(m,m.dtype,"min",e);let b;if(i){const t=Ou(h,a);b=QP({inputs:{x},backend:e,attrs:{shape:t}})}else{b=QP({inputs:{x},backend:e,attrs:{shape:h}})}e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(x);if(l!=null){e.disposeIntermediateTensorInfo(f)}return b}const ej={kernelName:Zn,backendName:"webgl",kernelFunc:nj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sj=RP+`\n  return min(a, b);\n`;const oj=`\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+EP+`\n  return result;\n`;const rj=UP({opSnippet:sj,packedOpSnippet:oj,cpuKernelImpl:dz});const ij={kernelName:Qn,backendName:"webgl",kernelFunc:rj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cj{constructor(t,n,e){this.variableNames=["x"];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=rL(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);const a=e==="reflect"?0:1;if(s===1){this.userCode=`\n        int start = ${r};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${a};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${a};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;return}this.userCode=`\n      ${o} start = ${o}(${r});\n      ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${a};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${a};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${c}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aj{constructor(t,n,e){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=rL(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=Wz("rc",s);const a=Wz("source",s);const u=`${c[s-1]} < ${this.outputShape[s-1]}`;const l=s===1?"source":`vec2(${a.slice(-2).join()})`;const f=e==="reflect"?0:1;let h="";if(s===1){const t=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${f};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${f};\n        }\n        source -= start;\n      `;h=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${a.join()}), ${l});\n        ${c[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${a.join()}), ${l});\n        }\n      `}else{const t=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${f}) +\n                gte * ((end - 1) * 2 - source + ${f});\n        source -= start;\n      `;h=`\n        ${o} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${a.join()}), ${l});\n        ${c[s-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${a.join()}), ${l});\n        }\n        rc = outputLoc;\n        ${c[s-2]} += 1;\n        if(${c[s-2]} < ${this.outputShape[s-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${a.join()}), ${l});\n          ${c[s-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${a.join()}), ${l});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${r});\n      const ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uj=({inputs:t,backend:n,attrs:e})=>{const{x:s}=t;const{paddings:o,mode:r}=e;const i=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aj(s.shape,o,r):new cj(s.shape,o,r);const c=n.runWebGLProgram(i,[s],s.dtype);return c};const lj={kernelName:te,backendName:"webgl",kernelFunc:uj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fj=`if (b == 0.0) return NAN;\n  return mod(a, b);`;const hj=`\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  `+EP+`\n  return result;\n`;const dj=UP({opSnippet:fj,packedOpSnippet:hj});const pj={kernelName:ne,backendName:"webgl",kernelFunc:dj};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mj{constructor(t,n,e){this.variableNames=["probs"];this.customUniforms=[{name:"seed",type:"float"}];this.outputShape=[t,e];this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${n-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${n-1}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xj=`\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`;const bj=`\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`;const gj=UP({opSnippet:xj,packedOpSnippet:bj,checkOutOfBounds:true});const wj={kernelName:cn,backendName:"webgl",kernelFunc:gj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vj="return a - b;";const $j=UP({opSnippet:vj,packedOpSnippet:vj,supportsComplex:true,cpuKernelImpl:Dz});const yj={kernelName:is,backendName:"webgl",kernelFunc:$j};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{dim:r}=s;const i=N([r],o.shape);const c=MH({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:false}});const a=Ou(c.shape,i);const u=QP({inputs:{x:c},backend:e,attrs:{shape:a}});const l=$j({inputs:{a:o,b:u},backend:e});const f=XG({inputs:{x:l},backend:e});const h=lV({inputs:{x:f},backend:e,attrs:{axis:i,keepDims:false}});const d=QP({inputs:{x:h},backend:e,attrs:{shape:a}});const p=gj({inputs:{a:f,b:d},backend:e});e.disposeIntermediateTensorInfo(c);e.disposeIntermediateTensorInfo(u);e.disposeIntermediateTensorInfo(l);e.disposeIntermediateTensorInfo(f);e.disposeIntermediateTensorInfo(h);e.disposeIntermediateTensorInfo(d);return p}const Cj={kernelName:qe,backendName:"webgl",kernelFunc:kj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(t){const{inputs:n,backend:e,attrs:s}=t;const{logits:o}=n;const{numSamples:r,seed:i,normalized:c}=s;const a=c?o:kj({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}});const u=a.shape[0];const l=a.shape[1];const f=new mj(u,l,r);const h=[[i]];const d=e.runWebGLProgram(f,[a],"int32",h);if(!c){e.disposeIntermediateTensorInfo(a)}return d}const Rj={kernelName:ee,backendName:"webgl",kernelFunc:Nj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sj=nP+`\n  return -x;\n`;const Ej=`\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;function Tj(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(e.shouldExecuteOnCPU([s])){const t=e.texData.get(s.dataId);const[n,o]=mz(t.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,n)}let o;if(et().getBool("WEBGL_PACK_UNARY_OPERATIONS")){o=new pP(s.shape,Ej)}else{o=new tP(s.shape,Sj)}return e.runWebGLProgram(o,[s],s.dtype)}const Ij={kernelName:oe,backendName:"webgl",kernelFunc:Tj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aj=dp;function Oj(t){ks("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a}=s;const u=e.readSync(o.dataId);const l=e.readSync(r.dataId);const{selectedIndices:f}=Aj(u,l,i,c,a);return e.makeTensorInfo([f.length],"int32",new Int32Array(f))}const Fj={kernelName:ie,backendName:"webgl",kernelFunc:Oj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _j=pp;function Mj(t){ks("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,padToMaxOutputSize:u}=s;const l=e.readSync(o.dataId);const f=e.readSync(r.dataId);const{selectedIndices:h,validOutputs:d}=_j(l,f,i,c,a,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}const Dj={kernelName:ce,backendName:"webgl",kernelFunc:Mj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lj=mp;function zj(t){ks("tf.nonMaxSuppression() in webgl locks the UI thread. "+"Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:s}=t;const{boxes:o,scores:r}=n;const{maxOutputSize:i,iouThreshold:c,scoreThreshold:a,softNmsSigma:u}=s;const l=e.readSync(o.dataId);const f=e.readSync(r.dataId);const h=i;const d=c;const p=a;const m=u;const{selectedIndices:x,selectedScores:b}=Lj(l,f,h,d,p,m);return[e.makeTensorInfo([x.length],"int32",new Int32Array(x)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const Pj={kernelName:ae,backendName:"webgl",kernelFunc:zj};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vj{constructor(t,n,e,s){this.variableNames=["indices"];this.outputShape=[t,n];this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${e}),\n                      float(index == coords.y)));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bj=t=>{const{inputs:n,backend:e,attrs:s}=t;const{indices:o}=n;const{dtype:r,depth:i,onValue:c,offValue:a}=s;const u=g(o.shape);const l=new Vj(u,i,c,a);const f=QP({inputs:{x:o},backend:e,attrs:{shape:[u]}});const h=e.runWebGLProgram(l,[f],r);e.disposeIntermediateTensorInfo(f);const d=[...o.shape,i];const p=QP({inputs:{x:h},backend:e,attrs:{shape:d}});e.disposeIntermediateTensorInfo(h);return p};const Wj={kernelName:le,backendName:"webgl",kernelFunc:Bj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gj(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="complex64"){const t=qB({inputs:{input:s},backend:e});const n=Gj({inputs:{x:t},backend:e});const o=dW({inputs:{input:s},backend:e});const r=Gj({inputs:{x:o},backend:e});const i=OP({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return iU({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}}const Uj={kernelName:xs,backendName:"webgl",kernelFunc:Gj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hj(t){const{inputs:n,backend:e}=t;const{x:s}=n;if(s.dtype==="string"){throw new Error("onesLike is not supported under string dtype")}else if(s.dtype==="complex64"){const t=qB({inputs:{input:s},backend:e});const n=Hj({inputs:{x:t},backend:e});const o=dW({inputs:{input:s},backend:e});const r=Gj({inputs:{x:o},backend:e});const i=OP({inputs:{real:n,imag:r},backend:e});e.disposeIntermediateTensorInfo(t);e.disposeIntermediateTensorInfo(n);e.disposeIntermediateTensorInfo(o);e.disposeIntermediateTensorInfo(r);return i}else{return iU({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}}const jj={kernelName:ue,backendName:"webgl",kernelFunc:Hj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(t){const{inputs:n,backend:e,attrs:s}=t;const{axis:o}=s;if(n.length===1){return JG({inputs:{input:n[0]},backend:e,attrs:{dim:o}})}const r=n[0].shape;const i=n[0].dtype;n.forEach((t=>{x(r,t.shape,"All tensors passed to stack must have matching shapes");m(i===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const c=[];const a=n.map((t=>{const n=JG({inputs:{input:t},backend:e,attrs:{dim:o}});c.push(n);return n}));const u=bW({inputs:a,backend:e,attrs:{axis:o}});c.forEach((t=>e.disposeIntermediateTensorInfo(t)));return u}const Xj={kernelName:fe,backendName:"webgl",kernelFunc:qj};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kj{constructor(t,n,e){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=rL(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`\n        int start = ${r};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${o} start = ${o}(${r});\n      ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${c}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jj{constructor(t,n,e){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=n.map(((n,e)=>n[0]+t[e]+n[1]));const s=t.length;const o=rL(s);const r=n.map((t=>t[0])).join(",");const i=n.map(((n,e)=>n[0]+t[e])).join(",");const c=Wz("rc",s);const a=Wz("source",s);const u=`${c[s-1]} < ${this.outputShape[s-1]}`;const l=s===1?"source":`vec2(${a.slice(-2).join()})`;const f=[`${o} rc = outputLoc;`,`${c[s-1]} += 1;\n       if(${u}) {\n      `,s===1?"":`}\n       rc = outputLoc;\n       ${c[s-2]} += 1;\n       if(${c[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${c[s-1]} += 1;\n         if(${u}) {`];const h=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let d="";for(let t=0,n=s===1?2:4;t<n;t++){d+=`\n        ${f[t]}\n        if (${h}) {\n          result[${t}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${t}] = getChannel(getX(${a.join()}), ${l});\n        }\n      `}d+=s===1?`} `:`}}`;this.userCode=`\n      const ${o} start = ${o}(${r});\n      const ${o} end = ${o}(${i});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yj=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{paddings:r,constantValue:i}=s;if(g(o.shape)===0){const t=r.map(((t,n)=>t[0]+o.shape[n]+t[1]));return iU({backend:e,attrs:{shape:t,value:i,dtype:o.dtype}})}const c=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jj(o.shape,r,i):new Kj(o.shape,r,i);const a=[[i]];return e.runWebGLProgram(c,[o],o.dtype,a)};const Zj={kernelName:he,backendName:"webgl",kernelFunc:Yj};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qj=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;const tq=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  `+EP+`\n  return result;\n`;const nq=UP({opSnippet:Qj,packedOpSnippet:tq});const eq={kernelName:de,backendName:"webgl",kernelFunc:nq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{axis:r,keepDims:i}=s;const c=o.shape.length;const a=[];const u=N(r,o.shape);let l=u;const f=_u(l,c);let h=o;if(f!=null){h=hV({inputs:{x:o},backend:e,attrs:{perm:f}});l=Du(l.length,c);a.push(h)}Fu("prod",l,c);let d;if(e.shouldExecuteOnCPU([h])){const t=e.texData.get(h.dataId).values;const{outVals:n,outShape:s,outDtype:o}=bz(h.shape,h.dtype,t,l);d=e.makeTensorInfo(s,o,n)}else{const[t,n]=Au(h.shape,l);const s=g(n);const r=QP({inputs:{x:h},backend:e,attrs:{shape:[-1,s]}});const i=ur(o.dtype);const c=oV(r,i,"prod",e);d=QP({inputs:{x:c},backend:e,attrs:{shape:t}});a.push(r);a.push(c)}if(i){a.push(d);const t=Ou(d.shape,u);d=QP({inputs:{x:d},backend:e,attrs:{shape:t}})}a.forEach((t=>e.disposeIntermediateTensorInfo(t)));return d}const oq={kernelName:me,backendName:"webgl",kernelFunc:sq};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rq(t){const{inputs:n,backend:e,attrs:s}=t;const{paramsNestedSplits:o,paramsDenseValues:r,indices:i}=n;const{outputRaggedRank:c}=s;const a=o.map((t=>e.readSync(t.dataId)));const u=o.map((t=>t.shape));const l=e.readSync(r.dataId);const f=e.readSync(i.dataId);const[h,d,p]=gz(a,u,l,r.shape,r.dtype,f,i.shape,c);const m=h.map((t=>e.makeTensorInfo([t.length],"int32",t)));const x=e.makeTensorInfo(p,r.dtype,d);return m.concat([x])}const iq={kernelName:xe,backendName:"webgl",kernelFunc:rq};
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cq(t){const{inputs:n,backend:e}=t;const{starts:s,limits:o,deltas:r}=n;const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=wz(i,s.shape,s.dtype,c,o.shape,a,r.shape);const f=e.makeTensorInfo([u.length],"int32",u);const h=e.makeTensorInfo([l.length],s.dtype,l);return[f,h]}const aq={kernelName:be,backendName:"webgl",kernelFunc:cq};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(t){const{inputs:n,backend:e,attrs:s}=t;const{shape:o,values:r,defaultValue:i,rowPartitionTensors:c}=n;const{rowPartitionTypes:a}=s;const u=e.readSync(o.dataId);const l=e.readSync(r.dataId);const f=e.readSync(i.dataId);const h=c.map((t=>e.readSync(t.dataId)));const d=c.map((t=>t.shape));const[p,m]=vz(u,o.shape,l,r.shape,r.dtype,f,i.shape,h,d,a);return e.makeTensorInfo(p,r.dtype,m)}const lq={kernelName:ge,backendName:"webgl",kernelFunc:uq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fq=t=>{const{backend:n,attrs:e}=t;const{start:s,stop:o,step:r,dtype:i}=e;const c=$z(s,o,r,i);return n.makeTensorInfo([c.length],i,c)};const hq={kernelName:we,backendName:"webgl",kernelFunc:fq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dq=`return 1.0 / x;`;const pq=GP({opSnippet:dq});const mq={kernelName:$e,backendName:"webgl",kernelFunc:pq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=nP+`\n  return (x < 0.0) ? 0.0 : x;\n`;const bq=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const gq=GP({opSnippet:xq,packedOpSnippet:bq});const wq={kernelName:ye,backendName:"webgl",kernelFunc:gq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq=nP+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const $q=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const yq=GP({opSnippet:vq,packedOpSnippet:$q});const kq={kernelName:Ee,backendName:"webgl",kernelFunc:yq};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cq{constructor(t,n,e,s,o){this.variableNames=["A"];this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];let f;if(o){f=`(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC`+` - vec2(0.5)`}else{f=`vec2(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nq{constructor(t,n,e,s,o){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];let f;if(o){f=`(vec3(yRC) + vec3(0.5)) * `+`effectiveInputOverOutputRatioRC - vec3(0.5)`}else{f=`vec3(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;const[a,u]=c;const l=et().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Nq(o.shape,a,u,r,i):new Cq(o.shape,a,u,r,i);return e.runWebGLProgram(l,[o],"float32")}const Sq={kernelName:Re,backendName:"webgl",kernelFunc:Rq};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eq{constructor(t,n,e){this.variableNames=["dy"];this.outputShape=[];this.outputShape=n;const[,s,o]=n;const[,r,i]=t;const c=[e&&r>1?s-1:s,e&&i>1?o-1:o];const a=[e&&r>1?r-1:r,e&&i>1?i-1:i];const u=c[0]/a[0];const l=c[1]/a[1];const f=1/u;const h=1/l;const d=Math.ceil(f)*2+2;const p=Math.ceil(h)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;const c=new Eq(r.shape,o.shape,i);return e.runWebGLProgram(c,[r],r.dtype)}const Iq={kernelName:Se,backendName:"webgl",kernelFunc:Tq};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aq{constructor(t,n,e,s,o){this.variableNames=["A"];this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];const f=s?"0.5":"0.0";let h;if(o){h=`max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC`+`, vec2(0.0))`}else{h=`vec2(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oq{constructor(t,n,e,s,o){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=[];const[r,i,c,a]=t;this.outputShape=[r,n,e,a];const u=[s&&n>1?i-1:i,s&&e>1?c-1:c];const l=[s&&n>1?n-1:n,s&&e>1?e-1:e];const f=s?"0.5":"0.0";let h;if(o){h=`max((vec3(yRC) + vec3(0.5)) * `+`effectiveInputOverOutputRatioRC, vec3(0.0))`}else{h=`vec3(yRC) * effectiveInputOverOutputRatioRC`}this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/l[0]},\n          ${u[1]/l[1]},\n          ${u[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,\n                                     ${c}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o}=n;const{alignCorners:r,halfPixelCenters:i,size:c}=s;const[a,u]=c;const l=et().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Oq(o.shape,a,u,r,i):new Aq(o.shape,a,u,r,i);return e.runWebGLProgram(l,[o],o.dtype)}const _q={kernelName:Ce,backendName:"webgl",kernelFunc:Fq};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mq{constructor(t,n,e){this.variableNames=["dy"];this.outputShape=[];this.outputShape=n;const[,s,o]=n;const[,r,i]=t;const c=[e&&r>1?s-1:s,e&&i>1?o-1:o];const a=[e&&r>1?r-1:r,e&&i>1?i-1:i];const u=c[0]/a[0];const l=c[1]/a[1];const f=1/u;const h=1/l;const d=Math.ceil(f)*2+2;const p=Math.ceil(h)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${p});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${c[0]}) *\n                (float(dyR) / float(${a[0]}));\n\n            float sourceFracCol =\n                float(${c[1]}) *\n                  (float(dyC) / float(${a[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${e} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${e} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(t){const{inputs:n,backend:e,attrs:s}=t;const{images:o,dy:r}=n;const{alignCorners:i}=s;const c=new Mq(r.shape,o.shape,i);return e.runWebGLProgram(c,[r],r.dtype)}const Lq={kernelName:Ne,backendName:"webgl",kernelFunc:Dq};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zq{constructor(t,n){this.variableNames=["x"];const e=t.length;if(e>4){throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`)}this.outputShape=t;if(e===1){this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `;return}const s=e=>{if(n.indexOf(e)!==-1&&t[e]!==1){return`${t[e]} - coords[${e}] - 1`}return`coords[${e}]`};const o=t.map(((t,n)=>s(n))).join(",");const r=rL(e);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pq{constructor(t,n){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;const e=t.length;if(e>4){throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`)}this.outputShape=t;const s=Wz("rc",e);const o=`${s[e-1]} + 1 < ${this.outputShape[e-1]}`;const r=`${s[e-2]} + 1 < ${this.outputShape[e-2]}`;const i=rL(e);if(e===1){this.userCode=`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `}else{this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${c(s.slice())};\n          if(${o}){\n            result.g = ${a(s.slice())};\n          }\n          if(${r}) {\n            result.b = ${u(s.slice())};\n            if(${o}) {\n              result.a = ${l(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}function c(t){return f(t)}function a(t){t[e-1]="("+t[e-1]+` + 1)`;return f(t)}function u(t){t[e-2]="("+t[e-2]+` + 1)`;return f(t)}function l(t){t[e-1]="("+t[e-1]+` + 1)`;t[e-2]="("+t[e-2]+` + 1)`;return f(t)}function f(n){const e=t.map(((t,e)=>h(e,n)));const s=e.join(",");const o=e.slice(-2).join(",");return`getChannel(getX(${s}), vec2(${o}))`}function h(e,s){if(n.indexOf(e)!==-1&&t[e]!==1){return`${t[e]} - ${s[e]} - 1`}else{return`${s[e]}`}}}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{dims:r}=s;const i=o.shape.length;const c=N(r,o.shape);if(i===0){return IP({inputs:{x:o},backend:e})}const a=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pq(o.shape,c):new zq(o.shape,c);return e.runWebGLProgram(a,[o],o.dtype)}const Bq={kernelName:Te,backendName:"webgl",kernelFunc:Vq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wq{constructor(t,n){this.variableNames=["Image"];this.outputShape=[];this.customUniforms=[{name:"params",type:"vec4"}];const e=t[1];const s=t[2];this.outputShape=t;let o="";if(typeof n==="number"){o=`float outputValue = ${n.toFixed(2)};`}else{o=`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`}this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${e}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gq={kernelName:ws,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:s}=t;const{radians:o,fillValue:r,center:i}=n;const c=e;const a=new Wq(s.shape,r);const[u,l]=ix(i,s.shape[1],s.shape[2]);const f=[[u,l,Math.sin(o),Math.cos(o)]];const h=c.runWebGLProgram(a,[s],s.dtype,f);return h}};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uq=`\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`;const Hq=GP({opSnippet:Uq});const jq={kernelName:Ie,backendName:"webgl",kernelFunc:Hq};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq=`return inversesqrt(x);`;const Xq=GP({opSnippet:qq,cpuKernelImpl:yz});const Kq={kernelName:Ae,backendName:"webgl",kernelFunc:Xq};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jq{constructor(t,n,e,s,o,r,i=true,c=false){this.variableNames=["updates","indices","defaultValue"];this.outputShape=r;const a=rL(o.length);const u=rL(r.length);let l="";if(e===1){l="i"}else if(e===2){l="i, j"}const f=`getIndices(${l})`;let h="";if(s===1){h="i"}else if(s===2){h="i, coords[1]"}const d=`getUpdates(${h})`;let p="";if(c){p="coords[0], coords[1]"}const m=`getDefaultValue(${p})`;const x=n>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${f});\n              flattenedIndex += index * ${x};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yq{constructor(t,n,e,s,o,r,i=true,c=false){this.variableNames=["updates","indices","defaultValue"];this.packedInputs=true;this.packedOutput=true;this.outputShape=r;const a=rL(o.length);const u=rL(r.length);let l="";if(e===1){l="i"}else if(e===2){l="i, j"}const f=`getIndices(${l})`;let h="";if(s===1){h="i"}else if(s===2){h="i, coords[1]"}const d=`getUpdates(${h})`;let p="";if(c){p="coords[0], coords[1]"}const m=`getDefaultValue(${p})`;const x=n>1?"strides[j]":"strides";const b=n>1?"strides[j + 1]":"strides";this.userCode=`\n        ${a} strides = ${a}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${n}; j+=2) {\n              ivec4 index = round(${f});\n              flattenedIndex += index.xz * ${x};\n              if (j + 1 < ${n}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(t){const{inputs:n,backend:e,attrs:s}=t;const{indices:o,updates:r}=n;const{shape:i}=s;const{sliceRank:c,numUpdates:a,sliceSize:u,strides:l,outputSize:f}=gd(r,o,i);const h=[f/u,u];if(f===0){return e.makeTensorInfo(i,o.dtype)}const d=QP({inputs:{x:o},backend:e,attrs:{shape:[a,c]}});const p=QP({inputs:{x:r},backend:e,attrs:{shape:[a,u]}});const m=e.makeTensorInfo([],"float32",new Float32Array([0]));let x;if(et().getBool("WEBGL_PACK")){x=new Yq(a,c,d.shape.length,p.shape.length,l,h)}else{x=new Jq(a,c,d.shape.length,p.shape.length,l,h)}const b=e.runWebGLProgram(x,[p,d,m],p.dtype);const g=QP({inputs:{x:b},backend:e,attrs:{shape:i}});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(b);e.disposeIntermediateTensorInfo(m);return g}const Qq={kernelName:Oe,backendName:"webgl",kernelFunc:Zq};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tX{constructor(t,n,e,s){this.variableNames=["sortedSequence","values"];this.customUniforms=[{name:"numInputs",type:"int"}];this.outputShape=[t,e];const o="while (left < right) {";const r=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`;const i=et().getNumber("WEBGL_VERSION")===2?o:r;const c=s==="left"?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${c} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(t){const{inputs:n,backend:e,attrs:s}=t;const{sortedSequence:o,values:r}=n;const{side:i}=s;const c=new tX(o.shape[0],o.shape[1],r.shape[1],i);const a=[[o.shape[1]]];return e.runWebGLProgram(c,[o,r],"int32",a)}const eX={kernelName:_e,backendName:"webgl",kernelFunc:nX};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sX{constructor(t,n,e){this.variableNames=["c","a","b"];this.outputShape=n;let s;let o;if(e>4){throw Error(`Where for rank ${e} is not yet supported`)}if(e===1){o=`resRC`;s=`resRC`}else{const e=["resRC.x","resRC.y","resRC.z","resRC.w"];const r=[];const i=[];for(let s=0;s<n.length;s++){i.push(`${e[s]}`);if(s<t){r.push(`${e[s]}`)}}s=r.join();o=i.join()}const r=rL(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(t){const{inputs:n,backend:e}=t;const{condition:s,t:o,e:r}=n;const i=new sX(s.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[s,o,r],ar(o.dtype,r.dtype))}const rX={kernelName:Me,backendName:"webgl",kernelFunc:oX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iX=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${hx};\n  float scale = ${dx};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`;const cX=GP({opSnippet:iX});const aX={kernelName:De,backendName:"webgl",kernelFunc:cX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uX=WP+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;const lX=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const fX=GP({opSnippet:uX,packedOpSnippet:lX,cpuKernelImpl:Cz});const hX={kernelName:Be,backendName:"webgl",kernelFunc:fX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dX=`\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`;const pX=GP({opSnippet:dX});const mX={kernelName:Ve,backendName:"webgl",kernelFunc:pX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xX=WP+`\n  return sin(x);\n`;const bX=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${EP}\n  return result;\n`;const gX=GP({opSnippet:xX,packedOpSnippet:bX});const wX={kernelName:ze,backendName:"webgl",kernelFunc:gX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX=`\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;const $X=GP({opSnippet:vX});const yX={kernelName:Pe,backendName:"webgl",kernelFunc:$X};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kX=`\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`;const CX=GP({opSnippet:kX});const NX={kernelName:We,backendName:"webgl",kernelFunc:CX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=t=>{const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{blockShape:r,paddings:i}=s;m(o.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not "+"implemented yet"));const c=r.reduce(((t,n)=>t*n));const a=[[0,0]];a.push(...i);for(let t=1+r.length;t<o.shape.length;++t){a.push([0,0])}const u=[];const l=Yj({inputs:{x:o},backend:e,attrs:{paddings:a,constantValue:0}});const f=cx(l.shape,r,c,false);const h=ax(f.length,r.length,false);const d=ux(l.shape,r,c,false);const p=QP({inputs:{x:l},backend:e,attrs:{shape:f}});const x=hV({inputs:{x:p},backend:e,attrs:{perm:h}});const b=QP({inputs:{x},backend:e,attrs:{shape:d}});u.push(l);u.push(p);u.push(x);u.forEach((t=>e.disposeIntermediateTensorInfo(t)));return b};const SX={kernelName:He,backendName:"webgl",kernelFunc:RX};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(t){const{inputs:n,backend:e}=t;const{indices:s,values:o,denseShape:r,defaultValue:i}=n;if(r.shape.length!==1){throw new Error(`Dense shape must be a vector, saw:\n         ${r.shape}`)}if(s.shape.length!==2){throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Values must be a vector, saw:\n         ${o.shape}`)}if(i.shape.length!==0){throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`)}const c=e.readSync(s.dataId);const a=e.readSync(o.dataId);const u=e.readSync(r.dataId);const l=e.readSync(i.dataId)[0];const[f,h,d,p,m]=Sz(c,s.shape,s.dtype,a,o.dtype,u,l);return[e.makeTensorInfo(h,s.dtype,f),e.makeTensorInfo([h[0]],o.dtype,d),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map((t=>Number(t))))),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const TX={kernelName:Xe,backendName:"webgl",kernelFunc:EX};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IX(t){const{inputs:n,backend:e}=t;const{inputIndices:s,inputShape:o,newShape:r}=n;if(s.shape.length!==2){throw new Error(`Input indices should be a matrix but received shape ${s.shape}`)}if(o.shape.length!==1){throw new Error(`Input shape should be a vector but received shape ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Target shape should be a vector but received shape ${r.shape}`)}const i=Array.from(e.readSync(o.dataId));const c=e.readSync(s.dataId);const a=Array.from(e.readSync(r.dataId));const[u,l,f]=Ez(c,s.shape,s.dtype,i,a);return[e.makeTensorInfo(l,s.dtype,u),e.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const AX={kernelName:Ke,backendName:"webgl",kernelFunc:IX};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n              ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n              ${r.shape}`)}const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=Tz(i,s.shape,s.dtype,c,a,true);return e.makeTensorInfo(l,s.dtype,u)}const FX={kernelName:Je,backendName:"webgl",kernelFunc:OX};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(t){const{inputs:n,backend:e}=t;const{data:s,indices:o,segmentIds:r}=n;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(o.shape.length!==1){throw new Error(`Indices should be a vector but received shape\n             ${o.shape}`)}if(r.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape\n             ${r.shape}`)}const i=e.readSync(s.dataId);const c=e.readSync(o.dataId);const a=e.readSync(r.dataId);const[u,l]=Tz(i,s.shape,s.dtype,c,a);return e.makeTensorInfo(l,s.dtype,u)}const MX={kernelName:Ye,backendName:"webgl",kernelFunc:_X};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DX(t){const{inputs:n,backend:e,attrs:s}=t;const{sparseIndices:o,sparseValues:r,defaultValue:i}=n;const{outputShape:c}=s;const{sliceRank:a,numUpdates:u,sliceSize:l,strides:f,outputSize:h}=gd(r,o,c);const d=false;if(r.dtype==="string"){const t=e.bufferSync(o);const n=e.bufferSync(r);const s=Ao(e.readSync(i.dataId)[0]);const p=kz(t,n,c,h,l,u,a,f,s,d);return e.makeTensorInfo(c,p.dtype,p.values)}const p=new Jq(u,a,o.shape.length,r.shape.length,f,[h,1],d);const m=e.runWebGLProgram(p,[r,o,i],r.dtype);const x=QP({inputs:{x:m},backend:e,attrs:{shape:c}});e.disposeIntermediateTensorInfo(m);return x}const LX={kernelName:Ze,backendName:"webgl",kernelFunc:DX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zX(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{numOrSizeSplits:r,axis:i}=s;const c=N(i,o.shape)[0];const a=zx(o,r,c);const u=o.shape.length;const l=new Array(u).fill(0);const f=o.shape.slice();return a.map((t=>{const n=[...f];n[c]=t;const s=OB({inputs:{x:o},backend:e,attrs:{begin:l,size:n}});l[c]+=t;return s}))}const PX={kernelName:je,backendName:"webgl",kernelFunc:zX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VX=`return sqrt(x);`;const BX=GP({opSnippet:VX,packedOpSnippet:VX,cpuKernelImpl:Iz});const WX={kernelName:Ge,backendName:"webgl",kernelFunc:BX};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GX=`return x * x;`;const UX=GP({opSnippet:GX});const HX={kernelName:ts,backendName:"webgl",kernelFunc:UX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jX="return (a - b) * (a - b);";const qX=UP({opSnippet:jX,packedOpSnippet:jX});const XX={kernelName:Qe,backendName:"webgl",kernelFunc:qX};
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KX(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;if(o.dtype!=="string"){throw new Error("Input must be of datatype string")}const r=e.readSync(o.dataId);const i=nb(r);const c=Az(i,"string",s);return e.makeTensorInfo(o.shape,"string",c)}const JX={kernelName:ns,backendName:"webgl",kernelFunc:KX};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX({inputs:t,attrs:n,backend:e}){const{x:s}=t;const o=nP+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `;const r=new tP(s.shape,o);return e.runWebGLProgram(r,[s],s.dtype)}const ZX={kernelName:bs,backendName:"webgl",kernelFunc:YX};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QX{constructor(t,n,e){this.variableNames=["x"];this.outputShape=e;const s=e.length;const o=rL(e.length);const r=rL(e.length);let i="";if(s===1){i="coords * strides + begin"}else{let t=0;i=e.map(((n,s)=>{t++;return e.length===1?`coords * strides[${s}] + begin[${s}]`:`coords[${t-1}] * strides[${s}] + begin[${s}]`})).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${n});\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tK(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{begin:r,end:i,strides:c,beginMask:a,endMask:u,ellipsisMask:l,newAxisMask:f,shrinkAxisMask:h}=s;const{finalShapeSparse:d,finalShape:p,isIdentity:x,sliceDim0:b,isSimpleSlice:g,begin:w,end:v,strides:$}=Gm(o.shape,r,i,c,a,u,l,f,h);let y;if(x){y=QP({inputs:{x:o},backend:e,attrs:{shape:p}})}else if(b||g){m(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const t=Im(w,v,$);const n=OB({inputs:{x:o},backend:e,attrs:{begin:w,size:t}});y=QP({inputs:{x:n},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(n)}else{const t=e.shouldExecuteOnCPU([o]);if(t){const t=e.readSync(o.dataId);const n=Fi(o.shape,o.dtype,t);const s=Oz(d,n,$,w);y=e.makeTensorInfo(p,o.dtype,s.values)}else{const t=new QX(w,$,d);y=e.runWebGLProgram(t,[o],o.dtype)}}const k=QP({inputs:{x:y},backend:e,attrs:{shape:p}});e.disposeIntermediateTensorInfo(y);return k}const nK={kernelName:es,backendName:"webgl",kernelFunc:tK};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eK(t){const{inputs:n,backend:e,attrs:s}=t;const{separator:o,nGramWidths:r,leftPad:i,rightPad:c,padWidth:a,preserveShortSequences:u}=s;const{data:l,dataSplits:f}=n;const h=e.readSync(l.dataId);const d=e.readSync(f.dataId);const[p,m]=Fz(h,d,o,r,i,c,a,u);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(f.shape,"int32",m)]}const sK={kernelName:ss,backendName:"webgl",kernelFunc:eK};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oK(t){const{inputs:n,backend:e,attrs:s}=t;const{skipEmpty:o}=s;const{input:r,delimiter:i}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(r.shape.length!==1){throw new Error(`Input must be a vector, got shape: ${r.shape}`)}if(i.shape.length!==0){throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`)}const c=e.readSync(r.dataId);const a=e.readSync(i.dataId)[0];const[u,l,f]=_z(c,a,o);const h=l.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(f))]}const rK={kernelName:os,backendName:"webgl",kernelFunc:oK};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(t){const{inputs:n,backend:e,attrs:s}=t;const{numBuckets:o}=s;const{input:r}=n;if(r.dtype!=="string"){throw new Error("Input must be of datatype string")}if(o<=0){throw new Error(`Number of buckets must be at least 1`)}const i=e.readSync(r.dataId);const c=Mz(i,o);return e.makeTensorInfo(r.shape,"int32",c)}const cK={kernelName:rs,backendName:"webgl",kernelFunc:iK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aK=`return tan(x);`;const uK=GP({opSnippet:aK});const lK={kernelName:cs,backendName:"webgl",kernelFunc:uK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK=`\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;const hK=GP({opSnippet:fK});const dK={kernelName:as,backendName:"webgl",kernelFunc:hK};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(t){const{inputs:n,backend:e,attrs:s}=t;const{tensor:o,indices:r,updates:i}=n;const{sliceRank:c,numUpdates:a,sliceSize:u,strides:l,outputSize:f}=gd(i,r,o.shape);const h=[f/u,u];if(f===0){return e.makeTensorInfo(o.shape,r.dtype)}const d=QP({inputs:{x:r},backend:e,attrs:{shape:[a,c]}});const p=QP({inputs:{x:i},backend:e,attrs:{shape:[a,u]}});const m=QP({inputs:{x:o},backend:e,attrs:{shape:h}});const x=new Jq(a,c,d.shape.length,p.shape.length,l,h,false,true);const b=e.runWebGLProgram(x,[p,d,m],m.dtype);const g=QP({inputs:{x:b},backend:e,attrs:{shape:o.shape}});e.disposeIntermediateTensorInfo(d);e.disposeIntermediateTensorInfo(p);e.disposeIntermediateTensorInfo(m);e.disposeIntermediateTensorInfo(b);return g}const mK={kernelName:Fe,backendName:"webgl",kernelFunc:pK};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xK{constructor(t,n){this.variableNames=["A"];const e=new Array(t.length);for(let s=0;s<e.length;s++){e[s]=t[s]*n[s]}this.outputShape=e;this.rank=e.length;const s=rL(this.rank);const o=bK(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function bK(t){const n=t.length;if(n>5){throw Error(`Tile for rank ${n} is not yet supported`)}if(n===1){return`imod(resRC, ${t[0]})`}const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"];const s=[];for(let n=0;n<t.length;n++){s.push(`imod(${e[n]}, ${t[n]})`)}return s.join()}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gK(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{reps:r}=s;if(o.dtype==="string"||o.shape.length>5){const t=e.readSync(o.dataId);const n=o.dtype==="string"?t.map((t=>Ao(t))):t;const s=Fi(o.shape,o.dtype,n);const i=Lz(s,r);return e.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new xK(o.shape,r);const c=e.runWebGLProgram(i,[o],o.dtype);return c}const wK={kernelName:us,backendName:"webgl",kernelFunc:gK};class vK{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];this.outputShape=t;this.userCode=`\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `}}class $K{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];this.outputShape=t;this.userCode=`\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(t,n){if(n!==null){t.disposeIntermediateTensorInfo(n)}}function kK(t){let n=1;while(n<t){n*=2}return n}function CK(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o}=n;const{k:r,sorted:i}=s;const c=et().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");const a=et().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");const u=o.shape;const l=u[u.length-1];if(e.shouldExecuteOnCPU([o])||l<c||r>a){const t=e.readSync(o.dataId);const[n,s]=zz(t,u,o.dtype,r,i);return[e.makeTensorInfo(n.shape,n.dtype,n.values),e.makeTensorInfo(s.shape,s.dtype,s.values)]}if(r===0){u[u.length-1]=0;return[e.makeTensorInfo(u,o.dtype,[]),e.makeTensorInfo(u,"int32",[])]}if(l===1){return[o,iU({attrs:{shape:u,dtype:"int32",value:0},backend:e})]}const f=e.texData.get(o.dataId);const h=f!==null&&f.isPacked;const d=h?e.unpackTensor(o):o;const p=g(u);const m=p/l;const x=QP({inputs:{x:d},attrs:{shape:[m,l]},backend:e});if(h){yK(e,d)}const b=kK(r);const w=kK(l);let v=null;const $=()=>v===null?[x,x]:[x,v];const y=(t,n,s)=>{const o=$();const r=new vK(s);const i=v===null?1:0;const c=[[l],[i],[Number.NEGATIVE_INFINITY],[t],[n]];const a=v;v=e.runWebGLProgram(r,o,"int32",c);yK(e,a)};for(let t=1;t<b;t*=2){const n=t*2;for(let e=t;e>=1;e/=2){y(n,e,[m,w])}}for(let t=w;t>b;t/=2){const n=$();const s=new $K([m,t/2]);const o=v===null?1:0;const r=[[l],[o],[b]];const i=v;v=e.runWebGLProgram(s,n,"int32",r);yK(e,i);const c=b/2;const a=c*2;for(let t=c;t>=1;t/=2){y(a,t,v.shape)}}let k=v;v=OB({inputs:{x:v},backend:e,attrs:{begin:0,size:[m,r]}});yK(e,k);let C=OU({inputs:{x,indices:v},backend:e,attrs:{axis:1,batchDims:1}});yK(e,x);const N=u.slice(0,-1);N.push(r);k=v;v=QP({inputs:{x:v},attrs:{shape:N},backend:e});yK(e,k);const R=C;C=QP({inputs:{x:C},attrs:{shape:N},backend:e});yK(e,R);return[C,v]}const NK={kernelName:ls,backendName:"webgl",kernelFunc:CK};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RK{constructor(t,n,e,s,o,r){this.variableNames=["Image","Transforms"];this.outputShape=r;const i=e==="nearest"?1:2;let c;switch(s){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${c} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${c} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${n}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SK(t){const{inputs:n,backend:e,attrs:s}=t;const{image:o,transforms:r}=n;const{interpolation:i,fillMode:c,fillValue:a,outputShape:u}=s;const[l,f,h,d]=o.shape;const[p,m]=u!=null?u:[f,h];const x=[l,p,m,d];const b=new RK(f,h,i,c,a,x);return e.runWebGLProgram(b,[o,r],"float32")}const EK={kernelName:fs,backendName:"webgl",kernelFunc:SK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(t){const{inputs:n,attrs:e,backend:s}=t;const{axis:o}=e;const{x:r}=n;cD(r,"unique");console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(r.dataId);const{outputValues:c,outputShape:a,indices:u}=Vz(i,o,r.shape,r.dtype);return[s.makeTensorInfo(a,r.dtype,c),s.makeTensorInfo([u.length],"int32",u)]}const IK={kernelName:ds,backendName:"webgl",kernelFunc:TK};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AK(t){const{inputs:n,backend:e,attrs:s}=t;const{value:o}=n;let{axis:r}=s;if(r<0){r+=o.shape.length}const i=o;const c=i.shape.length;const a=o.shape[r];const u=new Array(c-1);let l=0;for(let t=0;t<c;t++){if(t!==r){u[l++]=i.shape[t]}}const f=[];const h=new Array(c).fill(0);const d=i.shape.slice();d[r]=1;const p=new Array(a);for(let t=0;t<p.length;t++){h[r]=t;const n=OB({inputs:{x:i},backend:e,attrs:{begin:h,size:d}});const s=QP({inputs:{x:n},backend:e,attrs:{shape:u}});p[t]=s;f.push(n)}f.forEach((t=>e.disposeIntermediateTensorInfo(t)));return p}const OK={kernelName:ps,backendName:"webgl",kernelFunc:AK};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FK{constructor(t,n){this.variableNames=["x","segmentIds"];const e=t.windowSize;const s=t.batchSize;const o=t.inSize;const r=t.numSegments;const i=r*Math.ceil(o/e);this.outputShape=[s,i];const c="0.0";const a=`sumValue`;const u=Math.floor(e/4)*4;const l=e%4;const f=`\n        sumValue += dot(values, segFilter);\n    `;let h="";if(o%e>0){h=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `}let d="";if(o%e>0){d=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `}this.userCode=`\n      const float initializationValue = ${c};\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${r})) * float(${e}));\n        int currentSeg = int(mod(float(outIdx), float(${r})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${l===1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${l===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${l===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(${a});\n      }\n    `}}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(t){const{inputs:n,backend:e,attrs:s}=t;const{x:o,segmentIds:r}=n;const{numSegments:i}=s;const c=o.shape.length;const a=[];let u=0;const l=_u([u],c);let f=o;if(l!=null){f=hV({inputs:{x:o},backend:e,attrs:{perm:l}});a.push(f);u=Du(1,c)[0]}const h=Zx(f.shape,u,i);const d=g([f.shape[u]]);const p=QP({inputs:{x:f},backend:e,attrs:{shape:[-1,d]}});a.push(p);const m=ur(o.dtype);const x=(t,n,s,o,r)=>{const i=t.shape[0];const c=t.shape[1];const u=Yx(c,r);const l={windowSize:u,inSize:c,batchSize:i,numSegments:r};const f=new FK(l,n);const h=e.compileAndRun(f,[t,s],o);a.push(h);if(h.shape[1]===r){return h}const d=fq({backend:e,attrs:{start:0,stop:r,step:1,dtype:"float32"}});const p=gK({inputs:{x:d},backend:e,attrs:{reps:[c/u]}});a.push(d);a.push(p);const m=x(h,n,p,o,r);return m};const b=x(p,"unsortedSegmentSum",r,m,i);const w=QP({inputs:{x:b},backend:e,attrs:{shape:h}});let v=w;if(l!=null){a.push(w);const t=Mu(l);v=hV({inputs:{x:v},backend:e,attrs:{perm:t}})}a.forEach((t=>e.disposeIntermediateTensorInfo(t)));return v}const MK={kernelName:ms,backendName:"webgl",kernelFunc:_K};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK=[bV,vV,kV,RV,TV,FV,MV,LV,UV,jV,KV,ZV,nB,rB,aB,hB,pB,gB,vB,yB,RB,MB,LB,BB,GB,ZB,nW,rW,FP,uW,gW,SW,FW,DW,zW,VW,WW,jW,KW,ZW,rG,cG,uG,hG,xG,vG,yG,NG,EG,IG,_G,zG,WG,HG,KG,YG,tU,oU,cU,uU,hU,xU,wU,CU,RU,TU,FU,LU,BU,AP,GU,pW,jU,KU,ZU,LP,eH,iH,aH,hH,mH,wH,yH,RH,IH,FH,DH,VH,WH,UH,XH,JH,ZH,tj,ej,ij,lj,pj,Rj,YP,Ij,Fj,Dj,Pj,jB,Wj,jj,Xj,Zj,eq,BP,oq,iq,aq,lq,hq,XB,wj,mq,wq,kq,tV,Sq,Iq,_q,Lq,Bq,Gq,jq,Kq,Qq,eX,rX,aX,hX,mX,wX,yX,FB,Cj,NX,SX,TX,AX,FX,MX,LX,PX,WX,HX,XX,JX,ZX,nK,sK,rK,cK,yj,fV,lK,dK,mK,wK,NK,EK,dV,IK,OK,MK,Uj];for(const t of DK){Is(t)}async function LK(t,n){const e=Lr([1212,12]).print();console.info("el tensor es: ",e,t,n);return e}async function zK(t,n){if(t.length!==n.length)throw new Error("v1 and v2 must have the same length");let e=0;let s=0;while(e<t.length){s+=Math.pow(t[e].x-n[e].x,2)+Math.pow(t[e].y-n[e].y,2)+Math.pow(t[e].z-n[e].z,2);e++}return Math.sqrt(s)}async function PK(t,n,e=1.5){let s=null;let o=Infinity;for(const r of t){const t=await zK(r.descriptors,n);if(t>e){continue}if(t<o){o=t;s=r}}return s}e.getBestMatch=PK;e.getDistance=zK;e.tsDistance=LK})();