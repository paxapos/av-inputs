{"version":3,"names":["CameraService","constructor","initCamera","elVideo","elCanvas","facingMode","exact","drawImageCb","this","resetCamera","canvas","parentNode","insertBefore","nextSibling","navigator","mediaDevices","getUserMedia","audio","video","width","min","height","then","stream","srcObject","renderToCanvas","catch","err0r","console","log","ctx","getContext","imgWidth","videoWidth","imgHeight","videoHeight","imgSize","Math","left","top","call","drawImage","requestAnimationFrame","_b","_a","getVideoTracks","forEach","track","stop","removeTrack","async","Promise","resolve","reject","toBlob","blob","filename","abs","round","random","file","File","error","camera","inputFileFromWebcamCss","InputFileFromWebcam","pic","takePic","pictureTaken","emit","onClickHandler","__toogleFacingMode","__facingMode","facingModeChanged","__createfacingModeConstrainDOMString","ideal","componentWillMount","render","h","Host","name","autoplay","ref","el"],"sources":["./src/utils/camera.ts","./src/components/input-file-from-webcam/input-file-from-webcam.css?tag=input-file-from-webcam&encapsulation=shadow","./src/components/input-file-from-webcam/input-file-from-webcam.tsx"],"sourcesContent":["\nexport class CameraService {\n\n    elVideo: HTMLVideoElement;\n    stream: MediaStream;\n    canvas: HTMLCanvasElement;\n    constructor() {\n    }\n\n    public fotoActual: any;\n\n    initCamera( elVideo: HTMLVideoElement, elCanvas: HTMLCanvasElement, facingMode: ConstrainDOMString = {exact: \"user\"}, drawImageCb: Function = null ) {\n        this.resetCamera();\n        this.elVideo = elVideo;\n        this.canvas = elCanvas\n        \n        this.elVideo.parentNode.insertBefore(this.canvas, this.elVideo.nextSibling);\n\n        if (navigator.mediaDevices.getUserMedia) {\n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { min: 200 },\n                    height: { min: 200 },\n                    facingMode: facingMode\n                }\n            })\n            .then((stream) => {\n                this.stream = stream;\n                this.elVideo.srcObject = this.stream;\n\n                this.renderToCanvas( drawImageCb );\n            })\n            .catch(function (err0r) {\n                console.log(\"Something went wrong!\", err0r);\n            });\n        }\n    }\n\n\n    renderToCanvas( drawImageCb: Function = null) {\n\n        let ctx = this.canvas.getContext('2d');\n\n        let imgWidth = this.elVideo.videoWidth;\n        let imgHeight = this.elVideo.videoHeight;\n\n    \tvar imgSize = Math.min(imgWidth, imgHeight);\n        // The following two lines yield a central based cropping.\n        // They can both be amended to be 0, if you wish it to be\n        // a left based cropped image.\n    \tvar left = (imgWidth - imgSize) / 2;\n    \tvar top = (imgHeight - imgSize) / 2;\n\n        if ( typeof drawImageCb == 'function' ) {\n            drawImageCb.call(ctx, this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height)\n        } else {\n            ctx.drawImage(this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n        }\n\n        requestAnimationFrame(() => this.renderToCanvas() );\n\n    }\n\n    resetCamera() {\n        if (this.stream) this.stream?.getVideoTracks()?.forEach(track => {\n            track?.stop()\n            this.stream?.removeTrack(track)\n        });\n        if (this.elVideo) this.elVideo.srcObject = null;\n    }\n\n    async takePic(): Promise<File> {\n        return new Promise((resolve, reject) => {\n            try {\n                this.canvas.toBlob( (blob) => {\n                    const filename = \"pic_\" + Math.abs( Math.round( Math.random() * 1000))\n                    var file = new File([blob], filename);\n                    resolve(file);\n                })\n            } catch (error) {\n                reject(error);\n            }\n\n          });\n\n    }\n\n}\n\nexport const camera = new CameraService();\n",":host {\n  display: inline-block;\n  width: 100px;\n  filter: drop-shadow(2px 4px 6px black);\n  border: #5a5252 1px solid;\n  border-style: groove;\n}\n\n\nvideo {\n  display: none;\n}\n\ncanvas {\n  width: 100%;\n  height: 100%;\n}","import { Component, Host, h, Method, Listen, State, Prop, Event, EventEmitter } from '@stencil/core';\nimport { camera } from '../../utils/camera';\n\n@Component({\n  tag: 'input-file-from-webcam',\n  styleUrl: 'input-file-from-webcam.css',\n  shadow: true,\n})\nexport class InputFileFromWebcam {\n\n  private elVideo: HTMLVideoElement\n  private elCanvas: HTMLCanvasElement\n\n\n  @Prop() width?: number = 460\n  @Prop() height?: number = 460\n\n    /**\n   * FacingModel optiones following https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode#value\n   */\n  @Prop() facingMode?: \"user\"|\"environment\" = null\n\n  /**\n   * you can pass a function and override the canvas.drawImage function so you\n   * can change the image adding filters or any kind of magin in your image\n   * \n   * you just need to crear a function with all canvas.-drawImage arguments\n   * \n   * here you have the list of vars you get: videoElement, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height\n   */\n  @Prop() drawImageCb?: Function = null\n\n  @Method()\n  async takePic(): Promise<File> {\n    // show a prompt\n    const pic = await camera.takePic()\n    this.pictureTaken.emit(pic);\n    return pic\n  }\n\n\n  @Event({\n    eventName: 'pictureTaken',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) pictureTaken: EventEmitter<File>;\n\n  @Event({\n    eventName: 'facingModeChanged',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) facingModeChanged: EventEmitter<ConstrainDOMString>;\n\n\n  @State() __facingMode: string = 'user'\n\n\n  @Listen('click')\n  onClickHandler() {\n    this.__toogleFacingMode()\n  }\n\n \n\n  /**\n   * Toogle webcam, for example in mobile show front or back camera\n   * you can block this behaviour by setting the facingMode Property\n   */\n  private __toogleFacingMode() {\n    if ( this.facingMode == null) {\n      // only change if no facinMode property was set\n      this.__facingMode = (this.__facingMode == \"environment\") ? \"user\" : \"environment\"\n      this.facingModeChanged.emit( this.__createfacingModeConstrainDOMString() )\n    }\n  }\n\n  __createfacingModeConstrainDOMString(): ConstrainDOMString {\n    return {ideal: this.__facingMode}\n  }\n\n\n  componentWillMount() {\n    if ( this.facingMode) {\n      this.__facingMode = this.facingMode\n    }\n\n  }\n  \n  async componentDidRender() {\n    camera.initCamera( this.elVideo, this.elCanvas, this.__createfacingModeConstrainDOMString(), this.drawImageCb );\n  }\n\n  async disconnectedCallback() {\n    camera.resetCamera()\n  }\n\n  render() {\n    return (\n      <Host>\n\n        <slot name='before'></slot>\n        <video autoplay=\"true\" ref={(el) => this.elVideo = el }></video>\n        <canvas ref={(el) => this.elCanvas = el } width={this.width} height={this.height}></canvas>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"],"mappings":"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"}