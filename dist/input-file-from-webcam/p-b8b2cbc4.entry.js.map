{"version":3,"names":["CameraDirection","WebCamera","constructor","async","parentElement","direction","drawImageCb","this","resetCamera","videos","getElementsByTagName","length","elVideo","document","createElement","autoplay","style","display","appendChild","canvasss","canvas","width","parseInt","getAttribute","height","Front","navigator","mediaDevices","getUserMedia","console","info","facingMode","audio","video","min","then","stream","srcObject","renderToCanvas","catch","err0r","log","ctx","getContext","imgWidth","videoWidth","imgHeight","videoHeight","imgSize","Math","left","top","call","drawImage","requestAnimationFrame","_b","_a","getVideoTracks","forEach","track","stop","removeTrack","Promise","resolve","reject","toBlob","blob","filename","abs","round","random","file","File","type","error","CameraService","camaraManager","cameraDirection","initCamera","takePicture","camera","inputFileFromWebcamCss","InputFileFromWebcam","pic","pictureTaken","emit","__toogleFacingMode","onClickHandler","Rear","facingModeChanged","componentWillMount","el","render","h","Host","name"],"sources":["./src/utils/camera.ts","./src/components/input-file-from-webcam/input-file-from-webcam.css?tag=input-file-from-webcam&encapsulation=shadow","./src/components/input-file-from-webcam/input-file-from-webcam.tsx"],"sourcesContent":["\nexport enum CameraDirection {\n    Rear = \"REAR\",\n    Front = \"FRONT\"\n}\n\ninterface SuperCamera {\n    initCamera(parentElement: HTMLElement, direction: CameraDirection, drawImageCb: Function): Promise<void>,\n    takePicture(): Promise<Blob>,\n    resetCamera(): void,\n}\n\n\nexport class WebCamera implements SuperCamera {\n\n    elVideo: HTMLVideoElement;\n    stream: MediaStream;\n    canvas: HTMLCanvasElement;\n    direction: CameraDirection\n\n    constructor() {\n    }\n\n    public fotoActual: any;\n\n    async initCamera( parentElement: HTMLElement, direction: CameraDirection, drawImageCb: Function = null ) {\n        \n        this.resetCamera();\n\n        const videos = parentElement.getElementsByTagName(\"video\");\n        if ( videos.length == 0 ) {\n            this.elVideo = document.createElement(\"video\")\n            this.elVideo.autoplay = true;\n            this.elVideo.style.display = \"none\"\n            parentElement.appendChild( this.elVideo )\n        } else {\n            this.elVideo = videos[0]\n        }\n        \n        const canvasss = parentElement.getElementsByTagName(\"canvas\");\n        if ( canvasss.length === 0 ) {\n            this.canvas = document.createElement(\"canvas\")\n            this.canvas.width = parseInt( parentElement.getAttribute(\"width\") );\n            this.canvas.height = parseInt( parentElement.getAttribute(\"height\") );\n            parentElement.appendChild( this.canvas )\n        } else {\n            this.canvas = canvasss[0]\n        }\n\n\n        this.direction = CameraDirection.Front\n        \n        if (navigator.mediaDevices.getUserMedia) {\n            console.info(\"la camara\")\n            const facingMode = (direction == CameraDirection.Front) ? \"user\": \"environment\"\n\n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { min: 200 },\n                    height: { min: 200 },\n                    facingMode: facingMode\n                }\n            })\n            .then((stream) => {\n                this.stream = stream;\n                console.info(\"la camara\", this.stream)\n                this.elVideo.srcObject = this.stream;\n\n                this.renderToCanvas( drawImageCb );\n            })\n            .catch(function (err0r) {\n                console.log(\"Something went wrong!\", err0r);\n            });\n        }\n    }\n\n\n    renderToCanvas( drawImageCb: Function = null) {\n\n        let ctx = this.canvas.getContext('2d');\n\n        let imgWidth = this.elVideo.videoWidth;\n        let imgHeight = this.elVideo.videoHeight;\n\n    \tvar imgSize = Math.min(imgWidth, imgHeight);\n        // The following two lines yield a central based cropping.\n        // They can both be amended to be 0, if you wish it to be\n        // a left based cropped image.\n    \tvar left = (imgWidth - imgSize) / 2;\n    \tvar top = (imgHeight - imgSize) / 2;\n\n        if ( typeof drawImageCb == 'function' ) {\n            drawImageCb.call(ctx, this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height)\n        } else {\n            ctx.drawImage(this.elVideo, left, top, imgSize, imgSize, 0,0, this.canvas.width, this.canvas.height);\n        }\n\n        requestAnimationFrame(() => this.renderToCanvas() );\n\n    }\n\n    resetCamera() {\n        if (this.stream) this.stream?.getVideoTracks()?.forEach(track => {\n            track?.stop()\n            this.stream?.removeTrack(track)\n        });\n        if (this.elVideo) this.elVideo.srcObject = null;\n    }\n\n    async takePicture(): Promise<File> {\n        return new Promise((resolve, reject) => {\n            try {\n                this.canvas.toBlob( (blob) => {\n                    const filename = \"pic_\" + Math.abs( Math.round( Math.random() * 1000))\n                    var file = new File([blob], filename, {type: \"image/jpeg\"});\n                    resolve(file);\n                }, \"image/jpeg\", 0.8)\n            } catch (error) {\n                reject(error);\n            }\n\n          });\n\n    }\n\n}\n\n\n\nexport class CameraService {\n\n    private camaraManager: SuperCamera\n\n    constructor() {\n      \n        this.camaraManager = new WebCamera()\n    }\n\n\n    async initCamera( parentElement: HTMLElement, cameraDirection: CameraDirection , drawImageCb: Function = null ) {\n       this.camaraManager.initCamera( parentElement, cameraDirection, drawImageCb )\n    }\n\n    async takePicture(): Promise<Blob> {\n        return await this.camaraManager.takePicture()\n    }\n\n    async resetCamera() {\n        return await this.camaraManager.resetCamera()\n    }\n}\n\n\n\nexport const camera = new CameraService()\n",":host {\n  display: inline-block;\n  width: 100px;\n  filter: drop-shadow(2px 4px 6px black);\n  border: #5a5252 1px solid;\n  border-style: groove;\n}\n\n\nvideo {\n  display: none;\n}\n\ncanvas {\n  width: 100%;\n  height: 100%;\n}","import { Component, Host, h, Method, Listen, Prop, Event, EventEmitter, Element } from '@stencil/core';\nimport { CameraDirection, camera } from '../../utils/camera';\n\n\n@Component({\n  tag: 'input-file-from-webcam',\n  styleUrl: 'input-file-from-webcam.css',\n  shadow: true,\n})\nexport class InputFileFromWebcam {\n\n\n  @Element() el: HTMLElement;\n\n\n  @Prop({reflect: true, mutable: true}) width?: number = 460\n  @Prop({reflect: true, mutable: true}) height?: number = 460\n\n  /**\n   * FacingModel optiones following https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode#value\n   */\n  @Prop({ mutable: true, reflect: true }) facingMode?: CameraDirection = CameraDirection.Front\n\n  /**\n   * you can pass a function and override the canvas.drawImage function so you\n   * can change the image adding filters or any kind of magin in your image\n   * \n   * you just need to crear a function with all canvas.-drawImage arguments\n   * \n   * here you have the list of vars you get: videoElement, left, top, imgSize, imgSize, 0,0, canvas.width, canvas.height\n   */\n  @Prop() drawImageCb?: Function = null\n\n  @Method()\n  async takePic(): Promise<Blob> {\n    // show a prompt\n    const pic = await camera.takePicture()\n    this.pictureTaken.emit(pic);\n    return pic\n  }\n\n  @Method()\n  async resetCamera(): Promise<void> {\n    // show a prompt\n    camera.resetCamera()\n  }\n\n  @Method()\n  async toggleCamera(): Promise<void>{\n    this.__toogleFacingMode()\n  }\n\n\n  @Event({\n    eventName: 'pictureTaken',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) pictureTaken: EventEmitter<Blob>;\n\n  @Event({\n    eventName: 'facingModeChanged',\n    composed: true,\n    cancelable: false,\n    bubbles: true,\n  }) facingModeChanged: EventEmitter<CameraDirection>;\n\n\n\n  @Listen('click')\n  onClickHandler() {\n    this.__toogleFacingMode()\n  }\n\n \n\n  /**\n   * Toogle webcam, for example in mobile show front or back camera\n   * you can block this behaviour by setting the facingMode Property\n   */\n  private __toogleFacingMode() {\n    // only change if no facinMode property was set\n    this.facingMode = (this.facingMode != CameraDirection.Front) ? CameraDirection.Front : CameraDirection.Rear\n    this.facingModeChanged.emit( this.facingMode   )\n  }\n\n \n\n  componentWillMount() {\n   \n  }\n  \n  async componentDidRender() {\n    camera.initCamera( this.el, CameraDirection.Front, this.drawImageCb );\n  }\n\n  async disconnectedCallback() {\n    camera.resetCamera()\n  }\n\n  render() {\n    return (\n      <Host style={{height: this.height+\"px\", width: this.width+\"px\"}}>\n\n        <slot name='before'></slot>\n        \n        <slot></slot>\n\n        <slot name='after'></slot>\n      </Host>\n    );\n  }\n\n}\n"],"mappings":"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"}